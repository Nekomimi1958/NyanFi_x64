//----------------------------------------------------------------------//
// 2画面ファイラー NyanFi												//
//  メインフォーム														//
//----------------------------------------------------------------------//
#include <vcl.h>
#pragma hdrstop
#include <tchar.h>
#include <algorithm>
#include <memory>
#include <math.h>
#include <mmsystem.h>
#include <shlobj.h>
#include <System.IOUtils.hpp>
#include <System.DateUtils.hpp>
#include <System.WideStrUtils.hpp>
#include <System.NetEncoding.hpp>
#include <System.Zip.hpp>
#include <Vcl.Imaging.GIFImg.hpp>
#include <Vcl.Clipbrd.hpp>
#include <Vcl.Direct2D.hpp>
#include <RegularExpressions.hpp>
#include "UserMdl.h"
#include "usr_file_ex.h"
#include "usr_wic.h"
#include "usr_exif.h"
#include "usr_id3.h"
#include "usr_excmd.h"
#include "usr_xd2tx.h"
#include "usr_swatch.h"
#include "check_thread.h"
#include "htmconv.h"
#include "UserFunc.h"
#include "Global.h"
#include "Splash.h"
#include "MainFrm.h"
#include "About.h"
#include "AppDlg.h"
#include "AskRep.h"
#include "BakDlg.h"
#include "BitmapFrm.h"
#include "BtnDlg.h"
#include "ChInfFrm.h"
#include "CmdListDlg.h"
#include "ColDlg.h"
#include "ColPicker.h"
#include "CompDlg.h"
#include "CsvRecFrm.h"
#include "CvEncDlg.h"
#include "CvImgDlg.h"
#include "DirDlg.h"
#include "DistrDlg.h"
#include "DotDlg.h"
#include "DriveDlg.h"
#include "EditHistDlg.h"
#include "ExeDlg.h"
#include "FileExtDlg.h"
#include "FileInfDlg.h"
#include "FindDlg.h"
#include "FindTxtDlg.h"
#include "FuncDlg.h"
#include "GenInfDlg.h"
#include "SubView.h"
#include "GrepOptDlg.h"
#include "HistDlg.h"
#include "HistFrm.h"
#include "InpCmds.h"
#include "InpDir.h"
#include "InpExDlg.h"
#include "InspectFrm.h"
#include "JoinDlg.h"
#include "KeyDlg.h"
#include "LoupeFrm.h"
#include "MaskDlg.h"
#include "MaskSelDlg.h"
#include "ModalScr.h"
#include "OptDlg.h"
#include "PackDlg.h"
#include "PrnImgDlg.h"
#include "RenDlg.h"
#include "SameDlg.h"
#include "SrtModDlg.h"
#include "SyncDlg.h"
#include "TaskDlg.h"
#include "TxtViewer.h"
#include "CreDirsDlg.h"
#include "TabDlg.h"
#include "FtpDlg.h"
#include "ChmodDlg.h"
#include "XmlView.h"
#include "GitView.h"
#include "ShareDlg.h"
#include "FindTag.h"
#include "RegExChk.h"
#include "ExTViewer.h"
#include "DebugFrm.h"
#include "DrvGraph.h"
#include "ExpCsv.h"
#include "CalcDlg.h"
#include "TagDlg.h"
#include "DiffDlg.h"
#include "NewDlg.h"
#include "GraphFrm.h"
#include "DuplDlg.h"
#include "FindKey.h"

#pragma link "IdAllFTPListParsers"

//---------------------------------------------------------------------------
#pragma package(smart_init)
#pragma resource "*.dfm"
TNyanFiForm *NyanFiForm;

//---------------------------------------------------------------------------
//ローカルフック
//フォルダーの参照ダイアログ/メッセージの位置調整
//---------------------------------------------------------------------------
HHOOK hDlgHook;
HWND  ReqActWnd = NULL;

//---------------------------------------------------------------------------
LRESULT CALLBACK DlgHookProc(int code, WPARAM wParam, LPARAM lParam)
{
	if (code<0) return ::CallNextHookEx(hDlgHook, code, wParam, lParam);

	if (code==HC_ACTION) {
		PCWPSTRUCT sp = (PCWPSTRUCT)lParam;
		if (sp->message==WM_SHOWWINDOW && sp->wParam==1) {
			HWND hWnd = sp->hwnd;
			UnicodeString tit = get_WndText(hWnd);
			if (contained_wd_i(_T("#32770|TMessageForm"), get_WndClassName(hWnd))
				&& (USAME_TS(tit, "フォルダーの参照") || (SureAdjPos && (USAME_TS(tit, "確認") || USAME_TS(tit, "エラー")))))
			{
				TControl *cp = NULL;
				bool is_fl = false;
				//ダイアログ
				for (int i=0; i<Screen->FormCount; i++) {
					TForm *fp = Screen->Forms[i];
					if (fp->Handle==hWnd) continue;
					if (!fp->Visible || !fp->Floating || fp==Application->MainForm) continue;
					if (fp->BorderStyle==bsNone) continue;
					if (fp->FormStyle==fsStayOnTop && !contained_wd_i(_T("CsvRecForm|DebugForm"), fp->Name)) continue;
					cp = (TControl *)fp;  break;
				}
				//メイン
				if (!cp) {
					if (ScrMode==SCMD_FLIST && !MsgPosCenter) {
						cp = (TControl *)((CurListTag==0)? NyanFiForm->L_Panel : NyanFiForm->R_Panel);
						is_fl = true;
					}
					else {
						cp = (TControl *)NyanFiForm;
					}
				}

				//中央揃え
				TRect rc;
				::GetWindowRect(hWnd, &rc);
				TPoint p = cp->ClientToScreen(cp->ClientRect.CenteredRect(rc).Location);

				//はみ出し修正
				if (is_fl) cp = (TControl *)NyanFiForm->ListPanel; else cp = (TControl *)NyanFiForm;
				TPoint p_t = cp->ClientToScreen(Point(0, 8));
				TPoint p_b = cp->ClientToScreen(Point(0, cp->Height - 8));
				if (p.y < p_t.y)				 p.y = p_t.y;
				if ((p.y + rc.Height()) > p_b.y) p.y = p_b.y - rc.Height();

				::SetWindowPos(hWnd, HWND_TOP, p.x, p.y, 0, 0, SWP_NOSIZE|SWP_NOZORDER);
			}
		}
		else if (sp->message==WM_ACTIVATE && (LOWORD(sp->wParam)==WA_ACTIVE)) {
			ReqActWnd = sp->hwnd;
		}
	}

	return ::CallNextHookEx(hDlgHook, code, wParam, lParam);
}


//---------------------------------------------------------------------------
// TNfForm クラス
//---------------------------------------------------------------------------
__fastcall TNyanFiForm::TNyanFiForm(TComponent* Owner)
	: TForm(Owner)
{
	WndSizing	 = false;
	ReqClose	 = ReqPowerOff = ReqReboot = false;
	ReqKeepDupl  = false;
	NotSaveINI	 = false;
	CurWorking	 = false;
	CancelHelp	 = false;
	CancelWork	 = false;
	CurListWidth = CurListHeight = -1;
	WarnBlink	 = false;
	KeepModalScr = InhModalScr = false;
	ApplyDotNyan = false;
	ChkHardLink  = false;

	hWatchDir[0] = hWatchDir[1] = NULL;

	InhDrawImg	 = 0;
	InhDirHist	 = 0;
	InhUpdBgImg  = 0;
	DrawOppCsr	 = 0;
	KeepCurCsr	 = 0;
	ViewInfCnt	 = 0;

	InhFTPCheck	 = false;
	FTPhasCHMOD  = false;

	MoveTag 	 = -1;
	MoveCnt 	 = 0;
	MoveIndex	 = -1;

	DragTabIndex = HotTabIndex = -1;
	TabMouseCliped = false;

	isViewText	 = isRichText = isXDoc2Txt = false;
	fromGrep	 = fromViewer = false;
	isViewWork	 = false;

	ActionOk	 = false;
	fromFileList = fromMenuFile = false;

	Wait2ndKey	 = false;
	DblClicked	 = R_Clicked = RClickAtCur = false;
	DragCancel	 = false;
	LastIndex[0] = LastIndex[1] = -1;
	fromOpenStd  = false;

	ImgMoving	  = false;
	VListMaking   = false;
	TmpEqualSize  = false;
	ThumbExtended = false;
	ThumbClicked  = false;
	isLoopHint	  = false;
	IsEvenPage	  = true;
	InhSeekBar	  = 0;
	LockTxtPrv	  = false;
	FinfSkipped   = false;

	IdFTP1 = NULL;
	IdAntiFreeze1 = NULL;
	IdSSLIOHandlerSocketOpenSSL1 = NULL;
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::FormCreate(TObject *Sender)
{
#ifdef _DEBUG
	if (SplashForm) {
		SplashForm->VerLabel->Caption = SplashForm->VerLabel->Caption + "  DEBUG MODE";
		SplashForm->Repaint();
	}
#endif

	MainHandle = Handle;
	::GetWindowThreadProcessId(Handle, &ProcessId);

	hDlgHook = ::SetWindowsHookEx(WH_CALLWNDPROC, DlgHookProc, NULL, ::GetCurrentThreadId());

	LogRWLock	 = new TMultiReadExclusiveWriteSynchronizer();
	IconRWLock	 = new TMultiReadExclusiveWriteSynchronizer();
	FldIcoRWLock = new TMultiReadExclusiveWriteSynchronizer();

	UserModule->SetUsrPopupMenu(this);

	UserHighlight = new HighlightFile(ExtractFilePath(Application->ExeName) + HILT_INI_FILE);

	RecycleFTP();

	TempRichEdit = ViewMemo;

	org_TabPanelWndProc 	   = TabPanel->WindowProc;
	TabPanel->WindowProc	   = TabPanelWndProc;
	org_TabCtrlWindowProc	   = TabControl1->WindowProc;
	TabControl1->WindowProc    = TabCtrlWindowProc;

	org_RelPanelWndProc 	   = RelPanel->WindowProc;
	RelPanel->WindowProc	   = RelPanelWndProc;
	org_RelPanel2WndProc	   = RelPanel2->WindowProc;
	RelPanel2->WindowProc	   = RelPanel2WndProc;

	org_L_DirPanelWndProc	   = L_DirPanel->WindowProc;
	L_DirPanel->WindowProc	   = L_DirPanelWndProc;
	org_L_DirPanel2WndProc	   = L_DirPanel2->WindowProc;
	L_DirPanel2->WindowProc	   = L_DirPanel2WndProc;
	org_R_DirPanelWndProc	   = R_DirPanel->WindowProc;
	R_DirPanel->WindowProc	   = R_DirPanelWndProc;
	org_R_DirPanel2WndProc	   = R_DirPanel2->WindowProc;
	R_DirPanel2->WindowProc	   = R_DirPanel2WndProc;

	org_L_StatPanelWndProc	   = L_StatPanel->WindowProc;
	L_StatPanel->WindowProc	   = L_StatPanelWndProc;
	org_R_StatPanelWndProc	   = R_StatPanel->WindowProc;
	R_StatPanel->WindowProc	   = R_StatPanelWndProc;

	org_FileListWindowProc[0]  = L_ListBox->WindowProc;
	org_FileListWindowProc[1]  = R_ListBox->WindowProc;
	L_ListBox->WindowProc	   = L_ListWindowProc;
	R_ListBox->WindowProc	   = R_ListWindowProc;

	org_TvViewPanelWndProc	   = TxtViewPanel->WindowProc;
	TxtViewPanel->WindowProc   = TvViewPanelWndProc;
	org_TvScrlPanelWndProc	   = TxtScrollPanel->WindowProc;
	TxtScrollPanel->WindowProc = TvScrlPanelWndProc;
	org_LogPanelWndProc		   = LogPanel->WindowProc;
	LogPanel->WindowProc	   = LogPanelWndProc;

	org_SttBar1WndProc		   = StatusBar1->WindowProc;
	StatusBar1->WindowProc	   = SttBar1WndProc;
	org_ClockBarWndProc 	   = ClockBar->WindowProc;
	ClockBar->WindowProc	   = ClockBarWndProc;
	org_ClockBarIWndProc	   = ClockBarI->WindowProc;
	ClockBarI->WindowProc	   = ClockBarIWndProc;
	org_TxtSttHdrWndProc	   = TxtSttHeader->WindowProc;
	TxtSttHeader->WindowProc   = TxtSttHdrWndProc;
	org_ImgSttHdrWndProc	   = ImgSttHeader->WindowProc;
	ImgSttHeader->WindowProc   = ImgSttHdrWndProc;
	org_ImgInfBarWndProc	   = ImgInfBar->WindowProc;
	ImgInfBar->WindowProc	   = ImgInfBarWndProc;

	TabPinWidth = 0;

	FileListBox[0]	 = L_FileListBox = L_ListBox;
	FileListBox[1]	 = R_FileListBox = R_ListBox;
	FileListPanel[0] = L_Panel;
	FileListPanel[1] = R_Panel;

	LogWndListBox  = LogListBox;

	FilterComboBox->Tag   = CBTAG_HISTORY;
	GrepMaskComboBox->Tag = CBTAG_HISTORY;

	//独自スクロールバー
	FlScrPanel[0]	= new UsrScrollPanel(L_Panel, L_ListBox, USCRPNL_FLAG_FL|USCRPNL_FLAG_P_WP);
	FlScrPanel[0]->OnRButtonUp = FlScrPanelMouseUp;
	FlScrPanel[1]	= new UsrScrollPanel(R_Panel, R_ListBox, USCRPNL_FLAG_FL|USCRPNL_FLAG_P_WP);
	FlScrPanel[1]->OnRButtonUp = FlScrPanelMouseUp;

	TxtPrvScrPanel	= new UsrScrollPanel(TxtPrvListPanel,TxtPrvListBox, USCRPNL_FLAG_L_WP);
	TxtTailScrPanel	= new UsrScrollPanel(TxtTailListPanel, TxtTailListBox, USCRPNL_FLAG_L_WP);
	InfScrPanel 	= new UsrScrollPanel(InfListPanel, InfListBox, USCRPNL_FLAG_L_WP);
	LogScrPanel 	= new UsrScrollPanel(LogListPanel, LogListBox, USCRPNL_FLAG_L_WP);
	LogWndScrPanel	= LogScrPanel;
	ImgInfScrPanel	= new UsrScrollPanel(SideInfPanel, ImgInfListBox, USCRPNL_FLAG_L_WP);
	TxtViewScrPanel = new UsrScrollPanel(TxtScrollPanel, TextScrollBar, USCRPNL_FLAG_TV|USCRPNL_FLAG_L_WP);
	ResultScrPanel	= new UsrScrollPanel(GrepPanel, ResultListBox, USCRPNL_FLAG_L_WP);

	TaskSttTimer->Enabled	= false;
	UpdLogTimer->Enabled	= false;
	WatchDirTimer->Enabled	= false;
	WatchTailTimer->Enabled = false;
	MsgHintTimer->Enabled	= false;
	KeyHintTimer->Enabled	= false;
	BlinkTimer->Enabled 	= false;

	LastConnect		= InternetConnected();
	LastBatteryStt	= get_BatteryTimeStr();
	LastBatteryLife = 100;

	//初期化、オプション読み込み
	InitializeSysColor();
	InitializeGlobal();
	ResetIndColor(-1);
	get_DriveInfoList();

	if (!SameText(IniFile->FileName, ChangeFileExt(Application->ExeName, ".INI")))
		AddInitialLog(make_LogHdr(_T("LOAD"), ExtractFileName(IniFile->FileName)));

	//仮想ドライブのマウント
	if (VirDriveList->Count>0) {
		int cnt = 0;
		for (int i=0; i<VirDriveList->Count; i++) {
			UnicodeString msg = mount_VirDriveList(i);
			if (!msg.IsEmpty()) {
				if (msg[1]!='E') cnt++;
				AddInitialLog(msg);
			}
		}
		if (cnt>0) get_DriveInfoList();
	}

	//アーカイバDLL情報
	for (int i=0; i<MAX_ARC_DLL; i++) {
		arc_func *fp = &usr_ARC->ArcFunc[i];
		if (fp->hDll) {
			UnicodeString tmp = make_LogHdr(_T("LOAD"), fp->DllName, false, 12);
			tmp.cat_sprintf(_T(" %s"), fp->VerStr.c_str());

			if (fp->Available) {
				if (fp->use7zdll) {
					if (fp->err7zdll) {
						tmp[1] = 'E';
						tmp += " 7z.dll not found";
					}
					else {
						tmp += " using 7z.dll";
					}
				}
				else if (usr_ARC->Use7zDll) {
					if ((USAME_TI(fp->Prefix, "Unrar") && test_FileExt(".rar", FExt7zDll)) ||
						(USAME_TI(fp->Prefix, "UnIso") && test_FileExt(".iso", FExt7zDll)))
					{
						tmp += "  NOT USED";
					}
				}
			}
			else {
				tmp[1] = 'E';
				tmp += "not available";
			}
			AddInitialLog(tmp);
		}
	}
	//Susieプラグイン情報
	if (SPI->PlgList->Count>0) {
		for (int i=0; i<SPI->PlgList->Count; i++) {
			spi_info *sp = SPI->PlgList->Items[i];
			AddInitialLog(
				make_LogHdr(_T("LOAD"), sp->FileName, false, 12).cat_sprintf(
					_T(" (%s) %s"), sp->VerType.c_str(), sp->FileType.c_str()));
		}
	}
	//Migemo
	if (usr_Migemo->DictReady) {
		AddInitialLog(make_LogHdr(_T("LOAD"),
			usr_Migemo->FileName, false, 13).cat_sprintf(_T("v%s"), usr_SH->get_VerStr(usr_Migemo->FileName).c_str()));
	}

	//起動時オプションの解析
	StartTag = LastCurTag;
	UnicodeString start_pnam[MAX_FILELIST];
	int i = 1;
	while (!ParamStr(i).IsEmpty()) {
		UnicodeString prmbuf = Trim(ParamStr(i++));
		if (prmbuf.IsEmpty()) break;
		if (remove_top_s(prmbuf, '-')) {
			UnicodeString opt = split_top_ch(prmbuf).UpperCase();
			prmbuf = exclude_quot(prmbuf);
			if (opt.IsEmpty() || prmbuf.IsEmpty()) continue;

			switch (opt[1]) {
			case 'L': case 'R':						//左右パス
				start_pnam[USAME_TS(opt, "L")? 0 : 1] = to_path_name(exclude_quot(prmbuf));	break;
			case 'C':								//カレント
				StartTag  = USAME_TS(prmbuf, "R")? 1: 0; break;
			case 'F': StartFile = prmbuf;	break;	//カレントファイル
			case 'X': StartCmds = prmbuf;	break;	//コマンド
			case 'M': StartMsg  = prmbuf;	break;	//メッセージ
			}
		}
		//カレントファイル
		else StartFile = exclude_quot(prmbuf);
	}

	//カレントファイル/ディレクトリ
	if (!StartFile.IsEmpty()) {
		start_pnam[StartTag] = dir_exists(StartFile) ? IncludeTrailingPathDelimiter(StartFile)
													 : ExtractFilePath(StartFile);
	}

	//フォント初期化
	std::unique_ptr<TFont> defFont(new TFont());
	defFont->Name = "ＭＳ ゴシック";
	defFont->Size = 10;
	ListFont	= IniFile->ReadFontInf(_T("FileList"),	defFont.get(), FontList, _T("リスト"));
	FileInfFont = IniFile->ReadFontInf(_T("FileInf"),	defFont.get(), FontList, _T("ファイル情報"));
	TxtPrvFont	= IniFile->ReadFontInf(_T("TxtPrv"),	FileInfFont,   FontList, _T("テキストプレビュー"));
	LogFont 	= IniFile->ReadFontInf(_T("Log"),		defFont.get(), FontList, _T("ログ"));
	ViewerFont	= IniFile->ReadFontInf(_T("Viewer"),	defFont.get(), FontList, _T("テキストビュアー"));
	GrepResFont = IniFile->ReadFontInf(_T("GrepRes"),	ListFont,	   FontList, _T("GREP結果リスト"));
	DirInfFont	= IniFile->ReadFontInf(_T("DirInf"),	defFont.get(), FontList, _T("ディレクトリ情報"));
	DrvInfFont	= IniFile->ReadFontInf(_T("DrvInf"),	defFont.get(), FontList, _T("ドライブ情報"));
	LstHdrFont	= IniFile->ReadFontInf(_T("LstHdr"),	Application->DefaultFont, FontList, _T("一覧のヘッダ"));
	ViewHdrFont = IniFile->ReadFontInf(_T("ViewHdr"),	defFont.get(), FontList, _T("情報ヘッダ"));
	GenListFont = IniFile->ReadFontInf(_T("GenList"),	defFont.get(), FontList, _T("一覧ダイアログ"));
	HintFont	= IniFile->ReadFontInf(_T("Hint"),		defFont.get(), FontList, _T("ヒント"));
	SttBarFont	= IniFile->ReadFontInf(_T("SttBar"),	defFont.get(), FontList, _T("ステータスバー"));
	CalcFont	= IniFile->ReadFontInf(_T("Calculator"),defFont.get(), FontList, _T("電卓"));
	DialogFont  = IniFile->ReadFontInf(_T("Dialog"),	Application->DefaultFont, FontList, _T("ダイアログ"));
	if (DialogFont->Size>10) DialogFont->Size = 10;
	Application->DefaultFont->Assign(DialogFont);
	ToolBarFont = IniFile->ReadFontInf(_T("ToolBar"),	DialogFont,	   FontList, _T("ツールボタン"));
	TabBarFont	= IniFile->ReadFontInf(_T("TabBar"),	DialogFont,	   FontList, _T("タブバー"));

	defFont->Name = "ＭＳ 明朝";
	CharInfFont = IniFile->ReadFontInf(_T("CharInfo"),	defFont.get(), FontList);

	//メッセージ用ヒント
	MsgHint = new UsrHintWindow(this);
	//2ストロールキー用ヒント
	KeyHint = new UsrHintWindow(this);

	SetupFont();

	ExeCmdsBusy = false;
	FindBusy	= false;
	CalcBusy	= false;

	//ディレクトリ履歴
	CheckDirHistory(0);
	CheckDirHistory(1);

	//ワークリスト履歴
	i = 0;
	while (i<WorkListHistory->Count) {
		if (!file_exists(get_csv_item(WorkListHistory->Strings[i], 0))) WorkListHistory->Delete(i); else i++;
	}

	//ワークリスト履歴を初期化
	for (int i=0; i<MAX_WORKHISTORY; i++) {
		TMenuItem *mp = new TMenuItem(WorkListHistoryItem);
		mp->OnClick   = WorkListHstItemClick;
		mp->Tag 	  = i;
		WorkListHistoryItem->Add(mp);
	}

	UnicodeString sct = "Grep";
	for (int i=0; i<100; i++) SubDirNCombo->Items->Add(i);
	SubDirCheckBox->Checked   = IniFile->ReadBool(   sct, "FindSubDir");
	SubDirNCombo->ItemIndex   = IniFile->ReadInteger(sct, "SubDirN",	99);
	SkipDirEdit->Hint		  = LoadUsrMsg(USTR_HintMltSepSC);
	SkipDirEdit->Text		  = IniFile->ReadString( sct, "SkipDirs");
	RegExCheckBox->Checked	  = IniFile->ReadBool(   sct, "RegExp");
	AndCheckBox->Checked	  = IniFile->ReadBool(   sct, "AndSearch");
	CaseCheckBox->Checked	  = IniFile->ReadBool(   sct, "CaseSenstive");
	ExclTagCheckBox->Checked  = IniFile->ReadBool(   sct, "ExcludeTag");
	OneMatchCheckBox->Checked = IniFile->ReadBool(   sct, "OneMatch");
	NextLineCheckBox->Checked = IniFile->ReadBool(   sct, "NextLine");
	RegExRCheckBox->Checked   = IniFile->ReadBool(   sct, "RegExpR");
	CaseRCheckBox->Checked	  = IniFile->ReadBool(   sct, "CaseReplace");
	AskRepCheckBox->Checked   = IniFile->ReadBool(   sct, "AskReplace");
	AndOrCheckBox->Checked	  = IniFile->ReadBool(   sct, "FltAndOr");
	set_MigemoCheckBox(MigemoCheckBox, _T("MigemoMode"), sct);

	IniFile->LoadComboBoxItems(GrepFindComboBox, RegExCheckBox->Checked? _T("GrepPtnHistory") : _T("GrepFindHistory"));
	IniFile->LoadComboBoxItems(GrepMaskComboBox, _T("GrepMaskHistory"));
	IniFile->LoadComboBoxItems(RepFindComboBox,  RegExRCheckBox->Checked? _T("RepPtrnHisgory") : _T("RepFindHistory"));
	IniFile->LoadComboBoxItems(RepStrComboBox,	_T("RepStrHistory"));

	if (GrepMaskComboBox->Items->Count==0) GrepMaskComboBox->Items->Add("*.txt");
	GrepMaskComboBox->ItemIndex = IniFile->ReadInteger(sct, "MaskHistIdx");
	GrepMaskComboBox->Hint = LoadUsrMsg(USTR_HintMltSepSC);

	//一時ディレクトリを設定
	TempPathA = chk_cre_dir(TempPathA);
	if (TempPathA.IsEmpty()) {
		msgbox_WARN("一時ディレクトリが作成できません\r\n実行ディレクトリに作成します。");
		SetTempPathA("Temp");
		TempPathA = chk_cre_dir(TempPathA);
		if (TempPathA.IsEmpty()) {
			TempPathFTP = EmptyStr;
			msgbox_WARN(USTR_CantMakeTmpDir);
		}
	}
	else {
		ClearTempDir();
		ClearTempArc();
		ClearTempArc(TempPathFTP);
	}

	//Grep用プログレスバー初期化
	SttPrgBar = new SttProgressBar(GrepStatusBar, 1);
	SttPrgBar->MsgIndex = 2;

	//Taskスレッド初期化
	for (int i=0; i<MAX_TASK_THREAD; i++) TaskThread[i] = NULL;

	//アイコン取得スレッド
	GetIconThread = new TGetIconThread(true);
	GetIconThread->CallbackWnd = Handle;
	GetIconThread->Start();

	//画像ビュースレッド作成
	ImgViewThread = new TImgViewThread(true);
	ImgViewThread->Start();
	ThumbnailThread = new TThumbnailThread(true);
	ThumbnailThread->CallbackWnd = Handle;
	ThumbnailThread->Start();
	ImgBuff = new Graphics::TBitmap();

	//背景画像
	for (int i=0; i<MAX_FILELIST; i++) {
		BgBuff[i] = new Graphics::TBitmap();
		HideBgImg[i] = false;
	}

	//テキストビュアー
	TxtViewer = new TTxtViewer(this, TextPaintBox, TextScrollBar, TxtViewScrPanel,
								TxtSttHeader, TextRulerBox, TextCurColPanel, TextMarginBox);
	TxtViewer->isHtm2Txt   = IniFile->ReadBoolGen(_T("Htm2Txt"));
	TxtViewer->isFixedLen  = IniFile->ReadBoolGen(_T("FixedLen"));
	TxtViewer->ShowRuby    = IniFile->ReadBoolGen(_T("ShowRuby"),	true);
	TxtViewer->TopIsHeader = IniFile->ReadBoolGen(_T("TopIsHeader"));
	TxtViewer->isIncMigemo = IniFile->ReadBoolGen(_T("TvIncMigemo"));

	//テキストプレビュー
	TxtPrvBuff	= new TStringList();
	TxtTailBuff = new TStringList();
	TxtPrvShowLineNo = IniFile->ReadBoolGen(_T("TxtPrvShowLnNo"),	false);
	TxtPrvKeepIndex  = IniFile->ReadBoolGen(_T("TxtPrvKeepIndex"),	false);

	//ワークリスト
	WorkListName = to_absolute_name(
			(IniWorkMode==1)? HomeWorkList : IniFile->ReadStrGen(_T("WorkListName"), "WORKLIST.nwl"));
	WorkListTime = get_file_age(WorkListName);

	//ファイルリストの初期設定
	for (int i=0; i<MAX_FILELIST; i++) {
		if (IniSortMode[i]>0) SortMode[i] = IniSortMode[i] - 1;
		//パス
		ApplyDotNyan = true;
		if (!start_pnam[i].IsEmpty()) {
			CurPath[i] = exclede_delimiter_if_root(start_pnam[i]);
		}
		else {
			UnicodeString key;  key.sprintf(_T("CurPath%u"), i + 1);
			UnicodeString c_path = exclede_delimiter_if_root(IniFile->ReadStrGen(key.c_str(), ExePath));
			if (InitialPath[i].IsEmpty()) InitialPath[i] = ExePath;
			PathMask[i] = make_PathMask(InitialMask[i], "起動時");

			switch (IniPathMode[i]) {
			case 1:	//ワークリスト
				ListStt[i].is_Work = true;
				FCurPath[i] = c_path;
				break;
			case 2:	//指定
				CurPath[i] = exclede_delimiter_if_root(cv_env_str(InitialPath[i]));
				break;
			default:
				CurPath[i] = c_path;
			}
		}
	}

	//タブバーの初期化
	int tab_idx = -1;
	if (IniPathToTab1) {
		//初期パスを先頭タブに
		TStringDynArray itm_buf = get_csv_array((TabList->Count>0)? TabList->Strings[0] : EmptyStr, TABLIST_CSVITMCNT, true);
		itm_buf[0] = CurPath[0];
		itm_buf[1] = CurPath[1];
		UnicodeString lbuf = make_csv_rec_str(itm_buf);
		if (TabList->Count==0) add_TabList(lbuf); else TabList->Strings[0] = lbuf;
		tab_idx = 0;
	}
	else {
		for (int i=0; i<TabList->Count; i++) {
			TStringDynArray itm_buf = get_csv_array(TabList->Strings[i], TABLIST_CSVITMCNT, true);
			if (SameText(itm_buf[0], CurPath[0]) && SameText(itm_buf[1], CurPath[1])) {
				tab_idx = i; break;
			}
		}
		if (tab_idx==-1) {
			insert_TabList(0, make_csv_str(CurPath[0]) + "," + make_csv_str(CurPath[1]) + ",\"\",\"\"");
			tab_idx = 0;
		}
	}

	//初期パス以外のタブをホームに戻す
	if (IniTabHomeAll) {
		for (int i=0; i<TabList->Count; i++) {
			if (i==tab_idx) continue;
			TStringDynArray itm_buf = get_csv_array(TabList->Strings[i], TABLIST_CSVITMCNT, true);
			if (!itm_buf[4].IsEmpty()) itm_buf[0] = itm_buf[4];
			if (!itm_buf[5].IsEmpty()) itm_buf[1] = itm_buf[5];
			TabList->Strings[i] = make_csv_rec_str(itm_buf);
			SetTabStr(i);
		}
	}

	//タブバーの初期化
	UpdateTabBar(tab_idx, true);

	//タブのワークリスト
	if (ShowTabBar) {
		UnicodeString wnam = get_TabWorkList(TabControl1->TabIndex);
		if (!wnam.IsEmpty()) WorkListName = wnam;
	}

	//ドロップターゲット(テキストビュアー)を設定
	usr_SH->AddTargetList(this, TxtScrollPanel);

	if (SplashForm) SplashForm->SetMsgLabel(_T("画面準備中..."));
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::FormShow(TObject *Sender)
{
	if (Initialized) return;

	Screen->OnActiveFormChange = ActiveFormChange;

	IconImgList->SetSize(SIcoSize, SIcoSize);
	IconImgListI->SetSize(SIcoSize, SIcoSize);
	IconImgListP->SetSize(SIcoSize, SIcoSize);
	IconImgListV->SetSize(SIcoSize, SIcoSize);

	//透過設定
	AlphaBlend		= AlphaForm;
	AlphaBlendValue = AlphaValue;

	//最初に起動
	if (IsPrimary) {
		//指定サイズ
		if (IniWinMode==1) {
			WindowState = wsNormal;
			SetBounds(IniWinLeft, IniWinTop, IniWinWidth, IniWinHeight);
		}
		//前回のサイズ
		else IniFile->LoadFormPos(this, 800,600);
	}
	//二重起動
	else {
		IniFile->LoadFormPos(this, 800,600, "Win2");

		//メインの位置を取得
		TRect rc;
		if (IniWinMode==1) {
			rc.Left = IniWinLeft;
			rc.Top	= IniWinTop;
			rc.SetWidth(IniWinWidth);
			rc.SetHeight(IniWinHeight);
		}
		else {
			rc.Left = IniFile->ReadInteger(SCT_General, "WinLeft",	0);
			rc.Top	= IniFile->ReadInteger(SCT_General, "WinTop",	0);
			rc.SetWidth( IniFile->ReadInteger(SCT_General, "WinWidth",	0));
			rc.SetHeight(IniFile->ReadInteger(SCT_General, "WinHeight",	0));
		}
		//交差面積が半分以下ならオフセットを設定
		rc = TRect::Intersect(rc, BoundsRect);
		if ((rc.Width() * rc.Height()) <= (Width * Height / 2)) {
			IniFile->PosOffsetLeft = Left - rc.Left;
			IniFile->PosOffsetTop  = Top  - rc.Top;
		}
	}

	OrgWinState  = WindowState;
	LastWinState = WindowState;

	//デザイン設定
	SetupDesign(true, true);

	//ツールバー
	if (SplashForm) SplashForm->SetMsgLabel(_T("ツールバー設定中..."));
	UpdateToolBtn(SCMD_FLIST);
	UpdateToolBtn(SCMD_TVIEW);
	UpdateToolBtn(SCMD_IVIEW);

	SetScrMode();

	//ファンクションキーバー
	InitFKeyBtn();

	Initialized = true;

	if (WindowState==wsMaximized) FormResize(this);

	::PostMessage(Handle, WM_FORM_SHOWED, 0, 0);
}

//---------------------------------------------------------------------------
//フォームが表示された直後の処理
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::WmFormShowed(TMessage &msg)
{
	if (SplashForm) SplashForm->Close();

	FileListBox[0]->ItemIndex = 0;
	FileListBox[1]->ItemIndex = 0;
	FileListBox[StartTag]->SetFocus();
	FlScrPanel[0]->UpdateKnob();
	FlScrPanel[1]->UpdateKnob();
	Application->ProcessMessages();
	L_PanelResize(NULL);
	R_PanelResize(NULL);
	UpdateFileListRect();

	UpdateFKeyBtn();

	ClearNopStt();

	UpdateBgImage(true, true);
	if (!StartFile.IsEmpty()) IndexOfFileList(StartFile);
	SetFileInf();

	//起動時ログ
	UnicodeString tmp;
	tmp.sprintf(_T("NyanFi %s %s"), VersionStr.c_str(), is_X64()? _T("x64") : _T("x86"));
	if (MultiInstance) {
		if (IsPrimary)
			tmp += " (Primary)";
		else
			tmp.cat_sprintf(_T(" (Duplicated-%u)"), NyanFiIdNo);
	}
#ifdef _DEBUG
	tmp += "  ### DEBUG MODE ###";
#endif
	StartLog(tmp);
	if (IsAdmin) AddLog(_T("  管理者として実行"));

	if (!InitialLog.IsEmpty()) {
		std::unique_ptr<TStringList> lst(new TStringList());
		lst->Text = InitialLog;
		for (int i=0; i<lst->Count; i++) AddLog(lst->Strings[i]);
	}

	//xdoc2txt
	if (xd2tx_Initialize()) {
		AddLog(make_LogHdr(_T("LOAD"), "xd2txlib.dll"));
	}

	//ワークリスト
	if ((CurStt->is_Work || OppStt->is_Work)? SetWorkList(WorkListName) : load_WorkList(WorkListName))
		AddLog(make_LogHdr(_T("LOAD"), WorkListName));

	//構文強調定義エラー
	AddErr_Highlight();

	//色見本
	UnicodeString swatch_file = ExePath + SWATCH_FILE;
	if (file_exists(swatch_file)) {
		tmp = make_LogHdr(_T("LOAD"), swatch_file);
		if (LoadSwatchbook(swatch_file)==0) tmp[1] = 'E';
		AddLog(tmp);
	}

	//フォントサンプル定義
	load_FontSample(ExePath + FONTSMPL_FILE);

	//使用済みバッチファイルを削除
	delete_FileIf(ExePath + "update.bat");
	delete_FileIf(ExePath + "demote.bat");

	//ホットキー登録
	if (IsPrimary) {
		if (!register_HotKey(ID_CALL_HOTKEY, CallHotKey))	 msgbox_ERR(GlobalErrMsg);
		if (!register_HotKey(ID_APP_HOTKEY,	 AppListHotKey)) msgbox_ERR(GlobalErrMsg);
	}

	//タイマー始動
	for (int i=0; i<MAX_TIMER_EVENT; i++) Timer_StartCnt[i] = GetTickCount();
	TaskSttTimer->Enabled	= true;
	UpdLogTimer->Interval	= LogInterval;
	UpdLogTimer->Enabled	= true;
	WatchDirTimer->Interval = WatchInterval;
	WatchDirTimer->Enabled	= true;
	WatchTailTimer->Enabled = true;
	MsgHintTimer->Interval	= MsgHintTime;

	//起動時間表示
	if (LogDebugInf) AddLog(tmp.sprintf(_T("%8.3f秒"), (GetTickCount() - StartedCount)/1000.0));

	AddLog(_T("All Task Ready"));

	if (!StartCmds.IsEmpty()) ExeCommandsCore(StartCmds); else ExeEventCommand(OnAppStart);

	//メッセージ
	if (!StartMsg.IsEmpty()) {
		if (WindowState==wsMinimized) Application->Restore();
		::SetForegroundWindow(Handle);
		CmdRequestList->Add(tmp.sprintf(_T("MsgBoxCenter_\"%s\""), StartMsg.c_str()));
	}

	//タスクトレイ
	TrayIcon1->Hint    = Application->Title;
	TrayIcon1->Visible = (IsPrimary && StoreTaskTray);
}

//---------------------------------------------------------------------------
//終了確認
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::FormCloseQuery(TObject *Sender, bool &CanClose)
{
	UpdLogTimer->Enabled	= false;
	WatchDirTimer->Enabled	= false;
	WatchTailTimer->Enabled = false;

	try {
		if (usr_ARC->Busy) {
			msgbox_WARN("アーカイブ処理中です。");
			Abort();
		}
		if (SureExit && !msgbox_Sure(_T("NyanFi を終了しますか?"), true, true)) Abort();

		if (get_BusyTaskCount()>0 && !msgbox_Sure(_T("タスクを中止して終了しますか?"), true, true)) Abort();
		if (WorkListChanged && !WorkListFiltered) {
			if (WorkListName.IsEmpty()) {
				SaveAsWorkListAction->Execute();
			}
			else if (!save_WorkList(WorkListName)) {
				WorkListTime = get_file_age(WorkListName);
				msgbox_ERR(LoadUsrMsg(USTR_FaildSave, _T("ワークリスト")));
				Abort();
			}
		}
	}
	catch (EAbort &e) {
		CanClose = false;
		UpdLogTimer->Enabled	= true;
		WatchDirTimer->Enabled	= true;
		WatchTailTimer->Enabled = true;
		cursor_Default();
	}
}
//---------------------------------------------------------------------------
//終了
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::FormClose(TObject *Sender, TCloseAction &Action)
{
	if (Closing) return;

	Closing = true;
	Screen->OnActiveFormChange = NULL;

	//他のNyanFiを終了
	if (IsPrimary && !ReqKeepDupl && (CloseOthers || StoreTaskTray) && IsDuplicated()) {
		StartLog(_T("他のNyanFiを終了"));
		if (!CloseOtherNyanFi()) AddLog(_T("E 終了に失敗しました。"));
		AddLogCr();
	}

	if (FindBusy)	 FindAborted  = true;
	if (CalcBusy)	 CalcAborted  = true;
	if (ExeCmdsBusy) XCMD_Aborted = true;

	try {
		if (IdFTP1->Connected()) IdFTP1->Disconnect();
	}
	catch (...) {
		SetActionAbort(_T("FTP切断に失敗しました。"));
	}

	if		(ScrMode==SCMD_IVIEW) CloseIAction->Execute();
	else if (ScrMode==SCMD_TVIEW) ExeCommandV(_T("Close"));

	if (ScrMode!=SCMD_FLIST) SetScrMode();
	RecoverFileList(0);
	RecoverFileList(1);

	//タスク中断
	CancelAllTaskAction->Execute();
	for (int i=0; i<MAX_TASK_THREAD; i++) {
		TTaskThread *tp = TaskThread[i];
		if (tp) {
			tp->Terminate();
			TaskThread[i] = NULL;
		}
	}

	//イベント: 終了
	InhDirHist++;		//これ以降、ディレクトリ履歴追加を抑止
	ExeEventCommand(OnAppClose);

	TaskSttTimer->Enabled = false;
	UnInitializing = true;
	LastCurTag = CurListTag;

	ThumbnailThread->ReqClear = true;
	ThumbnailThread->Terminate();

	GetIconThread->Terminate();
	GetIconThread = NULL;

	ImgViewThread->AddRequest(_T("EMPTY"));
	ImgViewThread->Terminate();
	ImgViewThread = NULL;

	for (int i=0; i<MAX_FILELIST; i++) if (hWatchDir[i]) ::FindCloseChangeNotification(hWatchDir[i]);

	if		(!LoupeForm->Floating)	LoupeForm->SaveOption();
	else if (LoupeForm->Visible)	LoupeForm->Close();

	//プライマリー側での設定保存処理
	if (IsPrimary) {
		//ホットキーの解除
		for (int i=0; i<HotKeyList->Count; i++) {
			int id = HotKeyList->Names[i].ToIntDef(0);
			if (id!=0) ::UnregisterHotKey(Handle, id);
		}

		SaveOptions();

		IniFile->WriteBoolGen(_T("HistogramFloating"), HistForm->Floating);
		if (HistForm->Floating && HistForm->Visible) HistForm->Close();

		IniFile->WriteBoolGen(_T("DockIsTop"),	SideDockPanel->Align==alTop);
		if (LayoutMode==0) {
			IniFile->WriteIntGen(_T("SubHeight"),	SubPanel->Height);
			IniFile->WriteIntGen(_T("InfWidth"),	InfPanelWidth);
			IniFile->WriteIntGen(_T("ImageWidth"),	PreviewWidth);
		}
		else {
			IniFile->WriteIntGen(_T("SubWidth"),	SubPanel->Width);
			IniFile->WriteIntGen(_T("InfHeight"),	InfPanelHeight);
			IniFile->WriteIntGen(_T("ImageHeight"),	PreviewHeight);
		}

		IniFile->WriteIntGen(_T("TailHeight"),	TxtTailListPanel->Height);

		if (DivFileListUD)
			IniFile->WriteIntGen(_T("L_Height"),	L_Panel->Height);
		else
			IniFile->WriteIntGen(_T("L_Width"),		L_Panel->Width);

		IniFile->WriteIntGen(_T("GrepTR_Width"),	GrepT2Panel->Width);
		IniFile->WriteIntGen(_T("RepTR_Width"),		RepT2Panel->Width);
		IniFile->WriteIntGen(_T("GrepLL_Width"),	GrepM1Panel->Width);
		IniFile->WriteIntGen(_T("GrepFilterWidth"),	GrepFilterPanel->Width);
		IniFile->WriteBoolGen(_T("ShowThumbnail"),	ThumbnailGrid->Visible);
		IniFile->WriteIntGen(_T("ImgSidebarWidth"),	ImgSidePanel->Width);

		IniFile->SaveFormPos(this);

		IniFile->WriteStrGen(_T("CurPath1"),		CurPath[0]);
		IniFile->WriteStrGen(_T("CurPath2"),		CurPath[1]);
		IniFile->WriteStrGen(_T("WorkListName"),	WorkListName);

		for (int i=0; i<FontList->Count; i++)
			IniFile->WriteFontInf(FontList->Names[i], (TFont*)FontList->Objects[i]);

		IniFile->WriteBoolGen(_T("Htm2Txt"),		TxtViewer->isHtm2Txt);
		IniFile->WriteBoolGen(_T("FixedLen"),		TxtViewer->isFixedLen);
		IniFile->WriteBoolGen(_T("ShowRuby"),		TxtViewer->ShowRuby);
		IniFile->WriteBoolGen(_T("TopIsHeader"),	TxtViewer->TopIsHeader);
		IniFile->WriteBoolGen(_T("TvIncMigemo"),	TxtViewer->isIncMigemo);
		IniFile->WriteBoolGen(_T("TxtPrvShowLnNo"),	TxtPrvShowLineNo);
		IniFile->WriteBoolGen(_T("TxtPrvKeepIndex"),TxtPrvKeepIndex);

		UnicodeString sct = "Grep";
		IniFile->WriteBool(   sct, "FindSubDir",	SubDirCheckBox);
		IniFile->WriteInteger(sct, "SubDirN",		SubDirNCombo);
		IniFile->WriteString( sct, "SkipDirs",		SkipDirEdit);
		IniFile->WriteBool(   sct, "RegExp",		RegExCheckBox);
		IniFile->WriteBool(   sct, "AndSearch",		AndCheckBox);
		IniFile->WriteBool(   sct, "CaseSenstive",	CaseCheckBox);
		IniFile->WriteBool(   sct, "ExcludeTag",	ExclTagCheckBox);
		IniFile->WriteBool(   sct, "OneMatch",		OneMatchCheckBox);
		IniFile->WriteBool(   sct, "NextLine",		NextLineCheckBox);
		IniFile->WriteBool(   sct, "RegExpR",		RegExRCheckBox);
		IniFile->WriteBool(   sct, "CaseReplace",	CaseRCheckBox);
		IniFile->WriteBool(   sct, "AskReplace",	AskRepCheckBox);
		IniFile->WriteBool(   sct, "FltAndOr",		AndOrCheckBox);
		IniFile->WriteBool(   sct, "MigemoMode",	MigemoCheckBox);

		IniFile->SaveComboBoxItems(GrepFindComboBox, RegExCheckBox->Checked? _T("GrepPtnHistory") : _T("GrepFindHistory"));
		IniFile->SaveComboBoxItems(GrepMaskComboBox, _T("GrepMaskHistory"));
		IniFile->SaveComboBoxItems(RepFindComboBox,  RegExRCheckBox->Checked? _T("RepPtrnHisgory") : _T("RepFindHistory"));
		IniFile->SaveComboBoxItems(RepStrComboBox,	 _T("RepStrHistory"));
		IniFile->WriteInteger(sct, "MaskHistIdx",	 GrepMaskComboBox);

		CheckDirHistory(0);
		CheckDirHistory(1);

		if (!NotSaveINI) {
			UpdateIniFile(IniFile);
			UpdateIniFile(FolderIconFile);
		}

		//ドライブ容量ログの更新
		if (!DriveLogName.IsEmpty()) update_DriveLog(true);
	}
	//二重起動側の画面情報を送出
	else {
		HWND hPrimeWnd = get_PrimNyanWnd();
		if (hPrimeWnd) {
			if (WindowState==wsMinimized) WindowState = wsNormal;
			Win2Data.WinState = WindowState;
			if (WindowState==wsMaximized) WindowState = wsNormal;
			Win2Data.WinLeft	 = Left;
			Win2Data.WinTop 	 = Top;
			Win2Data.WinWidth	 = Width;
			Win2Data.WinHeight	 = Height;
			Win2Data.SubHeight	 = SubPanel->Height;
			Win2Data.SubWidth	 = SubPanel->Width;
			Win2Data.InfWidth	 = InfPanelWidth;
			Win2Data.InfHeight	 = InfPanelHeight;
			Win2Data.ImageWidth  = PreviewWidth;
			Win2Data.ImageHeight = PreviewHeight;
			Win2Data.TailHeight	 = TxtTailListPanel->Height;
			Win2Data.ShowFileListOnly = IsPrimary? ShowFileListOnly : ShowFileListOnly2;
			COPYDATASTRUCT cd;
			cd.dwData = CPYDTID_DPL_INF;
			cd.cbData = sizeof(Win2Data);
			cd.lpData = &Win2Data;
			::SendMessage(hPrimeWnd, WM_COPYDATA, 0, (LPARAM)&cd);
		}
	}

	StartLog(_T("終了")); AddLogCr();

	//ログを保存
	if (SaveLog) {
		UnicodeString bnam = ExePath + "tasklog";
		if (NyanFiIdNo>1) bnam.cat_sprintf(_T("%u"), NyanFiIdNo);
		UnicodeString lnam = bnam + ".txt";

		bool app_flag = AppendLog? ((int)get_file_age(lnam) == (int)Now()) : false;
		//古いログを更新
		if (!app_flag) {
			//最大世代数以降を削除
			for (int i= std::max(1, MaxLogFiles); ; i++) {
				UnicodeString fnam = bnam;  fnam.cat_sprintf(_T("~%u.txt"), i);
				if (!file_exists(fnam)) break;
				delete_File(fnam);
			}
			//名前をシフト
			for (int i=MaxLogFiles-1; i>0; i--) {
				UnicodeString o_nam = bnam;  o_nam.cat_sprintf(_T("~%u.txt"), i);
				UnicodeString n_nam = bnam;  n_nam.cat_sprintf(_T("~%u.txt"), i + 1);
				if (file_exists(o_nam)) move_File(o_nam, n_nam);
			}
			if (file_exists(lnam) && MaxLogFiles>0) move_File(lnam, bnam + "~1.txt");
		}
		//保存
		try {
			if (app_flag)
				TFile::AppendAllText(lnam, LogBufList->Text, TEncoding::UTF8);
			else
				LogBufList->SaveToFile(lnam, TEncoding::UTF8);
		}
		catch (...) {
			msgbox_ERR(LoadUsrMsg(USTR_FaildSave, _T("ログ")));
		}
	}

	//シャットダウン/再起動
	if (ReqPowerOff || ReqReboot) {
		//特権を有効化
		bool ok = false;
		HANDLE hToken;
		if (::OpenProcessToken(::GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES|TOKEN_QUERY, &hToken)) {
			TOKEN_PRIVILEGES tknPrvlgs;
			if (::LookupPrivilegeValue(NULL, SE_SHUTDOWN_NAME, &(tknPrvlgs.Privileges[0].Luid))) {
				tknPrvlgs.PrivilegeCount = 1;
				tknPrvlgs.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
				::AdjustTokenPrivileges(hToken, FALSE, &tknPrvlgs, 0, NULL, NULL);
				ok = (GetLastError()==ERROR_SUCCESS);
			}
			::CloseHandle(hToken);
		}
		//シャットダウン
		if (ok)
			::ExitWindowsEx(ReqReboot? EWX_REBOOT : EWX_POWEROFF, 0);
		else
			msgbox_ERR(USTR_FaildProc);
	}
}

//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::FormDestroy(TObject *Sender)
{
	::UnhookWindowsHookEx(hDlgHook);

	EndGlobal();

	delete LogRWLock;
	delete IconRWLock;
	delete FldIcoRWLock;

	delete SttPrgBar;
	delete MsgHint;
	delete KeyHint;
	delete TxtViewer;
	delete TxtPrvBuff;
	delete TxtTailBuff;

	delete ImgBuff;

	for (int i=0; i<MAX_FILELIST; i++) {
		delete BgBuff[i];
		delete FlScrPanel[i];
	}

	delete TxtPrvScrPanel;
	delete TxtTailScrPanel;
	delete InfScrPanel;
	delete LogScrPanel;
	delete ImgInfScrPanel;
	delete TxtViewScrPanel;
	delete ResultScrPanel;

	delete IdFTP1;
	delete IdAntiFreeze1;
	delete IdSSLIOHandlerSocketOpenSSL1;

	delete UserHighlight;
	delete IniFile;
}

//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ActivateMainForm()
{
	if (::IsIconic(Handle)) this->Perform(WM_SYSCOMMAND, SC_RESTORE, (NativeInt)0);
	::SetForegroundWindow(Handle);
	if (StoreTaskTray) Show();
	Application->Restore();
	Application->BringToFront();
}

//---------------------------------------------------------------------------
//FindBusy プロパティの設定
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::SetFindBusy(bool Value)
{
	FFindBusy = Value;
	FindDiff  = false;
	if (!Initialized) return;

	if (Value) {
		FindTag 	= CurListTag;
		FindCount	= 0;
		FindAborted = false;
		cursor_HourGlass();
	}
	else {
		MsgHint->ReleaseHandle();
		cursor_Default();
	}

	for (int i=0; i<MainMenu1->Items->Count; i++) MainMenu1->Items->Items[i]->Enabled = !Value;
	ToolBarF->Enabled = !Value;
	set_CloseButton(!Value);
}
//---------------------------------------------------------------------------
//CalcBusy プロパティの設定
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::SetCalcBusy(bool Value)
{
	FCalcBusy = Value;
	if (!Initialized) return;

	if (Value) {
		CalcTag = CurListTag;
		CalcAborted = false;
		cursor_HourGlass();
	}
	else {
		MsgHint->ReleaseHandle();
		cursor_Default();
	}

	for (int i=0; i<MainMenu1->Items->Count; i++) MainMenu1->Items->Items[i]->Enabled = !Value;
	ToolBarF->Enabled = !Value;
	set_CloseButton(!Value);
}
//---------------------------------------------------------------------------
//CurWorking プロパティの設定
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::SetCurWorking(bool Value)
{
	FCurWorking = Value;
	if (!Initialized) return;

	if (Value) {
		WorkingTag = CurListTag;
		cursor_HourGlass();
	}
	else {
		MsgHint->ReleaseHandle();
		cursor_Default();
	}
}
//---------------------------------------------------------------------------
//ExeCmdsBusy プロパティの設定
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::SetExeCmdsBusy(bool Value)
{
	FExeCmdsBusy = Value;
	XCMD_IsBusy  = Value;
	XCMD_Aborted = XCMD_MsgOff = false;
	XCMD_ModalResult = mrNone;
	if (!Initialized) return;

	set_CloseButton(!Value);
	SubPanel->Enabled = !Value;
}

//---------------------------------------------------------------------------
//確認「その他」が有効か?
//---------------------------------------------------------------------------
bool __fastcall TNyanFiForm::SureOtherActiv()
{
	return ((ExeCmdsBusy && XCMD_MsgOff)? false : SureOther);
}

//---------------------------------------------------------------------------
//Windows終了時の処理
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::WmQueryEndSession(TMessage& msg)
{
	StartLog(_T("シャットダウン"));
	if (!ReqPowerOff && !ReqReboot) Perform(WM_CLOSE, 0, (NativeInt)0);
	msg.Result = 1;
}

//---------------------------------------------------------------------------
//二重起動された NyanFi からの情報を処理
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::WmCopyData(TMessage& msg)
{
	COPYDATASTRUCT *cd = (COPYDATASTRUCT*)msg.LParam;
	if (!Initialized || UnInitializing) { msg.Result = 0; return; }

	//起動オプションの処理
	if (cd->dwData==CPYDTID_OPTIONS) {
		//オプションの解析
		UnicodeString cmdln = (LPTSTR)cd->lpData;
		StartLog("RCVMSG " + cmdln);
		std::unique_ptr<TStringList> opt_lst(new TStringList());
		split_cmd_line(cmdln, opt_lst.get());

		bool req_close = false;
		bool not_act   = false;
		for (int i=0; i<opt_lst->Count && !req_close; i++) {
			UnicodeString lbuf = opt_lst->Strings[i];
			req_close  = SameText(lbuf, "-Q");
			NotSaveINI = SameStr(lbuf, "-q");
			if (StartsText("-XCalculator_CB", lbuf)) not_act = true;
		}

		if (!not_act) {
			if (WindowState==wsMinimized) Application->Restore();
			Application->BringToFront();
		}

		if (req_close) {
			Close();
		}
		else {
			int  c_tag = CurListTag;
			UnicodeString msg_str, c_fnam, l_pnam, r_pnam, x_cmds;

			for (int i=0; i<opt_lst->Count; i++) {
				UnicodeString cbuf = Trim(opt_lst->Strings[i]);
				if (cbuf.IsEmpty()) continue;
				if (remove_top_s(cbuf, '-')) {
					if (cbuf.IsEmpty()) continue;
					UnicodeString opt = split_top_ch(cbuf).UpperCase();
					WideChar och = opt[1];
					//パス、ファイル、コマンド、メッセージ
					if (starts_tchs(_T("LRFXM"), opt)) {
						UnicodeString prmbuf;
						if (remove_top_s(cbuf, '\"')) {
							prmbuf = split_tkn(cbuf, '\"');
						}
						else {
							if (och=='X' && remove_top_AT(cbuf)) {
								if (remove_top_s(cbuf, '\"'))
									prmbuf.sprintf(_T("@\"%s\""), split_tkn(cbuf, '\"').c_str());
								else
									prmbuf.sprintf(_T("@%s"),	  split_tkn(cbuf, ' ').c_str());
							}
							else prmbuf = split_tkn(cbuf, ' ');
						}

						if (!prmbuf.IsEmpty()) {
							switch (och) {
							case 'L': l_pnam  = prmbuf;	break;	//左パス
							case 'R': r_pnam  = prmbuf;	break;	//右パス
							case 'F': c_fnam  = prmbuf;	break;	//カレントファイル
							case 'X': x_cmds  = prmbuf;	break;	//コマンド
							case 'M': msg_str = prmbuf;	break;	//メッセージ
							}
						}
					}
					//カレントの指定
					else if (och=='C') c_tag = USAME_TS(split_tkn(cbuf, ' '), "R")? 1 :0;
				}
				//カレントファイル/ディレクトリ
				else {
					UnicodeString prmbuf;
					if (remove_top_s(cbuf, '\"'))
						prmbuf = split_tkn(cbuf, '\"');
					else
						prmbuf = split_tkn(cbuf, ' ');
					c_fnam = exclude_quot(prmbuf);
				}
			}

			if (!l_pnam.IsEmpty() || !r_pnam.IsEmpty() || !c_fnam.IsEmpty()) {
				if (ScrMode!=SCMD_FLIST) SetScrMode();
				if ((!c_fnam.IsEmpty() && CurListTag==0) || !l_pnam.IsEmpty()) RecoverFileList(0);
				if ((!c_fnam.IsEmpty() && CurListTag==1) || !r_pnam.IsEmpty()) RecoverFileList(1);
			}

			if (!l_pnam.IsEmpty()) CurPath[0] = exclede_delimiter_if_root(l_pnam);
			if (!r_pnam.IsEmpty()) CurPath[1] = exclede_delimiter_if_root(r_pnam);
			ExeCmdAction((c_tag==0)? ToLeftAction : ToRightAction);
			Application->ProcessMessages();

			if (!c_fnam.IsEmpty()) {
				if (dir_exists(c_fnam)) {
					CurPath[c_tag] = exclede_delimiter_if_root(c_fnam);
				}
				else {
					CurPath[c_tag] = exclede_delimiter_if_root(ExtractFilePath(c_fnam));
					IndexOfFileList(c_fnam);
				}
				SetFileInf();
			}
			SetCurStt(c_tag);

			if (!msg_str.IsEmpty()) {
				MsgPosCenter = true;
				msgbox_OK(msg_str);
				MsgPosCenter = false;
			}

			if (!x_cmds.IsEmpty())  ExeCommandsCore(x_cmds);
		}
	}
	//二重起動側の画面情報を保存
	else if (cd->dwData==CPYDTID_DPL_INF) {
		win_dat *dp = (win_dat*)cd->lpData;
		IniFile->WriteIntGen(_T("Win2State"),			(int)dp->WinState);
		IniFile->WriteIntGen(_T("Win2Left"),			dp->WinLeft);
		IniFile->WriteIntGen(_T("Win2Top"),				dp->WinTop);
		IniFile->WriteIntGen(_T("Win2Width"),			dp->WinWidth);
		IniFile->WriteIntGen(_T("Win2Height"),			dp->WinHeight);
		IniFile->WriteBoolGen(_T("ShowFileListOnly2"),	(ShowFileListOnly2 = dp->ShowFileListOnly));

		if (LayoutMode==0) {
			IniFile->WriteIntGen(_T("SubHeight2"),		dp->SubHeight);
			IniFile->WriteIntGen(_T("InfWidth2"),		dp->InfWidth);
			IniFile->WriteIntGen(_T("ImageWidth2"),		dp->ImageWidth);
		}
		else {
			IniFile->WriteIntGen(_T("SubWidth2"),		dp->SubWidth);
			IniFile->WriteIntGen(_T("InfHeight2"),		dp->InfHeight);
			IniFile->WriteIntGen(_T("ImageHeight2"),	dp->ImageHeight);
		}

		IniFile->WriteIntGen(_T("TailHeight2"),	dp->TailHeight);

		if (Initialized && !Closing && !UnInitializing) UpdateIniFile(IniFile);
	}
	//通知メッセージ
	else if (cd->dwData==CPYDTID_DPL_MSG) {
		if (Active) ShowMessageHint((LPTSTR)cd->lpData, col_bgHint, false, false, true);
	}
	//テキストビュアーで指定ファイルを開く
	else if (cd->dwData==CPYDTID_TXTVIEW) {
		UnicodeString fnam = (LPTSTR)cd->lpData;
		if (!fnam.IsEmpty()) {
			if (ScrMode==SCMD_IVIEW) CloseIAction->Execute();
			if (!SetAndOpenTxtViewer(fnam)) SetActionAbort(USTR_FileNotOpen);
		}
	}
	//イメージビュアーで指定ファイルを開く
	else if (cd->dwData==CPYDTID_IMGVIEW) {
		UnicodeString fnam = (LPTSTR)cd->lpData;
		if (!fnam.IsEmpty()) {
			if (ScrMode==SCMD_IVIEW) CloseIAction->Execute();
			if		(!JumpToList(CurListTag, fnam))		SetActionAbort(GlobalErrMsg);
			else if (!ExeCmdAction(ImageViewerAction))	SetActionAbort(ActionErrMsg);
		}
	}
	//コマンドを実行
	else if (cd->dwData==CPYDTID_EXECMDS) {
		UnicodeString cmds = (LPTSTR)cd->lpData;
		if (!cmds.IsEmpty()) CmdRequestList->Add("ExeCommands_" + cmds);
	}

	msg.Result = 1;
}

//---------------------------------------------------------------------------
//呼び出しホットキー
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::WmHotKey(TMessage &msg)
{
	switch (msg.WParam) {
	case ID_CALL_HOTKEY:
		ActivateMainForm();
		break;
	case ID_APP_HOTKEY:
		Application->BringToFront();
		ActionParam = AppListHotPrm;
		AppListAction->Execute();
		break;
	}

	msg.Result = 0;
}

//---------------------------------------------------------------------------
//Alt+文字キーに対応するメニュー項目がない場合の処理
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::WmMenuChar(TMessage &msg)
{
	if (ContextMenu3)
		ContextMenu3->HandleMenuMsg2(msg.Msg, msg.WParam, msg.LParam, (LRESULT*)&msg.Result);
	else {
		if (msg.WParamHi==MF_POPUP)
			TForm::Dispatch(&msg);				//通常処理(アイコン表示の場合に必要)
		else
			msg.Result = (MNC_CLOSE << 16);		//ビープ音が鳴らないようにする
	}
}

//---------------------------------------------------------------------------
//コンテキストメニュー
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::WmContextMnueProc(TMessage &msg)
{
	msg.Result = 0;
	if (ContextMenu3)
		ContextMenu3->HandleMenuMsg2(msg.Msg, msg.WParam, msg.LParam, (LRESULT*)&msg.Result);
	else if (ContextMenu2)
		ContextMenu2->HandleMenuMsg(msg.Msg, msg.WParam, msg.LParam);

	TForm::Dispatch(&msg);
}

//---------------------------------------------------------------------------
//クリップボードへのコピー情報をヒント表示
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::WmNyanFiClpCopied(TMessage &msg)
{
	UnicodeString lbuf;
	bool txt_cliped = false;

	//テキスト
	if (msg.WParam & 0x80000000) {
		txt_cliped = true;
		lbuf.cat_sprintf(_T("　%s行 %s文字\r\n"),
			get_size_str_C(msg.WParam & 0x7fffffff).c_str(),
			get_size_str_C((unsigned int)msg.LParam).c_str());
	}
	//画像
	else {
		lbuf.cat_sprintf(_T("　サイズ: %u × %u\r\n"), (unsigned int)msg.WParam, (unsigned int)msg.LParam);
	}
	if (!lbuf.IsEmpty()) lbuf.Insert("\r\nクリップボードにコピーしました\r\n", 1);

	//ヒント表示
	if (ShowCopyHint && !lbuf.IsEmpty()) {
		TWinControl *cp = Screen->ActiveControl;
		if (ScrMode==SCMD_IVIEW) cp = ImgScrollPanel; else if (!cp) cp = ListPanel;
		MsgHint->ActivateHintEx(lbuf, ScaledInt(480), ScaledInt(240), cp, col_bgHint);
		MsgHintTimer->Interval = MsgHintTime;
		MsgHintTimer->Enabled  = true;
	}

	StatusBar1->Panels->Items[0]->Text = lbuf;

	//イベント: クリップボードにテキストをコピー
	if (txt_cliped) ExeEventCommand(OnClipText);
}

//---------------------------------------------------------------------
//サイズ変更/移動終了
//---------------------------------------------------------------------
void __fastcall TNyanFiForm::WmExitSizeMove(TMessage &msg)
{
	WndSizing = false;

	SetFlItemWidth(GetFileList(0), 0);
	SetFlItemWidth(GetFileList(1), 1);
	UpdateBgImage(true);
}

//---------------------------------------------------------------------
// 最大化情報を補正(タイトルバーとメニューを隠す)
//---------------------------------------------------------------------
void __fastcall TNyanFiForm::WmGetMinMaxInfo(TWMGetMinMaxInfo &msg)
{
	TForm::Dispatch(&msg);

	if (HideTitleMenu && !IS_FullScr()) {
		RECT rc;
		::GetWindowRect(::GetDesktopWindow(), &rc);
		::AdjustWindowRect(&rc, WS_OVERLAPPEDWINDOW, TRUE);
		rc.bottom -= 2;
		rc.top	  += 2;
		if (!ShowMainMenu) rc.top += ::GetSystemMetrics(SM_CYMENU);
		msg.MinMaxInfo->ptMaxSize.y		 = rc.bottom - rc.top;
		msg.MinMaxInfo->ptMaxTrackSize.y = rc.bottom - rc.top;
		msg.MinMaxInfo->ptMaxPosition.y	 = rc.top;
	}
}

//---------------------------------------------------------------------
//サウンド再生終了時の処理
//---------------------------------------------------------------------
void __fastcall TNyanFiForm::MmMciNotify(TMessage &msg)
{
	if (msg.WParam==MCI_NOTIFY_SUCCESSFUL) {
		MCIDEVICEID id = msg.LParam;
		//一般
		if (id==::mciGetDeviceID(_T("TPLYSND"))) {
			::mciSendString(_T("close TPLYSND"), NULL, 0, NULL);
		}
		//プレイリスト
		else if (id==::mciGetDeviceID(_T("PLYLIST"))) {
			play_PlayList();
			if (GeneralInfoDlg->Visible)
				::PostMessage(GeneralInfoDlg->Handle, WM_NYANFI_PLAYLIST, ListShuffled? 1 : 0, 0);
			ListShuffled = false;
		}
	}
	msg.Result = 0;
}

//---------------------------------------------------------------------------
//サイズ変更時の処理
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::FormResize(TObject *Sender)
{
	if (!Initialized || UnInitializing) return;

	//ファイルリスト
	if (DivFileListUD && !DivDirInfUD) L_TopPanel->Width = (HdrPanel->Width - RelPanel->Width)/2;

	if (KeepOnResize) {
		ActionParam = ListPercent;
		if (KeepCurListWidth && ListPercent!=50) ActionOptStr.sprintf(_T("%s"), (CurListTag==0)? _T("Left") : _T("Right"));
		WidenCurListAction->Execute();
	}

	//ファンクションキーバー
	UpdateFKeyBtn();

	//ステータスバー
	StatusBar1->Font->Assign(SttBarFont);
	StatusBar1->Panels->Items[0]->Width = ClientWidth
		- set_SttBarPanelWidth(StatusBar1, 1, str_len_half(GetClockStr())) - ScaledInt(20);

	//テキストビュアーヘッダ
	TxtSttHeader->Font->Assign(ViewHdrFont);
	TxtSttHeader->Panels->Items[0]->Width = ClientWidth
		- set_SttBarPanelWidth(TxtSttHeader, 1, 17)		//"UTF-16(BE) BOM付 "
		- set_SttBarPanelWidth(TxtSttHeader, 2,  5)		//"CR/LF"
		- set_SttBarPanelWidth(TxtSttHeader, 3, 14)		//".TXT:CLIPBOARD"
		- set_SttBarPanelWidth(TxtSttHeader, 4, 30);	//"00000行 0000桁 00列 0000字選択"

	if (ScrMode==SCMD_TVIEW) {
		TxtViewer->SetMetric(true);
		TxtViewer->Repaint(true);
	}

	//イメージビュアー情報ヘッダ
	TStatusPanels *pp = ImgSttHeader->Panels;
	int p_wd = (ClientWidth - pp->Items[2]->Width - pp->Items[3]->Width - pp->Items[4]->Width) / 3;
	pp->Items[0]->Width = p_wd;
	pp->Items[1]->Width = p_wd * 2;

	//Grep用ステータスバー
	GrepSttSplitterMoved(GrepSttSplitter);
	if (ScrMode==SCMD_GREP) ResultListBox->Invalidate();

	//ウィンドウの状態が変化
	if (LastWinState!=WindowState) {
		switch (WindowState) {
		case wsMaximized: ExeEventCommand(OnMaximized);	break;	//イベント: 最大化された
		case wsMinimized: ExeEventCommand(OnMinimized);	break;	//イベント: 最小化された
		case wsNormal:	  ExeEventCommand(OnRestored);	break;	//イベント: 元のサイズに戻った
		}
	}
	LastWinState = WindowState;
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ListPanelResize(TObject *Sender)
{
	if (!Initialized || UnInitializing) return;

	UpdateFileListRect();

	RequestSlowTask();

	if (KeepOnResize) {
		ActionParam = ListPercent;
		if (KeepCurListWidth && ListPercent!=50) ActionOptStr.sprintf(_T("%s"), (CurListTag==0)? _T("Left") : _T("Right"));
		WidenCurListAction->Execute();
	}
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::LRSplitterCanResize(TObject *Sender, int &NewSize, bool &Accept)
{
	Accept = !FixListWidth;
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::LRSplitterMoved(TObject *Sender)
{
	if (!Initialized || UnInitializing) return;

	RequestSlowTask();

	if (!DivFileListUD) {
		SetDirCaption(0);
		SetDirCaption(1);
	}
}

//---------------------------------------------------------------------------
//ファイルリストのスクリーン座標情報を更新
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::UpdateFileListRect()
{
	TPoint lt = ListPanel->ClientToScreen(Point(0, 0));
	TPoint rb = ListPanel->ClientToScreen(Point(ListPanel->Width, ListPanel->Height));
	UserModule->FileListRect = Rect(lt.x, lt.y, rb.x, rb.y);
}

//---------------------------------------------------------------------------
//左側リストのサイズ変更
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::L_PanelResize(TObject *Sender)
{
	if (!Initialized || UnInitializing) return;

	RequestSlowTask();

	if (DivFileListUD) {
		int r_hi = LRSplitter->Height;
		if (TabPanel->Visible) r_hi += TabPanel->Height;
		if (HdrPanel->Visible) r_hi += HdrPanel->Height;
		CurListHeight = (CurListTag==0)? L_Panel->Height : (ListPanel->ClientHeight - L_Panel->Height - r_hi);
		if (!DivDirInfUD) L_TopPanel->Width = (HdrPanel->Width - RelPanel->Width)/2;
	}
	else {
		CurListWidth = (CurListTag==0)? L_Panel->Width : (ListPanel->ClientWidth - L_Panel->Width - LRSplitter->Width);
		L_TopPanel->Width = L_Panel->Width - (RelPanel->Width - LRSplitter->Width)/2;
	}

	if (!WndSizing) SetFlItemWidth(GetFileList(0), 0);

	UpdateBgImage(true);
}
//---------------------------------------------------------------------------
//右側リストのサイズ変更
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::R_PanelResize(TObject *Sender)
{
	if (!Initialized || UnInitializing) return;

	if (!WndSizing) SetFlItemWidth(GetFileList(1), 1);

	UpdateBgImage(true);
}

//---------------------------------------------------------------------------
//サブパネルのサイズ変更
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::SubPanelResize(TObject *Sender)
{
	if (!Initialized || UnInitializing) return;

	if (LayoutMode==0)
		IniFile->WriteIntGen(IsPrimary? _T("SubHeight") : _T("SubHeight2"),	SubPanel->Height);
	else
		IniFile->WriteIntGen(IsPrimary? _T("SubWidth")  : _T("SubWidth2"),	SubPanel->Width);
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ImgInfSplitterMoved(TObject *Sender)
{
	if (!Initialized || UnInitializing) return;

	if (PreviewPanel->Visible) {
		if (LayoutMode==0) PreviewWidth = PreviewPanel->Width; else PreviewHeight = PreviewPanel->Height;
	}
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::InfLogSplitterMoved(TObject *Sender)
{
	if (!Initialized || UnInitializing) return;

	if (InfPanel->Visible) {
		if (LayoutMode==0) InfPanelWidth = InfPanel->Width; else InfPanelHeight = InfPanel->Height;
	}
}

//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::TxtPrvSplitterMoved(TObject *Sender)
{
	if (!Initialized || UnInitializing) return;

	IniFile->WriteIntGen(IsPrimary? _T("TailHeight") : _T("TailHeight2"),	TxtTailListPanel->Height);
}

//---------------------------------------------------------------------------
//分割境界線の描画
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::SplitterBgPaint(TObject *Sender)
{
	TSplitter *sp = (TSplitter*)Sender;
	TCanvas *cv = sp->Canvas;
	Graphics::TBitmap *ip = BgImgBuff[sp->Tag + 2];
	if (!ip->Empty) {
		std::unique_ptr<Graphics::TBitmap> bp(new Graphics::TBitmap());
		std::unique_ptr<Graphics::TBitmap> vp(new Graphics::TBitmap());
		bp->Assign(ip);
		if ((sp->Align==alLeft || sp->Align==alRight) != (bp->Height>bp->Width)) {
			WIC_rotate_image(bp.get(), 1);  WIC_rotate_image(bp.get(), 4);
		}
		WIC_resize_image(bp.get(), vp.get(), 0.0, sp->Width, sp->Height, WicScaleOpt);
		cv->Draw(0, 0, vp.get());
	}
	else {
		cv->Brush->Color = col_Splitter;
		cv->FillRect(sp->ClientRect);
	}
}

//---------------------------------------------------------------------------
//アクティブ化
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::FormActivate(TObject *Sender)
{
	KeepCurCsr = 0;
}

//---------------------------------------------------------------------------
//アクティブ/非アクティブ化の直前
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::WmActivate(TMessage &msg)
{
	bool inact = (LOWORD(msg.WParam)==WA_INACTIVE);

	//ツールバー背景色
	SetupToolBarColor(!inact, true);

	//モーダル表示効果
	if (inact) {
		HWND hWnd = (HWND)msg.LParam;	//新たにアクティブになったウィンドウ
		bool is_own = false;
		if (hWnd) {
			DWORD pid;
			::GetWindowThreadProcessId(hWnd, &pid);
			is_own = (pid==ProcessId);
		}

		if (is_own && !InhModalScr) {
			TWinControl *wp = FindControl(hWnd);
			if (wp && wp!=ModalScrForm && wp->InheritsFrom(__classid(TForm))) {
				TForm *fp = (TForm*)wp;
				if (fp->Floating && fp->BorderStyle!=bsNone && fp->FormStyle!=fsStayOnTop) LastModalForm = fp;
			}

			//モーダルスクリーンの表示
			if (ModalScreen && ModalScrAlpha>0 && !UnInitializing && ScrMode==SCMD_FLIST
				&& !usr_ARC->RarUnpacking && !(GitViewer && GitViewer->GitBusy))
			{
				if (!contained_wd_i(
					_T("HH Parent|User32_ReaderMode|TApplication|TModalScrForm|TAppListDlg|")
					_T("TOptionDlg|TGrepExOptDlg|TDotNyanDlg|TExTxtViewer|TSubViewer|TDebugForm"),
					get_WndClassName(hWnd)))
				{
					ModalScrForm->Visible = true;
				}
			}
		}

		KeepCurCsr = 1;
		InhModalScr   = false;
	}
	else {
		HWND hWnd = get_ModalWnd();
		if (!KeepModalScr && !hWnd) ModalScrForm->Visible = false;
		if (hWnd) ::SetFocus(hWnd);
	}

	TForm::Dispatch(&msg);
}

//---------------------------------------------------------------------------
//アクティブなフォームが変化
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ActiveFormChange(TObject *Sender)
{
	CloseIME(Screen->ActiveForm->Handle);
	UpdateFKeyBtn();
}

//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ApplicationEvents1Activate(TObject *Sender)
{
	if (!Initialized || UnInitializing) return;

	if (DebugForm && DebugForm->Visible) {
		DebugForm->SetFocus();
	}
	else if (ReqActWnd && ReqActWnd!=MainHandle) {
		::SetFocus(ReqActWnd);
		if (RestoreComboBox && ReqActWnd!=get_HelpWnd()) UserModule->RestoreLastComboBox();
	}
	else if (Active && Screen->ActiveForm==this) {
		UpdateFKeyBtn();

		if (ScrMode==SCMD_FLIST) {
			CloseIME(Handle);
			if (InhReload>0)
				InhReload--;
			else if (ReloadOnActive && WatchDirTimer->Enabled)
				for (int i=0; i<MAX_FILELIST; i++) if (!ListStt[i].is_Find) ReloadList(i);
		}

		//ミュート状態を取得
		mute_Volume("GET");

		//ワークリストの外部更新チェック
		if (!WorkListName.IsEmpty()) {
			TDateTime dt = get_file_age(WorkListName);
			if (dt!=WorkListTime) {
				UnicodeString msg;
				msg = "ワークリストが更新されています\r\n";
				msg.cat_sprintf(_T("%s → %s\r\n読み込み直しますか?"),
					FormatDateTime(TimeStampFmt, WorkListTime).c_str(),
					FormatDateTime(TimeStampFmt, dt).c_str());

				if (msgbox_Sure(msg, SureWorkList || WorkListChanged, true)) {
					if (!SetWorkList(EmptyStr, !CurStt->is_Work && !OppStt->is_Work))
						SetActionAbort(USTR_WlistCantOpen);
				}

				WorkListTime = dt;
			}
		}
	}

	ReqActWnd = NULL;
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ApplicationEvents1Deactivate(TObject *Sender)
{
	if (!Initialized || UnInitializing) return;
	CancelKeySeq();
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ApplicationEvents1Minimize(TObject *Sender)
{
	if (StoreTaskTray && get_PrimNyanWnd()) Hide();
}

//---------------------------------------------------------------------------
//モーダルフォームを開いた
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ApplicationEvents1ModalBegin(TObject *Sender)
{
	//ヘルプが開かれていたら閉じる
	HtmlHelpClose();

	XCMD_ModalResult = mrNone;
}
//---------------------------------------------------------------------------
//モーダルフォームを閉じた
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ApplicationEvents1ModalEnd(TObject *Sender)
{
	if (LastModalForm) XCMD_ModalResult = LastModalForm->ModalResult;

	if (lpfHtmlHelp && get_HelpWnd()) {
		InhModalScr = true;
		HtmlHelpClose();
		::SetForegroundWindow(Handle);
	}
}

//---------------------------------------------------------------------------
//リスト/グリッドの内容が表示幅に収まらない場合のヒント表示
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ApplicationEvents1ShowHint(UnicodeString &HintStr, bool &CanShow, THintInfo &HintInfo)
{
	//リストボックス(ShowHint=true のみ)
	if (class_is_ListBox(HintInfo.HintControl)) {
		TListBox *lp = (TListBox*)HintInfo.HintControl;
		TCanvas  *cv = lp->Canvas;
		cv->Font->Assign(lp->Font);
		int idx = lp->ItemAtPos(HintInfo.CursorPos, true);
		if (lp->ShowHint && idx!=-1) {
			UnicodeString lbuf = lp->Items->Strings[idx];
			int flag = (int)lp->Items->Objects[idx];
			int lw;
			//特殊フォルダ一覧
			if (lp->Tag & LBTAG_OPT_SDIR) {
				lbuf = yen_to_delimiter(get_pre_tab(lbuf));
				lw	 = lp->ClientWidth + 4;	//必ず表示
			}
			//ファイル名一覧/ツリー表示
			else if (lp->Tag & LBTAG_TAB_FNAM) {
				lbuf = yen_to_delimiter(get_post_tab(lbuf));
				lw	 = lp->ClientWidth + 4;	//必ず表示
			}
			//ファイル情報
			else if ((lp->Tag & (LBTAG_OPT_FIF1|LBTAG_OPT_FIF2)) && (flag & LBFLG_STD_FINF)==0) {
				lw = LOWORD(lp->Tag) + cv->TextWidth(get_tkn_r(lbuf, _T(": ")) + ": ");
			}
			//その他
			else {
				TStringDynArray path_lst = split_strings_semicolon(lbuf);
				//名前=値1;値2;…
				if (path_lst.Length>1 && path_lst[0].Pos('=')>1 && lbuf.Pos(',')==0) {
					for (int i=0; i<path_lst.Length; i++) {
						if (i==0)
							lbuf = ReplaceStr(path_lst[0], "=", "=\n") + "\n";
						else
							lbuf.cat_sprintf(_T("%s\n"), path_lst[i].c_str());
					}
					lw	 = lp->ClientWidth + 4;	//必ず表示
				}
				//通常
				else {
					lw = get_TabTextWidth(lbuf, cv, lp->TabWidth);
					if (lp->Tag & LBTAG_OPT_LNNO) lw += get_CharWidth(cv, 6, 4);	//行番号有り " 99999"
				}
			}
			HintInfo.HintStr	   = Trim(lbuf);
 			HintInfo.CursorRect    = lp->ItemRect(idx);
 			HintInfo.ReshowTimeout = 1000;
			CanShow = (lw > lp->ClientWidth-2);
		}
		else CanShow = false;
	}
	//グリッド
	else if (HintInfo.HintControl->ClassNameIs("TStringGrid")) {
		TStringGrid *gp = (TStringGrid*)HintInfo.HintControl;
		int col, row;
		gp->MouseToCell(HintInfo.CursorPos.x, HintInfo.CursorPos.y, col, row);
		if (col!=-1 && row!=-1) {
			std::unique_ptr<TStringList> h_buf(new TStringList());
			h_buf->Text = ReplaceStr(gp->Cells[col][row], "\t", "\r\n");
			UnicodeString max_str;
			for (int i=0; i<h_buf->Count; i++) {
				if (gp->Canvas->TextWidth(h_buf->Strings[i]) > gp->Canvas->TextWidth(max_str))
					max_str = h_buf->Strings[i];
			}
			HintInfo.HintStr	   = Trim(h_buf->Text);
			HintInfo.CursorRect	   = gp->CellRect(col, row);
			HintInfo.ReshowTimeout = 1000;
			CanShow = gp->Canvas->TextWidth(max_str) > gp->ColWidths[col]-2;
		}
		else CanShow = false;
	}
}

//---------------------------------------------------------------------------
//特殊キー、ホイール、マウスボタンなどの処理
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ApplicationEvents1Message(tagMSG &Msg, bool &Handled)
{
	if (!Initialized || UnInitializing || CurWorking) return;

	//ヘルプのキーメッセージ処理
	if (lpfHtmlHelp) {
		if (EscapeHelp && Msg.message==WM_KEYDOWN && GetForegroundWindow()==get_HelpWnd()) {
			//ESCキーで閉じる
			if ((WORD)Msg.wParam==VK_ESCAPE) {
				HtmlHelpClose();
				Handled = true;
				return;
			}
			//F1キーでフォーカス切り替え
			else if ((WORD)Msg.wParam==VK_F1) {
				HWND hWnd = get_ModalWnd();
				if (!hWnd) hWnd = MainHandle;
				::SetFocus(hWnd);
				Handled = true;
				return;
			}
		}

		//その他のメッセージ処理
		if (Msg.message==WM_KEYDOWN || Msg.message==WM_SYSKEYDOWN) {
			Handled = (lpfHtmlHelp(NULL, NULL, HH_PRETRANSLATEMESSAGE, (DWORD)&Msg) != NULL);
			if (Handled) return;
		}
	}

	TWinControl *pCtrl = FindControl(Msg.hwnd);
	int fl_tag = (pCtrl==FileListBox[0]) ? 0 : (pCtrl==FileListBox[1]) ? 1 : -1;

	TExTxtViewer *ex_tv = Screen->ActiveForm->ClassNameIs("TExTxtViewer")?
							dynamic_cast<TExTxtViewer *>(Screen->ActiveForm) : NULL;

	//----------------------
	//キー
	//----------------------
	if (Msg.message==WM_KEYDOWN) {
		WORD Key = Msg.wParam;
		TShiftState   Shift   = get_Shift();
		UnicodeString KeyStrK = get_KeyStr(Key);

		if (KeyStrK.IsEmpty()) {
			//ファンクションキーバーの更新
			if (LastShift!=Shift) {
				UpdateFKeyBtn(Shift);
				LastShift = Shift;
			}
			return;
		}

		UnicodeString KeyStr = get_ShiftStr(Shift) + KeyStrK;
		ClearNopStt();

		//ファイラー
		if (fl_tag!=-1) {
			if (is_DialogKey(Key)) {
				if (Wait2ndKey) {
					Wait2ndKey = false;
					KeyStr.sprintf(_T("%s~%s"), FirstKey.c_str(), KeyStrK.c_str());
				}

				UnicodeString CmdStr, CmdStrS;
				if (!ListStt[fl_tag].is_IncSea) {
					CmdStr  = Key_to_CmdF(KeyStr);
					CmdStrS = KeyFuncList->Values["F:SELECT+" + KeyStr];
				}

				CancelKeySeq();
				ActionParam = EmptyStr;

				//ExeCommands実行中...
				if (ExeCmdsBusy) {
					if (USAME_TI(CmdStr, "TaskMan")) {
						MsgHint->ReleaseHandle();
						TaskManAction->Execute();
					}
					Handled = true;
				}
				//検索中...
				else if (FindBusy) {
					if (contained_wd_i(ONFIND_CMD, CmdStr) && ExeCommandAction(CmdStr)) {
						Handled = true;
					}
					else if (Shift.Empty()) {
						Handled = true;
						switch (Key) {
						case VK_UP:		ExeCmdAction(CursorUpAction);	break;
						case VK_DOWN:	ExeCmdAction(CursorDownAction);	break;
						case VK_PRIOR:	ExeCmdAction(PageUpAction);		break;
						case VK_NEXT:	ExeCmdAction(PageDownAction);	break;
						default:		Handled = false;
						}
					}
				}
				//通常
				else if (GetSelCount(GetCurList())>0 && ExeCommandAction(CmdStrS))
					Handled = true;
				else if (ExeCommandAction(CmdStr))
					Handled = true;
				else if (!ListStt[fl_tag].is_IncSea && Shift.Empty()) {
					Handled = true;
					switch (Key) {
					case VK_RIGHT:	ExeCmdAction(ToRightAction);	break;
					case VK_LEFT:	ExeCmdAction(ToLeftAction);		break;
					case VK_TAB:	ExeCmdAction((fl_tag==0)? ToRightAction : ToLeftAction);	break;
					case VK_UP:		ExeCmdAction(CursorUpAction);	break;
					case VK_DOWN:	ExeCmdAction(CursorDownAction);	break;
					case VK_PRIOR:	ExeCmdAction(PageUpAction);		break;
					case VK_NEXT:	ExeCmdAction(PageDownAction);	break;
					case VK_HOME:	ExeCmdAction(CursorTopAction);	break;
					case VK_END:	ExeCmdAction(CursorEndAction);	break;
					default:		Handled = false;
					}
				}
			}
			//TListBox のインクリメンタルサーチを回避
			else {
				FileListBox[fl_tag]->Perform(Msg.message, Msg.wParam, Msg.lParam);
				Handled = true;
			}
		}
		//Grep結果リスト
		else if (pCtrl==ResultListBox) {
			if (!equal_ESC(KeyStr)) {
				if (equal_TAB(KeyStr)) Handled = focus_ExViewer();
				if (!Handled) {
					ResultListBox->Perform(Msg.message, Msg.wParam, Msg.lParam);
					Handled = true;
				}
			}
		}
		//テキストビュアー/ イメージビュアー
		else if (pCtrl==this || pCtrl==ThumbnailGrid) {
			if (is_DialogKey(Key) && (ScrMode==SCMD_TVIEW || ScrMode==SCMD_IVIEW || ex_tv)) {
				if (Wait2ndKey) {
					Wait2ndKey = false;
					KeyStr.sprintf(_T("%s~%s"), FirstKey.c_str(), KeyStrK.c_str());
				}
				CancelKeySeq();
				//テキストビュアー
				if (ScrMode==SCMD_TVIEW) {
					if (ExeCommandV(Key_to_CmdV(KeyStr)))
						Handled = true;
					//別テキストビュアーがあればフォーカスを移す
					else if (equal_TAB(KeyStr))
						Handled = focus_ExViewer();
				}
				//別テキストビュアー
				else if (ex_tv) {
					if (ex_tv->ExeCommandV(Key_to_CmdV(KeyStr))) Handled = true;
				}
				//イメージビュアー
				else {
					UnicodeString CmdStr = KeyFuncList->Values["I:" + KeyStr];
					//右綴じでNext/PrevFile入替
					if (SeekSwapNxtPrv && DoublePage && RightBind && ShowSeekBar) {
						if		(StartsText("NextFile", CmdStr)) CmdStr = ReplaceText(CmdStr, "NextFile", "PrevFile");
						else if (StartsText("PrevFile", CmdStr)) CmdStr = ReplaceText(CmdStr, "PrevFile", "NextFile");
					}

					if (ExeCommandI(CmdStr)) Handled = true;
				}
			}
		}
		//ソート
		else if (SortModeDlg && SortModeDlg->Visible) {
			//カーソルキーで確定させない
			SortModeDlg->InhOk = contained_wd_i(_T("DOWN|UP|LEFT|RIGHT"), KeyStr);
		}
		//キー検索
		else if (FindKeyDlg && FindKeyDlg->Visible) {
			FindKeyDlg->FormKeyDown(NULL, Key, Shift);
			Handled = true;
		}
		//ヒストグラム/文字情報
		else if (pCtrl==HistForm || pCtrl==CharInfoForm) {
			SetFocus();
			Perform(Msg.message, Msg.wParam, Msg.lParam);
			Handled = true;
		}
		//TABキーの処理(フォーカス移動)
		else if (equal_TAB(KeyStr)) {
			Handled = true;

			//別テキストビュアーから
			if (ex_tv)
				SetFocus();
			//ログ
			else if (pCtrl==LogListBox)
				ExeCmdAction(ToLeftAction);
			//キー一覧
			else if (pCtrl==KeyListDlg->KeyListGrid)
				KeyListDlg->FilterEdit->SetFocus();
			else if (pCtrl==KeyListDlg->FilterEdit)
				KeyListDlg->KeyListGrid->SetFocus();
			//コマンドファイル一覧
			else if (pCtrl==CmdFileListDlg->CmdFileGrid)
				CmdFileListDlg->FilterEdit->SetFocus();
			else if (pCtrl==CmdFileListDlg->FilterEdit)
				CmdFileListDlg->CmdFileGrid->SetFocus();
			//関数一覧
			else if (pCtrl==FuncListDlg->FuncListBox) {
				if (FuncListDlg->ListMode==1)
					FuncListDlg->UserDefComboBox->SetFocus();
				else
					FuncListDlg->FilterEdit->SetFocus();
			}
			else if (pCtrl==FuncListDlg->FilterEdit)
				FuncListDlg->FuncListBox->SetFocus();
			//最近編集/閲覧したファイル一覧/栞マーク一覧
			else if (pCtrl==EditHistoryDlg->EditHistGrid && EditHistoryDlg->OpeToolBar->Visible)
				EditHistoryDlg->FilterEdit->SetFocus();
			else if (pCtrl==EditHistoryDlg->FilterEdit)
				EditHistoryDlg->EditHistGrid->SetFocus();
			//一覧ダイアログ
			else if (pCtrl==GeneralInfoDlg->GenListBox)
				GeneralInfoDlg->FilterEdit->SetFocus();
			else if (pCtrl==GeneralInfoDlg->FilterEdit)
				GeneralInfoDlg->GenListBox->SetFocus();
			//特殊フォルダ一覧
			else if (RegDirDlg && RegDirDlg->IsSpecial && pCtrl==RegDirDlg->RegDirListBox)
				RegDirDlg->FilterEdit->SetFocus();
			else if (RegDirDlg && RegDirDlg->IsSpecial && pCtrl==RegDirDlg->FilterEdit)
				RegDirDlg->RegDirListBox->SetFocus();
			else Handled = false;
		}
		//アプリケーションキーの処理(エディット/コンボボックスのメニュー表示)
		//※Shift+F10は拾えない
		else if (USAME_TI(KeyStr, "APP")) {
			if (UserModule->ShowPopupMenu()) Handled = true;
		}
		//Ctrl+X, Ctrl+C でカーソル移動(非選択時)
		else if (contained_wd_i(_T("Ctrl+X|Ctrl+C"), KeyStr)) {
			TWinControl *wp = Screen->ActiveControl;
			int sel_len = -1;
			if		(class_is_LabeledEdit(wp))	sel_len = ((TLabeledEdit*)wp)->SelLength;
			else if (class_is_Edit(wp))			sel_len = ((TEdit*)wp)->SelLength;
			//選択中でなければ移動
			if (sel_len==0) {
				Handled = true;
				if		(wp==FilterComboBox) 			 FilterComboBoxKeyDown(NULL, Key, Shift);
				else if (wp==FuncListDlg->FilterEdit)	 FuncListDlg->FilterEditKeyDown(NULL, Key, Shift);
				else if (wp==KeyListDlg->FilterEdit)	 KeyListDlg->FilterEditKeyDown(NULL, Key, Shift);
				else if (wp==EditHistoryDlg->FilterEdit) EditHistoryDlg->FilterEditKeyDown(NULL, Key, Shift);
				else if (wp==CmdFileListDlg->FilterEdit) CmdFileListDlg->FilterEditKeyDown(NULL, Key, Shift);
				else if (wp==GeneralInfoDlg->FilterEdit) GeneralInfoDlg->FilterEditKeyDown(NULL, Key, Shift);
				else Handled = false;
			}
		}
		else if (equal_ESC(KeyStr) && Screen->ActiveForm->ClassNameIs("TDebugForm")) {
			DebugForm->Close();
			Handled = true;
		}
	}
	else if (Msg.message==WM_SYSKEYDOWN || Msg.message==WM_SYSKEYUP || Msg.message==WM_KEYUP) {
		TShiftState Shift = get_Shift();
		//Altキーによるメニューフォーカスの抑止
		if ((InhbitAltMenu || Menu==NULL) && Msg.message==WM_SYSKEYUP && Msg.wParam==VK_MENU && Shift.Empty()) Handled = true;
		//ファンクションキーバーの更新
		if (LastShift!=Shift) {
			UpdateFKeyBtn(Shift);
			LastShift = Shift;
		}
	}
	//----------------------
	//ホイール
	//----------------------
	else if (Msg.message==WM_MOUSEWHEEL) {
		ClearNopStt();
		int delta = GET_WHEEL_DELTA_WPARAM(Msg.wParam);
		int kmd = get_shift_from_wparam(Msg.wParam);
		UnicodeString cmd_V = WheelCmdV[kmd];
		cmd_V = Trim((delta>0)? get_tkn(cmd_V, '/') : get_tkn_r(cmd_V, '/'));

		//ファイラー
		if (fl_tag!=-1) {
			CancelKeySeq();
			TListBox *lp = FileListBox[fl_tag];
			lp->SetFocus();	//Win10非アクティブウィンドウのスクロールの対策
			int lst_idx = lp->ItemIndex;

			UnicodeString cmd = WheelCmdF[kmd];
			cmd = Trim((delta>0)? get_tkn(cmd, '/') : get_tkn_r(cmd, '/'));
			ExeCommandAction(cmd);

			if (ListStt[fl_tag].is_IncSea && ListStt[fl_tag].is_Filter && lst_idx!=lp->ItemIndex) lp->Invalidate();
			Handled = true;
		}
		//テキストビュアー
		else if (Active && ScrMode==SCMD_TVIEW) {
			CancelKeySeq();
			if (TxtScrollPanel->Visible) ExeCommandV(cmd_V);
			Handled = true;
		}
		//イメージビュアー
		else if (Active && ScrMode==SCMD_IVIEW) {
			UnicodeString cmd = WheelCmdI[kmd];
			cmd = Trim((delta>0)? get_tkn(cmd, '/') : get_tkn_r(cmd, '/'));
			ExeCommandI(cmd);
			Handled = true;
		}
		//ログ/ ファイル情報/ テキストプレビュー
		else if (pCtrl==LogListBox || pCtrl==InfListBox || pCtrl==TxtPrvListBox || pCtrl==TxtTailListBox) {
			TListBox *lp = (pCtrl==LogListBox)   ? LogListBox :
						   (pCtrl==InfListBox)   ? InfListBox :
						   (pCtrl==TxtPrvListBox)? TxtPrvListBox : TxtTailListBox;
			int idx = lp->TopIndex;
			if (delta>0) idx -= ListWheelScrLn; else idx += ListWheelScrLn;
			if (idx<0) idx = 0;
			lp->TopIndex = idx;
			if (FlCursorVisible) ListBoxCsrToVisible(lp);

			UsrScrollPanel *sp = (pCtrl==LogListBox)   ? LogScrPanel :
								 (pCtrl==InfListBox)   ? InfScrPanel :
								 (pCtrl==TxtPrvListBox)? TxtPrvScrPanel : TxtTailScrPanel;
			sp->Repaint();
			Handled = true;
		}
		//一覧ダイアログ、関数／ユーザ定義文字列／マーク行一覧、拡張子別一覧
		else if (ExeListBoxCommandV(cmd_V, Msg.hwnd)) {
			Handled = true;
		}
	}
	//----------------------
	//ホイールボタン
	//----------------------
	else if (Msg.message==WM_MBUTTONDOWN) {
		//コマンドが設定されていたらオートスクロールを無効化
		int kmd = get_shift_from_wparam(Msg.wParam);
		//ファイラー
		if (fl_tag!=-1) {
			if (!WheelBtnCmdF[kmd].IsEmpty()) {
				FileListBox[fl_tag]->SetFocus();
				Handled = true;
			}
		}
		//一覧ダイアログ、関数／ユーザ定義文字列／マーク行一覧、拡張子別一覧
		else if (GeneralInfoDlg->Visible || FileInfoDlg->Visible || FuncListDlg->Visible
			|| (FileExtensionDlg && FileExtensionDlg->Visible))
		{
			if (!WheelBtnCmdV.IsEmpty()) Handled = true;
		}
	}
	else if (Msg.message==WM_MBUTTONUP) {
		ClearNopStt();
		int kmd = get_shift_from_wparam(Msg.wParam);
		if (Active) {
			switch (ScrMode) {
			case SCMD_FLIST:
				CancelKeySeq();
				ExeCommandAction(WheelBtnCmdF[kmd]);
				break;
			case SCMD_TVIEW:
				if (!WheelBtnCmdV.IsEmpty()) ExeCommandV(WheelBtnCmdV); else TxtViewer->ExeCommand(_T("ZoomReset"));
				break;
			case SCMD_IVIEW:
				if (!WheelBtnCmdI.IsEmpty()) ExeCommandI(WheelBtnCmdI); else FittedSizeAction->Execute();
				break;
			}
			Handled = true;
		}
		else if (ex_tv) {
			if (!WheelBtnCmdV.IsEmpty()) ex_tv->ExeCommandV(WheelBtnCmdV); else ex_tv->ExViewer->ExeCommand(_T("ZoomReset"));
		}
		//一覧ダイアログ、関数／ユーザ定義文字列／マーク行一覧、拡張子別一覧
		else if (ExeListBoxCommandV(WheelBtnCmdV, Msg.hwnd)) {
			Handled = true;
		}
	}
	//----------------------
	//X1,X2ボタン
	//----------------------
	else if (Msg.message==WM_XBUTTONDOWN) {
		if		(fl_tag!=-1)			FileListBox[fl_tag]->SetFocus();
		else if (pCtrl==TxtPrvListBox)	TxtPrvListBox->SetFocus();
		else if (pCtrl==TxtTailListBox)	TxtTailListBox->SetFocus();
		else if (pCtrl==InfListBox)		InfListBox->SetFocus();
		else if (pCtrl==LogListBox)		LogListBox->SetFocus();
	}
	else if (Msg.message==WM_XBUTTONUP) {
		ClearNopStt();
		int btn = GET_XBUTTON_WPARAM(Msg.wParam);
		if (Active) {
			switch (ScrMode) {
			case SCMD_FLIST:
				CancelKeySeq();
				if (fl_tag!=-1) ExeCommandAction((btn==XBUTTON2)? X2BtnCmdF : X1BtnCmdF);
				break;
			case SCMD_TVIEW:
				ExeCommandV((btn==XBUTTON2)? X2BtnCmdV : X1BtnCmdV);
				break;
			case SCMD_IVIEW:
				ExeCommandI((btn==XBUTTON2)? X2BtnCmdI : X1BtnCmdI);
				break;
			}
			Handled = true;
		}
		else if (ex_tv) {
			ex_tv->ExeCommandV((btn==XBUTTON2)? X2BtnCmdV : X1BtnCmdV);
			Handled = true;
		}
		//一覧ダイアログ、ファイル情報、関数／ユーザ定義文字列／マーク行一覧、拡張子別一覧
		else if (ExeListBoxCommandV((btn==XBUTTON2)? X2BtnCmdV : X1BtnCmdV, Msg.hwnd)) {
			Handled = true;
		}
	}
	else if (!Active) return;

	//以下はメインフォームのみ

	bool in_Splitter = (ScrMode==SCMD_FLIST
						&& LRSplitter->ClientRect.PtInRect(LRSplitter->ScreenToClient(Mouse->CursorPos)));

	//----------------------
	//マウスボタン
	//----------------------
	//左ボタン
	if (Msg.message==WM_LBUTTONDOWN) {
		ClearNopStt();
		//ファイラー
		if (fl_tag!=-1) {
			int xp = LOWORD(Msg.lParam);
			int yp = HIWORD(Msg.lParam);
			TListBox *lp = FileListBox[fl_tag];
			if (lp->ItemAtPos(Point(xp, yp), true)==-1) {
				//項目外の場合はフォーカス設定のみ
				lp->SetFocus();
				Handled = true;
			}
		}
	}
	//ダブルクリック
	else if (Msg.message==WM_LBUTTONDBLCLK) {
		ClearNopStt();
		Handled = true;
		//タブバーの空きスペース
		if (pCtrl==TabOuterPanel) ExeEventCommand(OnTabDClick);
		//ディレクトリ情報
		else if (pCtrl==L_DirPanel || pCtrl==R_DirPanel || pCtrl==L_DirPanel2 || pCtrl==R_DirPanel2) {
			if (!OnDirDClick.IsEmpty()) ExeEventCommand(OnDirDClick); else ShowInpDirPanel();
		}
		//ディレクトリ関係
		else if (pCtrl==RelPanel || pCtrl==RelPanel2)
			ExeEventCommand(OnRelDClick);
		//ドライブ情報
		else if (pCtrl==L_StatPanel || pCtrl==R_StatPanel)
			ExeEventCommand(OnDrvDClick);
		//ファイル情報
		else if (pCtrl==InfListBox) {
			if (!OnFlIDClick.IsEmpty()) ExeEventCommand(OnFlIDClick); else Handled = false;
		}
		//テキストプレビュー
		else if (pCtrl==TxtPrvListBox)	ExeEventCommand(OnTxtDClick);
		else if (pCtrl==TxtTailListBox)	ExeEventCommand(OnTxtDClick);
		//時計パネル
		else if (pCtrl==StatusBar1) {
			TPoint p = StatusBar1->ScreenToClient(Mouse->CursorPos);
			if		(p.x>StatusBar1->Panels->Items[0]->Width + 2) ExeEventCommand(OnTimDClick);
			else if (p.x<StatusBar1->Panels->Items[0]->Width)     ExeEventCommand(OnSttDClick);
		}
		else if (pCtrl==ClockBar)		ExeEventCommand(OnTimDClick);
		//ログウィンドウ
		else if (pCtrl==LogListBox)		ExeEventCommand(OnLogDClick);
		//サムネイル
		else if (pCtrl==ThumbnailGrid) {
			if (ThumbClicked) ExeEventCommand(OnThmDClick);
			else CloseIAction->Execute();	//サムネイル外ならビュアーを閉じる
		}
		//左右分割境界
		else if (in_Splitter) ExeEventCommand(OnSplDClick);
		else Handled = false;
	}
	//右クリック
	else if (Msg.message==WM_RBUTTONUP) {
		ClearNopStt();
		Handled = true;
		//ファイラーのツールバー
		if (pCtrl==ToolBarF) {
			ExeEventCommandMP(OnFlTbRClick);
		}
		//タブバー
		else if (pCtrl==TabControl1 || pCtrl==TabPanel) {
			if (!OnTabRClick.IsEmpty())
				ExeEventCommandMP(OnTabRClick);
			else
				TabPopupMenu->Popup(Mouse->CursorPos.x, Mouse->CursorPos.y);
		}
		//ディレクトリ情報
		else if (pCtrl==L_DirPanel || pCtrl==R_DirPanel || pCtrl==L_DirPanel2 || pCtrl==R_DirPanel2) {
			if (pCtrl==L_DirPanel || pCtrl==L_DirPanel2) ToLeftAction->Execute(); else ToRightAction->Execute();
			if (OnDirRClick.IsEmpty()) {
				if (IsCurFList()) {
					TPanel *pp = dynamic_cast<TPanel *>(pCtrl);
					if (pp) {
						UnicodeString pnam = pp->Caption;
						remove_top_s(pnam, TabPinMark);
						//クリック位置のディレクトリを取得
						int px = LOWORD(Msg.lParam);
						int idx_r = -1;
						int w = Scaled4 + TabPinWidth;
						TStringDynArray plst = split_path(pnam, DirDelimiter);
						for (int i=0; i<plst.Length && idx_r==-1; i++) {
							w += get_WidthInPanel(plst[i] + DirDelimiter, pp);
							if (px<w) idx_r = plst.Length - 1 - i;
						}

						if (idx_r!=-1) {
							TStringDynArray alst = split_path(CurPath[CurListTag]);
							int idx = alst.Length - 1 - idx_r;
							if (idx<alst.Length && !(StartsStr("\\\\", CurPath[CurListTag]) && idx==0)) {
								UnicodeString rnam = EmptyStr;
								for (int i=0; i<=idx; i++) rnam.cat_sprintf(_T("%s\\"), alst[i].c_str());
								ActionOptStr = "MousePos";
								ExeCommandAction("SubDirList_ND;" + rnam);
							}
						}
					}
				}
			}
			else ExeEventCommandMP(OnDirRClick);
		}
		//ディレクトリ関係
		else if (pCtrl==RelPanel || pCtrl==RelPanel2)
			ExeEventCommandMP(OnRelRClick);
		//ヘッダ
		else if (pCtrl==L_HeaderControl || pCtrl==R_HeaderControl) {
			if (pCtrl==L_HeaderControl) ToLeftAction->Execute(); else ToRightAction->Execute();
			ExeEventCommandMP(OnHdrRClick);
		}
		//ドライブ情報
		else if (pCtrl==L_StatPanel || pCtrl==R_StatPanel) {
			if (pCtrl==L_StatPanel) ToLeftAction->Execute(); else ToRightAction->Execute();
			ExeEventCommandMP(OnDrvRClick);
		}
		//時計パネル
		else if (pCtrl==StatusBar1) {
			TPoint p = StatusBar1->ScreenToClient(Mouse->CursorPos);
			if		(p.x>StatusBar1->Panels->Items[0]->Width + 2) ExeEventCommandMP(OnTimRClick);
			else if (p.x<StatusBar1->Panels->Items[0]->Width)     ExeEventCommandMP(OnSttRClick);
		}
		else if (pCtrl==ClockBar)		ExeEventCommandMP(OnTimRClick);
		//テキストビュアーのツールバー
		else if (pCtrl==ToolBarV)		ExeEventCommandMP(OnTvTbRClick);
		//テキストビュアーで情報ヘッダ
		else if (pCtrl==TxtSttHeader)	ExeEventCommandMP(OnTvHRClick);
		//イメージビュアーのツールバー
		else if (pCtrl==ToolBarI || pCtrl==ToolBarI2)	ExeEventCommandMP(OnIvTbRClick);
		//イメージビュアーのシークバー
		else if (pCtrl==SeekBar || pCtrl==SeekSttPanel)	ExeEventCommandMP(OnIvSbRClick);
		//サムネイル
		else if (pCtrl==ThumbnailGrid)	ExeEventCommandMP(OnThmRClick);
		//左右分割境界
		else if (in_Splitter) ExeEventCommandMP(OnSplRClick);
		else Handled = false;
	}
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ApplicationEvents1Idle(TObject *Sender, bool &Done)
{
	//ツールバーの状態を更新
	//※テキスト/イメージビュアーだとうまく更新されないため(謎)
	TToolBar *tp = (ScrMode==SCMD_TVIEW)? ToolBarV :
				   (ScrMode==SCMD_IVIEW)? (ToolBarISide? ToolBarI2 : ToolBarI) : NULL;
	if (tp) {
		for (int i=0; i<tp->ButtonCount; i++) {
			TToolButton *bp = tp->Buttons[i];
			if (bp && bp->Action) bp->Action->Update();
		}
	}

	//アクティブなコンボボックスの状態を保存
	if (RestoreComboBox) UserModule->SaveLastComboBox();
}

//---------------------------------------------------------------------------
//ヘルプ
//---------------------------------------------------------------------------
bool __fastcall TNyanFiForm::ApplicationEvents1Help(WORD Command, NativeInt Data, bool &CallHelp)
{
	if (Command==HELP_CONTEXT || Command==HELP_CONTEXTPOPUP) {
		if (CancelHelp) {	//キーにF1が割り当てられていたら抑止
			CancelHelp = false;
		}
		else {
			int idx = Data;
			if (Active) {
				if (IS_FullScr())
					idx = -1;
				else if (get_MenuWnd())
					;
				else if (FileListBox[CurListTag]->Focused())
					idx = (CurStt->is_Work? 60 : CurStt->is_IncSea? 50 : 4);
				else if (ScrMode==SCMD_TVIEW)
					idx = TxtViewer->isIncSea? 50 : 6;
				else if (ScrMode==SCMD_IVIEW)
					idx = 7;
			}
			else if (Screen->ActiveForm->ClassNameIs("TExTxtViewer")) {
				TExTxtViewer *ex_tv = dynamic_cast<TExTxtViewer *>(Screen->ActiveForm);
				if (ex_tv) idx = ex_tv->ExViewer->isIncSea? 50 : 6;
			}

			if (idx!=-1) HtmlHelpContext(idx);
		}
		CallHelp = false;
	}
	return true;
}

//---------------------------------------------------------------------------
//ディレクトリ情報の描画
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::DrawDirPanel(TPanel *pp)
{
	HDC hDc = ::GetDC(pp->Handle);
	if (hDc) {
		std::unique_ptr<TCanvas> cv(new TCanvas());
		cv->Lock();
		{
			TRect rc = pp->ClientRect;
			if (!FlatInfPanel) InflateRect(rc, -1, -1);
			cv->Handle = hDc;
			cv->Font->Assign(pp->Font);
			cv->Brush->Color = pp->Color;
			cv->FillRect(rc);
			UnicodeString lbuf = pp->Caption;
			int x = rc.Left + Scaled4;
			int y = rc.Top + (rc.Height() - abs(cv->Font->Height))/2;
			if (has_Leading(cv.get())) y--;

			//固定ピン
			if (remove_top_s(lbuf, TabPinMark)) {
				if (TDirect2DCanvas::Supported()) {
					std::unique_ptr<TDirect2DCanvas> dcv(new TDirect2DCanvas(hDc, rc));
					dcv->BeginDraw();
					dcv->Font->Assign(pp->Font);
					dcv->Brush->Style = bsClear;
					dcv->TextOut(x, rc.Top + (rc.Height() - dcv->TextHeight(TabPinMark))/2, TabPinMark);
					dcv->EndDraw();
				}
				else {
					cv->TextOut(x, y, TabPinMark);
				}
				x += TabPinWidth;
			}
			//パス名
			PathNameOut(lbuf, NULL, cv.get(), x, y, false);
		}
		cv->Unlock();
		::ReleaseDC(pp->Handle, hDc);
	}
}

//---------------------------------------------------------------------------
//ドライブ情報の描画
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::DrawDrivePanel(TPanel *pp)
{
	HDC hDc = ::GetDC(pp->Handle);
	if (hDc) {
		std::unique_ptr<TCanvas> cv(new TCanvas());
		cv->Lock();
		{
			flist_stt *lst_stt = &ListStt[pp->Tag];

			TRect rc = pp->ClientRect;
			if (!FlatInfPanel) InflateRect(rc, -1, -1);
			cv->Handle = hDc;
			cv->Font->Assign(pp->Font);
			cv->Brush->Color = pp->Color;
			cv->FillRect(rc);

			UnicodeString lbuf = pp->Caption;
			int x = rc.Left + Scaled2;
			int y = rc.Top + (rc.Height() - abs(cv->Font->Height))/2;
			if (has_Leading(cv.get())) y--;

			//マスク
			out_TextEx(cv.get(), x, y, split_pre_tab(lbuf));

			//上部境界線
			if (FlatInfPanel &&
				(lst_stt->is_IncSea || lst_stt->is_Filter || pp->Tag==SHOW_WARN_TAG 
					|| (lst_stt->sel_d_cnt>0 || lst_stt->sel_f_cnt>0)))
			{
				cv->Pen->Color = col_Splitter;
				cv->MoveTo(rc.Left,  rc.Top);
				cv->LineTo(rc.Right, rc.Top);
			}

			//疑似キャレット
			if (lst_stt->is_IncSea && pp->Tag!=SHOW_WARN_TAG) {
				cv->Pen->Color = col_Cursor;
				cv->MoveTo(x, y + Scaled2);
				cv->LineTo(x, rc.Bottom - Scaled2);
			}

			if (!lbuf.IsEmpty()) {
				x = rc.Right - cv->TextWidth(lbuf) - Scaled2;
				cv->TextOut(x, y, lbuf);
			}
		}
		cv->Unlock();
		::ReleaseDC(pp->Handle, hDc);
	}
}

//---------------------------------------------------------------------------
//背景画像の更新 (リスト毎のバッファを更新)
// 戻り値: ファイル再読み込みに失敗したら false
//---------------------------------------------------------------------------
bool __fastcall TNyanFiForm::UpdateBgImage(
	bool repaint_sw,	//再描画		(default = false)
	bool reload_sw)		//再読み込み	(default = false)
{
	if (!Initialized || UnInitializing || InhUpdBgImg>0) return false;

	if (reload_sw) {
		int err_cnt = 0;
		for (int i=0; i<2; i++) {
			if ((BgImgMode==1 || BgImgMode==2) && !BgImgName[i].IsEmpty()) {
				UnicodeString fnam = to_absolute_name(BgImgName[i]);
				if		(!file_exists(fnam))												err_cnt++;
				else if (!load_ImageFile(fnam, BgImgBuff[i], WICIMG_PREVIEW, col_bgList))	err_cnt++;
			}
			else BgImgBuff[i]->Handle = NULL;
		}

		if (err_cnt>0) {
			if (repaint_sw) RepaintList();
			return false;
		}
	}

	InhUpdBgImg++;
	if (!WndSizing && BgImgMode>0 && (BgImgMode==3 || !BgImgBuff[0]->Empty)) {
		try {
			TRect rc_l[MAX_FILELIST];
			for (int i=0; i<MAX_FILELIST; i++) {
				if (DivFileListUD)
					if (i==0) {
						rc_l[i] = Rect(0, 0, L_Panel->Width, FileListBox[i]->Height);
					}
					else {
						int h = ListPanel->ClientHeight - L_Panel->Height - LRSplitter->Height;
						if (TabPanel->Visible) h -= TabPanel->Height;
						if (HdrPanel->Visible) h -= HdrPanel->Height;
						if (h<=0) Abort();
						rc_l[i] = Rect(0, 0, L_Panel->Width, h);
					}
				else {
					if (i==0) {
						rc_l[i] = Rect(0, 0, L_Panel->Width, FileListBox[i]->Height);
					}
					else {
						int w = ListPanel->ClientWidth - LRSplitter->Width - L_Panel->Width;	if (w<=0) Abort();
						rc_l[i] = Rect(0, 0, w, FileListBox[i]->Height);
					}
				}

				Graphics::TBitmap *bp = BgBuff[i];
				bp->SetSize(rc_l[i].Width(), rc_l[i].Height());
				if (BgImgMode!=3 && BgImgSubMode==0) {
					//背景色
					bp->Canvas->Lock();
					bp->Canvas->Brush->Style = bsSolid;
					bp->Canvas->Brush->Color = col_bgList;
					bp->Canvas->FillRect(rc_l[i]);
					bp->Canvas->Unlock();
				}
			}

			//2画面に渡って表示
			TRect rc_c;
			if (BgImgMode==1) {
				Graphics::TBitmap *bp = BgImgBuff[0];
				std::unique_ptr<Graphics::TBitmap> bp2(new Graphics::TBitmap());
				if (DivFileListUD)
					bp2->SetSize(rc_l[0].Width(),
						rc_l[0].Height() + rc_l[1].Height() + L_StatPanel->Height + R_HeaderControl->Height + SplitterWidth);
				else
					bp2->SetSize(rc_l[0].Width() + rc_l[1].Width() + SplitterWidth, rc_l[0].Height());

				TRect rc_d = Rect(0, 0, bp2->Width, bp2->Height);
				bp2->Canvas->Lock();
				{
					bp2->Canvas->Brush->Style = bsSolid;
					bp2->Canvas->Brush->Color = col_bgList;
					bp2->Canvas->FillRect(rc_d);
					int sub_mode = (BgImgTileIf && std::min(bp->Width, bp->Height)<=BgTileSize)? 1 : BgImgSubMode;
					switch (sub_mode) {
					case 0:	//中央に表示
						rc_c = rc_d.CenteredRect(Rect(0, 0, bp->Width, bp->Height));
						bp2->Canvas->Draw(rc_c.Left, rc_c.Top, bp);
						break;
					case 1:	//並べて表示
						for (int x=0; x<bp2->Width; x+=bp->Width) for (int y=0; y<bp2->Height; y+=bp->Height)
							bp2->Canvas->Draw(x, y, bp);
						break;
					case 2:	//表示サイズにストレッチ
						WIC_resize_image(BgImgBuff[0], bp2.get(), 0.0, rc_d.Width(), rc_d.Height(), WicScaleOpt);
						break;
					case 3:	//表示サイズに合わせて切り出し
						WIC_fit_trim_image(BgImgBuff[0], bp2.get(), rc_d.Width(), rc_d.Height(), WicScaleOpt);
						break;
					}

					BgBuff[0]->Canvas->CopyRect(rc_l[0], bp2->Canvas, rc_l[0]);
					TRect rc_s = rc_l[1];
					if (DivFileListUD)
						rc_s.Offset(0, rc_l[0].Height() + L_StatPanel->Height + R_HeaderControl->Height + SplitterWidth);
					else
						rc_s.Offset(rc_l[0].Width() + SplitterWidth, 0);
					BgBuff[1]->Canvas->CopyRect(rc_l[1], bp2->Canvas, rc_s);
				}
				bp2->Canvas->Unlock();
			}
			//デスクトップを表示
			else if (BgImgMode==3) {
				std::unique_ptr<Graphics::TBitmap> bp2(new Graphics::TBitmap());
				bp2->SetSize(Screen->Width, Screen->Height);
				if (::PaintDesktop(bp2->Canvas->Handle)) {
					TPoint p   = FileListBox[0]->ClientToScreen(Point(0, 0));
					TRect rc_s = rc_l[0]; rc_s.Offset(p.x, p.y);
					BgBuff[0]->Canvas->CopyRect(rc_l[0], bp2->Canvas, rc_s);
					p	 = FileListBox[1]->ClientToScreen(Point(0, 0));
					rc_s = rc_l[1]; rc_s.Offset(p.x, p.y);
					BgBuff[1]->Canvas->CopyRect(rc_l[1], bp2->Canvas, rc_s);
				}
			}
			//それぞれに表示
			else {
				Graphics::TBitmap *bp[2] = {BgImgBuff[0], !BgImgBuff[1]->Empty? BgImgBuff[1] : BgImgBuff[0]};
				for (int i=0; i<MAX_FILELIST; i++) {
					int sub_mode = (BgImgTileIf && std::min(bp[i]->Width, bp[i]->Height)<=BgTileSize)? 1: BgImgSubMode;
					switch (sub_mode) {
					case 0:	//中央に表示
						rc_c = rc_l[i].CenteredRect(Rect(0, 0, bp[i]->Width, bp[i]->Height));
						BgBuff[i]->Canvas->Draw(rc_c.Left, rc_c.Top, bp[i]);
						break;
					case 1:	//並べて表示
						for (int x=0; x<rc_l[i].Width(); x+=bp[i]->Width) for (int y=0; y<rc_l[i].Height(); y+=bp[i]->Height)
							BgBuff[i]->Canvas->Draw(x, y, bp[i]);
						break;
					case 2:	//表示サイズにストレッチ
						WIC_resize_image(bp[i], BgBuff[i], 0.0, rc_l[i].Width(), rc_l[i].Height(), WicScaleOpt);
						break;
					case 3:	//表示サイズに合わせて切り出し
						WIC_fit_trim_image(bp[i], BgBuff[i], rc_l[i].Width(), rc_l[i].Height(), WicScaleOpt);
						break;
					}
				}
			}

			//グレースケール化
			if (BgImgGray) for (int i=0; i<MAX_FILELIST; i++) WIC_grayscale_image(BgBuff[i]);

			//背景色ブレンド
			if (BgColAlpha>0) {
				for (int i=0; i<MAX_FILELIST; i++) {
					alpha_blend_Rect(BgBuff[i]->Canvas, 0, 0, BgBuff[i]->Width, BgBuff[i]->Height,
										get_FlBgColor(&ListStt[i]), BgColAlpha);
				}
			}
		}
		catch (...) {
			;
		}
	}
	else {
		BgBuff[0]->Handle = NULL;
		BgBuff[1]->Handle = NULL;
	}
	InhUpdBgImg--;

	//再描画
	if (repaint_sw) {
		HideBgImg[0] = HideBgImg[1] = false;
		RepaintList();
	}

	return true;
}
//---------------------------------------------------------------------------
//隠した背景を復帰
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::RestoreBgImg()
{
	bool flag[MAX_FILELIST];
	flag[0] = HideBgImg[0];  HideBgImg[0] = false;
	flag[1] = HideBgImg[1];  HideBgImg[1] = false;

	if (flag[0] || flag[1]) {
		UpdateBgImage();
		if (BgImgMode>0) {
			for (int i=0; i<MAX_FILELIST; i++) {
				if (flag[i]) {
					TListBox *lp = FileListBox[i];
					if ((lp->TopIndex + lp->ClientHeight/lp->ItemHeight) <=lp->Count)
						lp->Invalidate(); else RepaintList(i);
				}
			}
		}
	}
}

//---------------------------------------------------------------------------
//ファイルリストの描画およびスクロール時処理
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ListWndProc(TMessage &msg, int tag)
{
	TListBox *lp = (tag==0)? L_ListBox : R_ListBox;

	switch (msg.Msg) {
	case WM_VSCROLL:
	case WM_NYANFI_USCROLL:	//シンプルスクロールバーのノブドラッグ
		ClearNopStt();
		if (FlCursorVisible) {
			if (IsDiffList()) {
				//ディレクトリ比較結果の左右同期
				TListBox *lp_c = FileListBox[CurListTag];
				TListBox *lp_o = FileListBox[OppListTag];
				if (tag==CurListTag) {
					if (ListBoxCsrToVisible(lp)) {
						SetFileInf();
					}
					else {
						lp_o->TopIndex	= lp_c->TopIndex;
						lp_o->ItemIndex = lp_c->ItemIndex;
						lp_o->Invalidate();
					}
				}
				else {
					int idx0 = lp_c->ItemIndex;
					lp_c->TopIndex	= lp_o->TopIndex;
					lp_c->ItemIndex = lp_o->ItemIndex;
					lp_c->Invalidate();
					if (lp_c->ItemIndex!=idx0) SetFileInf();
				}
			}
			else if (ListBoxCsrToVisible(lp)) {
				if (tag==CurListTag) SetFileInf();
			}
		}

		if (BgImgMode>0 && BgImgHideScr && !HideBgImg[tag]) {
			HideBgImg[tag] = true;
			lp->Invalidate();
		}

		if (msg.Msg==WM_VSCROLL) org_FileListWindowProc[tag](msg);
		break;

	case WM_NYANFI_UPDKNOB:
		FlScrPanel[tag]->UpdateKnob();
		msg.Result = 1;
		break;

	case WM_ERASEBKGND:
		if (BgImgMode>0 && !HideBgImg[tag] && !BgBuff[tag]->Empty) {
			//描画すべき領域がバッファになかったら更新
			TRect rc;
			if (!::GetUpdateRect(lp->Handle, &rc, FALSE))
				rc = Rect(0, 0, (tag==0)? L_Panel->Width : R_Panel->Width, lp->Height);
			HRGN rgn = ::CreateRectRgn(rc.Left, rc.Top, rc.Right, rc.Bottom);
			::SelectClipRgn(lp->Canvas->Handle, rgn);
			//描画すべき領域がバッファになかったら更新
			rc.Right += 1; rc.Bottom += 1;
			if (!rc.Contains(Rect(0, 0, BgBuff[tag]->Width, BgBuff[tag]->Height))) UpdateBgImage();
			//背景を描画
			lp->Canvas->Draw(0, 0, BgBuff[tag]);
			//すぐに再描画要求
			::RedrawWindow(lp->Handle, NULL, 0, RDW_INVALIDATE|RDW_FRAME|RDW_UPDATENOW);
			::DeleteObject(rgn);
			msg.Result = 1;
		}
		else {
			org_FileListWindowProc[tag](msg);
		}
		break;

	case WM_PAINT:
		FlScrPanel[tag]->Repaint();
		org_FileListWindowProc[tag](msg);
		break;

	default:
		org_FileListWindowProc[tag](msg);
	}
}

//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ActionList1Execute(TBasicAction *Action, bool &Handled)
{
	if (CurWorking) Handled = true;
}

//---------------------------------------------------------------------------
// ドライブが変更された
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::WmDeviceChange(TMessage &msg)
{
	if (!Initialized || UnInitializing) return;

	//ドライブ情報を取得
	drive_info *new_dp = get_DriveInfoList();

	//ドライブが追加された
	if (new_dp) {
		//追加ドライブをカレントで開く
		if (OpenAddedDrive) {
			if (WindowState==wsMinimized) Application->Restore();
			Application->BringToFront();
			if (file_exists(new_dp->drive_str)) {
				UpdateCurDrive(new_dp->drive_str);
				//イベント: 追加ドライブが開かれた
				ExeEventCommand(OnNewDrive);
			}
		}
	}
	//パスの存在チェック
	else {
		for (int i=0; i<MAX_FILELIST; i++) {
			UnicodeString dnam = CheckAvailablePath(CurPath[i], i);
			if (!dnam.IsEmpty() && !SameText(CurPath[i], dnam)) {
				CurPath[i] = dnam;
				if (i==CurListTag) SetFileInf();
			}
		}
	}

	//ドライブ一覧を更新
	if (SelDriveDlg && SelDriveDlg->Visible) SelDriveDlg->UpdateDriveList();

	//ツールボタンの状態更新
	UpdateToolDriveBtn();
}

//---------------------------------------------------------------------------
//ファイルリストのドロップ受け入れ
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::WmDropped(TMessage &msg)
{
	if (CurWorking || FindBusy) return;

	HWND hWnd = get_window_from_pos();

	//テキストビュアー
	if (hWnd==TxtScrollPanel->Handle) {
		if (DroppedList->Count>0) {
			TxtViewer->add_ViewHistory();
			if (!SetAndOpenTxtViewer(DroppedList->Strings[0])) SttBarWarn(LoadUsrMsg(USTR_FileNotOpen));
		}
		DroppedList->Clear();
		return;
	}

	//ファイラー
	try {
		if (DroppedTag==-1) {
			if		(hWnd==FileListBox[0]->Handle) DroppedTag = 0;
			else if (hWnd==FileListBox[1]->Handle) DroppedTag = 1;
		}
		if (DroppedTag==-1 || DroppedTag==DragStartTag || DroppedList->Count==0 ) Abort();

		flist_stt *cur_stt = &ListStt[DroppedTag];
		if (ScrMode!=SCMD_FLIST || cur_stt->is_Arc || IsDiffList()) UserAbort(USTR_CantOperate);

		//右ドラッグの場合、一旦メニューを出す
		if (DroppedMode==(DROPEFFECT_COPY|DROPEFFECT_MOVE|DROPEFFECT_LINK)) {
			DropPopupMenu->Popup(Mouse->CursorPos.x + 2, Mouse->CursorPos.y);
			return;
			//メニュー選択後、再度 WmDropped が呼ばれる
		}

		//結果リスト
		if (cur_stt->is_Find) {
			if (!cur_stt->find_TAG && DroppedMode!=DROPEFFECT_COPY) UserAbort(USTR_CantOperate);
			//タグ検索結果リスト(タグ追加)
			for (int i=0; i<DroppedList->Count; i++) {
				usr_TAG->AddTags(DroppedList->Strings[i], cur_stt->find_Keywd);
			}
			ReloadList(DroppedTag);
		}
		//ワークリスト
		else if (cur_stt->is_Work) {
			if (DroppedMode!=DROPEFFECT_COPY) UserAbort(USTR_CantOperate);
			if (WorkListFiltered) UserAbort(USTR_WorkFiltered);
			for (int i=0; i<DroppedList->Count; i++) {
				UnicodeString fnam = DroppedList->Strings[i];
				if (WorkList->IndexOf(fnam)!=-1) continue;
				file_rec *fp = cre_new_file_rec(fnam);
				if (fp) WorkList->AddObject(fp->f_name, (TObject*)fp);
			}
			ChangeWorkList(DroppedTag);
			rqWorkListDirInf = !WorkListChanged;
			WorkListChanged  = true;
		}
		//FTP (アップロード)
		else if (cur_stt->is_FTP) {
			if (DroppedMode!=DROPEFFECT_COPY) UserAbort(USTR_CantOperate);
			StartLog(UnicodeString().sprintf(_T("アップロード開始  DROP\t%s"), yen_to_slash(CurFTPPath).c_str()));
			BeginWorkProgress(LoadUsrMsg(USTR_Upload), EmptyStr, FileListBox[DroppedTag], true);
			CurWorking	= true;
			gCopyCancel = false;
			int d_cnt = 0;
			for (int i=0; i<DroppedList->Count; i++) {
				UnicodeString fnam = DroppedList->Strings[i];
				file_rec *fp = cre_new_file_rec(fnam);
				if (fp->is_dir) d_cnt++; else UploadFtpCore(fp);
				del_file_rec(fp);
				if (gCopyCancel || CancelWork) break;
			}
			CurWorking = false;

			if (gCopyCancel || CancelWork) {
				EndWorkProgress(EmptyStr, LoadUsrMsg(USTR_Canceled));
				AddLog(_T("アップロード中断"), true);
			}
			else {
				EndWorkProgress();
				EndLog(USTR_Upload);
				if (!ChangeFtpFileList(DroppedTag)) GlobalAbort();
			}
			if (d_cnt>0) UserAbort(USTR_IncludeDir);
		}
		//代替データストリーム
		else if (cur_stt->is_ADS) {
			if (DroppedMode!=DROPEFFECT_COPY) UserAbort(USTR_CantOperate);
			StartLog(UnicodeString().sprintf(_T("コピー開始  DROP\t%s:"), cur_stt->ads_Name.c_str()));

			CurWorking = true;
			CancelWork = false;
			BeginWorkProgress(_T("代替データストリームへコピー"), EmptyStr, FileListBox[CurListTag], true);
			bool ow_all = false, sk_all = false;
			for (int i=0; i<DroppedList->Count && !CancelWork; i++) {
				UnicodeString fnam = DroppedList->Strings[i];
				UnicodeString dst_nam = cur_stt->ads_Name + ":" + ExtractFileName(fnam);
				CopyAdsCore(fnam, dst_nam, ow_all, sk_all);
			}
			ChangeAdsList(cur_stt->ads_Name, DroppedTag);
			CurWorking = false;

			if (CancelWork) {
				EndWorkProgress(EmptyStr, LoadUsrMsg(USTR_Canceled));
				AddLog(_T("コピー中断"));
			}
			else {
				EndWorkProgress();
				EndLog(_T("コピー"));
			}
		}
		//その他
		else {
			//ショートカット作成
			if (DroppedMode==DROPEFFECT_LINK) {
				UnicodeString dnam = GetCurPathStr(DroppedTag);
				//.url
				if (DroppedList->Count==1 && ContainsStr(DroppedList->Strings[0], "\t")) {
					UnicodeString url  = DroppedList->Strings[0];
					UnicodeString fnam = dnam + split_pre_tab(url);
					UnicodeString fext = get_extension(get_tkn(url, '?'));
					//画像
					if (!USAME_TI(get_extension(fnam), ".url")) {
						if (file_exists(fnam) && !msgbox_Sure(USTR_OverwriteQ)) SkipAbort();
						TModalResult mr = DownloadWorkProgress(url, fnam, FileListBox[DroppedTag]);
						if (mr==mrCancel) SkipAbort();
						if (mr!=mrOk) Abort();
					}
					//ショートカット
					else {
						if (!make_url_file(fnam, url)) Abort();
					}
				}
				//.lnk
				else {
					UnicodeString tmp;
					StartLog(tmp.sprintf(_T("ショートカット作成開始  DROP\t%s"), dnam.c_str()));
					int ok_cnt = 0, er_cnt = 0;
					for (int i=0; i<DroppedList->Count; i++) {
						UnicodeString fnam = ExcludeTrailingPathDelimiter(DroppedList->Strings[i]);
						UnicodeString lnam = dnam + ChangeFileExt(ExtractFileName(fnam), ".lnk");
						tmp = make_LogHdr(_T("CREATE"), lnam);
						if (!usr_SH->CreateShortCut(lnam, fnam)) tmp[1] = 'E';
						AddLog(tmp);
						((tmp[1]=='E')? er_cnt : ok_cnt)++;
					}
					EndLog(_T("作成"), get_res_cnt_str(ok_cnt, er_cnt));
				}
			}
			//コピー or 移動
			else if (DroppedMode==DROPEFFECT_COPY || DroppedMode==DROPEFFECT_MOVE) {
				UnicodeString cmd;
				cmd.sprintf(_T("%s"), (DroppedMode==DROPEFFECT_MOVE)? _T("MOV") : _T("CPY"));
				UnicodeString cnam = GetCurPathStr(DroppedTag);
				std::unique_ptr<TStringList> dir_lst(new TStringList());
				if (USAME_TS(cmd, "CPY")) get_SyncDstList(cnam, dir_lst.get()); else dir_lst->Add(cnam);
				for (int i=0; i<dir_lst->Count; i++) {
					TaskConfig  *cp = NULL;
					TTaskThread *tp = CreTaskThread(&cp);	if (!cp) Abort();
					UnicodeString dnam = dir_lst->Strings[i];
					UnicodeString tmp;
					for (int j=0; j<DroppedList->Count; j++) {
						cp->TaskList->Add(tmp.sprintf(_T("%s\t%s\t%s"),
											cmd.c_str(), DroppedList->Strings[j].c_str(), dnam.c_str()));
					}
					cp->CopyMode = gCopyMode;
					cp->CopyAll  = false;
					cp->CmdStr	 = TaskCmdList->Values[cmd];
					cp->DistPath = dnam;
					cp->InfStr.sprintf(_T("DROP ---> %s"), dnam.c_str());
					ActivateTask(tp, cp);
				}
			}
		}

		if (CurListTag==DragStartTag) ClearAllAction->Execute();
	}
	catch (EAbort &e) {
		if (!e.Message.IsEmpty() && !USAME_TI(e.Message, "SKIP")) SttBarWarn(e.Message);
	}

	DroppedList->Clear();
	DragStartTag = -1;
	DroppedTag	 = -1;
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::DropMenuItemClick(TObject *Sender)
{
	switch (((TMenuItem*)Sender)->Tag) {
	case 0:  DroppedMode = DROPEFFECT_COPY; break;
	case 1:  DroppedMode = DROPEFFECT_MOVE; break;
	case 2:  DroppedMode = DROPEFFECT_LINK; break;
	default: DroppedMode = DROPEFFECT_NONE;
	}
	if (DroppedMode!=DROPEFFECT_NONE) Perform(WM_FORM_DROPPED, 0, (NativeInt)0);
}

//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::WmSettingChange(TMessage &msg)
{
	if (msg.WParam==SPI_SETHIGHCONTRAST) {
		InitializeSysColor();
		SetupDesign(false);
	}
}

//---------------------------------------------------------------------------
//タイマー処理 (タスク状態表示)
// インターバル = 200ms
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::TaskSttTimerTimer(TObject *Sender)
{
	if (TaskSttTimer->Tag>0) return;
	TaskSttTimer->Tag = 1;

	if (ReqClose) ExitAction->Execute();

	bool ready	  = false;
	int  busy_cnt = 0;
	UnicodeString tmp;

	for (int i=0; i<MAX_TASK_THREAD; i++) {
		TTaskThread *tp = TaskThread[i];	if (!tp) continue;

		//同名ファイルの処理
		if (tp->TaskAskSame) {
			SameNameDlg->Caption  = LoadUsrMsg(USTR_SameName, tmp.sprintf(_T("タスク%u"), i + 1));
			SameNameDlg->TaskNo   = i;
			SameNameDlg->CopyMode = tp->Config->CopyMode;
			SameNameDlg->CopyAll  = tp->Config->CopyAll;
			SameNameDlg->RenameEdit->Text = tp->CopyName;
			SameNameDlg->IsSamePath = tp->IsSamePath;
			SameNameDlg->CurSrcName = tp->CurSrcName;
			SameNameDlg->CurSrcSize = get_file_size(tp->CurSrcName);
			SameNameDlg->CurSrcTime = get_file_age(tp->CurSrcName);
			SameNameDlg->CurDstName = tp->CurDstName;
			SameNameDlg->CurDstSize = get_file_size(tp->CurDstName);
			SameNameDlg->CurDstTime = get_file_age(tp->CurDstName);

			if (SameNameDlg->ShowModal()==mrCancel) {
				tp->TaskCancel = true;
			}
			else {
				tp->Config->CopyMode = SameNameDlg->CopyMode;
				(tp->IsSamePath? gCopyMode2 : gCopyMode) = SameNameDlg->CopyMode;
				tp->Config->CopyAll  = SameNameDlg->CopyAll;
				tp->CopyName		 = SameNameDlg->RenameEdit->Text;
			}

			tp->TaskAskSame = false;
		}

		//----------------------
		//タスク終了時の処理
		//----------------------
		if (tp->TaskFinished) {
			FlushLog();
			//削除したハードリンクがあれば更新
			if (tp->LnkDeleted) {
				ReloadList();
			}
			//その他必要なリストを更新
			else {
				for (int i=0; i<tp->Config->UpdDirList->Count; i++) {
					UnicodeString dnam = tp->Config->UpdDirList->Strings[i];
					for (int j=0; j<MAX_FILELIST; j++) {
						flist_stt *lst_stt = &ListStt[j];
						if (!lst_stt->is_Arc && !lst_stt->is_Find && !lst_stt->is_Work && !lst_stt->is_FTP) {
							if (SameText(dnam, CurPath[j])) ReloadList(j);
						}
					}
				}
			}

			//カーソル位置の設定
			//反対側がコピー/移動先
			if (SameText(ExtractFilePath(tp->FirstDstName), CurPath[OppListTag])) {
				if (tp->Config->DstPosMode==1)
					IndexOfFileList(tp->FirstDstName, OppListTag);
				else if (tp->Config->DstPosMode==2)
					IndexOfFileList(tp->LastDstName, OppListTag);
			}
			//カレント側がコピー/移動先
			if (SameText(ExtractFilePath(tp->LastDstName), CurPath[CurListTag])) {
				if (tp->Config->DstPosMode==2) {
					IndexOfFileList(tp->LastDstName, CurListTag);
					SetFileInf();
				}
			}

			tp->Config->UpdDirList->Clear();

			//終了通知
			if (tp->TaskTime>=NotifyTaskTime && !tp->TaskCancel) {
				play_sound(SoundTaskFin);
				if (FlashCntTaskfin>0 && FlashTimeTaskfin>0) flash_win(FlashCntTaskfin, FlashTimeTaskfin);
			}
			//エラー通知
			if (tp->ErrCount>0) {
				SttBarWarn(tmp.sprintf(_T("タスク%uで%u個のエラーがありました"), i + 1, tp->ErrCount));
			}

			ready = true;

			//ディレクトリ比較結果の更新
			if (IsDiffList()) {
				for (int i=0; i<MAX_FILELIST; i++) {
					TStringList *r_lst = ResultList[i];
					for (int j=0; j<r_lst->Count; j++) {
						file_rec *fp = (file_rec*)r_lst->Objects[j];
						if (file_exists(fp->f_name)) {
							fp->is_dummy = false;
							fp->f_time	 = get_file_age(fp->f_name);
							fp->f_attr	 = file_GetAttr(fp->f_name);
							fp->attr_str = get_file_attr_str(fp->f_attr);
							fp->f_size	 = get_file_size(fp->f_name);
						}
						else {
							fp->is_dummy = true;
						}
					}
					RepaintList(i);
				}
				SetFileInf();
			}
			//結果一覧の更新
			else {
				for (int i=0; i<MAX_FILELIST; i++) {
					flist_stt *lst_stt = &ListStt[i];
					if (!lst_stt->is_Find) continue;
					TStringList *lst = ResultList[i];
					int j = 0;
					int chg = false;
					while (j<lst->Count) {
						file_rec *fp = (file_rec*)lst->Objects[j];
						if (fp->is_up || fp->is_dummy || file_exists(fp->f_name)) {
							j++;
						}
						else {
							del_FileListItem(lst, j);
							chg = true;
						}
					}
					if (chg) {
						update_FileListBox(lst, i);
						RepaintList(i);
						SetFileInf();
					}
				}
			}

			//ディレクトリが削除されたら履歴を更新
			if (tp->DirDeleted) {
				CheckDirHistory(0);
				CheckDirHistory(1);
			}

			//スレッドの終了・破棄
			tp->Terminate();
			TaskThread[i] = NULL;
		}
		else {
			busy_cnt++;
		}
	}

	//予約タスクを実行
	if (busy_cnt<MaxTasks && TaskReserveList->Count>0 && !RsvSuspended) {
		StartReserve();
	}
	//全タスク終了
	else if (ready && busy_cnt==0 && TaskReserveList->Count==0) {
		AddLog(_T("All Task Ready"));
		NotifyPrimNyan("すべてのタスクが終了しました");
	}

	//タスク表示更新
	TaskPaintBox->Invalidate();

	//ワークリストの変更表示
	if (rqWorkListDirInf) {
		rqWorkListDirInf = false;
		if		(ListStt[0].is_Work) SetDirCaption(0);
		else if (ListStt[1].is_Work) SetDirCaption(1);
	}

	//検索状態の表示
	if (ScrMode==SCMD_FLIST && FindBusy && !FindDiff) {
		tmp = "検索中...";
		if (ShowSttBar) {
			StatusBar1->Panels->Items[0]->Text = tmp.cat_sprintf(_T(" (%u) %s"), FindCount, FindPath.c_str());
		}
		else {
			int plen = CurPath[FindTag].Length();
			TPanel *stt_panel = (FindTag==0)? L_StatPanel : R_StatPanel;
			stt_panel->Alignment = taLeftJustify;
			stt_panel->Caption	 = tmp.cat_sprintf(_T(" (%u) %s"),
				FindCount, yen_to_delimiter(FindPath.SubString(plen, FindPath.Length() - plen + 1)).c_str());
		}
	}

	//時計パネル
	UnicodeString clk_str = GetClockStr();
	StatusBar1->Panels->Items[1]->Text = clk_str;
	ClockBar->Panels->Items[0]->Text   = clk_str;
	ClockBarI->Panels->Items[0]->Text  = clk_str;

	//電源切れ警告
	if (WarnPowerFail) {
		UnicodeString bat_str = get_BatteryTimeStr();
		if (USAME_TI(LastBatteryStt, "ONLINE") && !USAME_TI(bat_str, "ONLINE"))
			SttBarWarn(_T("電源が切れました。"));
		LastBatteryStt = bat_str;
	}
	//バッテリー低下警告
	if (WarnLowBattery) {
		int bat_life = get_BatteryPercentStr().ToIntDef(0);
		if (LastBatteryLife>=BatLowerLimit && bat_life<BatLowerLimit)
			SttBarWarn(tmp.sprintf(_T("バッテリーが低下しています。 [%u%%]"), bat_life));
		LastBatteryLife = bat_life;
	}
	//インターネット接続切れ
	if (WarnDisconnect) {
		bool inet_con = InternetConnected();
		if (LastConnect && !inet_con) SttBarWarn(_T("インターネット接続が切れました。"));
		LastConnect = inet_con;
	}

	//コマンド要求の処理
	if (CmdRequestList->Count>0) {
		UnicodeString cbuf = CmdRequestList->Strings[0];
		CmdRequestList->Delete(0);

		try {
			UnicodeString cmd = split_tkn(cbuf, '_');
			UnicodeString prm = exclude_quot(split_pre_tab(cbuf));
			UnicodeString opt = cbuf;
			if (USAME_TI(cmd, "ChangeDir")) {
				UpdateCurPath(IncludeTrailingPathDelimiter(prm));
				if (!GlobalErrMsg.IsEmpty()) GlobalAbort();
			}
			else if (USAME_TI(cmd, "TextViewer")) {
				if (USAME_TI(prm, "CB")) {
					if (!ViewClipText()) Abort();
				}
				else {
					if (!SetAndOpenTxtViewer(prm, opt.ToIntDef(1))) UserAbort(USTR_FileNotOpen);
				}
			}
			else if (USAME_TI(cmd, "FileEdit")) {
				if (!open_by_TextEditor(prm, opt.ToIntDef(1))) GlobalAbort();
			}
			else if (USAME_TI(cmd, "FileEditV")) {
				ExeCommandV(_T("FileEdit"));
			}
			else if (USAME_TI(cmd, "ExeCommands")) {
				if (!ExeCommandsCore(prm)) GlobalAbort();
			}
			else if (USAME_TI(cmd, "MsgBoxCenter")) {
				MsgPosCenter = true;
				msgbox_OK(prm);
				MsgPosCenter = false;
			}
			//内部コマンド
			else if (USAME_TI(cmd, "_SetFileInf")) {
				SetFileInf();
			}
		}
		catch (EAbort &e) {
			SetActionAbort(e.Message);
		}
	}

	//キーリピートでスキップされたファイル情報取得を要求
	if (FinfSkipped && !has_KeyDownMsg()) {
		FinfSkipped = false;
		if (ScrMode==SCMD_FLIST) {
			SetFileInf();
		}
		else if (ScrMode==SCMD_IVIEW && ImgSidePanel->Visible) {
			int idx = ViewFileList->IndexOf(ViewFileName);
			if (idx!=-1) SetImgInfListBox((file_rec*)ViewFileList->Objects[idx]);
		}
	}

	if (Initialized && !UnInitializing) {
		//タイマーイベント処理
		UnicodeString msg;
		for (int i=0; i<MAX_TIMER_EVENT; i++) {
			if (!Timer_Enabled[i]) continue;
			//インターバル
			if (Timer_TimeCnt[i]>0) {
				if ((int)(GetTickCount() - Timer_StartCnt[i]) > Timer_TimeCnt[i]) {
					Timer_StartCnt[i] = GetTickCount();
					msg.sprintf(_T("TIMER %u"), i + 1);
					if (Timer_RepeatCnt[i]>0) {
						if (--Timer_RepeatCnt[i]==0) {
							Timer_TimeCnt[i] = 0;
							msg += " LAST";
						}
					}
					StartLog(msg);
					ExeEventCommand(OnTimerEvent[i]);
				}
			}
			//無操作
			else if (Timer_NopCnt[i]>0 && !Timer_NopAct[i]) {
				if ((int)(GetTickCount() - LastOpCount) > Timer_NopCnt[i]) {
					StartLog(msg.sprintf(_T("NOPTM %u"), i + 1));
					Timer_NopAct[i] = true;
					ExeEventCommand(OnTimerEvent[i]);
				}
			}
			//アラーム
			else {
				try {
					TStringList *sp = Timer_AlarmList[i];
					for (int j=0; j<sp->Count; j++) {
						TDateTime dt = TDateTime(sp->Strings[j]);
						if (Dateutils::CompareDateTime(Now(), dt)==GreaterThanValue) {
							sp->Strings[j] = IncDay(dt, 1);
							StartLog(msg.sprintf(_T("ALARM %u"), i + 1));
							ExeEventCommand(OnTimerEvent[i]);
						}
					}
				}
				catch (...) {
					;
				}
			}
		}

		//スクロールで隠した背景の復帰
		if ((int)(GetTickCount() - LastOpCount) > BgHideTime) RestoreBgImg();
	}

	//FTPの接続監視
	try {
		if (!InhFTPCheck){
			if (IdFTP1->Connected()) {
				//自動切断
				if (!InternetConnected() || ((int)(GetTickCount() - FTPLastWorkCnt) > FTPDisconTimeout*1000)) {
					FTPDisconnectAction->Execute();
				}
				//接続維持
				else if ((int)(GetTickCount() - FTPLastNoopCnt) > 60*1000) {	//***
					FTPLastNoopCnt = GetTickCount();
					IdFTP1->Noop();
					//NOOP コマンドが失敗したら切断
					if (IdFTP1->LastCmdResult->NumericCode!=200) FTPDisconnectAction->Execute();
				}
			}
			//切断イベントが発生せず、画面と状態が合わなくなった場合の対処
			else if (ScrMode==SCMD_FLIST && (CurStt->is_FTP || OppStt->is_FTP)) {
				DisconnectFTP();
				ClearTempArc(TempPathFTP);
				AddLog(_T("FTP切断*"), true);
				play_sound(FTPSndDiscon);
			}
		}
	}
	catch (...) {
		InhFTPCheck = true;
		//FTPを一旦破棄して再生成
		RecycleFTP();
	}

	TaskSttTimer->Tag = 0;
}

//---------------------------------------------------------------------------
//タイマー処理 (ログ表示更新)
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::UpdLogTimerTimer(TObject *Sender)
{
	FlushLog();
}

//---------------------------------------------------------------------------
//タイマー処理 (ディレクトリ監視)
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::WatchDirTimerTimer(TObject *Sender)
{
	WatchDirTimer->Enabled = false;

	for (int i=0; i<MAX_FILELIST; i++) {
		if (!hWatchDir[i]) continue;
		DWORD waitResult = ::WaitForSingleObject(hWatchDir[i], 0);
		if (waitResult==WAIT_OBJECT_0) {
			if (::FindNextChangeNotification(hWatchDir[i])==0) {
				::FindCloseChangeNotification(hWatchDir[i]);
				hWatchDir[i] = NULL;
			}

			//変更有り
			flist_stt *lst_stt = &ListStt[i];
			if (SameText(WatchPath[i], GetCurPathStr(i))
				&& !lst_stt->is_Arc && !lst_stt->is_Find && !lst_stt->is_Work && !lst_stt->is_FTP)
			{
				ReloadList(i);
				//コピー/移動先のカーソル位置設定
				for (int j=0; j<MAX_TASK_THREAD; j++) {
					TTaskThread *tp = TaskThread[j];
					if (tp && SameText(ExtractFilePath(tp->LastDstName), CurPath[i]))
						IndexOfFileList(tp->LastDstName, i);
				}
			}
		}
		else if (waitResult==WAIT_ABANDONED) {
			::FindCloseChangeNotification(hWatchDir[i]);
			hWatchDir[i] = NULL;
			WatchPath[i] = EmptyStr;
		}
	}

	WatchDirTimer->Enabled = true;
}

//---------------------------------------------------------------------------
//タイマー処理 (ファイル追加更新の監視)
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::WatchTailTimerTimer(TObject *Sender)
{
	if (WatchTailList->Count==0 || !Initialized || UnInitializing) return;

	WatchTailTimer->Enabled = false;

	std::unique_ptr<TStringList> log_buf(new TStringList());

	for (int i=0; i<WatchTailList->Count; i++) {
		UnicodeString lbuf = WatchTailList->Strings[i];
							//ファイル名	コードページ	前回のサイズ	キーワード
		UnicodeString fnam = split_pre_tab(lbuf);
		int		 code_page = split_pre_tab(lbuf).ToIntDef(0);
		__int64  last_size = StrToInt64Def(split_pre_tab(lbuf), -1);
		UnicodeString kwd  = lbuf;
		if (!file_exists(fnam)) continue;

		__int64 fsz = get_file_size(fnam);
		if (fsz>last_size) {
			//通知
			if (last_size!=-1) {
				std::unique_ptr<TStringList> lst(new TStringList());
				if (check_text_tail(fnam, code_page, (int)(fsz - last_size), kwd, lst.get())) {
					play_sound(SoundWatch);
					//ログ出力
					AddLogCr();
					AddLog(lbuf.sprintf(_T("WATCH %s"), ExtractFileName(fnam).c_str()), true);
					AddLogStrings(lst.get());
					AddLogCr();

					log_buf->Add(fnam);
					log_buf->AddStrings(lst.get());
					log_buf->Add(EmptyStr);
				}
			}
			//リスト更新
			lbuf.sprintf(_T("%s\t%u\t%llu\t"), fnam.c_str(), code_page, fsz);
			lbuf += kwd;
			WatchTailList->Strings[i] = lbuf;
		}
	}

	//イベント : WatchTailコマンドからの通知
	if (log_buf->Count>0) {
		LastWatchLog = log_buf->Text;
		ExeEventCommand(OnWatchNotify);
	}

	WatchTailTimer->Enabled = true;
}

//---------------------------------------------------------------------------
//タイマー処理 (メッセージヒント表示)
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::MsgHintTimerTimer(TObject *Sender)
{
	MsgHintTimer->Enabled = false;

	MsgHint->ReleaseHandle();
	PreviewSizeLabel->Visible = false;
	StatusBar1->Tag = 0;
	StatusBar1->Repaint();

	SetDrivePanel(0);
	SetDrivePanel(1);

	if (FindBusy) ShowMessageHint(USTR_SearchingESC, col_bgHint, false, true);
}

//---------------------------------------------------------------------------
//タイマー処理 (２ストロークキーのヒント表示)
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::KeyHintTimerTimer(TObject *Sender)
{
	KeyHintTimer->Enabled = false;

	//該当する2ストローク操作を列挙
	UnicodeString fkey = GetModeIdStr();
	if (fkey.IsEmpty()) return;

	fkey.cat_sprintf(_T(":%s~"), FirstKey.c_str());

	std::unique_ptr<TStringList> key_lst(new TStringList());
	for (int i=0; i<KeyFuncList->Count; i++) {
		UnicodeString lbuf = KeyFuncList->Strings[i];
		if (StartsText(fkey, lbuf)) key_lst->Add(get_tkn_r(lbuf, ':'));
	}
	if (key_lst->Count==0) return;

	//表示最大幅を取得
	std::unique_ptr<TStringList> cmd_lst(new TStringList());
	std::unique_ptr<TStringList> dsc_lst(new TStringList());
	TCanvas *cv = KeyHint->Canvas;
	int max_w_k = 0, max_w_c = 0;
	for (int i=0; i<key_lst->Count; i++) {
		max_w_k = std::max(cv->TextWidth(key_lst->Names[i]), max_w_k);
		UnicodeString cmd = key_lst->ValueFromIndex[i];
		dsc_lst->Add(get_CmdDesc(cmd, true));
		cmd = del_CmdDesc(cmd);
		UnicodeString prm = get_PrmStr(cmd);
		cmd = get_CmdStr(cmd);
		if (USAME_TI(cmd, "ExeCommands") && !get_tkn_r(prm, ':').IsEmpty())
			prm = get_tkn(prm, ':') + ": ...";
		else if (USAME_TI(cmd, "CopyFileName") && prm.Length()>8)
			prm = prm.SubString(1, 8) + "...";
		else if (!get_tkn_r(prm, _T(":\\")).IsEmpty())
			prm = get_tkn(prm, _T(":\\")) + ":\\...";
		if (!prm.IsEmpty()) cmd.cat_sprintf(_T("_%s"), prm.c_str());
		cmd_lst->Add(cmd);
		max_w_c = std::max(cv->TextWidth(cmd), max_w_c);
	}
	max_w_k += 20;
	max_w_c += 20;

	UnicodeString tmp;
	//表示位置を揃えるために空白を付加して調整
	for (int i=0; i<key_lst->Count; i++) {
		UnicodeString key = key_lst->Names[i];
		UnicodeString cmd = cmd_lst->Strings[i];
		while (cv->TextWidth(key) < max_w_k) key += " ";
		while (cv->TextWidth(cmd) < max_w_c) cmd += " ";
		key_lst->Strings[i] = tmp.sprintf(_T("%s%s%s "), key.c_str(), cmd.c_str(), dsc_lst->Strings[i].c_str());
	}

	//表示
	tmp = key_lst->Text;
	remove_end_s(tmp, "\r\n");
	KeyHint->ActivateHintEx(tmp, ScaledInt(600), ScaledInt(400), GetCurControl(), col_bgHint);
}

//---------------------------------------------------------------------------
//タイマー処理 (白飛び警告)
// インターバル = 500ms
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::BlinkTimerTimer(TObject *Sender)
{
	if (!WarnHighlight || ScrMode!=SCMD_IVIEW || !ImgScrollPanel->Visible) return;
	if (!ImgViewThread->IsReady() || ImgViewThread->ViewBuff->Empty) return;
	if (isViewAGif) return;

	WarnBlink = !WarnBlink;
	ViewerImage->Picture->Bitmap->Assign(ImgViewThread->ViewBuff);
	TCanvas *cv = ViewerImage->Picture->Bitmap->Canvas;
	if (WarnBlink) {
		std::unique_ptr<Graphics::TBitmap> mp(new Graphics::TBitmap());
		mp->Assign(ImgViewThread->ViewBuff);
		mp->PixelFormat = pf24bit;
		mp->Mask(clWhite);
		cv->CopyMode = cmSrcInvert;
		cv->Draw(0, 0, mp.get());
	}

	//分割グリッド
	if (ImgViewThread->ShowGrid) draw_ImgGrid(cv, ImgViewThread->ViewBuff);
	ImgSttHeader->Repaint(); ImgInfBar->Repaint();
}

//---------------------------------------------------------------------------
//サブパネルのレイアウト設定
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::SetSubLayout(
	bool initial)		//初期化時 (default = false)
{
	InfListBox->Tag    = LBTAG_OPT_FIF1;
	ImgInfListBox->Tag = LBTAG_OPT_FIF1;

	InfPanel->Visible		= (PreviewPanel->Visible || InfListPanel->Visible);
	ImgInfSplitter->Visible = (PreviewPanel->Visible && InfListPanel->Visible);
	InfLogSplitter->Visible = (InfPanel->Visible && LogPanel->Visible);

	if (initial) {
		PreviewHeight  = IniFile->ReadIntGen(IsPrimary? _T("ImageHeight") : _T("ImageHeight2"),	150);
		PreviewWidth   = IniFile->ReadIntGen(IsPrimary? _T("ImageWidth")  : _T("ImageWidth2"),	150);
		InfPanelHeight = IniFile->ReadIntGen(IsPrimary? _T("InfHeight")   : _T("InfHeight2"),	Height/2);
		InfPanelWidth  = IniFile->ReadIntGen(IsPrimary? _T("InfWidth")    : _T("InfWidth2"),	Width/2);
	}

	//サブパネルが下
	if (LayoutMode==0) {
		set_PanelAlign(InfPanel, InfLogSplitter, alLeft, SplitterWidth2);
		if (!LogPanel->Visible) InfPanel->Align = alClient;

		SubPanel->Height = IniFile->ReadIntGen(IsPrimary? _T("SubHeight") : _T("SubHeight2"),	100);
		InfPanel->Width  = InfPanelWidth;
		//プレビュー/ファイル情報
		ImgInfSplitter->Align = alRight;
		PreviewPanel->Align   = (PreviewPanel->Visible && !InfListPanel->Visible)? alClient : alLeft;
		if (PreviewPanel->Align==alLeft)
			PreviewPanel->Width = PreviewWidth;
		else
			InfListBox->Width = InfPanel->Width - PreviewWidth;
		ImgInfSplitter->Align = alLeft;
	}
	//サブパネルがサイド
	else {
		set_PanelAlign(InfPanel, InfLogSplitter, alTop, SplitterWidth2);
		if (!LogPanel->Visible) InfPanel->Align = alClient;

		SubPanel->Width  = IniFile->ReadIntGen(IsPrimary? _T("SubWidth") : _T("SubWidth2"),	200);
		InfPanel->Height = InfPanelHeight;
		if (LogPanel->Visible && InfPanel->Height>=SubPanel->Height) InfPanel->Height = Height/2;

		//プレビュー/ファイル情報
		ImgInfSplitter->Align = alBottom;
		PreviewPanel->Align   = (PreviewPanel->Visible && !InfListPanel->Visible)? alClient : alTop;
		if (PreviewPanel->Align==alTop)
			PreviewPanel->Height = PreviewHeight;
		else
			InfListBox->Height = InfPanel->Height - PreviewHeight;
		ImgInfSplitter->Align = alTop;
	}

	TxtTailListPanel->Height = IniFile->ReadIntGen(IsPrimary? _T("TailHeight") : _T("TailHeight2"),	36);	//***

	if (PreviewPanel->Visible) {
		if (PreviewPanel->Align==alTop)  PreviewHeight = PreviewPanel->Height;
		if (PreviewPanel->Align==alLeft) PreviewWidth  = PreviewPanel->Width;
	}
}

//---------------------------------------------------------------------------
//フォントの設定
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::SetupFont()
{
	for (int i=0; i<MAX_FILELIST; i++) set_StdListBox(FileListBox[i]);
	set_StdListBox(ResultListBox, 0, GrepResFont);

	set_ListBoxItemHi(InfListBox,		FileInfFont);
	set_ListBoxItemHi(TxtPrvListBox,	TxtPrvFont);
	set_ListBoxItemHi(TxtTailListBox,	TxtPrvFont);
	set_ListBoxItemHi(ImgInfListBox,	FileInfFont);
	set_ListBoxItemHi(LogListBox,		LogFont);

	LockTxtPanel->Font->Assign(TxtPrvFont);
	LockTxtPanel->ClientHeight = get_FontHeight(TxtPrvFont, 4);

	MsgHint->Canvas->Font->Assign(HintFont);
	MsgHint->Canvas->Font->Color = col_fgHint;
	KeyHint->Canvas->Font->Assign(HintFont);
	KeyHint->Canvas->Font->Color = col_fgHint;

	StatusBar1->Font->Assign(SttBarFont);
	StatusBar1->ClientHeight = get_FontHeight(SttBarFont, 4, 4);
	StatusBar1->Panels->Items[0]->Width = ClientWidth
		- set_SttBarPanelWidth(StatusBar1, 1, str_len_half(GetClockStr())) - ScaledInt(20);

	ClockBar->Font->Assign(SttBarFont);
	ClockBar->ClientHeight = get_FontHeight(SttBarFont, 4, 4);
	ClockBarI->Font->Assign(SttBarFont);
	ClockBarI->ClientHeight = get_FontHeight(SttBarFont, 4, 4);
	GrepStatusBar->Font->Assign(SttBarFont);
	GrepStatusBar->ClientHeight = get_FontHeight(SttBarFont, 4);

	TabControl1->Font->Assign(TabBarFont);
	ToolBarF->Font->Assign(ToolBarFont);
	ToolBarV->Font->Assign(ToolBarFont);
	ToolBarI->Font->Assign(ToolBarFont);
	ToolBarI2->Font->Assign(ToolBarFont);
	FKeyBar->Font->Assign(ToolBarFont);
}

//---------------------------------------------------------------------------
//サムネイルの設定
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::SetupThumbnail(
	int idx)		//インデックス	(default = -1)
{
	TStringGrid *gp = ThumbnailGrid;
	if (ThumbExtended) {
		gp->Align	   = alClient;
		gp->ScrollBars = ShowThumbScroll? ssVertical : ssNone;
		gp->BevelKind  = bkNone;
	}
	else {
		switch (ThumbnailPos) {
		case 0: gp->Align = alTop;		break;
		case 1: gp->Align = alBottom;	break;
		case 2:
			if (ImgSidePanel->Visible && ImgSidePanel->Align==alLeft) gp->Align = alRight;
			gp->Align = alLeft;
			break;
		case 3:
			if (ImgSidePanel->Visible && ImgSidePanel->Align==alRight) gp->Align = alLeft;
			gp->Align = alRight;
			break;
		}

		//スクロールバー
		if (ShowThumbScroll)
			gp->ScrollBars = (ThumbnailPos<2)? Stdctrls::ssHorizontal : Stdctrls::ssVertical;
		else
			gp->ScrollBars = ssNone;

		gp->BevelKind = bkFlat;
	}

	int s_16 = ScaledInt(16);
	gp->Color			 = col_bgImage;
	gp->DefaultColWidth  = ThumbnailSize + 4;
	gp->DefaultRowHeight = ThumbnailSize + (ShowThumbName? ScaledInt(20) : 4) + (ShowThumbExif? s_16 : 0) + (ShowThumbTags? s_16 : 0);
	gp->GridLineWidth	 = ThumbBdrWidth;

	//全面表示
	if (ThumbExtended) {
		gp->ColCount = ViewFileList->Count;
		gp->LeftCol  = 0;
		gp->ColCount = gp->VisibleColCount;
		gp->RowCount = ViewFileList->Count/gp->ColCount + ((ViewFileList->Count%gp->ColCount>0)? 1 : 0);
	}
	//通常表示(横)
	else if (ThumbnailPos<2) {
		gp->RowCount	 = 1;
		gp->ColCount	 = ViewFileList->Count;
		gp->ClientHeight = gp->DefaultRowHeight + 1;
	}
	//通常表示(縦)
	else {
		gp->ColCount	= 1;
		gp->RowCount	= ViewFileList->Count;
		gp->ClientWidth = gp->DefaultColWidth + 1;
	}

	if (idx!=-1) set_GridIndex(gp, idx, ViewFileList->Count);
}

//---------------------------------------------------------------------------
//個別配色をリセット
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ResetIndColor(int tag)
{
	for (int i=0; i<MAX_FILELIST; i++) {
		if (tag==-1 || tag==i) { 
			flist_stt *lst_stt = &ListStt[i];
			lst_stt->color_bgDirInf = col_bgDirInf;
			lst_stt->color_fgDirInf = col_fgDirInf;
			lst_stt->color_bgDrvInf = col_bgDrvInf;
			lst_stt->color_fgDrvInf = col_fgDrvInf;
			lst_stt->color_Cursor	= col_Cursor;
			lst_stt->color_selItem  = col_selItem;
		}
	}
}

//---------------------------------------------------------------------------
//デザインを設定
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::SetupDesign(
	bool chg_layout,	//レイアウトが変化
	bool initial)		//初期化時 (default = false)
{
	InhUpdBgImg++;

	//境界線/ノブ画像
	BgImgName[BGIMGID_KNOB_H] = BgImgName[BGIMGID_KNOB_V];
	for (int i=2; i<MAX_BGIMAGE; i++) {
		UnicodeString fnam = to_absolute_name(BgImgName[i]);
		if (file_exists(fnam)) {
			TColor bgcol = (i==BGIMGID_KNOB_V || i==BGIMGID_KNOB_H)? col_bgScrKnob : col_Splitter;
			load_ImageFile(fnam, BgImgBuff[i], WICIMG_THUMBNAIL, bgcol);
			if (i==BGIMGID_KNOB_H) {
				WIC_rotate_image(BgImgBuff[i], 1);
				WIC_rotate_image(BgImgBuff[i], 4);
			}
		}
		else BgImgBuff[i]->Handle = NULL;
	}

	//カラー
	SubPanel->Color 			= col_bgList;
	PreviewPanel->Color 		= col_bgImage;
	PrvInnerPanel->Color		= col_bgImage;
	InfListBox->Color			= col_bgInf;
	TxtPrvListBox->Color		= col_bgTxtPrv;
	TxtTailListBox->Color		= col_bgTxtPrv;
	LockTxtPanel->Color 		= col_bgTxtPrv;
	LockTxtPanel->Font->Color	= col_Error;
	ImgInfListBox->Color		= col_bgInf;
	LogListBox->Color			= col_bgLog;
	LogSplitPanel->Color		= SelectWorB(col_bgLog, 0.3);
	TxtViewPanel->Color 		= col_bgView;
	TxtScrollPanel->Color		= col_bgView;

	ImgViewPanel->Color 		= col_bgImage;
	ImgScrollBox->Color 		= col_bgImage;
	ThumbnailGrid->Color		= col_bgImage;
	SideDockPanel->Color		= col_bgImage;
	LoupeDockPanel->Color		= col_bgImage;
	HistDockPanel->Color		= col_bgImage;

	setup_ToolBar(LoupeForm->MagToolBar);

	LRSplitter->Color			= col_Splitter;
	ListSubSplitter->Color		= col_Splitter;
	ImgInfSplitter->Color		= col_Splitter;
	TxtPrvSplitter->Color		= col_Splitter;
	ImgSideSplitter->Color		= col_Splitter;
	SideDockSplitter->Color 	= col_Splitter;
	InfLogSplitter->Color		= col_Splitter;

	SetupToolBarColor();

	ModalScrForm->Color 		  = col_ModalScr;
	ModalScrForm->AlphaBlendValue = ModalScrAlpha;

	//個別配色をリセット
	if (!initial) ResetIndColor(-1);

	//タブバー
	TabPanel->Color 	   = col_bgTabBar;
	TabControl1->Style	   = (FlTabStyle==2)? tsButtons : (FlTabStyle==3)? tsFlatButtons : tsTabs;
	TabControl1->Height    = std::max(get_FontHeight(TabBarFont, 8, 8) + ((TabControl1->Style==tsTabs)? 0: 4), 18);
	TabControl1->TabWidth  = FlTabWidth;
	TabControl1->Top	   = 2;
	TabControl1->Left	   = ShowPopTabBtn? PopTabBtn->Width : 0;

	PopTabBtn->Top		   = 2;
	PopTabBtn->Height	   = TabControl1->Height;
	PopTabBtn->Visible	   = ShowPopTabBtn;

	TabPanel->ClientHeight = TabControl1->Height + TabControl1->Top;
	TabPanel->Visible	   = ShowTabBar;
	TabBottomPaintBox->Visible = (FlatInfPanel && col_frmTab!=col_None && (FlTabStyle==0 || FlTabStyle==1));
	UpdateTabBar(TabControl1->TabIndex);

	//ボタンマーク
	TColor col_mk = is_HighContrast()? scl_BtnText : SelectWorB(col_bgDirInf);
	set_ButtonMark(L_SelDrvBtn,  UBMK_DOWN, col_mk);
	set_ButtonMark(L_SelDrvBtn2, UBMK_DOWN, col_mk);
	set_ButtonMark(R_SelDrvBtn,  UBMK_DOWN, col_mk);
	set_ButtonMark(R_SelDrvBtn2, UBMK_DOWN, col_mk);
	set_ButtonMark(PopTabBtn,    UBMK_DOWN, is_HighContrast()? scl_BtnText : SelectWorB(col_bgTabBar));
	set_ButtonMark(SeekLBtn, UBMK_HTOP);
	set_ButtonMark(SeekRBtn, UBMK_HEND);

	L_SelDrvBtn->Visible  = ShowPopDirBtn;
	L_SelDrvBtn2->Visible = ShowPopDirBtn;
	R_SelDrvBtn->Visible  = ShowPopDirBtn;
	R_SelDrvBtn2->Visible = ShowPopDirBtn;

	set_SplitterWidht(LRSplitter,		SplitterWidth);
	set_SplitterWidht(ListSubSplitter,	SplitterWidth);
	set_SplitterWidht(ImgInfSplitter,	SplitterWidth2);
	set_SplitterWidht(ImgSideSplitter,	IS_FullScr()? 0 : SplitterWidth);
	set_SplitterWidht(SideDockSplitter,	SplitterWidth2);
	set_SplitterWidht(InfLogSplitter,	SplitterWidth2);
	set_SplitterWidht(TxtPrvSplitter,	4);

	//リストのヘッダ
	InitializeListHeader(L_HeaderControl, _T("名前|種類|サイズ|更新日時|場所"));
	InitializeListHeader(R_HeaderControl, _T("名前|種類|サイズ|更新日時|場所"));
	L_HeaderControl->Visible = ShowHeader;
	R_HeaderControl->Visible = ShowHeader;
	int fnam_wd = get_CharWidth(Canvas, 8, ScaledInt((IconMode>0)? 20 : 8));
	L_HeaderControl->Sections->Items[0]->MinWidth = fnam_wd;
	R_HeaderControl->Sections->Items[0]->MinWidth = fnam_wd;

	//ディレクトリ表示部
	for (int i=0; i<3; i++) {
		TPanel *pp = (i==1)? L_HdrPanel : (i==2)? R_HdrPanel : HdrPanel;
		pp->Height = get_FontHeight(DirInfFont, 8, FlatInfPanel? 8 : 10);
		pp->Font->Assign(DirInfFont);
		pp->Color 	    = col_bgDirInf;
		pp->Font->Color = col_fgDirInf;
	}

	//ピンマークの幅を取得
	TabPinWidth = get_WidthInPanel(TabPinMark, L_DirPanel, true) + Scaled4;

	L_TopPanel->Color = col_bgDirInf;
	R_TopPanel->Color = col_bgDirInf;
	L_HdrPanel->Color = col_bgDirInf;
	R_HdrPanel->Color = col_bgDirInf;

	HdrPanel->BevelOuter   = FlatInfPanel? bvNone : bvRaised;
	L_HdrPanel->BevelOuter = FlatInfPanel? bvNone : bvRaised;
	R_HdrPanel->BevelOuter = FlatInfPanel? bvNone : bvRaised;
	RelPanel->BevelOuter   = FlatInfPanel? bvNone : bvLowered;
	RelPanel2->BevelOuter  = FlatInfPanel? bvNone : bvLowered;
	RelPanel->ClientWidth  = HdrPanel->ClientHeight * 2 + 8;
	RelPanel2->ClientWidth = RelPanel->ClientWidth;
	RelPanel->Color 	   = col_bgDirRel;
	RelPanel2->Color 	   = col_bgDirRel;

	//ドライブ表示
	for (int i=0; i<2; i++) {
		TPanel *stt_panel = (i==0)? L_StatPanel : R_StatPanel;
		stt_panel->Font->Assign(DrvInfFont);
		stt_panel->ClientHeight = get_FontHeight(DrvInfFont, 4);
		stt_panel->Color		= col_bgDrvInf;
		stt_panel->Font->Color  = col_fgDrvInf;
		stt_panel->BevelKind	= FlatInfPanel? bkNone : bkFlat;
		stt_panel->BevelOuter	= FlatInfPanel? bvNone : bvLowered;
	}

	//フィルタ
	FilterComboBox->Font->Assign(DrvInfFont);
	FilterComboBox->Height = L_StatPanel->ClientHeight;

	//イメージビュアー情報ヘッダ
	ImgSttHeader->Align = ImgSttIsBottom? alBottom : alTop;
	ImgSttHeader->Font->Assign(ViewHdrFont);
	ImgSttHeader->ClientHeight = get_FontHeight(ViewHdrFont, 4, 4);
	set_SttBarPanelWidth(ImgSttHeader, 2, 12);	//"9999 × 9999"
	set_SttBarPanelWidth(ImgSttHeader, 3,  9);	//"100%  G !"
	set_SttBarPanelWidth(ImgSttHeader, 4, 18);	//"999/999 (選択 999)"

	ImgInfBar->Align = ImgSttIsBottom? alBottom : alTop;
	ImgInfBar->Font->Assign(ViewHdrFont);
	ImgInfBar->ClientHeight = get_FontHeight(ViewHdrFont, 4, 4);
	ImgInfBar->Panels->Items[0]->Width = ImgSttHeader->Panels->Items[4]->Width;
	ImgSttHeader->Repaint(); ImgInfBar->Repaint();

	//テキストビュアー情報ヘッダ
	TxtSttHeader->Align 	   = TxtSttIsBottom? alBottom : alTop;
	TxtSttHeader->ClientHeight = ImgSttHeader->ClientHeight;
	TxtSttHeader->Font->Assign(ViewHdrFont);
	TxtSttHeader->Repaint();

	//プレビュー/ファイル情報
	PreviewPanel->Visible = ShowImgPreview;
	InfListPanel->Visible = ShowProperty;

	//ログウィンドウ
	LogPanel->Visible = ShowLogWin;

	//タスク表示部
	TPaintBox *pp = TaskPaintBox;
	pp->Canvas->Font->Assign(LogFont);
	TaskPaintBox->Width = get_CharWidth(pp->Canvas,  9);
	pp->Color = col_bgTask;

	//コンボボックスの自動補完
	set_ComboBox_AutoComp(this);

	//画面レイアウト
	if (chg_layout) {
		SubPanel->Visible = !(IsPrimary? ShowFileListOnly : ShowFileListOnly2);
		InfPanel->Visible = (PreviewPanel->Visible || InfListPanel->Visible);

		set_PanelAlign(SubPanel, ListSubSplitter, LayoutMode, SplitterWidth);
		SetSubLayout(initial);

		if (initial) {
			L_Panel->Width	  = IniFile->ReadIntGen(_T("L_Width"), (ListPanel->ClientWidth + LRSplitter->Width)/2);
			L_TopPanel->Width = L_Panel->Width - (RelPanel->Width - LRSplitter->Width)/2;
		}
	}

	//上下分割
	if (DivFileListUD) {
		if (L_Panel->Align!=alTop) set_PanelAlign(L_Panel, LRSplitter, alTop, SplitterWidth);
		//ディレクトリ情報も分割
		if (DivDirInfUD) {
			HdrPanel->Visible	= false;
			L_HdrPanel->Visible = true;
			R_HdrPanel->Visible = true;
		}
		//非分割
		else {
			HdrPanel->Visible	= true;
			L_HdrPanel->Visible = false;
			R_HdrPanel->Visible = false;
			L_TopPanel->Width	= (HdrPanel->Width - RelPanel->Width)/2;
		}
		if (initial) {
			int h = ListPanel->ClientHeight - LRSplitter->Height;
			if (TabPanel->Visible) h -= TabPanel->Height;
			if (HdrPanel->Visible) h -= HdrPanel->Height;
			L_Panel->Height = IniFile->ReadIntGen(_T("L_Height"), h/2);
		}
	}
	//左右分割
	else {
		if (L_Panel->Align!=alLeft) set_PanelAlign(L_Panel, LRSplitter, alLeft, SplitterWidth);
		if (initial) L_Panel->Width = IniFile->ReadIntGen(_T("L_Width"), (ListPanel->ClientWidth - LRSplitter->Width)/2);
		L_TopPanel->Width = L_Panel->Width - (RelPanel->Width - LRSplitter->Width)/2;
		HdrPanel->Visible	= true;
		L_HdrPanel->Visible = false;
		R_HdrPanel->Visible = false;
	}

	if (KeepOnResize) {
		ActionParam = ListPercent;
		if (KeepCurListWidth && ListPercent!=50) ActionOptStr.sprintf(_T("%s"), (CurListTag==0)? _T("Left") : _T("Right"));
		WidenCurListAction->Execute();
	}

	if (initial) {
		GrepT2Panel->Width = IniFile->ReadIntGen(_T("GrepTR_Width"),	50);
		RepT2Panel->Width  = IniFile->ReadIntGen(_T("RepTR_Width"),		50);
		GrepM1Panel->Width = IniFile->ReadIntGen(_T("GrepLL_Width"),	ClientWidth/2);
		GrepMidSplitter->MinSize = GrepM3Panel->Width + ScaledInt(200);	//***
		if ((ClientWidth - GrepM1Panel->Width)<GrepMidSplitter->MinSize)
			GrepM1Panel->Width = ClientWidth - GrepMidSplitter->MinSize;
		GrepFilterPanel->Width = IniFile->ReadIntGen(_T("GrepFilterWidth"),	200);
		if ((ClientWidth - GrepFilterPanel->Width)<GrepSttSplitter->MinSize)
			GrepFilterPanel->Width = ClientWidth - GrepMidSplitter->MinSize;
	}

	//メニューバー
	Menu = (ShowMainMenu && !IS_FullScr())? MainMenu1 : NULL;

	//アクセラレータキーがキー設定と重複しないように調整
	UnicodeString acc_lst = "ZYXWVUTSRQPONMLKJIHGFEDCBA0987654321";
	for (int i=0; i<KeyFuncList->Count; i++) {
		UnicodeString kbuf = get_tkn_m(KeyFuncList->Names[i], ':', '~');
		if (remove_top_text(kbuf, _T("Alt+")) && kbuf.Length()==1)
			acc_lst = ReplaceText(acc_lst, kbuf, EmptyStr);
	}

	struct {
		TMenuItem *mp;		//メニュー項目
		const _TCHAR *tit;	//タイトル
		const _TCHAR *akc;	//アクセラレータ
	} menu_def[] = {
		{FileMenu,	 _T("ファイル"), _T("F")},
		{EditMenu,	 _T("編集"),	 _T("E")},
		{FindMenu,	 _T("検索"),	 _T("S")},
		{ViewMenu,	 _T("表示"),	 _T("V")},
		{ListMenu,	 _T("一覧"),	 _T("L")},
		{ToolMenu,	 _T("ツール"),	 _T("T")},
		{OptionMenu, _T("設定"),	 _T("O")},
		{HelpMenu,	 _T("ヘルプ"),	 _T("H")}
	};

	int cnt = sizeof(menu_def)/sizeof(menu_def[0]);
	for (int i=0; i<cnt; i++) {
		UnicodeString tmp = menu_def[i].tit;
		int p = acc_lst.Pos(menu_def[i].akc);
		WideChar ak;
		if (p) {
			ak = acc_lst[p];
			acc_lst.Delete(p, 1);
		}
		else {
			ak = split_top_wch(acc_lst);
		}
		if (ak) tmp.cat_sprintf(_T("(&%c)"), ak);
		menu_def[i].mp->Caption = tmp;
	}

	//メニュー
	TMenuAutoFlag ak_flag = MenuAutoHotkey? maAutomatic : maManual;
	MainMenu1->AutoHotkeys	 = ak_flag;
	ExPopupMenu->AutoHotkeys = ak_flag;

	//ツールバー
	ToolBarF->Visible  = ShowToolBar;
	ToolBarV->Visible  = ShowToolBarV;
	if (!IS_FullScr()) {
		ToolBarI2->Visible = ShowToolBarI && ShowImgSidebar && ToolBarISide;
		ToolBarI->Visible  = ShowToolBarI && !ToolBarI2->Visible;
	}

	//シンプルスクロールバー
	set_UsrScrPanel(FlScrPanel[0]);
	set_UsrScrPanel(FlScrPanel[1]);
	set_UsrScrPanel(TxtPrvScrPanel);
	set_UsrScrPanel(TxtTailScrPanel);
	set_UsrScrPanel(InfScrPanel);
	set_UsrScrPanel(LogScrPanel);
	set_UsrScrPanel(ImgInfScrPanel);
	set_UsrScrPanel(ResultScrPanel);
	set_UsrScrPanel(TxtViewScrPanel);

	if (!IS_FullScr()) {
		//シークバー
		SeekPanel->Visible = ShowSeekBar;

		//ステータスバー
		StatusBar1->Visible = ShowSttBar;
		StatusBar1->Repaint();
	}

	//時計パネル
	ClockBar->Visible  = !ShowSttBar && (LayoutMode!=0) && !SttClockFmt.IsEmpty();
	ClockBar->SizeGrip = (LayoutMode==1);
	ClockBar->Repaint();

	//ファンクションキーバー
	if (!IS_FullScr()) {
		FKeyBar->Visible = ShowFKeyBar;
		UpdateFKeyBtn();
	}

	//---------------------------------------
	//イメージビュアーサイドバー
	//---------------------------------------
	if (initial) {
		ImgSidePanel->Visible = ShowImgSidebar;
		ImgSidePanel->Width   = IniFile->ReadIntGen(_T("ImgSidebarWidth"),	200);
		//ルーペのドッキング
		if (!IniFile->ReadBoolGen(_T("LoupeFloating"), true)) {
			DockSideCtrl(LoupeForm, LoupeDockPanel, IniFile->ReadBoolGen(_T("DockIsTop"), true));
			LoupeForm->Visible = ShowLoupe;
			if (LoupeForm->Visible) {
				LoupeDockPanel->Constraints->MinHeight = MINHI_LOUPE;
				LoupeDockPanel->Constraints->MaxHeight = 0;
				SideDockPanel->Height = HistDockPanel->Height + IniFile->ReadIntGen(_T("LoupeHeight"),	200);
			}
			else {
				LoupeDockPanel->Constraints->MinHeight = 1;
				LoupeDockPanel->Constraints->MaxHeight = 1;
				SideDockPanel->Height = HistDockPanel->Height;
			}
		}
		//ヒストグラム
		if (!IniFile->ReadBoolGen(_T("HistogramFloating"), true)) {
			DockSideCtrl(HistForm, HistDockPanel, IniFile->ReadBoolGen(_T("DockIsTop"), true));
			HistForm->Visible = ShowHistogram;
			if (!HistForm->Visible) {
				HistDockPanel->Constraints->MinHeight = 1;
				HistDockPanel->Constraints->MaxHeight = 1;
				SideDockPanel->Height = SideDockPanel->Height - CLHI_HISTOGRAM;
			}
		}
	}
	else if (!IS_FullScr()) {
		ImgSidePanel->Visible = ShowImgSidebar;
	}

	SideDockSplitter->Height = (LoupeForm->Visible && !LoupeForm->Floating)? SplitterWidth2 : 0;

	if (!IS_FullScr()) {
		ImgSttHeader->Visible = !ShowImgSidebar;
		set_PanelAlign(ImgSidePanel, ImgSideSplitter, ImgSidebarIsLeft? alLeft : alRight, SplitterWidth);

		//時計パネル
		ClockBarI->Visible	= !ShowSttBar && !SttClockFmt.IsEmpty();;
		ClockBarI->SizeGrip = !ImgSidebarIsLeft;
	}

	//サムネイル
	SetupThumbnail();

	if (initial) {
		ThumbnailGrid->Visible = IniFile->ReadBoolGen(_T("ShowThumbnail"),	true);
		//※テキストビュアーを一旦表示状態にしないと幅が初期化されない
		TxtViewPanel->Visible	= true;
		TxtScrollPanel->Visible = true;
		TxtScrollPanel->Visible = false;
		TxtViewPanel->Visible	= false;
	}

	InhUpdBgImg--;
	//背景画像
	if (!initial) UpdateBgImage(true, true);
}

//---------------------------------------------------------------------------
//ツールバーの背景色を設定
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::SetupToolBarColor(bool act_sw, bool bg_only)
{
	TColor cl_gr1 = act_sw? col_bgTlBar1 : GrayCol(col_bgTlBar1);
	TColor cl_gr2 = act_sw? col_bgTlBar2 : GrayCol(col_bgTlBar2);
	ToolBarF->GradientStartColor  = cl_gr1;
	ToolBarF->GradientEndColor	  = cl_gr2;
	ToolBarV->GradientStartColor  = cl_gr1;
	ToolBarV->GradientEndColor	  = cl_gr2;
	ToolBarI->GradientStartColor  = cl_gr1;
	ToolBarI->GradientEndColor	  = cl_gr2;
	ToolBarI2->GradientStartColor = cl_gr1;
	ToolBarI2->GradientEndColor   = cl_gr2;
	FKeyBar->GradientStartColor   = cl_gr1;
	FKeyBar->GradientEndColor	  = cl_gr2;

	if (!bg_only) {
		ToolBarF->Font->Color	  = col_fgTlBar;
		ToolBarF->HotTrackColor	  = col_htTlBar;
		ToolBarV->Font->Color	  = col_fgTlBar;
		ToolBarV->HotTrackColor	  = col_htTlBar;
		ToolBarI->Font->Color	  = col_fgTlBar;
		ToolBarI->HotTrackColor	  = col_htTlBar;
		ToolBarI2->Font->Color	  = col_fgTlBar;
		ToolBarI2->HotTrackColor  = col_htTlBar;
		FKeyBar->Font->Color	  = col_fgTlBar;
		FKeyBar->HotTrackColor	  = col_htTlBar;
	}
}

//---------------------------------------------------------------------------
//ファイルリストのフォントサイズを設定
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::SetFileListFontSize(
	int sz,			//指定サイズ (default = 0 : リセット)
	bool r_sw,		//相対指定	 (default = false)
	bool x_sw)		//^指定		 (default = false)
{
	for (int i=0; i<MAX_FILELIST; i++) {
		TListBox *lp = FileListBox[i];
		int fsz = (sz==0)? ListFont->Size :
				     r_sw? lp->Font->Size + std::max(std::min(sz, 12), -12) :
				  (x_sw && lp->Font->Size==sz)? ListFont->Size : sz;
		lp->Font->Size = std::max(std::min(fsz, MAX_FNTZOOM_SZ), MIN_FNTZOOM_SZ);
		lp->ItemHeight = get_FontHeight(lp->Font, ListInterLn);
		FlScrPanel[i]->UpdateKnob();
		SetFlItemWidth(GetFileList(i), i);
	}
}

//---------------------------------------------------------------------------
//ツールボタンの更新
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::UpdateToolBtn(int scr_mode)
{
	if (scr_mode==-1) scr_mode = ScrMode;

	TToolBar    *tp;
	TStringList *b_lst = GetCurBtnList(scr_mode);
	TImageList  *i_lst;

	switch (scr_mode) {
	case SCMD_FLIST:
		tp = ToolBarF;
		i_lst = IconImgList;
		break;
	case SCMD_TVIEW:
		tp = ToolBarV;
		i_lst = IconImgListV;
		break;
	case SCMD_IVIEW:
		tp = ToolBarI2->Visible? ToolBarI2 : ToolBarI->Visible? ToolBarI : NULL;
		i_lst = IconImgListI;
		break;
	default:
		return;
	}

	if (!tp) return;

	if (b_lst->Count==0) b_lst->Add("\"設定\",\"ToolBarDlg\",\"\"");	//デフォルト

	set_RedrawOff(tp);
	{
		//一旦破棄
		while (tp->ButtonCount>0) delete tp->Buttons[0];
		i_lst->Clear();

		//更新
		for (int i=b_lst->Count-1; i>=0; i--) {
			TToolButton *bp = new TToolButton(this);
			bp->Tag 	   = i;
			bp->AutoSize   = true;
			bp->ImageIndex = -1;
			TStringDynArray itm_buf = get_csv_array(b_lst->Strings[i], 3, true);
			//セパレータ
			if (is_separator(itm_buf[0])) {
				bp->Style	 = tbsSeparator;
				bp->AutoSize = false;
				bp->Width	 = extract_int_def(itm_buf[1], Scaled4);
			}
			//ボタン
			else {
				//単独でパラメータ無コマンドだったらアクションへバインド(Checked 反映)
				UnicodeString cmd = Trim(itm_buf[1]);
				if (is_OneNrmCmd(cmd, true)) {
					for (int j=0; j<ActionList1->ActionCount; j++) {
						TAction *ap = (TAction*)ActionList1->Actions[j];
						if (StartsText("Command", ap->Category) && SameText(cmd, get_tkn(ap->Name, _T("Action")))) {
							bp->Action = ap;
							break;
						}
					}
				}

				bp->OnClick    = ToolBtnClick;
				bp->ImageIndex = add_IconImage(itm_buf[2], i_lst);
				bp->Caption    = get_tkn(itm_buf[0], ';');
				bp->Hint	   = get_tkn_r(itm_buf[0], ';');
				if (USAME_TS(bp->Hint, "*") && is_OneNrmCmd(cmd)) bp->Hint = get_CmdDesc(cmd, true);
				bp->Style	   = (bp->Caption.IsEmpty() && bp->ImageIndex!=-1)? tbsButton : tbsTextButton;
			}
			//ツールバーに追加
			bp->Parent = tp;
		}
	}
	set_RedrawOn(tp);

	//ドライブボタンの状態更新
	if (scr_mode==SCMD_FLIST) UpdateToolDriveBtn();
}

//---------------------------------------------------------------------------
//ツールボタンの実行
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ToolBtnClick(TObject *Sender)
{
	TToolButton *bp = dynamic_cast<TToolButton *>(Sender);
	if (bp==NULL) return;

	//他の画面モードのアクセラレータキーによる誤動作防止
	if (ScrMode==SCMD_FLIST && bp->Parent!=ToolBarF) return;
	if (ScrMode==SCMD_TVIEW && bp->Parent!=ToolBarV) return;
	if (ScrMode==SCMD_IVIEW && bp->Parent!=ToolBarI && bp->Parent!=ToolBarI2) return;

	CancelKeySeq();

	TStringList *lst = GetCurBtnList();
	int tag = bp->Tag;
	if (lst && tag>=0 && tag<lst->Count) {
		UnicodeString cmd = get_csv_item(lst->Strings[tag], 1);
		if (contains_wd_i(get_CmdStr(cmd), _T("ExPopupMenu|PopupMainMenu|PopupTab|RegDirPopup"))) {
			ButtonPos = bp->ClientToScreen(Point(0, bp->Height));
			ActionOptStr = "ButtonPos";
		}
		else {
			ActionOptStr = "MousePos";
		}

		if (!ExeAliasOrCommands(cmd)) SetActionAbort(GlobalErrMsg);
	}
}

//---------------------------------------------------------------------------
//ファンクションキーボタンの初期化
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::InitFKeyBtn()
{
	TToolBar *tp = FKeyBar;
	int bw = (tp->ClientWidth - 24) / 12;
	UnicodeString kid = (ScrMode==SCMD_TVIEW)? "V" : (ScrMode==SCMD_IVIEW)? "I" : "F";

	set_RedrawOff(tp);
	{
		//一旦破棄
		while (tp->ButtonCount>0) delete tp->Buttons[0];

		//更新
		tp->Canvas->Font->Assign(ToolBarFont);
		for (int i=11; i>=0; i--) {
			TToolButton *bp = new TToolButton(this);
			bp->Style		= tbsButton;
			bp->AutoSize	= false;
			bp->Caption 	= fit_str(UnicodeString().sprintf(_T("%u:"), i + 1), tp->Canvas, bw - 12, true);
			bp->OnClick 	= FKeyBtnClick;
			bp->OnMouseUp	= FKeyBtnMouseUp;
			bp->Parent		= tp;
			bp->Tag 		= i;

			//セパレータ
			if (i==8 || i==4) {
				TToolButton *bp = new TToolButton(this);
				bp->Style	= tbsSeparator;
				bp->Width	= 8;
				bp->Parent	= tp;
				bp->Tag 	= -1;
			}
		}
	}
	set_RedrawOn(tp);
}
//---------------------------------------------------------------------------
//ファンクションキーボタンの実行
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::FKeyBtnClick(TObject *Sender)
{
	TToolButton *bp = (TToolButton *)Sender;
	UnicodeString cmds = bp->Hint;

	if (USAME_TS(cmds, "Help")) {
		int idx = 4;
		if (FileListBox[CurListTag]->Focused())
			idx = (CurStt->is_Work? 60 : CurStt->is_IncSea? 50 : 4);
		else if (ScrMode==SCMD_TVIEW)
			idx = TxtViewer->isIncSea? 50 : 6;
		else if (ScrMode==SCMD_IVIEW)
			idx = 7;
		HtmlHelpContext(idx);
	}
	else {
		if (StartsText("ExeCommands_", cmds)) cmds = exclude_quot(get_PrmStr(cmds));
		ActionOptStr = "MousePos";
		if (!ExeAliasOrCommands(cmds)) SetActionAbort(GlobalErrMsg);
	}
}

//---------------------------------------------------------------------------
//ファンクションキーボタンの更新
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::UpdateFKeyBtn(TShiftState shift)
{
	if (!Initialized || UnInitializing) return;

	TToolBar *tp = FKeyBar;
	if (!tp->Visible) return;

	int bw = (tp->ClientWidth - 16) / 12;	//(幅 - セパレータ*2) / 12

	bool is_extv = Screen->ActiveForm->ClassNameIs("TExTxtViewer");
	UnicodeString kid = (ScrMode==SCMD_TVIEW || is_extv)? "V:" :
						(ScrMode==SCMD_IVIEW)? "I:" :
						(ScrMode==SCMD_FLIST)? ((FileListBox[0]->Focused() || FileListBox[1]->Focused())? "F:" :
																				   LogListBox->Focused()? "L:" : "")
											 : "";
	if (!kid.IsEmpty()) kid += get_ShiftStr(shift);
	tp->Canvas->Font->Assign(ToolBarFont);

	for (int i=0; i<tp->ButtonCount; i++) {
		TToolButton *bp = tp->Buttons[i];
		int idx = bp->Tag;	if (idx==-1) continue;

		UnicodeString key, cmd, lbl;
		if (!kid.IsEmpty()) {
			key.sprintf(_T("%sF%u"), kid.c_str(), idx + 1);
			cmd = KeyFuncList->Values[key];
			lbl = FKeyLabelList->Values[key];
		}

		//表示名
		UnicodeString s;
		if (!lbl.IsEmpty())
			s.sprintf(_T("%u:%s"), idx + 1, lbl.c_str());
		else if (idx==0 && shift.Empty() && cmd.IsEmpty())
			s = "1:Help";
		else
			s.sprintf(_T("%u:%s"), idx + 1, get_CmdStr(cmd).c_str());
		bp->Caption = fit_str(s, tp->Canvas, bw - 12, true);	//***

		//コマンド
		if (idx==0 && shift.Empty() && cmd.IsEmpty()) {
			cmd = "Help";
			bp->Enabled = true;
		}
		else {
			if (is_extv) {
				TExTxtViewer *ex_tv = dynamic_cast<TExTxtViewer *>(Screen->ActiveForm);
				bp->Enabled = ex_tv? ex_tv->ExViewer->IsCmdAvailable(cmd) : false;
			}
			else if (ScrMode==SCMD_TVIEW) {
				bp->Enabled = !cmd.IsEmpty() && !TxtViewer->IsCmdInhibited(cmd);
			}
			else {
				bp->Enabled = !cmd.IsEmpty();
			}
		}

		//Hint でコマンドを渡して処理
		bp->Hint = cmd;
	}

	tp->Invalidate();
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::UpdateFKeyBtn()
{
	if (!Initialized || UnInitializing) return;

	FKeyBar->Visible = (ScrMode==SCMD_GREP || IS_FullScr())? false : ShowFKeyBar;

	if (FKeyBar->Visible) UpdateFKeyBtn(get_Shift());
}

//---------------------------------------------------------------------------
//ファンクションキー表示名の変更
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::FK_RenameActionExecute(TObject *Sender)
{
	int idx = ActionParam.ToIntDef(-1);
	if (idx>=0) {
		UnicodeString kstr = (ScrMode==SCMD_TVIEW)? "V:" :
							 (ScrMode==SCMD_IVIEW)? "I:" :
							 (ScrMode==SCMD_FLIST)? ((FileListBox[0]->Focused() || FileListBox[1]->Focused())? "F:" :
																					    LogListBox->Focused()? "L:" : "")
												  : "";
		if (!kstr.IsEmpty()) {
			kstr.cat_sprintf(_T("%sF%u"), get_ShiftStr(LastShift).c_str(), idx + 1);
			UnicodeString tit = "ファンクションキー表示名の変更";
			InputExDlg->Caption = tit.cat_sprintf(_T(" - %s"), KeyFuncList->Values[kstr].c_str());
			InputExDlg->IpuntExMode = INPEX_FUNCTIONKEY;
			InputExDlg->InputEdit->EditLabel->Caption
				= UnicodeString().sprintf(_T("[%s]"), get_tkn_r(kstr, ":").c_str());
			InputExDlg->InputEdit->Text = FKeyLabelList->Values[kstr];
			if (InputExDlg->ShowModal()==mrOk) FKeyLabelList->Values[kstr] = InputExDlg->InputEdit->Text;
			UpdateFKeyBtn();
		}
	}
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::FKeyBtnMouseUp(TObject *Sender, TMouseButton Button,
	TShiftState Shift, int X, int Y)
{
	if (Button==mbRight) {
		ActionParam = ((TComponent *)Sender)->Tag;
		FK_RenameAction->Execute();
	}
}

//---------------------------------------------------------------------------
//ツールボタン(ChangeDrive)の状態更新
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::UpdateToolDriveBtn()
{
	if (ToolBarF->Visible) {
		set_RedrawOff(ToolBarF);
		{
			for (int i=0; i<ToolBarF->ButtonCount; i++) {
				TStringDynArray itm_buf = get_csv_array(ToolBtnList->Strings[i], 3, true);
				UnicodeString dstr = itm_buf[1];
				if (remove_top_text(dstr, _T("ChangeDrive_"))) {
					TToolButton *bp = ToolBarF->Buttons[i];
					bp->Visible = false;
					bool found  = false;
					for (int j=0; j<DriveInfoList->Count && !found; j++) {
						drive_info *dp = (drive_info *)DriveInfoList->Objects[j];
						found = dp->accessible && StartsText(dstr, dp->drive_str);
					}
					bp->Visible = found;
					bp->Enabled = found;
				}
			}
		}
		set_RedrawOn(ToolBarF);
	}
}

//---------------------------------------------------------------------------
//画面モードの切換
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::SetScrMode(
	int scr_mode,	//モード (default = SCMD_FLIST)
	int tag)
{
	bool cls_grep = (ScrMode==SCMD_GREP && scr_mode==SCMD_FLIST);

	CloseIME(Handle);

	TxtViewer->CloseAuxForm();
	if (LoupeForm->Visible && LoupeForm->Floating) LoupeForm->Close();
	if (HistForm->Visible && HistForm->Floating)   HistForm->Close();
	if (ColorPicker->Visible) ColorPicker->Close();

	ScrMode = scr_mode;
	UserModule->ScrMode = ScrMode;
	BlinkTimer->Enabled = false;

	//メニュー表示の切換
	FindMenu->Visible = ScrMode==SCMD_FLIST || ScrMode==SCMD_TVIEW;
	ToolMenu->Visible = ScrMode==SCMD_FLIST;

	//ツールバーの切替
	for (int i=0; i<ToolBarF->ButtonCount;  i++) ToolBarF->Buttons[i]->Enabled  = (ScrMode==SCMD_FLIST);
	for (int i=0; i<ToolBarV->ButtonCount;  i++) ToolBarV->Buttons[i]->Enabled  = (ScrMode==SCMD_TVIEW);
	for (int i=0; i<ToolBarI->ButtonCount;  i++) ToolBarI->Buttons[i]->Enabled  = (ScrMode==SCMD_IVIEW);
	for (int i=0; i<ToolBarI2->ButtonCount; i++) ToolBarI2->Buttons[i]->Enabled = (ScrMode==SCMD_IVIEW);
	if (ScrMode==SCMD_FLIST) UpdateToolDriveBtn();

	//ファンクションキーバーの切換
	UpdateFKeyBtn();

	switch (ScrMode) {
	case SCMD_TVIEW:	//テキストビュアー
		TxtViewPanel->Visible = true;
		MainPanel->Visible	  = false;
		GrepPanel->Visible	  = false;
		ImgViewPanel->Visible = false;
		break;

	case SCMD_IVIEW:	//イメージビュアー
		ImgViewPanel->Visible = true;
		MainPanel->Visible	  = false;
		GrepPanel->Visible	  = false;
		TxtViewPanel->Visible = false;
		if (LoupeDockPanel->DockSite) LoupeDockPanel->DockManager->ResetBounds(true);
		if (HistDockPanel->DockSite)  HistDockPanel->DockManager->ResetBounds(true);
		BlinkTimer->Enabled   = WarnHighlight;
		break;

	case SCMD_GREP:		//文字列検索(GREP)
		GrepPanel->Visible	  = true;
		MainPanel->Visible	  = false;
		TxtViewPanel->Visible = false;
		ImgViewPanel->Visible = false;
		GrepSttSplitterMoved(GrepSttSplitter);
		break;

	default:			//ファイルリスト
		HotPosImage->Visible  = false;
		MainPanel->Visible	  = true;
		GrepPanel->Visible	  = false;
		TxtViewPanel->Visible = false;
		ImgViewPanel->Visible = false;
		Application->ProcessMessages();
		if (!CurStt->is_Find && !CurStt->is_FTP) ReloadList(tag); else RepaintList();
		FileListBox[CurListTag]->SetFocus();
	}

	CancelKeySeq();
	Application->ProcessMessages();

	//イベント : 文字列検索(GREP)を閉じた直後
	if (cls_grep) ExeEventCommand(OnGrepClosed);
}

//---------------------------------------------------------------------------
//カーソル位置のファイル名文字列を取得
//  アーカイブ内のファイルは一時解凍
//！失敗したら EAbort 例外
//---------------------------------------------------------------------------
UnicodeString __fastcall TNyanFiForm::GetCurFileStr(
	bool inc_dir)	//ディレクトリも含める (default = false)
{
	file_rec *fp = GetCurFrecPtr();
	if (!fp || (!inc_dir && fp->is_dir)) return EmptyStr;

	UnicodeString f_str;
	if (fp->is_virtual) {
		if (fp->is_dir)		 UserAbort(USTR_CantOperate);
		if (!SetTmpFile(fp)) UserAbort(USTR_FaildTmpUnpack);
		f_str = fp->tmp_name;
	}
	else {
		f_str = fp->f_name;
	}

	return add_quot_if_spc(f_str);
}
//---------------------------------------------------------------------------
UnicodeString __fastcall TNyanFiForm::GetOppFileStr(bool inc_dir)
{
	file_rec *fp = GetOppFrecPtr();
	if (!fp || (!inc_dir && fp->is_dir)) return EmptyStr;

	UnicodeString f_str;
	if (fp->is_virtual) {
		if (!SetTmpFile(fp)) UserAbort(USTR_FaildTmpUnpack);
		f_str = fp->tmp_name;
	}
	else {
		f_str = fp->f_name;
	}

	return add_quot_if_spc(f_str);
}

//---------------------------------------------------------------------------
//選択中(無ければカーソル位置)のパス無し項目名リストを取得
//---------------------------------------------------------------------------
int __fastcall TNyanFiForm:: GetCurObjList(TStringList *flst)
{
	GetSelList(GetCurList(), flst, false);

	if (flst->Count==0) {
		file_rec *cfp = GetCurFrecPtr(true);
		if (cfp) flst->Add(cfp->n_name);
	}

	return flst->Count;
}

//---------------------------------------------------------------------------
//ファイル、ディレクトリ・マスクを分離
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::SplitMasksFD(
	UnicodeString masks,
	TStringList *f_msk,		//[o] ファイルのマスクリスト
	TStringList *d_msk,		//[o] ディレクトリのマスクリスト
	bool sel_sw)			//true = MaskSelect	(default = false)
{
	TStringDynArray mask_lst = split_strings_semicolon(masks);
	for (int i=0; i<mask_lst.Length; i++) {
		UnicodeString mask = mask_lst[i];
		if (mask.IsEmpty()) continue;
		if (remove_end_s(mask, '\\')) d_msk->Add(mask); else f_msk->Add(mask);
	}

	//除外指定以外のマスクがない場合 * を追加
	bool flag = false;
	for (int i=0; i<d_msk->Count && !flag; i++) flag = !StartsStr('!', d_msk->Strings[i]);
	if (!flag && (!sel_sw || (sel_sw && d_msk->Count>0))) d_msk->Add("*");

	flag = false;
	for (int i=0; i<f_msk->Count && !flag; i++) flag = !StartsStr('!', f_msk->Strings[i]);
	if (!flag && (!sel_sw || (sel_sw && f_msk->Count>0))) f_msk->Add("*");
}

//---------------------------------------------------------------------------
//マスクを用いてファイルを選択
//---------------------------------------------------------------------------
int __fastcall TNyanFiForm::SelectMask(TStringList *lst, UnicodeString masks)
{
	split_dsc(masks);
	std::unique_ptr<TStringList> f_msk(new TStringList());
	std::unique_ptr<TStringList> d_msk(new TStringList());
	SplitMasksFD(masks, f_msk.get(), d_msk.get(), true);

	int s_cnt = 0;
	int s_idx = -1;

	for (int i=0; i<lst->Count; i++) {
		file_rec *fp = (file_rec*)lst->Objects[i];
		if (!is_selectable(fp)) continue;
		fp->selected = false;

		bool match = false, excld = false;
		TStringList *m_lst = fp->is_dir? d_msk.get() : f_msk.get();
		for (int j=0; j<m_lst->Count; j++) {
			UnicodeString mask = m_lst->Strings[j];
			if (remove_top_s(mask, '!')) {
				 if (str_match(mask, fp->n_name)) excld = true;
			}
			else if (USAME_TS(mask, "*") || str_match(mask, fp->n_name)) match = true;
		}

		if (match && !excld) {
			fp->selected = true;  s_cnt++;
			if (s_idx==-1) s_idx = i;
		}
	}

	switch (ScrMode) {
	case SCMD_FLIST:
		if (s_idx!=-1) FileListBox[CurListTag]->ItemIndex = s_idx;
		RepaintList(CurListTag);
		break;
	case SCMD_IVIEW:
		if (s_idx!=-1) set_GridIndex(ThumbnailGrid, s_idx, lst->Count);
		break;
	}

	return s_cnt;
}

//---------------------------------------------------------------------------
//ファイルリスト項目の表示幅を設定
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::SetFlItemWidth(TStringList *lst, int tag)
{
	TListBox *lp = FileListBox[tag];
	TCanvas  *cv = lp->Canvas;
	cv->Font->Assign(lp->Font);
	bool is_irreg = IsIrregularFont(cv->Font);

	flist_stt *lst_stt = &ListStt[tag];
	lst_stt->lwd_half  = get_TextWidth(cv, "X", is_irreg);

	//拡張子
	if (lst_stt->is_Find && lst_stt->find_DICON) {
		lst_stt->lwd_fext_max = lst_stt->lwd_fext = 0;
	}
	else {
		lst_stt->lwd_fext_max = get_TextWidth(cv, ".WWWWWWWWWWWW", is_irreg);
		lst_stt->lwd_fext	  = get_TextWidth(cv, ".WWW", is_irreg);	//最小幅
		std::unique_ptr<TStringList> x_lst(new TStringList());
		for (int i=0; i<lst->Count; i++) {
			UnicodeString fext = ((file_rec*)lst->Objects[i])->f_ext;
			if (x_lst->IndexOf(fext)==-1) x_lst->Add(fext);
		}
		for (int i=0; i<x_lst->Count; i++) {
			lst_stt->lwd_fext = std::max(lst_stt->lwd_fext, get_TextWidth(cv, x_lst->Strings[i], is_irreg));
		}
		lst_stt->lwd_fext = std::min(lst_stt->lwd_fext, lst_stt->lwd_fext_max);	//最大幅
		if (is_irreg) lst_stt->lwd_fext += lst_stt->lwd_fext/lst_stt->lwd_half;
	}

	//サイズ
	UnicodeString lbuf;
	if (ShowByteSize) {
		lbuf = "9,999,999,999 ";
	}
	else if (SizeFormatMode>0) {
		if (SizeDecDigits>0)
			lbuf.sprintf(_T("9999.%s MB "), StringOfChar(_T('9'), SizeDecDigits).c_str());
		else
			lbuf = "9999 MB ";
	}
	else {
		lbuf = "9999.999 MB ";
	}
	lst_stt->lwd_size = get_TextWidth(cv, lbuf, is_irreg);

	//タイムスタンプ
	lst_stt->lwd_time = get_TextWidth(cv, FormatDateTime(TimeStampFmt, Now()), is_irreg);

	int x_right = (tag==1)? R_Panel->ClientWidth : L_Panel->ClientWidth;
	if (!HideScrBar) {
		if (ScrBarStyle>0)
			x_right -= FlScrPanel[tag]->KnobWidth;
		else
			x_right -= ::GetSystemMetrics(SM_CXVSCROLL);
	}

	//場所(検索)
	lst_stt->lwd_path = (lst_stt->find_TAG && FindTagsColumn)? FindTagsWidth : FindPathWidth;
	if (tag==0) {
		if (L_Panel->ClientWidth > R_Panel->ClientWidth)
			lst_stt->lwd_path += (L_Panel->ClientWidth - R_Panel->ClientWidth) / 4;
	}
	else {
		if (L_Panel->ClientWidth < R_Panel->ClientWidth)
			lst_stt->lwd_path += (R_Panel->ClientWidth - L_Panel->ClientWidth) / 4;
	}

	int w_file = lst_stt->lwd_half * 8;
	int x_base = ScaledInt((IconMode>0)? 20 : 8);
	int x_path = x_right - ((lst_stt->is_Find && FindPathColumn)? lst_stt->lwd_path + lst_stt->lwd_half : 0);
	int x_time = x_path - lst_stt->lwd_time - lst_stt->lwd_half;
	int x_size = x_time - lst_stt->lwd_size;
	int x_fext = x_size - lst_stt->lwd_fext - lst_stt->lwd_half;
	int w_fnam = std::max(x_size - x_base - lst_stt->lwd_half, w_file + lst_stt->lwd_fext);
	if ((x_base + w_fnam > x_size) || (x_base + w_file > x_fext)) {
		x_size = x_base + w_fnam + lst_stt->lwd_half;
		x_fext = x_size - lst_stt->lwd_fext - lst_stt->lwd_half;
		x_time = x_size + lst_stt->lwd_size;
		x_path = x_time + lst_stt->lwd_time + lst_stt->lwd_half;
	}

	lst_stt->lxp_right = x_right;
	lst_stt->lxp_fext  = x_fext;
	lst_stt->lxp_size  = x_size;
	lst_stt->lxp_time  = x_time;
	lst_stt->lxp_path  = x_path;

	SetListHeader(tag);
}

//---------------------------------------------------------------------------
//カレント側のファイルリスト状態を更新
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::SetCurStt(int tag, bool redraw)
{
	CurListTag = tag;
	OppListTag = (CurListTag==0)? 1 : 0;
	CurStt	   = &ListStt[CurListTag];
	OppStt	   = &ListStt[OppListTag];

	if (!StartsStr("\\\\", CurPath[CurListTag])) SetCurrentDir(CurPath[CurListTag]);	//***

	CurPathName = (ScrMode==SCMD_TVIEW)? ExtractFilePath(TxtViewer->FileName) :
				  (ScrMode==SCMD_IVIEW)? ExtractFilePath(ViewFileName) : CurPath[CurListTag];

	UserModule->CurPathName = CurPathName;

	SetCurTab(redraw);

	//タイトルバー
	UnicodeString tmp;
	if (IsAdmin) tmp = "管理者: ";
	if (PathInTitleBar) {
		UnicodeString pnam;
		try {
			pnam = (CurStt->is_FTP && IdFTP1->Connected())?
					yen_to_slash(IdFTP1->Host + CurFTPPath) : yen_to_delimiter(CurPathName);
		}
		catch (...) {
			pnam = yen_to_delimiter(CurPathName);
		}
		tmp.cat_sprintf(_T("%s - "), pnam.c_str());
	}
	Caption = tmp + Application->Title;
}

//---------------------------------------------------------------------------
//パスマスクを呼び出しキーで設定
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::SetCurPathMask(UnicodeString kstr)
{
	remove_top_s(kstr, '&');
	kstr = kstr.SubString(1, 1);

	UnicodeString lbuf;
	for (int i=0; i<PathMaskList->Count; i++) {
		TStringDynArray itm_buf = get_csv_array(PathMaskList->Strings[i], 3, true);
		if (SameText(itm_buf[0], kstr)) {
			lbuf = PathMaskList->Strings[i];
			if (USAME_TS(itm_buf[2], "*")) lbuf = EmptyStr;
			break;
		}
	}

	TListBox *lp = FileListBox[CurListTag];
	set_RedrawOff(lp);
	{
		UnicodeString fnam = GetCurFileName();
		PathMask[CurListTag] = lbuf;
		RefreshCurPath(fnam);
	}
	set_RedrawOn(lp);
}

//---------------------------------------------------------------------------
//リストのディレクトリ文字列を取得
//---------------------------------------------------------------------------
UnicodeString __fastcall TNyanFiForm::GetCurPathStr(
	int tag)	//default = CurListTag;
{
	return (tag>=0 && tag<MAX_FILELIST)? IncludeTrailingPathDelimiter(CurPath[tag]) : EmptyStr;
}
//---------------------------------------------------------------------------
UnicodeString __fastcall TNyanFiForm::GetSrcPathStr()
{
	return (CurStt->is_Work? ExtractFileName(WorkListName) : CurPath[CurListTag]);
}

//---------------------------------------------------------------------------
//インデックス位置の file_rec ポインタを取得
//---------------------------------------------------------------------------
file_rec* __fastcall TNyanFiForm::GetFrecPtr(TListBox *lp, TStringList *lst)
{
	int idx = lp->ItemIndex;
	return (idx!=-1 && idx<lst->Count)? (file_rec*)lst->Objects[idx] : NULL;
}

//---------------------------------------------------------------------------
//カーソル位置の file_rec ポインタを取得
//---------------------------------------------------------------------------
file_rec * __fastcall TNyanFiForm::GetCurFrecPtr(
	bool only_filer,	//ファイラーのみ対象	(default = false)
	bool inc_up)		//ファイラーで .. を含	(default = false);
{
	file_rec *fp = NULL;
	//テキストビュアー
	if (!only_filer && ScrMode==SCMD_TVIEW) {
		fp = TxtViewer->FileRec;
	}
	//イメージビュアー
	else if (!only_filer && ScrMode==SCMD_IVIEW) {
		int idx = GetCurIndex();
		if (idx!=-1) fp = (file_rec*)ViewFileList->Objects[idx];
	}
	//ファイラー
	else {
		fp = GetFrecPtr(FileListBox[CurListTag], GetCurList(true));
		if (!inc_up && !is_selectable(fp)) fp = NULL;
	}
	return fp;
}
//---------------------------------------------------------------------------
//反対パスのカーソル位置の file_rec ポインタを取得
//---------------------------------------------------------------------------
file_rec * __fastcall TNyanFiForm::GetOppFrecPtr()
{
	file_rec *fp = GetFrecPtr(FileListBox[OppListTag], GetOppList());
	if (!is_selectable(fp)) fp = NULL;
	return fp;
}

//---------------------------------------------------------------------------
//カーソル位置のファイル名を取得
//---------------------------------------------------------------------------
UnicodeString __fastcall TNyanFiForm::GetCurFileName()
{
	file_rec *cfp = GetCurFrecPtr();
	return (cfp && !cfp->is_dummy)? cfp->f_name : EmptyStr;
}

//---------------------------------------------------------------------------
//file_rec ポインタの該当するファイルリスト位置にカーソルを移動
//---------------------------------------------------------------------------
int __fastcall TNyanFiForm::SetCurFrecPtr(file_rec *fp)
{
	if (!fp) return -1;

	TStringList *lst = GetCurList(true);
	TListBox *lp = FileListBox[CurListTag];
	int idx = -1;
	for (int i=0; i<lst->Count; i++) {
		if ((file_rec*)lst->Objects[i] == fp) {
			if (i<lp->Count) lp->ItemIndex = idx =i;
			break;
		}
	}
	return idx;
}

//---------------------------------------------------------------------------
//現在のリストのカール位置を取得
//---------------------------------------------------------------------------
int __fastcall TNyanFiForm::GetCurIndex()
{
	return (ScrMode==SCMD_FLIST)? FileListBox[CurListTag]->ItemIndex :
		   (ScrMode==SCMD_IVIEW)? (ThumbnailGrid->Visible ? get_GridIndex(ThumbnailGrid, ViewFileList->Count)
														  : ViewFileList->IndexOf(ViewFileName))
								: -1;
}

//---------------------------------------------------------------------------
//指定したファイルリスト位置にカーソルを移動
//---------------------------------------------------------------------------
bool __fastcall TNyanFiForm::SetCurIndex(int idx)
{
	bool res = false;

	TStringList *lst = GetCurList();
	if (idx>=0 && idx<lst->Count) {
		switch (ScrMode) {
		case SCMD_FLIST:
			res = (IndexOfFileList(((file_rec*)lst->Objects[idx])->f_name) != -1);
			SetFileInf();
			break;
		case SCMD_IVIEW:
			set_GridIndex(ThumbnailGrid, idx, lst->Count);
			if (SetCurFrecPtr(GetFrecPtrFromViewList(idx)) != -1)
				res = OpenImgViewer((file_rec*)lst->Objects[idx]);
			break;
		}
	}

	return res;
}

//---------------------------------------------------------------------------
//ファイルリストから代表する file_rec ポインタを取得
// 選択中なら最初の選択項目、そうでなければカーソル位置
//---------------------------------------------------------------------------
file_rec * __fastcall TNyanFiForm::GetCurRepFrecPtr()
{
	TStringList *lst = GetCurList();
	file_rec *cfp = GetCurFrecPtr();
	file_rec *rfp = NULL;
	if (GetSelCount(lst)>0) {
		for (int i=0; i<lst->Count; i++) {
			file_rec *fp = (file_rec*)lst->Objects[i];
			if (fp->selected) { rfp = fp; break; }
		}
	}
	else if (cfp && !cfp->is_dummy) rfp = cfp;

	return rfp;
}

//---------------------------------------------------------------------------
//カレントパスから ViewFileList の Index or ファイル名とマッチする fp を探す
//---------------------------------------------------------------------------
file_rec * __fastcall TNyanFiForm::GetFrecPtrFromViewList(int idx, UnicodeString fnam)
{
	if (idx==-1) idx = ViewFileList->IndexOf(fnam);
	if (idx==-1 || idx>=ViewFileList->Count) return NULL;
	file_rec *vfp = (file_rec*)ViewFileList->Objects[idx];	if (!vfp) return NULL;

	file_rec *cfp = NULL;
	TStringList *lst = GetCurList(true);
	for (int i=0; !cfp && i<lst->Count; i++) {
		file_rec *fp = (file_rec*)lst->Objects[i];
		if (fp->is_dir) continue;
		if (SameText(vfp->f_name, fp->f_name)) { cfp = fp; break; }
	}
	return cfp;
}

//---------------------------------------------------------------------------
//現在の対象に削除制限項目が含まれていないかチェック
//  戻り値: true = 削除制限/ false = 削除許可
//---------------------------------------------------------------------------
bool __fastcall TNyanFiForm::IncProtectItem()
{
	bool ret = false;

	if (ProtectDirList->Count>0) {
		TStringList *lst = GetCurList();
		bool lst_sel = ListSelected(lst);
		int  cur_idx = FileListBox[CurListTag]->ItemIndex;
		for (int i=0; i<lst->Count && !ret; i++) {
			file_rec *fp = (file_rec*)lst->Objects[i];
			if (fp->is_up) continue;
			if ((fp->selected || (!lst_sel && i==cur_idx)) && !fp->is_virtual) {
				if (fp->is_dir)
					ret = is_ProtectDir(fp->f_name);
				else if (ProtectFile)
					ret = is_ProtectDir(fp->p_name);
			}
		}
	}

	if (ret) {
		UnicodeString msg = "対象に削除制限項目が含まれています。";
		if (ProtectDirMode==1) {
			msg += "\n制限を無視して削除しますか?";
			unsigned int flag = (SureCancel? MB_YESNOCANCEL : MB_YESNO) | MB_ICONQUESTION | MB_DEFBUTTON2;
			ret = (Application->MessageBox(msg.c_str(), _T("確認"), flag)!=IDYES);
		}
		else {
			msgbox_WARN(msg);
		}
	}

	return ret;
}

//---------------------------------------------------------------------------
//現在の対象にディレクトリが含まれていないかチェック
//---------------------------------------------------------------------------
bool __fastcall TNyanFiForm::TestCurIncDir(
	bool only_cur)		//カーソル位置のみ	(default = false)
{
	bool ret = false;
	TStringList *lst = GetCurList();
	if (!only_cur && GetSelCount(lst)>0) {
		for (int i=0; i<lst->Count; i++) {
			file_rec *fp = (file_rec*)lst->Objects[i];
			if (fp->selected && fp->is_dir) { ret = true; break; }
		}
	}
	else {
		file_rec *cfp = GetCurFrecPtr();
		ret = (cfp && cfp->is_dir);
	}
	return ret;
}
//---------------------------------------------------------------------------
//現在の対象にディレクトリ以外が含まれていないかチェック
//---------------------------------------------------------------------------
bool __fastcall TNyanFiForm::TestCurIncNotDir()
{
	bool ret = false;
	TStringList *lst = GetCurList();
	if (GetSelCount(lst)>0) {
		for (int i=0; i<lst->Count; i++) {
			file_rec *fp = (file_rec*)lst->Objects[i];
			if (fp->selected && !fp->is_dir) { ret = true; break; }
		}
	}
	else {
		file_rec *cfp = GetCurFrecPtr();
		ret = (cfp && !cfp->is_dir);
	}
	return ret;
}
//---------------------------------------------------------------------------
//結果リストの対象に仮想項目が含まれていないかチェック
//---------------------------------------------------------------------------
bool __fastcall TNyanFiForm::TestCurIncFindVirtual()
{
	bool ret = false;
	if (CurStt->is_Find) {
		TStringList *lst = GetCurList();
		if (GetSelCount(lst)>0) {
			for (int i=0; i<lst->Count; i++) {
				file_rec *fp = (file_rec*)lst->Objects[i];
				if (fp->selected && fp->is_virtual) { ret = true; break; }
			}
		}
		else {
			file_rec *cfp = GetCurFrecPtr();
			ret = (cfp && cfp->is_virtual);
		}
	}
	return ret;
}
//---------------------------------------------------------------------------
//変換や抽出が不可の場合に UserAbort を送出
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::NotConvertAbort()
{
	if (!IsOppFList()) 						UserAbort(USTR_CantOperate);
	if (CurStt->is_Arc || CurStt->is_ADS || CurStt->is_FTP)
											UserAbort(USTR_OpeNotSuported);
	if (TestCurIncDir())					UserAbort(USTR_IncludeDir);
	if (TestCurIncFindVirtual())			UserAbort(USTR_OpeNotSuported);
}

//---------------------------------------------------------------------------
//ファイル情報(FL/IV)の描画
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::InfListBoxDrawItem(TWinControl *Control, int Index, TRect &Rect,
		TOwnerDrawState State)
{
	TListBox *lp = (TListBox*)Control;
	draw_InfListBox(lp, Rect, Index, State);
	//カーソル
	draw_ListCursor(lp, Rect, Index, State);
}
//---------------------------------------------------------------------------
//テキストプレビューの描画(仮想)
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::TxtPrvListBoxDrawItem(TWinControl *Control, int Index,
		TRect &Rect, TOwnerDrawState State)
{
	TListBox *lp = (TListBox*)Control;
	TCanvas  *cv = lp->Canvas;
	cv->Font->Assign(TxtPrvFont);
	TRect     rc = Rect;

	//行番号
	bool is_cnt = (Index==PrvTxtInfLn);
	if (TxtPrvShowLineNo) LineNoOut(cv, rc, is_cnt? 0 : Index + 1);

	//テキスト
	bool is_sel = State.Contains(odSelected) && lp->Focused();
	cv->Brush->Color = is_sel? col_selItem : col_bgTxtPrv;
	cv->FillRect(rc);

	if (is_cnt) {
		RuledLnTextOut("……… 続く ………", cv, rc, col_LineNo, lp->TabWidth);
	}
	else {
		PrvTextOut(lp, Index, cv, rc,
			((is_sel && col_fgSelItem!=col_None)? col_fgSelItem : col_fgTxtPrv),
			lp->TabWidth, NULL, TxtPrvFile);
	}

	//カーソル
	bool is_focused = State.Contains(odFocused);
	if (lp->ItemIndex==Index) {
		int lw = is_focused? std::max(CursorWidth, 1) : 0;
		if (lw>0) {
			int yp = Rect.Bottom - lw;
			draw_Line(cv, Rect.Left, yp, Rect.Right, yp, lw, col_Cursor, psSolid);
		}
	}
	if (is_focused) cv->DrawFocusRect(Rect);
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::TxtPrvListBoxData(TWinControl *Control, int Index, UnicodeString &Data)
{
	Data = (Index>=0 && Index<TxtPrvBuff->Count)? TxtPrvBuff->Strings[Index] : EmptyStr;
}
//---------------------------------------------------------------------------
//末尾プレビューの描画(仮想)
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::TxtTailListBoxDrawItem(TWinControl *Control, int Index,
	TRect &Rect, TOwnerDrawState State)
{
	TListBox *lp = (TListBox*)Control;
	TCanvas  *cv = lp->Canvas;
	TRect     rc = Rect;

	if (TxtPrvShowLineNo) {
		int lcnt = TxtPrvBuff->Count;
		//最大行数以内
		if (PrvTxtInfLn==0 || lcnt<=PrvTxtInfLn) {
			LineNoOut(cv, rc, ((lcnt>PrvTxtTailLn)? lcnt - PrvTxtTailLn : 0) + Index + 1);
		}
		//最大行数超え
		else {
			int lno = TxtTailBuff->Count - Index - 1;
			UnicodeString ln_str;
			if (lno==0) ln_str = "END"; else ln_str.sprintf(_T("-%d"), lno);
			LineNoOut(cv, rc, ln_str);
		}
	}

	bool is_sel = State.Contains(odSelected) && lp->Focused();
	cv->Brush->Color = is_sel? col_selItem : col_bgTxtPrv;
	cv->FillRect(rc);

	PrvTextOut(lp, Index, cv, rc,
		((is_sel && col_fgSelItem!=col_None)? col_fgSelItem : col_fgTxtPrv),
		lp->TabWidth, NULL, TxtPrvFile);

	//カーソル
	draw_ListCursor(lp, Rect, Index, State);
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::TxtTailListBoxData(TWinControl *Control, int Index, UnicodeString &Data)
{
	Data = (Index>=0 && Index<TxtTailBuff->Count)? TxtTailBuff->Strings[Index] : EmptyStr;
}

//---------------------------------------------------------------------------
//ログの描画
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::LogListBoxDrawItem(TWinControl *Control, int Index, TRect &Rect,
		TOwnerDrawState State)
{
	TListBox *lp = (TListBox*)Control;
	TCanvas *cv = lp->Canvas;
	cv->Brush->Color = (State.Contains(odSelected) && lp->Focused())? col_selItem : col_bgLog;
	cv->FillRect(Rect);

	cv->Font->Assign(LogFont);
	cv->Font->Color = (lp->Focused() && is_SelFgCol(State))? col_fgSelItem : col_fgLog;
	bool is_irreg = IsIrregularFont(cv->Font);
	int xp = Rect.Left + Scaled2;
	int yp = Rect.Top  + Scaled1;

	UnicodeString lbuf = lp->Items->Strings[Index];
	if (!DirDelimiter.IsEmpty()) lbuf = ReplaceStr(lbuf, "\\", DirDelimiter);

	if (cv->Font->Color!=col_fgSelItem) {
		cv->Font->Color = get_LogColor(lbuf);
		if (remove_top_s(lbuf, " >    LOAD ")) {
			out_TextEx(cv, xp, yp, " >    LOAD ", col_None, col_None, 0, is_irreg);
			if (EndsStr("  NOT USED", lbuf)) {
				cv->Font->Color = AdjustColor(col_fgLog, 96);
			}
			else {
				UnicodeString fnam = split_tkn(lbuf, ' ');
				cv->Font->Color = get_ExtColor(get_extension(fnam), col_fgLog);
				out_TextEx(cv, xp, yp, fnam, col_None, col_None, 0, is_irreg);
				lbuf.Insert(" ", 1);
				cv->Font->Color = col_fgLog;
			}
		}
	}

	EmphasisTextOut(lbuf, EmptyStr, cv, xp, yp);

	//カーソル
	draw_ListCursor(lp, Rect, Index, State);
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::LogListBoxData(TWinControl *Control, int Index, UnicodeString &Data)
{
	Data = (Index>=0 && Index<LogBufList->Count)? LogBufList->Strings[Index] : EmptyStr;
}

//---------------------------------------------------------------------------
//作業中表示
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::SttWorkMsg(
	UnicodeString msg,		//メッセージ (EmptyStr なら復帰)
	int tag)
{
	TPanel *stt_panel = (tag==0)? L_StatPanel : R_StatPanel;
	if (!msg.IsEmpty()) {
		if (ShowSttBar) {
			StatusBar1->Panels->Items[0]->Text = msg;
			StatusBar1->Repaint();
		}
		else {
			DriveInf[tag]		 = stt_panel->Caption;
			stt_panel->Alignment = taLeftJustify;
			stt_panel->Caption	 = msg;
			stt_panel->Repaint();
		}
	}
	else {
		if (ShowSttBar) {
			SetSttBarInf();
		}
		else {
			stt_panel->Alignment = taRightJustify;
			stt_panel->Caption	 = DriveInf[tag];
		}
	}
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::SttWorkMsg(const _TCHAR *msg, int tag)
{
	SttWorkMsg(UnicodeString(msg), tag);
}

//---------------------------------------------------------------------------
//進捗状況パネル
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::BeginWorkProgress(UnicodeString tit, UnicodeString s, TControl *cp, bool can_sw)
{
	TRect rc = ProgressPanel->BoundsRect;
	if (!cp) cp = this;
	rc = cp->ClientRect.CenteredRect(rc);
	rc.SetLocation(cp->ClientToScreen(rc.Location));
	rc.SetLocation(this->ScreenToClient(rc.Location));
	ProgressPanel->BoundsRect = rc;

	ProgressPanel->Color		  = col_bgHint;
	ProgressLabel->Font->Color	  = col_fgHint;
	ProgressSubLabel->Font->Color = col_fgHint;

	ProgressLabel->Caption	  = tit;
	ProgressSubLabel->Caption = minimize_str(def_if_empty(s, _T("処理中...")), Canvas, ProgressSubLabel->Width);
	WorkProgressBar->Position = 0;

	CanDlBtn->Visible = can_sw;
	ProgressPanel->Height  = ScaledInt(can_sw? 140 : 110);
	ProgressPanel->Visible = true;
	ProgressPanel->BringToFront();
	ProgressPanel->Repaint();

	if (!can_sw) cursor_HourGlass();
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::BeginWorkProgress(const _TCHAR *tit, UnicodeString s, TControl *cp, bool can_sw)
{
	BeginWorkProgress(UnicodeString(tit), s, cp, can_sw);
}

//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::EndWorkProgress(UnicodeString tit, UnicodeString s, int wait)
{
	cursor_Default();
	if (!ProgressPanel->Visible) return;

	if (!tit.IsEmpty()) ProgressLabel->Caption = tit;
	ProgressSubLabel->Caption = def_if_empty(s, _T("終了しました"));
	WorkProgressBar->Position = WorkProgressBar->Max;
	Application->ProcessMessages();
	Sleep(wait);
	ProgressPanel->Visible = false;
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::PosWorkProgress(int idx, int cnt)
{
	if (ProgressPanel->Visible && cnt>0) {
		WorkProgressBar->Position = WorkProgressBar->Max * (1.0*(idx + 1)/cnt);
		Application->ProcessMessages();
	}
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::PosWorkProgress(__int64 idx, __int64 cnt)
{
	if (ProgressPanel->Visible && cnt>0) {
		WorkProgressBar->Position = WorkProgressBar->Max * (1.0*(idx + 1)/cnt);
		Application->ProcessMessages();
	}
}

//---------------------------------------------------------------------------
//ダウンロードの進捗状況表示
//---------------------------------------------------------------------------
TModalResult __fastcall TNyanFiForm::DownloadWorkProgress(
	UnicodeString url,	//URL
	UnicodeString fnam, //ファイル名
	TControl *cp)		//表示基準コントロール	(default = NULL)
{
	CurWorking = true;

	BeginWorkProgress(LoadUsrMsg(USTR_Download), replace_regex(url, _T("^https?://"), null_TCHAR), (cp? cp : ListPanel), true);

	TModalResult mr;
	CancelWork = false;
	if (get_OnlineFile(url, fnam, &CancelWork, WorkProgressBar)<=0) {
		WorkProgressBar->Position = WorkProgressBar->Max;
		mr = mrNo;
	}
	else {
		mr = CancelWork? mrCancel : mrOk;
	}

	ProgressPanel->Visible = false;
	CurWorking = false;
	Application->ProcessMessages();

	return mr;
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::CanDlBtnClick(TObject *Sender)
{
	CancelWork = true;

	try {
		if (IdFTP1->Connected()) {
			IdFTP1->Abort();
			Application->ProcessMessages();
			FTPDisconnectAction->Execute();
		}
	}
	catch (...) {
		SetActionAbort(_T("キャンセルに失敗しました。"));
	}

	FileListBox[CurListTag]->SetFocus();
}

//---------------------------------------------------------------------------
//警告表示
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::SttBarWarn(UnicodeString msg)
{
	if (!Initialized || UnInitializing) return;

	if (StartsText("Abort", msg) || USAME_TI(msg, "Operation aborted")) {
		StatusBar1->Panels->Items[0]->Text = EmptyStr;
	}
	else if (!msg.IsEmpty()) {
		if (ShowMsgHint) ShowMessageHint(msg, col_bgWarn);	//ヒントで表示

		//ステータスバーに表示
		if (ShowSttBar) {
			StatusBar1->Panels->Items[0]->Text = msg;
			if (!ShowMsgHint) {
				StatusBar1->Tag = SHOW_WARN_TAG;
				StatusBar1->Repaint();
				beep_Warn();
				MsgHintTimer->Interval = MsgHintTime;
				MsgHintTimer->Enabled  = true;
			}
		}
		//ドライブ情報部分に表示
		else if (!ShowMsgHint) {
			TPanel *stt_panel = (CurListTag==0)? L_StatPanel : R_StatPanel;
			DriveInf[CurListTag] = stt_panel->Caption;
			stt_panel->Tag		 = SHOW_WARN_TAG;
			SetDrivePanel(CurListTag, msg);
			beep_Warn();
			MsgHintTimer->Interval = MsgHintTime;
			MsgHintTimer->Enabled  = true;
		}
	}
	else {
		StatusBar1->Panels->Items[0]->Text = EmptyStr;
		beep_Warn();
	}
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::SttBarWarn(const _TCHAR *msg)
{
	SttBarWarn(UnicodeString(msg));
}

//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::SttBarWarnUstr(unsigned id)
{
	SttBarWarn(LoadUsrMsg(id));
}

//---------------------------------------------------------------------------
//対象コントロールを取得
//---------------------------------------------------------------------------
TControl * __fastcall TNyanFiForm::GetCurControl(bool center)
{
	if (Screen->ActiveForm!=this)	return (TControl*)Screen->ActiveForm;
	if (TxtViewPanel->Visible)		return (TControl*)TxtViewPanel;
	if (ImgViewPanel->Visible)		return (TControl*)ImgViewPanel;
	if (GrepPanel->Visible)			return (TControl*)GrepPanel;
	if (center)						return (TControl*)ListPanel;
	if (FindBusy)					return (TControl*)FileListBox[FindTag];
									return (TControl*)FileListBox[CurListTag];
}

//---------------------------------------------------------------------------
//メッセージをヒント表示
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ShowMessageHint(
	UnicodeString msg,	//メッセージ
	TColor col,			//背景色			(default = clWindow)
	bool beep,			//ビープ音			(default = true)
	bool not_hide,		//自動的に隠さない	(default = false)
	bool center)		//リスト中央に表示	(default = false)
{
	if (msg.IsEmpty()) {
		MsgHint->ReleaseHandle();
		return;
	}

	//表示位置を設定
	MsgHint->ActivateHintEx(
		UnicodeString().sprintf(_T("\r\n%s\r\n"), msg.c_str()),
		ScaledInt(480), ScaledInt(240), GetCurControl(center), col);

	if (beep) beep_Warn();

	if (!not_hide) {
		MsgHintTimer->Interval = MsgHintTime;
		MsgHintTimer->Enabled  = true;
	}
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ShowMessageHint(const _TCHAR *msg, TColor col, bool beep, bool not_hide, bool center)
{
	ShowMessageHint(UnicodeString(msg), col, beep, not_hide, center);
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ShowMessageHint(unsigned id, TColor col, bool beep, bool not_hide, bool center)
{
	ShowMessageHint(LoadUsrMsg(id), col, beep, not_hide, center);
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ShowMessageHintEsc(UnicodeString msg)
{
	ShowMessageHint("　" + msg + "\n　ESCキーで中断します。", col_bgHint, false, true);
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ShowHintAndStatus(UnicodeString msg)
{
	if (!ShowSttBar) ShowMessageHint(msg, col_bgHint, false);
	StatusBar1->Panels->Items[0]->Text = msg;
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ShowHintAndStatus(unsigned id)
{
	ShowHintAndStatus(LoadUsrMsg(id));
}

//---------------------------------------------------------------------------
//ディレクトリ情報でのマウス操作
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::L_DirPanelClick(TObject *Sender)
{
	ToLeftAction->Execute();
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::R_DirPanelClick(TObject *Sender)
{
	ToRightAction->Execute();
}
//---------------------------------------------------------------------------
//ディレクトリ入力パネルの表示
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ShowInpDirPanel(bool drop_sw)
{
	bool div_p = (DivFileListUD && DivDirInfUD);
	InpDirPanel->Parent  = (CurListTag==0)? (div_p? L_DirPanel2 : L_DirPanel) : (div_p? R_DirPanel2 : R_DirPanel);
	InpDirPanel->Align	 = alClient;
	InpDirPanel->Visible = true;
	InpDirComboBox->Font->Assign(DialogFont);
	InpDirComboBox->Items->Assign(InputDirHistory);
	InpDirComboBox->Text = GetCurPathStr();
	InpDirComboBox->SetFocus();
	if (drop_sw) InpDirComboBox->DroppedDown = true;
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::HideInpDirPanel()
{
	InputDirHistory->Assign(InpDirComboBox->Items);
	InpDirPanel->Align	 = alNone;
	InpDirPanel->Visible = false;
	FileListBox[CurListTag]->SetFocus();
}
//---------------------------------------------------------------------------
//ディレクトリの選択
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::RefDirBtnClick(TObject *Sender)
{
	UnicodeString dnam = CurPath[CurListTag];
	if (UserModule->SelectDirEx(("ディレクトリを開く - " + get_LRUD_str()).c_str(), dnam)) {
		InpDirComboBox->Text = to_absolute_name(dnam, CurPath[CurListTag]);
		ApplyInpDir();
	}
}
//---------------------------------------------------------------------------
//入力ディレクトリの適用
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ApplyInpDir()
{
	UnicodeString dnam = to_absolute_name(cv_env_str(InpDirComboBox->Text), CurPath[CurListTag]);
	int atr = file_GetAttr(dnam);
	if (atr==faInvalid) {
		SttBarWarn(SysErrorMessage(ERROR_PATH_NOT_FOUND));
	}
	else {
		UnicodeString fnam;
		if (!(atr & faDirectory)) {
			fnam = dnam;
			dnam = ExtractFilePath(dnam);
		}
		UpdateCurPath(dnam, fnam);
		add_ComboBox_history(InpDirComboBox, dnam);
	}
	HideInpDirPanel();
}

//---------------------------------------------------------------------------
//ディレクトリ入力パネルのキー操作
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::InpDirEditKeyDown(TObject *Sender, WORD &Key, TShiftState Shift)
{
	if		(Key==VK_RETURN)	ApplyInpDir();
	else if (Key==VK_ESCAPE)	HideInpDirPanel();
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::InpDirEditKeyPress(TObject *Sender, System::WideChar &Key)
{
	if (Key==VK_RETURN || Key==VK_ESCAPE) Key = 0;
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::InpDirEditExit(TObject *Sender)
{
	HideInpDirPanel();
}

//---------------------------------------------------------------------------
//ドライブ選択ポップアップを表示
//---------------------------------------------------------------------------
bool __fastcall TNyanFiForm::PopupDriveMenu(
	int tag,
	bool is_eject,		//トレイを開く	(default = false)
	bool no_size)		//容量非表示	(default = false)
{
	cursor_HourGlass();

	TPopupMenu *pPop = DrivePopupMenu;
	while (pPop->Items->Count>0) pPop->Items->Delete(0);
	UnicodeString cur_key = ExtractFileDrive(CurPath[CurListTag]).SubString(1, 1);
	UnicodeString tmp;

	//トレイを開くドライブを選択
	if (is_eject) {
		int cnt = 0;
		for (int i=0; i<DriveInfoList->Count; i++) {
			if (((drive_info *)DriveInfoList->Objects[i])->drv_type==DRIVE_CDROM) cnt++;
		}
		if (cnt<=1) return false;

		for (int i=0; i<DriveInfoList->Count; i++) {
			drive_info *dp = (drive_info *)DriveInfoList->Objects[i];
			if (dp->drv_type!=DRIVE_CDROM) continue;
			UnicodeString dstr = dp->drive_str;
			TMenuItem *mp  = new TMenuItem(pPop);
			mp->Caption    = tmp.sprintf(_T("&%s%s"), get_tkn(dstr, '\\').c_str(), dp->label.c_str());
			mp->OnDrawItem = PopSelectItemDrawItem;
			mp->OnClick    = PopEjectItemClick;
			mp->Tag 	   = i;
			mp->Checked    = SameText(cur_key, dstr[1]);
			pPop->Items->Add(mp);
		}
	}
	//移動するドライブを選択
	else {
		int cnt = 0;
		for (int i=0; i<DriveInfoList->Count; i++) {
			drive_info *dp = (drive_info *)DriveInfoList->Objects[i];
			if (!dp->accessible) continue;
			UnicodeString dstr = dp->drive_str;

			//容量
			UnicodeString sz_str;
			if (!no_size) {
				int dn = (char)dstr[1] - 'A' + 1;
				__int64 sTotal = DiskSize(dn);
				__int64 sFree  = DiskFree(dn);
				if (sTotal>0 && sFree>=0) {
					sz_str = get_size_str_T(sFree, SizeDecDigits);
					sz_str.cat_sprintf(_T(" (%4.1f%%) Free"), 100.0*sFree/sTotal);
				}
			}

			tmp.sprintf(_T("&%s%s"), get_tkn(dstr, '\\').c_str(), dp->label.c_str());
			if (!sz_str.IsEmpty()) tmp.cat_sprintf(_T(" \t%s"), sz_str.c_str());
			TMenuItem *mp  = new TMenuItem(pPop);
			mp->Caption    = tmp;
			mp->OnDrawItem = PopSelectItemDrawItem;
			mp->OnClick    = PopSelectItemClick;
			mp->Tag 	   = i;
			mp->Checked    = SameText(cur_key, dstr[1]);
			pPop->Items->Add(mp);
			cnt++;
		}
		if (cnt==0) return false;

		//セパレータ
		TMenuItem *mp = new TMenuItem(pPop);
		mp->Caption    = "-";
		mp->OnDrawItem = PopSelectItemDrawItem;
		pPop->Items->Add(mp);
		//ダイアログ表示
		mp = new TMenuItem(pPop);
		mp->OnDrawItem = PopSelectItemDrawItem;
		mp->Action	   = DriveListAction;
		mp->Tag		   = OTHERS_BASE;
		pPop->Items->Add(mp);
	}
	cursor_Default();

	//ポップメニューを表示
	TPoint p;
	if (is_eject) {
		p = FileListBox[tag]->ClientToScreen(Point(16, 16));
	}
	else {
		bool div_p = (DivFileListUD && DivDirInfUD);
		TSpeedButton *bp = (tag==0)? (div_p? L_SelDrvBtn2 : L_SelDrvBtn) : (div_p? R_SelDrvBtn2 : R_SelDrvBtn);
		p = ActionOptIsMousePos()? Mouse->CursorPos :
		   ActionOptIsButtonPos()? ButtonPos : bp->ClientToScreen(Point(0, bp->Height));
	}
	ActionOptStr = EmptyStr;
	pPop->Popup(p.x, p.y);
	return true;
}

//---------------------------------------------------------------------------
//選択ポップアップを表示 (登録ディレクトリ/ パスマスク)
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::PopupRegDirMenu(const _TCHAR *id_str)
{
	ClearKeyBuff(true);

	TPopupMenu *pPop = SelItemPopupMenu;
	while (pPop->Items->Count>0) pPop->Items->Delete(0);

	TStringList *lst = NULL;
	int tag_base = 0;
	UnicodeString cur_key;

	switch (idx_of_word_i(_T("RegDir|OppDir|PathMask"), id_str)) {
	case 0:
		lst = RegDirList;	tag_base = REGDIR_BASE;
		break;
	case 1:
		lst = RegDirList;	tag_base = OPPDIR_BASE;
		break;
	case 2:
		lst = PathMaskList;	tag_base = PATMSK_BASE;
		cur_key = get_tkn(PathMask[CurListTag], ',');
		break;
	}

	if (lst) {
		for (int i=0; i<lst->Count; i++) {
			TStringDynArray itm_buf = get_csv_array(lst->Strings[i], 3);
			if (itm_buf.Length<3) continue;

			TMenuItem *mp = new TMenuItem(pPop);
			mp->OnDrawItem = PopSelectItemDrawItem;
			//セパレータ
			if (is_separator(itm_buf[1])) {
				mp->Caption = "-";
			}
			//項目
			else {
				mp->Caption = UnicodeString().sprintf(_T("&%s:%s"), itm_buf[0].c_str(), itm_buf[1].c_str());
				mp->OnClick = PopSelectItemClick;
				mp->Tag 	= i + tag_base;
				mp->Checked = !cur_key.IsEmpty() && SameText(cur_key, itm_buf[0]);
			}
			pPop->Items->Add(mp);
		}
	}

	if (pPop->Items->Count==0) return;

	if (!USAME_TI(id_str, "OppDir")) {
		//セパレータ
		TMenuItem *mp = new TMenuItem(pPop);
		mp->Caption    = "-";
		mp->OnDrawItem = PopSelectItemDrawItem;
		pPop->Items->Add(mp);
		//ダイアログ
		mp = new TMenuItem(pPop);
		mp->OnDrawItem = PopSelectItemDrawItem;
		mp->Action	   = USAME_TI(id_str, "RegDir")? RegDirDlgAction : PathMaskDlgAction;
		mp->Tag		   = OTHERS_BASE;
		pPop->Items->Add(mp);
	}

	//メニュー表示
	int tag = USAME_TI(id_str, "OppDir")? OppListTag : CurListTag;
	TPanel *pp = (tag==0)? L_DirPanel : R_DirPanel;
	TPoint p = ActionOptIsMousePos()? Mouse->CursorPos :
			  ActionOptIsButtonPos()? ButtonPos : pp->ClientToScreen(Point(0, pp->Height));
	ActionOptStr = EmptyStr;
	pPop->Popup(p.x, p.y);
}

//---------------------------------------------------------------------------
//タブ選択ポップアップを表示
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::PopupTabMenu()
{
	ClearKeyBuff(true);

	TPopupMenu *pPop = SelItemPopupMenu;
	while (pPop->Items->Count>0) pPop->Items->Delete(0);

	for (int i=0; i<TabList->Count; i++) {
		TStringDynArray itm_buf = get_csv_array(TabList->Strings[i], TABLIST_CSVITMCNT, true);
		UnicodeString lbuf;
		if		(i<10) lbuf.sprintf(_T("&%u: "), (i + 1)%10);
		else if (i<36) lbuf.sprintf(_T("&%c: "), (char)('A' + (i - 10)));
		else lbuf = "   ";

		if (!itm_buf[2].IsEmpty()) lbuf.cat_sprintf(_T("%s : "), itm_buf[2].c_str());
		lbuf.cat_sprintf(_T("%s  |  %s"),
			ExcludeTrailingPathDelimiter(itm_buf[0]).c_str(),
			ExcludeTrailingPathDelimiter(itm_buf[1]).c_str());

		TMenuItem *mp = new TMenuItem(pPop);
		mp->Caption    = lbuf;
		mp->OnDrawItem = PopSelectItemDrawItem;
		mp->OnClick    = PopSelectItemClick;
		mp->Tag 	   = i + FL_TAB_BASE;
		mp->Checked    = (i==TabControl1->TabIndex);
		pPop->Items->Add(mp);
	}

	if (pPop->Items->Count==0) return;

	//メニュー表示
	TPoint p = ActionOptIsMousePos()? Mouse->CursorPos :
			  ActionOptIsButtonPos()? ButtonPos : TabPanel->ClientToScreen(Point(2, TabPanel->Height));
	ActionOptStr = EmptyStr;
	pPop->Popup(p.x, p.y);
}

//---------------------------------------------------------------------------
//選択ポップアップメニューの描画
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::PopSelectItemDrawItem(TObject *Sender, TCanvas *ACanvas,
		const TRect &ARect, bool Selected)
{
	TMenuItem *mp = (TMenuItem*)Sender;
	ACanvas->Brush->Color = Selected? scl_Highlight : scl_Menu;
	ACanvas->FillRect(ARect);

	UnicodeString lbuf = mp->Caption;
	int xp = ARect.Left + Scaled4;
	int yp = ARect.Top  + Scaled1;

	//セパレータ
	if (is_separator(lbuf)) {
		draw_Separator(ACanvas, ARect);
	}
	//選択項目
	else {
		//ドライブアイコン
		if (mp->Tag<DriveInfoList->Count) {
			drive_info *dp = (drive_info *)DriveInfoList->Objects[mp->Tag];
			TIcon *ip = dp->small_ico;
			if (ip && ip->Handle)
				::DrawIconEx(ACanvas->Handle, xp, yp + 1, ip->Handle, SIcoSize, SIcoSize, 0, NULL, DI_NORMAL);
			xp += ScaledInt(24);
		}
		//タブアイコン
		else if (mp->Tag>=FL_TAB_BASE) {
			int idx = mp->Tag - FL_TAB_BASE;
			if (idx>=0 && idx<TabList->Count) {
				UnicodeString inam = to_absolute_name(get_csv_item(TabList->Strings[idx], 3));
				if (file_exists(inam)) draw_SmallIcon2(inam, ACanvas, xp, yp + 1);
			}
			xp += ScaledInt(24);
		}

		ACanvas->Font->Color = Selected? scl_HighlightText : scl_MenuText;
		bool k_flag = remove_top_s(lbuf, '&');
		UnicodeString sbuf = split_pre_tab(lbuf);
		//呼び出しキー
		if (k_flag) {
			UnicodeString kstr = split_tkn(sbuf, ':');
			ACanvas->Font->Style = (ACanvas->Font->Style << fsBold);
			ACanvas->TextOut(xp, yp, kstr);
			//囲み
			if (mp->Checked) {
				TRect rc = ARect;
				rc.Left  = xp - 2;
				rc.Right = xp + ACanvas->TextWidth(kstr) + 4;
				InflateRect(rc, 0, -2);
				TColor col = ACanvas->Brush->Color;
				ACanvas->Brush->Color = scl_Highlight;
				ACanvas->FrameRect(rc);
				ACanvas->Brush->Color = col;
			}
			xp += ACanvas->TextWidth("W") + 6;
		}

		//ボリューム名/ 登録名
		ACanvas->Font->Style = (ACanvas->Font->Style >> fsBold);
		ACanvas->TextOut(xp, yp, Trim(sbuf));
		//空き容量
		if (!lbuf.IsEmpty() && mp->Tag<DriveInfoList->Count) {
			xp = ARect.Right - ACanvas->TextWidth(lbuf) - 4;
			ACanvas->TextOut(xp, yp, lbuf);
		}
	}
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::PopSelectItemClick(TObject *Sender)
{
	TMenuItem *mp = (TMenuItem*)Sender;
	UnicodeString kstr = mp->Caption;
	remove_top_s(kstr, '&');
	kstr = kstr.SubString(1, 1);
	//タブ
	if (mp->Tag>=FL_TAB_BASE) {
		int idx = mp->Tag - FL_TAB_BASE;
		if (idx<TabControl1->Tabs->Count) {
			StoreTabStt(TabControl1->TabIndex);
			TabControl1->TabIndex = idx;
			TabControl1Change(NULL);
		}
	}
	//パスマスク
	else if (mp->Tag>=PATMSK_BASE) {
		SetCurPathMask(kstr);
	}
	//登録ディレクトリ、ドライブ
	else {
		ActionParam = kstr;
		if (mp->Tag>=OPPDIR_BASE || mp->Tag>=REGDIR_BASE) {
			int idx = mp->Tag - ((mp->Tag>=OPPDIR_BASE)? OPPDIR_BASE : REGDIR_BASE);
			UnicodeString dnam = get_RegDirItem(idx);
			if (!dnam.IsEmpty()) {
				//特殊フォルダ
				if (StartsText("shell:", dnam)) {
					if (::ShellExecute(NULL, _T("explore"), dnam.c_str(), NULL, NULL, SW_SHOWNORMAL) <= (HINSTANCE)32)
						ActionErrMsg = LoadUsrMsg(USTR_FaildExec);
				}
				//タグ検索
				else if (remove_top_s(dnam, "#:")) {
					ExeCommandAction("FindTag", dnam);
				}
				//通常ディレクトリ
				else {
					if (mp->Tag>=OPPDIR_BASE) UpdateOppPath(dnam); else UpdateCurPath(dnam);
					ActionErrMsg = GlobalErrMsg;
				}
				ActionOk = ActionErrMsg.IsEmpty();
				if (ActionOk && IniFile->ReadBoolGen(_T("RegDirDlgMoveTop"))) move_top_RegDirItem(idx);
			}
		}
		else {
			ChangeDriveAction->Execute();
		}
	}

	if (!ActionOk && !ActionErrMsg.IsEmpty()) SttBarWarn(ActionErrMsg);
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::PopEjectItemClick(TObject *Sender)
{
	UnicodeString kstr = ((TMenuItem*)Sender)->Caption;
	remove_top_s(kstr, '&');
 	if (!ExeCmdAction(EjectAction, kstr.SubString(1, 1))) SetActionAbort();
}

//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::SelDrvBtnClick(TObject *Sender)
{
	int tag = ((TComponent*)Sender)->Tag;
	((tag==0)? ToLeftAction : ToRightAction)->Execute();
	PopupDriveMenu(tag, false, true);
}

//---------------------------------------------------------------------------
//ドライブ情報でのマウス操作
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::L_StatPanelClick(TObject *Sender)
{
	ToLeftAction->Execute();
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::R_StatPanelClick(TObject *Sender)
{
	ToRightAction->Execute();
}

//---------------------------------------------------------------------------
//情報欄/テキストプレビューでの操作
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::InfListBoxKeyDown(TObject *Sender, WORD &Key, TShiftState Shift)
{
	UnicodeString KeyStr = get_KeyStr(Key, Shift);
	UnicodeString cmd_F  = Key_to_CmdF(KeyStr);
	UnicodeString cmd_V  = Key_to_CmdV(KeyStr);
	TListBox *lp = (TListBox*)Sender;

	bool handled = true;
	if (ExeCmdListBox(lp, cmd_F) || ExeCmdListBox(lp, cmd_V))
		;
	else if (is_ToRightOpe(KeyStr, cmd_F))	ExeCmdAction(ToRightAction);
	else if (is_ToLeftOpe(KeyStr, cmd_F))	ExeCmdAction(ToLeftAction);
	else if (SameText(KeyStr, KeyStr_Copy)) ExeCmdListBox(lp, _T("ClipCopy"));
	//右クリックメニュー
	else if (contained_wd_i(KeysStr_Popup, KeyStr)) show_PopupMenu(lp);
	else handled = false;

	if (handled) Key = 0;
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::SubListBoxMouseDown(TObject *Sender, TMouseButton Button, TShiftState Shift, int X, int Y)
{
	((TListBox *)Sender)->SetFocus();
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::SubListBoxExit(TObject *Sender)
{
	TListBox *lp = (TListBox*)Sender;
	ListBoxSelectAll(lp, false);
	lp->Repaint();
}

//---------------------------------------------------------------------------
//追加メニューを設定
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::SetExtMenuItem(TMenuItem *m_item,
	TStringList *lst,		//項目リスト
	int tag_base,			//識別タグのベース
	int s_idx)				//抽出サブメニューの親のインデックス
{
	//追加項目を一旦削除
	int idx = 0;
	while (idx<m_item->Count) {
		if (m_item->Items[idx]->Tag>=tag_base) m_item->Delete(idx); else idx++;
	}

	//追加項目を登録
	if (lst->Count>0) {
		TMenuItem *pp = m_item;
		pp->NewBottomLine();
		for (int i=0; i<lst->Count; i++) {
			if (s_idx!=-1 && i<=s_idx) continue;
			TStringDynArray itm_buf = get_csv_array(lst->Strings[i], 6, true);
			if (itm_buf.Length==0 || itm_buf[0].IsEmpty()) continue;
			UnicodeString tit = itm_buf[0];

			//表示設定(抽出の場合は必ず表示)
			if (s_idx==-1) {
				if (tag_base==EXTMENU_BASE && equal_0(itm_buf[4])) continue;
				if (tag_base==EXTTOOL_BASE && equal_0(itm_buf[5])) continue;
			}

			//サブメニュー
			if (remove_top_s(tit, '>')) {
				TMenuItem *mp  = new TMenuItem(m_item);
				mp->Caption    = tit;
				mp->Tag 	   = tag_base + i;
				mp->ImageIndex = add_IconImage(((tag_base==EXTMENU_BASE)? itm_buf[5] : EmptyStr), IconImgListP);
				pp->Add(mp);
				pp = mp;
			}
			else if (remove_top_s(tit, '<')) {
				if		(pp!=m_item) pp = pp->Parent;
				else if (s_idx!=-1)  break;
			}
			else {
				//メニュー項目を作成
				TMenuItem *mp = new TMenuItem(m_item);
				mp->Caption   = itm_buf[0];
				mp->Tag		  = tag_base + i;
				if (!is_separator(mp->Caption)) mp->OnClick = ExtMenuItemClick;
				//アイコン
				UnicodeString fnam = (tag_base==EXTTOOL_BASE)? itm_buf[1] :
									 (tag_base==EXTMENU_BASE)? itm_buf[5] : EmptyStr;
				mp->ImageIndex = add_IconImage(fnam, IconImgListP);
				pp->Add(mp);
			}
		}
	}

	reduction_MenuLine(m_item);
}

//---------------------------------------------------------------------------
//ステータスバーの描画
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::StatusBarDrawPanel(TStatusBar *StatusBar, TStatusPanel *Panel,
	const TRect &Rect)
{
	TCanvas *cv = StatusBar->Canvas;
	cv->Font->Assign(StatusBar->Font);
	cv->Brush->Color = (StatusBar->Tag==SHOW_WARN_TAG && Panel->Index==0)? col_bgWarn : col_bgSttBar;
	cv->FillRect(Rect);

	UnicodeString lbuf = Panel->Text;
	cv->Font->Color = col_fgSttBar;
	cv->TextOut(Rect.Left + 2, Rect.Top, split_pre_tab(lbuf));
	if (!lbuf.IsEmpty()) cv->TextOut(Rect.Right - cv->TextWidth(lbuf) - 2, Rect.Top, lbuf);
}

//---------------------------------------------------------------------------
//左右ディレクトリの関係表示を設定
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::SetDirRelation()
{
	UnicodeString path0   = GetCurPathStr(0);
	UnicodeString path1   = GetCurPathStr(1);
	UnicodeString b_path0 = get_tkn_r(path0, ExtractFileDrive(path0)).LowerCase();
	UnicodeString b_path1 = get_tkn_r(path1, ExtractFileDrive(path1)).LowerCase();
	UnicodeString rel_str, syn_str;
	UnicodeString msg;

	if (!IsCurFList() || !IsOppFList()) {
		rel_str = "　";
		file_rec *fp = GetCurFrecPtr(true);
		if (fp) {
			if (IsDiffList()) {
				TListBox *lp = FileListBox[CurListTag];
				TStringList *o_lst = GetOppList();
				file_rec *d_fp = (lp->ItemIndex<o_lst->Count)? (file_rec*)o_lst->Objects[lp->ItemIndex] : NULL;
				if (!d_fp->is_dummy) {
					if (fp->f_size!=d_fp->f_size)
						msg += (fp->f_size>d_fp->f_size)? "反対側よりも大きい\n" : "反対側よりも小さい\n";
					if (fp->f_time!=d_fp->f_time)
						msg += (fp->f_time>d_fp->f_time)? "反対側よりも新しい\n" : "反対側よりも古い\n";
				}
				else {
					msg += "反対側に存在しない\n";
				}
			}
			else if (CurStt->is_Work || CurStt->is_Find) {
				//カーソル位置ファイルのパスが反対パスに一致
				bool is_match;
				if (contains_Slash(fp->f_name) && OppStt->is_Arc) {
					is_match = SameText(OppStt->arc_Name, fp->arc_name)
								&& SameText(OppStt->arc_SubPath, ExtractFilePath(get_tkn_r(fp->f_name, '/')));
				}
				else {
					is_match = (fp->is_dir && (CurStt->is_Work || (CurStt->is_Find && !CurStt->find_DirLink)))?
								SameText(fp->f_name, ExcludeTrailingPathDelimiter(CurPath[OppListTag])) :
								SameText(fp->p_name, CurPath[OppListTag]);
				}
				if (is_match) {
					rel_str = "⇔";
					msg += "カーソル位置項目に対応\n";
				}
			}
		}

		if (IsCurFList()) syn_str = (CurListTag==0)? is_SyncDir(path0, EmptyStr) : is_SyncDir(EmptyStr, path1);
		if (IsOppFList()) syn_str = (OppListTag==0)? is_SyncDir(path0, EmptyStr) : is_SyncDir(EmptyStr, path1);
	}
	//ファイルリスト同士
	else {
		msg += SameText(ExtractFileDrive(path0), ExtractFileDrive(path1))? "同ドライブ\n" : "別ドライブ\n";

		if (SameText(path0, path1)) {			//同一
			rel_str = "＝";
			msg += "同一パス\n";
		}
		else if (StartsText(path1, path0)) {	//左の方が階層が下
			int cnt = count_PathDlmtr(get_tkn_r(path0, path1));
			rel_str.sprintf(_T("%s"), (cnt>1)? _T("≪") : _T("＜"));
			msg.cat_sprintf(_T("%u階層%s\n"), cnt, (CurListTag==0)? _T("下") : _T("上")); 
		}
		else if (StartsText(path0, path1)) {	//左の方が階層が上
			int cnt = count_PathDlmtr(get_tkn_r(path1, path0));
			rel_str.sprintf(_T("%s"), (cnt>1)? _T("≫") : _T("＞"));
			msg.cat_sprintf(_T("%u階層%s\n"), cnt, (CurListTag==0)? _T("上") : _T("下")); 
		}
		else if (SameText(b_path0, b_path1)) {
			rel_str = "≒";
			msg += "同名パス\n";
		}
		else {
			TStringDynArray plst0 = split_path(b_path0);
			TStringDynArray plst1 = split_path(b_path1);
			if (plst0.Length>1 && plst1.Length>1) {
				if (SameText(plst0[plst0.Length - 1], plst1[plst1.Length - 1])) {
					rel_str = "∽";
					msg += "同名ディレクトリ\n";
				}
				else {
					rel_str = "≠";
				}
			}
			else {
				rel_str = "≠";
			}
		}

		syn_str = is_SyncDir(path0, path1);
	}

	UnicodeString rch1 = " ";
	UnicodeString rch2 = " ";
	if (USAME_TS(syn_str, "S")) {
		rch1 = rch2 = "*";
		msg += "互いに同期関係\n";
	}
	else {
		if (syn_str.Pos('1')) {
			rch1[1] = '+';
			if (CurListTag==0) msg += "同期コピー先あり\n";
		}
		if (syn_str.Pos('2')) {
			rch2[1] = '+';
			if (CurListTag==1) msg += "同期コピー先あり\n";
		}
	}

	if (SyncLR) msg += "階層同期 ON\n";

	DirRelStr = rch1 + rel_str + rch2;

	bool div_p = (DivFileListUD && DivDirInfUD);
	(div_p? RelPaintBox2 : RelPaintBox)->Repaint();
	(div_p?  RelPanel2 : RelPanel)->Hint = Trim(msg);
}
//---------------------------------------------------------------------------
//ディレクトリ関係の描画
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::RelPaintBoxPaint(TObject *Sender)
{
	TPaintBox *pp = (TPaintBox*)Sender;
	TCanvas *cv = pp->Canvas;
	TRect    rc = pp->ClientRect;

	cv->Brush->Color = col_bgDirRel;
	cv->FillRect(rc);
	cv->Font->Assign(DirInfFont);
	cv->Font->Color = col_fgDirRel;
	cv->Font->Style = cv->Font->Style >> fsItalic;

	//関係記号
	if (DirRelStr.Length()==3) {
		int xp = (rc.Width()  - cv->TextWidth(DirRelStr[2]))/2;
		int yp = (rc.Height() - cv->TextHeight(DirRelStr[2]))/2;
		cv->TextOut(xp, yp, DirRelStr[2]);
		cv->Font->Style = (cv->Font->Style >> fsBold);
		if (DirRelStr[1]!=' ') cv->TextOut(xp - cv->TextWidth(DirRelStr[1]) - 3, yp, DirRelStr[1]);
		if (DirRelStr[3]!=' ') cv->TextOut(xp + cv->TextWidth(DirRelStr[2]) + 3, yp, DirRelStr[3]);
	}

	//横線表示
	cv->Pen->Width = Scaled1;
	cv->Pen->Style = psSolid;
	cv->Pen->Color = AdjustColor(col_fgDirRel, 72);

	//左右同ドライブ
	if (((IsCurFList() && IsOppFList()) || IsDiffList())
		&& SameText(ExtractFileDrive(CurPath[0]), ExtractFileDrive(CurPath[1])))
	{
		int mgn = pp->Width/4;
		int yp = rc.Top + 3;
		cv->MoveTo(rc.Left + mgn, yp);	cv->LineTo(rc.Right - mgn, yp);
		yp = rc.Bottom - 4;
		cv->MoveTo(rc.Left + mgn, yp);	cv->LineTo(rc.Right - mgn, yp);
	}

	//左右同期
	if (SyncLR) {
		int yp = rc.Top + 1;
		cv->MoveTo(rc.Left + 4, yp);	cv->LineTo(rc.Right - 4, yp);
		yp = rc.Bottom - 2;
		cv->MoveTo(rc.Left + 4, yp);	cv->LineTo(rc.Right - 4, yp);
	}
}

//---------------------------------------------------------------------------
//ディレクトリ名表示
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::SetDirCaption(int tag)
{
	flist_stt *lst_stt = &ListStt[tag];

	UnicodeString pnam;
	//アーカイブ
	if (lst_stt->is_Arc) {
		pnam = CurPath[tag] + lst_stt->arc_DspPath;
	}
	//代替データストリーム
	else if (lst_stt->is_ADS) {
		pnam = lst_stt->ads_Name + ":";
	}
	//検索結果
	else if (lst_stt->is_Find) {
		file_rec *fp = GetFrecPtr(FileListBox[tag], ResultList[tag]);
		pnam = (fp && !fp->is_up)? fp->p_name : lst_stt->find_Path;
	}
	//ワークリスト
	else if (lst_stt->is_Work) {
		if (WorkListName.IsEmpty())
			pnam = " (新規ワークリスト)";
		else
			pnam.sprintf(_T(" %s"), get_base_name(WorkListName).c_str());
		pnam = IncludeTrailingPathDelimiter(pnam);
	}
	//FTP
	else if (lst_stt->is_FTP) {
		try {
			pnam = CurFTPPath;
			if (IdFTP1->Connected()) pnam.Insert(IdFTP1->Host, 1);
		}
		catch (...) {
			pnam = CurPath[tag];
		}
	}
	//その他
	else {
		pnam = CurPath[tag];
	}

	//ライブラリ名の処理
	if (!lst_stt->is_Work && !lst_stt->LibraryInfo.IsEmpty()) {
		UnicodeString dnam = lst_stt->LibraryInfo;
		UnicodeString lnam = get_base_name(split_pre_tab(dnam));
		dnam = IncludeTrailingPathDelimiter(dnam);
		if (StartsText(dnam, pnam)) {
			UnicodeString tmp;
			tmp.sprintf(_T("ライブラリ\\%s"), lnam.c_str());
			if (!lst_stt->LibSubPath.IsEmpty()) tmp.cat_sprintf(_T("(%s)"), lst_stt->LibSubPath.c_str());
			tmp += "\\";
			pnam.Delete(1, dnam.Length());
			pnam.Insert(tmp, 1);
		}
	}

	if (UncToNetDrive) pnam = UNC_to_NetDriveName(pnam);
	if (!lst_stt->is_Work && !lst_stt->is_FTP && DispRegName) pnam = get_RegDirName(slash_to_yen(pnam));
	if (lst_stt->is_Find) {
		pnam += lst_stt->find_Mask;
		if (!lst_stt->find_Keywd.IsEmpty()) pnam.cat_sprintf(_T(" : %s"), lst_stt->find_Keywd.c_str());
	}

	//配色
	((TPanel*)((tag==1)? R_HdrPanel : L_HdrPanel))->Color		= lst_stt->color_bgDirInf;
	((TPanel*)((tag==1)? R_TopPanel : L_TopPanel))->Color		= lst_stt->color_bgDirInf;
	((TPanel*)((tag==1)? R_HdrPanel : L_HdrPanel))->Font->Color = lst_stt->color_fgDirInf;
	((TPanel*)((tag==1)? R_TopPanel : L_TopPanel))->Font->Color = lst_stt->color_fgDirInf;

	bool div_p = (DivFileListUD && DivDirInfUD);
	TPanel *pp = (tag==0)? (div_p? L_DirPanel2 : L_DirPanel) : (div_p? R_DirPanel2 : R_DirPanel);
	pp->BevelOuter = FlatInfPanel? bvNone : lst_stt->is_Work? bvRaised : bvLowered;
	if (lst_stt->is_Work) {
		 if (WorkListChanged) pnam.Insert("*", 1); else if (WorkListFiltered) pnam.Insert("!", 1);
	}

	int p_wd = pp->ClientWidth - Scaled4;
	if (lst_stt->is_TabFixed) p_wd -= get_WidthInPanel(TabPinMark, pp, true);
	UnicodeString pnam0 = pnam;
	pnam = get_MiniPathName(pnam, p_wd, pp->Font, !lst_stt->is_FTP);
	pp->Hint = (pnam.Length()<pnam0.Length())? (lst_stt->is_FTP? yen_to_slash(pnam0) : yen_to_delimiter(pnam0))
											 : EmptyStr;
	if (lst_stt->is_FTP) pnam = yen_to_slash(pnam);
	pnam = ReplaceStr(pnam, "&", "&&");
	if (lst_stt->is_TabFixed) pnam.Insert(TabPinMark, 1);
	pp->Caption = pnam;

	//関係表示
	SetDirRelation();
}

//---------------------------------------------------------------------------
//ドライブ情報の配色などを設定
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::SetDrivePanel(int tag, UnicodeString msg)
{
	flist_stt *lst_stt = &ListStt[tag];
	TPanel *stt_panel = (tag==0)? L_StatPanel : R_StatPanel;

	if (lst_stt->is_IncSea || lst_stt->is_Filter) {
		stt_panel->Alignment   = taLeftJustify;
		stt_panel->Color	   = col_bgList;
		stt_panel->Font->Color = col_fgList;
		stt_panel->Caption	   = CurStt->is_Migemo ? " Migemo: "
												   : (lst_stt->is_Filter? " フィルタ: " : " サーチ: ");
	}
	else {
		stt_panel->Alignment   = taRightJustify;
		if (stt_panel->Tag==SHOW_WARN_TAG) {
			stt_panel->Color	   = col_bgWarn;
			stt_panel->Font->Color = col_fgDrvInf;
		}
		else if (lst_stt->sel_d_cnt>0 || lst_stt->sel_f_cnt>0) {
			stt_panel->Color	   = lst_stt->color_selItem;
			stt_panel->Font->Color = (col_fgSelItem!=col_None)? col_fgSelItem : col_fgList;
		}
		else {
			stt_panel->Color	   = lst_stt->color_bgDrvInf;
			stt_panel->Font->Color = lst_stt->color_fgDrvInf;
		}
	}

	if (!msg.IsEmpty()) {
		stt_panel->Caption = msg;
		stt_panel->Repaint();
	}
}

//---------------------------------------------------------------------------
//ドライブ取得
//---------------------------------------------------------------------------
UnicodeString __fastcall TNyanFiForm::GetDriveInfo(
	int tag,
	bool drv_upd,			//ドライブ情報を更新	(default = true)
	bool sel_upd,			//選択情報を更新		(default = true)
	UnicodeString get_fmt)	//書式(取得のみ)		(default = EmptyStr)
{
	static int last_idx = -1;

	//選択状態の取得
	flist_stt *lst_stt = &ListStt[tag];		if (lst_stt->is_Filter) return EmptyStr;
	TStringList *lst   = GetFileList(tag);
	if (drv_upd) lst_stt->clu_size = get_ClusterSize(CurPath[tag]);

	int d_cnt, f_cnt, d_cnt_total, f_cnt_total, sel_d_cnt, sel_f_cnt;
	__int64 sel_size;
	bool has_0 = (lst->Count>0 && ((file_rec*)lst->Objects[0])->is_up);

	if (sel_upd) {
		d_cnt = f_cnt = 0;
		d_cnt_total = f_cnt_total = 0;
		sel_d_cnt = sel_f_cnt = 0;
		sel_size = 0;
		__int64 total_size	 = 0;
		__int64 total_o_size = 0;

		for (int i=0; i<lst->Count; i++) {
			file_rec *fp = (file_rec*)lst->Objects[i];
			if (fp->is_up || fp->is_dummy) continue;
			//ディレクトリ
			if (fp->is_dir) {
				d_cnt++;
				//選択数
				if (fp->selected) {
					sel_d_cnt++;  if (fp->f_size>0) sel_size += fp->f_size;
				}
				//サイズ
				if (fp->f_size==-1) {
					total_size	= total_o_size = -1;
					d_cnt_total = f_cnt_total = -1;
				}
				else if (total_size!=-1) {
					total_size += fp->f_size;
					if (fp->o_size!=-1)  total_o_size += fp->o_size;
					if (fp->d_count!=-1) d_cnt_total  += (fp->d_count + 1);
					if (fp->f_count!=-1) f_cnt_total  += fp->f_count;
				}
			}
			//ファイル
			else {
				f_cnt++;
				if (total_size!=-1) f_cnt_total++;
				//選択数
				if (fp->selected) {
					sel_f_cnt++;	sel_size += fp->f_size;
				}
				//サイズ
				if (total_size!=-1) {
					total_size += fp->f_size;
					//占有サイズ
					if (lst_stt->clu_size>0) {
						fp->o_size = (fp->f_size/lst_stt->clu_size) * lst_stt->clu_size;
						if (fp->f_size%lst_stt->clu_size>0) fp->o_size += lst_stt->clu_size;
						total_o_size += fp->o_size;
					}
				}
			}
		}

		lst_stt->d_cnt		 = d_cnt;
		lst_stt->f_cnt		 = f_cnt;
		lst_stt->d_cnt_total = d_cnt_total;
		lst_stt->f_cnt_total = f_cnt_total;
		lst_stt->sel_d_cnt	 = sel_d_cnt;
		lst_stt->sel_f_cnt	 = sel_f_cnt;
		lst_stt->sel_size	 = sel_size;
		lst_stt->cur_total	 = total_size;
		lst_stt->occ_total	 = total_o_size;
		lst_stt->sub_counted = (d_cnt>0 && d_cnt_total!=-1);
		//全サブディレクトリが計算済みでない場合、グラフ表示を解除
		if (!lst_stt->sub_counted) lst_stt->dir_graph = lst_stt->dsk_graph = false;
	}
	else {
		d_cnt	  = lst_stt->d_cnt;
		f_cnt	  = lst_stt->f_cnt;
		sel_d_cnt = lst_stt->sel_d_cnt;
		sel_f_cnt = lst_stt->sel_f_cnt;
		sel_size  = lst_stt->sel_size;
	}

	//ドライブ情報文字列の設定
	//ページ
	TListBox *lp = FileListBox[tag];
	int i_cnt = lp->Count - (has_0? 1 : 0);
	int i_idx = lp->ItemIndex + (has_0? 0 : 1);
	int pg = lp->ClientHeight/lp->ItemHeight;
	int pn = (pg>0)? i_cnt/pg : 0; if (pg>0 && i_cnt%pg>0) pn++;

	UnicodeString tp_str = pn;
	UnicodeString cp_str = (pg>0)? (i_idx/pg + 1) : 0;
	UnicodeString ti_str = i_cnt;
	UnicodeString ci_str = i_idx;
	//ディレクトリ/ファイル
	UnicodeString td_str = d_cnt;
	UnicodeString tf_str = f_cnt;
	UnicodeString sd_str = sel_d_cnt;
	UnicodeString sf_str = sel_f_cnt;
	UnicodeString si_str = sel_d_cnt + sel_f_cnt;
	UnicodeString ad_str = (sel_d_cnt>0 && sel_d_cnt==d_cnt)? "All" : "";
	UnicodeString af_str = (sel_f_cnt>0 && sel_f_cnt==f_cnt)? "All" : "";
	UnicodeString sz_str = get_size_str_T(sel_size, SizeDecDigits);
	UnicodeString sb_str = get_size_str_B(sel_size, 0);
	//ドライブ
	UnicodeString dn_str = !lst_stt->is_FTP? get_drive_str(CurPath[tag]) : EmptyStr;
	UnicodeString vn_str, us_str, ub_str, ur_str, fs_str, fb_str, fr_str, ts_str, tb_str;
	if (!dn_str.IsEmpty()) {
		vn_str = lst_stt->vol_name;
		//ドライブ使用状況
		if (drv_upd) {
			lst_stt->vol_name = get_VolumeInfo(dn_str);
			ULARGE_INTEGER FreeAvailable, TotalBytes, FreeBytes;
			if (::GetDiskFreeSpaceEx(dn_str.c_str(), &FreeAvailable, &TotalBytes, &FreeBytes)) {
				lst_stt->drive_Total = TotalBytes.QuadPart;
				lst_stt->drive_Free  = FreeBytes.QuadPart;
				lst_stt->drive_Used  = lst_stt->drive_Total - lst_stt->drive_Free;
			}
			else lst_stt->drive_Total = lst_stt->drive_Free = lst_stt->drive_Used = 0;
		}
		us_str = get_size_str_T(lst_stt->drive_Used,  SizeDecDigits);
		ub_str = get_size_str_B(lst_stt->drive_Used,  0);
		fs_str = get_size_str_T(lst_stt->drive_Free,  SizeDecDigits);
		fb_str = get_size_str_B(lst_stt->drive_Free,  0);
		ts_str = get_size_str_T(lst_stt->drive_Total, SizeDecDigits);
		tb_str = get_size_str_B(lst_stt->drive_Total, 0);
		if (lst_stt->drive_Total>0) {
			ur_str.cat_sprintf(_T("%4.1f%%"), (float)(100.0 * lst_stt->drive_Used/lst_stt->drive_Total));
			fr_str.cat_sprintf(_T("%4.1f%%"), (float)(100.0 * lst_stt->drive_Free/lst_stt->drive_Total));
		}
		else {
			ur_str = fr_str = "--";
		}
	}
	else {
		us_str = ub_str = fs_str = fb_str = ts_str = tb_str = "----";
		ur_str = fr_str = "--";
	}

	//ドライブ情報/選択情報を表示
	UnicodeString fmt_str = !get_fmt.IsEmpty() ? get_fmt :
				  (sel_d_cnt>0 || sel_f_cnt>0) ? DrvInfFmtS :
				     is_root_dir(CurPath[tag]) ? DrvInfFmtR : DrvInfFmtN;

	UnicodeString rep_str;
	rep_str.sprintf(_T("$DN\t%s\n$TD\t%s\n$TF\t%s\n$SD\t%s\n"),
		dn_str.c_str(), td_str.c_str(), tf_str.c_str(), sd_str.c_str());
	rep_str.cat_sprintf(_T("$SF\t%s\n$SI\t%s\n$AD\t%s\n$AF\t%s\n"),
		sf_str.c_str(), si_str.c_str(), ad_str.c_str(), af_str.c_str());
	rep_str.cat_sprintf(_T("$SZ\t%s\n$SB\t%s\n$VN\t%s\n$US\t%s\n"),
		sz_str.c_str(), sb_str.c_str(), vn_str.c_str(), us_str.c_str());
	rep_str.cat_sprintf(_T("$UB\t%s\n$UR\t%s\n$FS\t%s\n$FB\t%s\n"),
		ub_str.c_str(), ur_str.c_str(), fs_str.c_str(), fb_str.c_str());
	rep_str.cat_sprintf(_T("$FR\t%s\n$TS\t%s\n$TB\t%s\n$TP\t%s\n"),
		fr_str.c_str(), ts_str.c_str(), tb_str.c_str(), tp_str.c_str());
	rep_str.cat_sprintf(_T("$CP\t%s\n$TI\t%s\n$CI\t%s\n"),
		cp_str.c_str(), ti_str.c_str(), ci_str.c_str());
	rep_str.cat_sprintf(_T("$SM\t%s\n"),
		get_word_i_idx(_T("名前|拡張子|日時|サイズ|属性|なし|場所"), TagSortMode(tag)).c_str());
	rep_str.cat_sprintf(_T("$S2\t%s\n"),
		get_word_i_idx(_T("名|拡|時|サ|属|無|場"), TagSortMode(tag)).c_str());
	rep_str.cat_sprintf(_T("$HS\t%c%c\n"), (ShowHideAtr? 'H' : '_'), (ShowSystemAtr? 'S' : '_'));
	std::unique_ptr<TStringList> r_lst(new TStringList());
	r_lst->Text = rep_str;

	UnicodeString stt_str = replace_str_by_list(fmt_str, r_lst.get());
	if (!get_fmt.IsEmpty()) return stt_str;

	//マスク
	UnicodeString mask_nam = lst_stt->is_Find? lst_stt->find_Mask :
							!lst_stt->is_Work? get_csv_item(PathMask[tag], 1) : EmptyStr;
	TStringList *sm_lst = SelMaskList[tag];
	UnicodeString msk_str;
	if (sm_lst->Count>0) msk_str += "SelMask";
	if (!mask_nam.IsEmpty())
		msk_str.cat_sprintf(_T("%s%s"), (msk_str.IsEmpty()? _T("Mask:") : _T(": ")), mask_nam.c_str());

	stt_str = msk_str + "\t" + stt_str;

	DriveInf[tag] = stt_str;
	SetDrivePanel(tag, stt_str);

	//カレントのカーソル移動チェック
	lp = FileListBox[CurListTag];
	if (last_idx!=lp->ItemIndex) {
		last_idx = lp->ItemIndex;
		//イベント: カーソル移動直後
		ExeEventCommand(OnFlCursor);
	}

	return stt_str;
}
//---------------------------------------------------------------------------
//ドライブ表示
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::SetDriveInfo(
	int tag,
	bool drv_upd,		//ドライブ情報を更新	(default = true)
	bool sel_upd)		//選択情報を更新		(default = true)
{
	GetDriveInfo(tag, drv_upd, sel_upd);
}

//---------------------------------------------------------------------------
//ファイルリスト項目の情報を表示
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::SetFileInf()
{
	if (!Initialized || UnInitializing || ScrMode!=SCMD_FLIST || CurWorking) return;

	//ディレクトリ比較結果リストのカーソル位置同期
	if (IsDiffList()) {
		TListBox *lp_c	= FileListBox[CurListTag];
		TListBox *lp_o	= FileListBox[OppListTag];
		lp_o->TopIndex	= lp_c->TopIndex;
		if (lp_o->ItemIndex!=lp_c->ItemIndex) {
			lp_o->ItemIndex = lp_c->ItemIndex;
			if (!has_KeyDownMsg()) lp_o->Repaint();
		}

		SetDirCaption(OppListTag);
		SetDriveFileInfo(OppListTag, false, false);
	}

	InfPanel->Visible = (PreviewPanel->Visible || InfListPanel->Visible);

	//検索情報
	if (CurStt->is_Find) SetDirCaption(CurListTag);

	//関係表示
	SetDirRelation();

	//ファイル情報
	StatusBar1->Panels->Items[0]->Text = EmptyStr;
	file_rec *cfp = GetCurFrecPtr(true, true);
	if (cfp) {
		UserModule->CurFileName = (!cfp->is_up && !cfp->is_dummy)? cfp->f_name : EmptyStr;

		//ワークリストの無チェックUNC項目
		if (CurStt->is_Work && StartsStr("\\\\", cfp->p_name) && NoCheckWorkUnc && !is_InvalidUnc(cfp->p_name)) {
			cfp->inf_list->Clear();
			cfp->inf_list->AddObject(cfp->b_name + cfp->f_ext,	(TObject*)(LBFLG_STD_FINF|LBFLG_FILE_FIF));
			cfp->inf_list->AddObject(cfp->p_name,				(TObject*)(LBFLG_STD_FINF|LBFLG_PATH_FIF));
			cfp->inf_list->AddObject("____",					(TObject*)(LBFLG_STD_FINF));
			add_WarnLine("存在チェックを行いません", cfp->inf_list);
			assign_InfListBox(GetCurInfListBox(), cfp->inf_list, (ScrMode==SCMD_IVIEW)? ImgInfScrPanel : InfScrPanel);
			return;
		}

		ViewFileInf(cfp);

		//サブビュアー
		if (SubViewer->Visible) {
			UnicodeString fnam;
			if (cfp && !cfp->is_ftp  && !cfp->is_dir) {
				if (cfp->is_virtual) {
					SetTmpFile(cfp);
					fnam = cfp->tmp_name;
				}
				else {
					fnam = cfp->f_name;
				}
			}
			SubViewer->DrawImage(fnam);
		}

		//結果リストのカーソル位置内容を反対パスに反映
		if (CurStt->is_Find && CurStt->find_ResLink && !OppStt->is_Find &&!cfp->is_dummy) {
			InhDirHist++;
			CurrToOppAction->Execute();
			InhDirHist--;
		}
	}

	if (FindBusy && !CurStt->find_TAG && !CurStt->find_MARK) {
		cursor_HourGlass();
		ShowMessageHint(USTR_SearchingESC, col_bgHint, false, true);
	}
}

//---------------------------------------------------------------------------
//ドライブ情報/ファイル情報を表示
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::SetDriveFileInfo(
	int tag,
	bool drv_upd,	//ドライブ情報を更新	(default = true)
	bool sel_upd)	//選択情報を更新		(default = true)
{
	SetDriveInfo(tag, drv_upd, sel_upd);
	if (tag==CurListTag) SetFileInf();
}

//---------------------------------------------------------------------------
//テキストプレビューの設定
//---------------------------------------------------------------------------
bool __fastcall TNyanFiForm::SetTxtPreview(
	UnicodeString fnam,		//ファイル名
	UnicodeString text,		//テキスト内容
	UnicodeString tail,		//末尾内容		(default = EmptyStr)
	int idx,				//インデックス	(default = 0)
	bool force_sw)			//強制表示		(default = false)
{
	if (UserHighlight->Recycle()) AddErr_Highlight();

	if (!PreviewPanel->Visible || LockTxtPrv) return false;

	TxtPrvFile		  = fnam;
	TxtPrvBuff->Text  = text;
	TxtTailBuff->Text = tail;

	if (force_sw) TxtPrvListPanel->Visible = true;
	TxtPrvListBox->TabWidth = get_ViewTabWidth(get_extension(fnam));	//描画のために流用
	TxtPrvListBox->Tag		= TxtPrvShowLineNo? LBTAG_OPT_LNNO : 0;
	assign_FileListBox(TxtPrvListBox, TxtPrvBuff, idx, TxtPrvScrPanel);
	if (force_sw) TxtPrvListBox->Repaint();

	if (TxtPrvBuff->Count>=PrvActTailLn && TxtTailBuff->Count>0) {
		TxtTailListBox->TabWidth = TxtPrvListBox->TabWidth;
		TxtTailListBox->Tag		 = TxtPrvListBox->Tag;
		assign_FileListBox(TxtTailListBox, TxtTailBuff, TxtTailBuff->Count - 1, TxtTailScrPanel);
	}
	else {
		TxtTailListBox->Count = 0;
	}

	return true;
}

//---------------------------------------------------------------------------
//ステータスバーにファイル情報を表示
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::SetSttBarInf(
	file_rec *fp,				// (default = NULL)
	UnicodeString *stt_txt)		// (default = NULL)
{
	if (!Initialized || UnInitializing || (!StatusBar1->Visible && !stt_txt)) return;

	if (!fp) fp = GetCurFrecPtr();

	int div_p = 0;
	UnicodeString stt_str, bnam, pnam;

	if (fp) {
		if (fp->is_virtual && !contains_Slash(fp->f_name))
			pnam.sprintf(_T("%s%s\\%s"), CurPath[CurListTag].c_str(), ExtractFileName(fp->arc_name).c_str(), fp->p_name.c_str());
		else
			pnam = fp->p_name;
		bnam = warn_filename_RLO(fp->n_name);
	}
	else
		pnam = CurStt->is_FTP? CurFTPPath : CurPath[CurListTag];

	//書式文字列の展開
	UnicodeString fmt = SttBarFmt;
	bool fp_ok = (fp && !fp->is_dummy && fp->f_attr!=faInvalid);

	while (!fmt.IsEmpty()) {
		WideChar c = split_top_wch(fmt);
		if (c=='$') {
			if (StartsStr("PR(", fmt)) {
				TStringDynArray s_buf = get_csv_array(split_in_paren(fmt), 3);
				if (fp_ok && s_buf.Length>0) {
					UnicodeString vstr = get_FileInfValue(fp, s_buf[0]);
					if (!vstr.IsEmpty()) {
						if ((s_buf.Length>1)) stt_str += s_buf[1];	//前置
						stt_str += vstr;
						if ((s_buf.Length>2)) stt_str += s_buf[2];	//後置
					}
				}
			}
			else if (remove_top_s(fmt, _T("P2")))	stt_str += yen_to_delimiter(pnam);
			else if (remove_top_s(fmt, 'P'))		stt_str += pnam;
			else if (remove_top_s(fmt, _T("F2")))	stt_str += yen_to_delimiter(pnam + bnam);
			else if (remove_top_s(fmt, 'F'))		stt_str += pnam + bnam;
			else if (remove_top_s(fmt, 'B'))		stt_str += bnam;
			else if (remove_top_s(fmt, _T("S2"))) {
				stt_str += get_word_i_idx(_T("名|拡|時|サ|属|無|場"), CurSortMode());
			}
			else if (remove_top_s(fmt, 'S')) {
				stt_str += get_word_i_idx(_T("名前|拡張子|日時|サイズ|属性|なし|場所"), CurSortMode());
			}
			else if (remove_top_s(fmt, _T("HS")))	stt_str.cat_sprintf(_T("%c%c"), (ShowHideAtr? 'H' : '_'), (ShowSystemAtr? 'S' : '_'));
			else if (remove_top_s(fmt, _T("DV")))	div_p = stt_str.Length() + 1;
			else if (remove_top_s(fmt, 'M'))		{ if (fp_ok) stt_str += IniFile->GetMarkMemo(fp->r_name); }
			else if (remove_top_s(fmt, 'Z'))		{ if (fp_ok) stt_str += get_FileSizeStr(fp->f_size); }
			else if (remove_top_s(fmt, 'Y'))		{ if (fp_ok) stt_str += get_size_str_B(fp->f_size, 0); }
			else if (remove_top_s(fmt, 'T'))		{ if (fp_ok) stt_str += FormatDateTime(TimeStampFmt, fp->f_time); }
		}
		else stt_str.cat_sprintf(_T("%c"), c);
	}

	//$DV以降を右寄せ
	if (div_p>0) stt_str.Insert("\t", div_p);

	if (stt_txt)
		*stt_txt = stt_str;
	else
		StatusBar1->Panels->Items[0]->Text = stt_str;
}

//---------------------------------------------------------------------------
//ファイルリストのヘッダを設定
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::SetListHeader(int tag)
{
	THeaderControl *hp = (tag==1)? R_HeaderControl : L_HeaderControl;
	if (hp->Visible) {
		THeaderSections *sp = hp->Sections;
		sp->Items[0]->MinWidth = get_CharWidth(Canvas, 8, ScaledInt((IconMode>0)? 20 : 8));
		sp->Items[0]->MaxWidth = ClientWidth;

		for (int i=1; i<sp->Count; i++) {
			sp->Items[i]->MinWidth = 0;
			sp->Items[i]->MaxWidth = ClientWidth;
		}

		flist_stt *lst_stt = &ListStt[tag];
		int mgn = hp->Width - lst_stt->lxp_right + 8;
		sp->Items[1]->Width = lst_stt->lwd_fext + (HideSizeTime? mgn : 8);
		sp->Items[4]->Width = HideSizeTime? 0 :
								(lst_stt->is_Find && (FindPathColumn || (lst_stt->find_TAG && FindTagsColumn)))?
									 std::max(hp->ClientWidth - ListStt[tag].lxp_path, 0) : 0;
		sp->Items[3]->Width = HideSizeTime? 0 :
								std::max(hp->ClientWidth - sp->Items[4]->Width - ListStt[tag].lxp_time, 0);
		sp->Items[2]->Width = HideSizeTime? 0 :
								std::max(hp->ClientWidth - sp->Items[4]->Width - sp->Items[3]->Width - ListStt[tag].lxp_size, 0);
		adjust_HeaderSecWidth(hp, 0);

		for (int i=0; i<sp->Count; i++) {
			sp->Items[i]->MinWidth = sp->Items[i]->Width;
			sp->Items[i]->MaxWidth = sp->Items[i]->Width;
		}

		sp->Items[4]->Text = (lst_stt->is_Find && lst_stt->find_TAG && FindTagsColumn)? "タグ(場所)" : "場所";
		hp->Invalidate();
	}
}
//---------------------------------------------------------------------------
//ファイルリストのヘッダを描画
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::FL_HeaderControlDrawSection(THeaderControl *HeaderControl,
		THeaderSection *Section, const TRect &Rect, bool Pressed)
{
	int s_mode;
	switch (Section->Index) {
	case 0: s_mode = 0; break;
	case 1: s_mode = 1; break;
	case 2: s_mode = 3; break;
	case 3: s_mode = 2; break;
	case 4: s_mode = 4; break;
	}

	int tag = HeaderControl->Tag;
	flist_stt *lst_stt = &ListStt[tag];

	int mk_mode = 0;
	if (s_mode==4) {
		if (lst_stt->is_Find && lst_stt->find_PathSort) mk_mode = FlOdrDscPath[tag]? -1 :  1;
	}
	else if ((!lst_stt->is_Find || !lst_stt->find_PathSort) && s_mode==SortMode[tag]) {
		switch (Section->Index) {
		case 0: mk_mode = FlOdrDscName[tag]? -1 :  1;	break;
		case 1: mk_mode = FlOdrDscName[tag]? -1 :  1;	break;
		case 2: mk_mode = FlOdrSmall[tag]?    1 : -1;	break;
		case 3: mk_mode = FlOdrOld[tag]?      1 : -1;	break;
		}
	}

	draw_SortHeader(HeaderControl, Section, Rect, mk_mode);
}

//---------------------------------------------------------------------------
//ファイルリストの再描画
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::RepaintList(
	int tag,					//リストタグ	(default = -1 左右とも)
	UnicodeString cur_fnam,		//カーソル位置のファイル名 (default = EmptyStr)
	bool sort_sw)				//要ソート		(default = false)
{
	if (!Initialized || UnInitializing) return;

	if (ScrMode!=SCMD_FLIST) return;

	if (tag==-1 || tag==0) set_RedrawOff(FileListBox[0]);
	if (tag==-1 || tag==1) set_RedrawOff(FileListBox[1]);
	{
		if (cur_fnam.IsEmpty() && (tag==-1 || tag==CurListTag)) cur_fnam = GetCurFileName();

		//状態表示
		for (int i=0; i<MAX_FILELIST; i++) {
			flist_stt *lst_stt = &ListStt[i];
			if (tag!=-1 && tag!=i) continue;
			if (lst_stt->is_IncSea) continue;

			if (!lst_stt->is_Arc && !lst_stt->is_Find && !lst_stt->is_Work) {
				if (!CheckUncPath(CurPath[i]))
					CurPath[i] = CheckAvailablePath(EmptyStr, i);
				else if (!dir_exists(CurPath[i]))
					CurPath[i] = get_parent_path(CurPath[i]);
			}

			//ディレクトリ情報を表示
			SetDirCaption(i);
			SetDriveInfo(i);

			//背景色を設定
			TListBox *lp = FileListBox[i];
			lp->Color = get_FlBgColor(lst_stt);

			//ソート(リストボックスに再割り当て)
			if (sort_sw) {
				TStringList *lst = GetFileList(i);
				SortList(lst, i);
				assign_FileListBox(lp, lst);
			}

			//ヘッダを設定
			SetListHeader(i);
		}
		if ((tag==-1 || tag==CurListTag) && !cur_fnam.IsEmpty()) IndexOfFileList(cur_fnam);
	}
	if (tag==-1 || tag==0) set_RedrawOn(FileListBox[0]);
	if (tag==-1 || tag==1) set_RedrawOn(FileListBox[1]);

	SetSttBarInf();
}

//---------------------------------------------------------------------------
//ディレクトリ履歴に追加
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::AddDirHistory(UnicodeString dnam, int tag)
{
	if (InhDirHist>0) return;

	//除外するパスのチェック
	if (ends_PathDlmtr(dnam) && match_path_list(dnam, NoDirHistPath)) return;

	TStringList *h_lst = get_DirHistory(TabControl1->TabIndex, tag);
	int *h_ptr = get_DirHistPtr(TabControl1->TabIndex, tag);
	if (h_lst && h_ptr) {
		//進む部分を削除
		for (int i=0; i<*h_ptr && h_lst->Count>0; i++) h_lst->Delete(0);
		*h_ptr = 0;

		if (indexof_csv_list(h_lst, dnam, 0)!=0) {
			//重複する履歴を削除
			for (;DelDplDirHist;) {
				int idx = indexof_csv_list(h_lst, dnam, 0);
				if (idx!=-1) h_lst->Delete(idx); else break;
			}
			//先頭に追加
			if (file_exists(dnam))
				h_lst->Insert(0, UnicodeString().sprintf(_T("\"%s\",%d"), dnam.c_str(), FileListBox[tag]->ItemIndex));
		}
	}

	//全体履歴
	h_lst = AllDirHistory;
	if (indexof_csv_list(h_lst, dnam, 0)!=0) {
		//重複する履歴を削除
		for (;;) {
			int idx = indexof_csv_list(h_lst, dnam, 0);
			if (idx!=-1) h_lst->Delete(idx); else break;
		}
		//先頭に追加
		if (file_exists(dnam))
			h_lst->Insert(0, UnicodeString().sprintf(_T("\"%s\",%d"), dnam.c_str(), FileListBox[tag]->ItemIndex));
	}
}

//---------------------------------------------------------------------------
//ディレクトリ履歴/スタックを調べ、存在しない項目や不正項目を削除
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::CheckDirHistory(int tag, UnicodeString drv)
{
	if (NoCheckDirHist) return;

	//チェックすべき履歴・スタックの項目を取得
	std::unique_ptr<TStringList> dir_lst(new TStringList());
	for (int i=0; i<2; i++) {
		TStringList *h_lst = (i==0)? get_DirHistory(TabControl1->TabIndex, tag) : DirStack;
		if (h_lst) {
			for (int j=0; j<h_lst->Count; j++) {
				UnicodeString dnam = get_csv_item(h_lst->Strings[j], 0);
				bool d_flag = !drv.IsEmpty()? StartsText(drv, dnam) : true;
				if (d_flag && dir_lst->IndexOf(dnam)==-1) dir_lst->Add(dnam);
			}
		}
	}
	dir_lst->Sort();

	//チェック不要の項目を調べながら存在チェック
	std::unique_ptr<TStringList> checked_lst(new TStringList());	//チェック済みリスト
	bool changed = false;
	for (int i=dir_lst->Count-1; i>=0; i--) {
		UnicodeString dnam = dir_lst->Strings[i];
		if (!ends_PathDlmtr(dnam)) continue;
		if (checked_lst->IndexOf(dnam)!=-1) continue;

		if (StartsText(dnam, CurPath[0]) || StartsText(dnam, CurPath[1])) {
			checked_lst->Add(dnam);
		}
		else {
			//dnam のサブディレクトリ・リストを取得
			std::unique_ptr<TStringList> sub_lst(new TStringList());
			for (int j=0; j<i; j++) {
				UnicodeString snam = dir_lst->Strings[j];
				if (StartsText(dnam, snam)) sub_lst->Add(snam);
			}
			//存在する
			if (is_dir_accessible(dnam)) {
				checked_lst->Add(dnam);
				for (int j=0; j<sub_lst->Count; j++) {
					UnicodeString snam = sub_lst->Strings[j];
					if (checked_lst->IndexOf(snam)==-1) checked_lst->Add(snam);
				}
			}
			//存在しない
			else {
				//履歴・スタックから項目を削除
				for (int j=0; j<MAX_FILELIST+1; j++) {
					TStringList *h_lst = (j<MAX_FILELIST)? get_DirHistory(TabControl1->TabIndex, j) : DirStack;
					if (!h_lst) continue;
					for (int k=-1; k<sub_lst->Count; k++) {
						UnicodeString snam = (k==-1)? dnam : sub_lst->Strings[k];
						for (;;) {
							int idx = indexof_csv_list(h_lst, snam, 0);
							if (idx!=-1) {
								h_lst->Delete(idx);
								if (j<MAX_FILELIST) {
									int *h_ptr = get_DirHistPtr(TabControl1->TabIndex, j);
									if (h_ptr && idx<*h_ptr) --(*h_ptr);
								}
								changed = true;
							}
							else break;
						}
					}
				}
			}
		}
	}

	//連続する冗長な履歴を削除
	if (changed) {
		for (int i=0; i<MAX_FILELIST+1; i++) {
			TStringList *h_lst = (i<MAX_FILELIST)? get_DirHistory(TabControl1->TabIndex, i) : DirStack;
			if (!h_lst) continue;
			int j = 0;
			while (j < h_lst->Count-1) {
				if (SameText(get_csv_item(h_lst->Strings[j], 0), get_csv_item(h_lst->Strings[j + 1], 0))) {
					h_lst->Delete(j + 1);
					if (i<MAX_FILELIST) {
						int *h_ptr = get_DirHistPtr(TabControl1->TabIndex, i);
						if (h_ptr && j<*h_ptr) --(*h_ptr);
					}
				}
				else j++;
			}
		}
	}
}

//---------------------------------------------------------------------------
//UNCパスの場合、その存在をチェック
//  ESC で中断可能(スレッドでチェック)
//---------------------------------------------------------------------------
bool __fastcall TNyanFiForm::CheckUncPath(UnicodeString pnam)
{
	if (!CheckUnc || !StartsStr("\\\\", pnam)) return true;

	TCheckPathThread *tp = new TCheckPathThread(true);
	tp->PathName = pnam;
	tp->Start();

	while (HIBYTE(::GetAsyncKeyState(VK_ESCAPE))!=0) Sleep(50);	//誤中断防止

	int cnt = 0;
	bool canceled = false;
	while (!tp->PathName.IsEmpty()) {
		if (is_KeyPress_ESC()) {
			ClearKeyBuff(true);
			canceled = true;
			break;
		}
		Sleep(100);
		cnt++;
		if (cnt==10) {	//1秒後にヒント表示
			ShowMessageHint(_T(" UNCパスをチェック中...\r\n　　ESCキーで中断します。\r\n"), col_bgHint, false, true, true);
		}
	}
	MsgHint->ReleaseHandle();

	bool ok = tp->isOk;
	int idx = InvalidUncList->IndexOf(pnam);
	if (!ok) {
		if (idx==-1) InvalidUncList->Add(pnam);
		GlobalErrMsg = canceled? LoadUsrMsg(USTR_Canceled) : SysErrorMessage(ERROR_PATH_NOT_FOUND);
	}
	else {
		if (idx!=-1) InvalidUncList->Delete(idx);
		GlobalErrMsg = EmptyStr;
	}

	tp->Terminate();

	return ok;
}

//---------------------------------------------------------------------------
bool __fastcall TNyanFiForm::CheckPath(UnicodeString dnam)
{
	if (!is_drive_accessible(dnam)) return false;

	if ((!NoCheckRecentUnc || !StartsStr("\\\\", dnam))
		&& (is_InvalidUnc(dnam) || !CheckUncPath(dnam) || !dir_exists(dnam)))
	{
		return false;
	}

	return true;
}

//---------------------------------------------------------------------------
//カレントディレクトの変更 (CurPath プロパティ)
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::SetCurPath(
	int Index,				//リストタグ
	UnicodeString Value)	//ディレクトリ名
							//  末尾が\でないドライブ名の場合、ルートに設定
							//  末尾が\のドライブ名の場合、履歴から設定
{
	GlobalErrMsg = EmptyStr;

	UnicodeString l_pnam = CurPath[Index];

	if (Index>=0 && Index<MAX_FILELIST && !Value.IsEmpty()) {
		UnicodeString dnam;

		//UNCパスのチェック
		if (!CheckUncPath(Value)) {
			dnam = CheckAvailablePath(EmptyStr, Index);
		}
		//通常パスのチェック
		else {
			//アクセス可能か？
			if (!is_dir_accessible(Value) && !l_pnam.IsEmpty()) {
				GlobalErrMsg = LoadUsrMsg(USTR_CantAccessDir);	return;
			}
			dnam = CheckAvailablePath(Value, Index);
		}

		if (dnam.IsEmpty()) {
			GlobalErrMsg = LoadUsrMsg(USTR_NotFound, _T("利用可能なドライブ"));	return;
		}

		if (!drive_exists(dnam) && !dir_exists(dnam)) {
			GlobalErrMsg = SysErrorMessage(ERROR_PATH_NOT_FOUND);	return;
		}

		//履歴を検索
		UnicodeString h_dnam;
		int h_idx = 0;
		TStringList *h_lst = get_DirHistory(TabControl1->TabIndex, Index);
		int *h_ptr = get_DirHistPtr(TabControl1->TabIndex, Index);

		//ルート
		if (SameText(dnam, get_drive_str(dnam))) {
			if (StartsText(dnam, l_pnam)) {
				h_dnam = l_pnam;
			}
			else {
				//履歴から探す
				CheckDirHistory(Index, dnam);	//該当ドライブの履歴のみチェック
				if (h_lst) {
					for (int i=0; i<h_lst->Count; i++) {
						TStringDynArray itm_buf = get_csv_array(h_lst->Strings[i], 2, true);
						if (!ends_PathDlmtr(itm_buf[0])) continue;
						if (StartsText(dnam, itm_buf[0])) {
							h_dnam = itm_buf[0];
							h_idx  = itm_buf[1].ToIntDef(0);
							break;
						}
					}
				}
			}
		}
		//ルート以外
		else {
			TStringDynArray itm_buf = record_of_csv_list(h_lst, dnam, 0, 2);
			if (itm_buf.Length==2) {
				h_dnam = dnam;
				h_idx  = itm_buf[1].ToIntDef(0);
			}
		}

		//存在しないディレクトリを履歴から削除
		if (h_lst && !h_dnam.IsEmpty() && !dir_exists(h_dnam)) {
			int idx = 0;
			while (idx<h_lst->Count) {
				if (StartsText(h_dnam, get_csv_item(h_lst->Strings[idx], 0))) {
					h_lst->Delete(idx);
					if (idx<*h_ptr) --(*h_ptr);
				}
				else idx++;
			}
			h_dnam = EmptyStr;
		}

		dnam = IncludeTrailingPathDelimiter(!h_dnam.IsEmpty()? h_dnam : dnam);
		is_InvalidUnc(dnam, true);

		TListBox *lp = FileListBox[Index];

		//直前のディレクトリのカーソル位置を保存
		TStringList *h_lst0 = get_DirHistory(CurTabIndex, Index);
		int *h_ptr0 = get_DirHistPtr(CurTabIndex, Index);
		if (h_lst0 && h_ptr0) {
			if (*h_ptr0>=0 && *h_ptr0<h_lst0->Count && *h_ptr0==indexof_csv_list(h_lst0, l_pnam, 0))
				h_lst0->Strings[*h_ptr0] = UnicodeString().sprintf(_T("\"%s\",%d"), l_pnam.c_str(), lp->ItemIndex);
		}

		set_RedrawOff(lp);
		{
			try {
				bool chg_img = false;
				//同じディレクトリ
				if (SameText(dnam, l_pnam) && !ApplyDotNyan) {
					FCurPath[Index] = get_case_name(dnam);
					UpdateList(FileList[Index], l_pnam, Index);
					SetDirWatch(dnam, Index);
					assign_FileListBox(lp, FileList[Index],
						((TabControl1->TabIndex==CurTabIndex)? lp->ItemIndex : h_idx), FlScrPanel[Index]);
				}
				//ディレクトリが変化
				else {
					flist_stt *lst_stt = &ListStt[Index];

					SelMaskList[Index]->Clear();
					if (!dir_exists(dnam)) Abort();

					bool is_cur 	 = (Index==CurListTag);
					bool cur_changed = (is_cur && !SameText(FCurPath[Index], dnam) && Initialized && !UnInitializing);
					bool drv_changed = (!SameText(ExtractFileDrive(FCurPath[Index]), ExtractFileDrive(dnam))
											&& Initialized && !UnInitializing);

					UnicodeString on_CurChange = is_cur? OnCurChange : EmptyStr;

					//プロパティ更新
					FCurPath[Index] = get_case_name(dnam);
					if (drv_changed) SetDriveInfo(Index);

					if (Index==OppListTag) UserModule->OppPathName = CurPath[OppListTag];

					//ライブラリパスのチェック
					if (!lst_stt->LibraryInfo.IsEmpty()) {
						if (!StartsText(IncludeTrailingPathDelimiter(get_post_tab(lst_stt->LibraryInfo)), dnam))
							lst_stt->LibraryInfo = lst_stt->LibSubPath = EmptyStr;
					}

					//------------------------------
					//.nyanfi による設定
					//------------------------------
					ApplyDotNyan = false;

					//個別配色をリセット
					ResetIndColor(Index);

					UnicodeString cfg_nam = get_dotNaynfi(CurPath[Index], InheritDotNyan);
					if (file_exists(cfg_nam)) {
						std::unique_ptr<TStringList> cfg_lst(new TStringList());
						load_text_ex(cfg_nam, cfg_lst.get());
						for (int i=0; i<cfg_lst->Count; i++) {
							UnicodeString lbuf = Trim(cfg_lst->Strings[i]);
							if (lbuf.IsEmpty() || StartsStr(';', lbuf)) continue;
							UnicodeString key = split_tkn(lbuf, '=');	if (lbuf.IsEmpty()) continue;

							switch (idx_of_word_i(
								_T("PathMask|SortMode|NaturalOrder|DscNameOrder|SmallOrder|OldOrder|DscAttrOrder|")				//0..6
								_T("Color_bgDirInf|Color_fgDirInf|Color_bgDrvInf|Color_fgDrvInf|Color_Cursor|Color_selItem"),	//7..12
								key))
							{
							case 0: {
									UnicodeString dsc;
									UnicodeString mask = extract_ExeParam(lbuf, &dsc);
									PathMask[Index] = make_PathMask(mask, dsc);
								}
								break;
							case 1: {
									int idx = SortIdStr.Pos(lbuf[1]);	if (idx==0) break;
									idx--;
									SortMode[Index] = idx;
								}
								break;

							case  2: FlOdrNatural[Index] = equal_1(lbuf);	break;
							case  3: FlOdrDscName[Index] = equal_1(lbuf);	break;
							case  4: FlOdrSmall[Index]	 = equal_1(lbuf);	break;
							case  5: FlOdrOld[Index]	 = equal_1(lbuf);	break;
							case  6: FlOdrDscAttr[Index] = equal_1(lbuf);	break;

							case  7: str_to_Color(lst_stt->color_bgDirInf,	lbuf);	break;
							case  8: str_to_Color(lst_stt->color_fgDirInf,	lbuf);	break;
							case  9: str_to_Color(lst_stt->color_bgDrvInf,	lbuf);	break;
							case 10: str_to_Color(lst_stt->color_fgDrvInf,	lbuf);	break;
							case 11: str_to_Color(lst_stt->color_Cursor,	lbuf);	break;
							case 12: str_to_Color(lst_stt->color_selItem,	lbuf);	break;

							//以下はカレントのみ
							default:
								if (is_cur) {
									bool flag = equal_1(lbuf);
									UnicodeString fnam, msg;

									switch (idx_of_word_i(
										_T("ShowHideAtr|ShowSystemAtr|ShowByteSize|ShowIcon|SyncLR|")			//0..4
										_T("GrepMask|ListWidth|BgImage|PlaySound|ExeCommands|Handled"), key))	//5..10
									{
									case 0: ShowHideAtr   = flag;					break;
									case 1: ShowSystemAtr = flag;					break;
									case 2: ShowByteSize  = flag;					break;
									case 3: IconMode = std::min(std::max(lbuf.ToIntDef(0), 0), 2);	break;
									case 4: SyncLR		  = flag;					break;
									case 5: GrepMaskComboBox->Text = lbuf;			break;
									case 6: ExeCommandAction("WidenCurList", lbuf);	break;
									case 7:
										if (BgImgMode==1 || BgImgMode==2) {
											fnam = to_absolute_name(lbuf);
											msg  = make_LogHdr(_T("BGIMG"), fnam);
											int tag  = (BgImgMode==2)? CurListTag : 0;
											if (load_ImageFile(fnam, BgImgBuff[tag])) {
												BgImgName[tag] = to_relative_name(fnam);
												UpdateBgImage();
												chg_img = true;
											}
											else set_LogErrMsg(msg, LoadUsrMsg(USTR_FaildLoad));
											AddLog(msg);
										}
										break;
									case 8:
										fnam = to_absolute_name(lbuf);
										if (file_exists(fnam)) play_sound_ex(fnam, false);
										break;
									case 9:
										if (!Initialized || UnInitializing) break;
										if (PermitDotCmds && remove_top_AT(lbuf) && ExtractFileDrive(lbuf).IsEmpty()) {
											on_CurChange = "@" + lbuf;
										}
										else {
											msg = make_LogHdr(_T("EXCMDS"), lbuf);
											set_LogErrMsg(msg, "許可されないコマンドです。");
											AddLog(msg);
										}
										break;
									case 10:
										if (flag) on_CurChange = EmptyStr;
										break;
									}
								}
							}	//end if switch
						}	//end of for
					}

					//ファイルリスト更新
					UpdateList(FileList[Index], CurPath[Index], Index);
					SetDirWatch(dnam, Index);
					assign_FileListBox(lp, FileList[Index], (DirHistCsrPos? h_idx : 0), FlScrPanel[Index]);

					//カレントを履歴へ
					AddDirHistory(CurPath[Index], Index);
					//グラフ表示等の解除
					lst_stt->show_f_d_cnt = lst_stt->dir_graph = lst_stt->dsk_graph = false;

					//カレント側が変化
					if (cur_changed) {
						//反対側ディレクトリの同期
						if (SyncLR && IsCurFList()) {
							if (IsOppFList()) {
								//親ディレクトリへ
								if (SameText(IncludeTrailingPathDelimiter(get_parent_path(l_pnam)), dnam)) {
									if (SameText(ExtractFileName(ExcludeTrailingPathDelimiter(l_pnam)),
												 ExtractFileName(ExcludeTrailingPathDelimiter(CurPath[OppListTag]))))
										OppToParent();
								}
								//サブディレクトリへ
								else {
									UnicodeString onam = CurPath[OppListTag] + ExtractFileName(ExcludeTrailingPathDelimiter(dnam));
									if (IndexOfFileList(onam, OppListTag)!=-1) {
										FCurPath[OppListTag] = IncludeTrailingPathDelimiter(onam);
										UpdateList(FileList[OppListTag], CurPath[OppListTag], OppListTag);
										SetDirWatch(CurPath[OppListTag], OppListTag);
										assign_FileListBox(FileListBox[OppListTag], FileList[OppListTag], -1, FlScrPanel[OppListTag]);
										RepaintList(OppListTag);
									}
								}
							}
							else if (OppStt->is_FTP) {
								if (SameText(IncludeTrailingPathDelimiter(get_parent_path(l_pnam)), dnam)) {
									//親ディレクトリへ
									if (SameText(
										ExtractFileName(ExcludeTrailingPathDelimiter(l_pnam)),
										ExtractFileName(ExcludeTrailingPathDelimiter(CurFTPPath))))
									{
										UnicodeString lnam = ExcludeTrailingPathDelimiter(CurFTPPath);
										if (!ChangeFtpFileList(OppListTag, "..", lnam)) GlobalAbort();
									}
								}
								else {
									//サブディレクトリへ
									UnicodeString onam = CurFTPPath + ExtractFileName(ExcludeTrailingPathDelimiter(dnam));
									if (IndexOfFileList(onam, OppListTag)!=-1) {
										if (!ChangeFtpFileList(OppListTag, ExtractFileName(onam), "..")) GlobalAbort();
									}
								}
							}
						}

						SetCurStt(CurListTag, true);
						CurStt->cmp_total = -1;

						//イベント: カレントのディレクトリ変更
						ExeEventCommand(on_CurChange);
					}
				}
				if (Initialized && !UnInitializing) RepaintList(chg_img? -1 : Index);
			}
			catch (...) {
				;
			}
		}

		set_RedrawOn(lp);
	}
}

//---------------------------------------------------------------------------
//監視ディレクトリを設定
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::SetDirWatch(UnicodeString dnam, int tag)
{
	if (hWatchDir[tag]) ::FindCloseChangeNotification(hWatchDir[tag]);
	hWatchDir[tag] = NULL;
	WatchPath[tag] = EmptyStr;

	//監視から除外するパスのチェック
	if (WatchDirTimer->Interval>0
		&& !match_path_list(dnam, NoWatchPath, true))	//除外チェック
	{
		DWORD filter =
				FILE_NOTIFY_CHANGE_FILE_NAME | FILE_NOTIFY_CHANGE_DIR_NAME |
				FILE_NOTIFY_CHANGE_ATTRIBUTES | FILE_NOTIFY_CHANGE_SIZE |
				FILE_NOTIFY_CHANGE_LAST_WRITE;

		HANDLE res = ::FindFirstChangeNotification(dnam.c_str(), FALSE, filter);
		if (res!=INVALID_HANDLE_VALUE) {
			hWatchDir[tag] = res;
			WatchPath[tag] = dnam;
		}
	}
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::SetDirWatch(bool active)
{
	for (int i=0; i<MAX_FILELIST; i++) {
		if (hWatchDir[i]) ::FindCloseChangeNotification(hWatchDir[i]);
		hWatchDir[i] = NULL;
		if (active && WatchDirTimer->Interval>0 && !WatchPath[i].IsEmpty()) {
			DWORD filter =
					FILE_NOTIFY_CHANGE_FILE_NAME | FILE_NOTIFY_CHANGE_DIR_NAME |
					FILE_NOTIFY_CHANGE_ATTRIBUTES | FILE_NOTIFY_CHANGE_SIZE |
					FILE_NOTIFY_CHANGE_LAST_WRITE;

			HANDLE res = ::FindFirstChangeNotification(WatchPath[i].c_str(), FALSE, filter);
			if (res!=INVALID_HANDLE_VALUE) hWatchDir[i] = res;
		}
	}
}

//---------------------------------------------------------------------------
//選択マスクの適用
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ApplySelMask(TStringList *lst, int tag, UnicodeString dnam)
{
	TStringList *sm_lst = SelMaskList[tag];
	if (sm_lst->Count==0) return;
	if (!dnam.IsEmpty() && !SameText(dnam, ExtractFilePath(sm_lst->Strings[0]))) return;

	int i = 0;
	while (i<lst->Count) {
		file_rec *fp = (file_rec*)lst->Objects[i];
		if (!fp->is_up && sm_lst->IndexOf(fp->f_name)==-1) del_FileListItem(lst, i); else i++;
	}
}

//---------------------------------------------------------------------------
//ファイルリストにパスマスクを適用
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ApplyPathMask(TStringList *lst, int tag)
{
	if (tag!=0 && tag!=1) return;

	//パスマスク
	UnicodeString mask_str = get_csv_item(PathMask[tag], 2);
	if (!mask_str.IsEmpty() && !USAME_TS(mask_str, "*")) {
		std::unique_ptr<TStringList> f_msk(new TStringList());
		std::unique_ptr<TStringList> d_msk(new TStringList());
		SplitMasksFD(mask_str, f_msk.get(), d_msk.get());

		int i = 0;
		while (i<lst->Count) {
			file_rec *fp = (file_rec*)lst->Objects[i];
			if (fp->is_up || fp->is_dummy) {
				i++;
			}
			else {
				bool match = false, excld = false;
				TStringList *m_lst = fp->is_dir? d_msk.get() : f_msk.get();
				for (int j=0; j<m_lst->Count; j++) {
					UnicodeString mask = m_lst->Strings[j];
					if (remove_top_s(mask, '!')) {
						 if (str_match(mask, fp->n_name)) excld = true;
					}
					else if (USAME_TS(mask, "*") || str_match(mask, fp->n_name)) {
						match = true;
					}
				}
				if (!match || excld) del_FileListItem(lst, i); else i++;
			}
		}
	}
}

//---------------------------------------------------------------------------
//ファイルリストの更新
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::UpdateList(TStringList *lst, UnicodeString dnam, int tag)
{
	if (InhUpdate) return;
	InhUpdate = true;

	cursor_HourGlass();

	while (HIBYTE(::GetAsyncKeyState(VK_ESCAPE)) != 0) Sleep(50);	//誤中断防止

	//直前の選択状態を取得
	std::unique_ptr<TStringList> sel_lst(new TStringList());
	GetSelList(lst, sel_lst.get());

	clear_FileList(lst);

	if (!contains_PathDlmtr(ExcludeTrailingPathDelimiter(dnam))) dnam = to_path_name(dnam);

	UnicodeString sea_str = dnam + "*.*";
	bool is_NTFS = false;
	if (StartsStr("\\\\", sea_str)) {
		sea_str.Insert("?\\UNC\\", 3);
	}
	else {
		sea_str.Insert("\\\\?\\", 1);
		drive_info *dp = get_DriveInfo(dnam);
		is_NTFS = dp? dp->is_NTFS : false;
	}

	TSearchRec sr;
	if (FindFirst(sea_str, faAnyFile, sr)==0) {
		bool is_root = is_root_dir(dnam);
		bool has_up  = false;

		do {
			if (USAME_TS(sr.Name, ".")) continue;

			if (USAME_TS(sr.Name, "..")) {
				if (is_root) continue;	//ネットワークドライブでルートに .. が付くのを抑止
				has_up = true;
			}
			else {
				//表示設定は通常項目に適用
				if (!ShowHideAtr   && (sr.Attr & faHidden))  continue;
				if (!ShowSystemAtr && (sr.Attr & faSysFile)) continue;
			}

			file_rec *fp = cre_new_file_rec();
			fp->tag		 = tag;
			fp->is_dir	 = (sr.Attr & faDirectory);
			fp->is_sym	 = (sr.Attr & faSymLink);
			fp->p_name	 = dnam;
			fp->f_name	 = dnam + sr.Name;
			fp->n_name	 = sr.Name;
			fp->r_name	 = fp->f_name;
			if (fp->is_sym) fp->l_name = get_ReparsePointTarget(fp->f_name, fp->is_jct);

			//ディレクトリ
			if (fp->is_dir) {
				fp->b_name = fp->n_name;
				fp->is_up  = USAME_TS(fp->b_name, "..");
			}
			//ファイル
			else {
				fp->f_ext  = ExtractFileExt(StartsStr('.', fp->n_name)? exclude_top(fp->n_name) : fp->n_name);
				fp->b_name = fp->f_ext.IsEmpty()? fp->n_name : fp->n_name.SubString(1, fp->n_name.Length() - fp->f_ext.Length());
				fp->f_size = (ShowTargetInf && !fp->l_name.IsEmpty())? get_file_size(fp->l_name) : sr.Size;
			}

			//タイムスタンプ
			if (ChkHardLink && is_NTFS && !fp->is_dir && get_HardLinkCount(fp->f_name)>1) {
				//ハードリングのタイムスタンプのずれを更新
				fp->f_time = get_file_age(fp->f_name);
			}
			else {
				fp->f_time = (ShowTargetInf && !fp->l_name.IsEmpty())? get_file_age(fp->l_name) : sr.TimeStamp;
			}

			//属性
			fp->f_attr	 = sr.Attr;
			fp->attr_str = get_file_attr_str(fp->f_attr);

			//項目追加
			if (lst->AddObject(fp->f_name, (TObject*)fp)%ESC_INTERVAL==0) {
				//ESC で中断
				if (is_KeyPress_ESC()) {
					ClearKeyBuff(true);
					break;
				}
			}
		} while(FindNext(sr)==0);

		FindClose(sr);

		//.. の欠損を補う
		//※UNCパスだと .. が無い?
		if (lst->Count>0 && !is_root && !has_up) {
			file_rec *fp = cre_new_up_rec(tag);
			fp->p_name	 = dnam;
			fp->f_time	 = get_file_age(dnam);
			lst->InsertObject(0, fp->f_name, (TObject*)fp);
		}
	}

	ApplySelMask(lst, tag, dnam);
	ApplyPathMask(lst, tag);
	SortList(lst, tag);
	SetFlItemWidth(lst, tag);

	//空ドライブの場合ダミーを追加
	if (lst->Count==0) {
		file_rec *fp = cre_new_file_rec(EmptyStr, tag);
		lst->AddObject(fp->f_name, (TObject*)fp);
	}

	//選択状態を復元
	if (sel_lst->Count>0) {
		for (int i=0; i<lst->Count; i++) {
			file_rec *fp = (file_rec*)lst->Objects[i];
			fp->selected = (sel_lst->IndexOf(fp->f_name)!=-1);
		}
	}

	UpdateBgImage();

	cursor_Default();
	InhUpdate = false;
}

//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::UpdateCurPath(
	UnicodeString dir,
	int  idx,
	bool inh_hist)		//履歴に入れない	(default = false)
{
	if (inh_hist) InhDirHist++;

	TListBox *lp = FileListBox[CurListTag];
	set_RedrawOff(lp);
	{
		RecoverFileList2();
		dir = dir.IsEmpty()? CurPath[CurListTag] : exclede_delimiter_if_root(dir);
		CurPath[CurListTag] = dir;
		if (DirHistCsrPos && idx!=-1) ListBoxSetIndex(lp, idx);
	}
	set_RedrawOn(lp);
	SetFileInf();

	if (inh_hist) InhDirHist--;
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::UpdateCurPath(
	UnicodeString dir, 
	UnicodeString fnam)
{
	TListBox *lp = FileListBox[CurListTag];
	set_RedrawOff(lp);
	{
		RecoverFileList2();
		dir = dir.IsEmpty()? CurPath[CurListTag] : exclede_delimiter_if_root(dir);
		CurPath[CurListTag] = dir;

		if (IndexOfFileList(fnam)==-1) {
			//指定ファイルが無ければマスクにマッチする最初の項目へ
			TStringDynArray mask_lst = split_strings_semicolon(get_csv_item(PathMask[CurListTag], 2));
			TStringList *lst = GetCurList(true);
			int idx = -1;
			for (int i=0; i<lst->Count && idx==-1; i++) {
				file_rec *fp = (file_rec*)lst->Objects[i];  if (fp->is_dir) continue;
				for (int j=0; j<mask_lst.Length && idx==-1; j++) {
					UnicodeString ptn = mask_lst[j];
					if (!ptn.IsEmpty() && ptn[1]!='!' && str_match(ptn, fp->n_name)) idx = i;
				}
			}
			if (idx!=-1) lp->ItemIndex = idx;
		}
	}
	set_RedrawOn(lp);
	SetFileInf();
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::RefreshCurPath(UnicodeString fnam)
{
	if (CurStt->is_Arc)
		ChangeArcFileListEx(CurStt->arc_Name, CurStt->arc_SubPath, CurListTag, fnam);
	else if (CurStt->is_ADS)
		ChangeAdsList(CurStt->ads_Name, CurListTag);
	else if (CurStt->is_FTP)
		ChangeFtpFileList(CurListTag, EmptyStr, fnam);
	else
		UpdateCurPath(EmptyStr, fnam);
}

//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::UpdateOppPath(UnicodeString dir, int idx)
{
	TListBox *lp = FileListBox[OppListTag];
	set_RedrawOff(lp);
	{
		RecoverFileList2(OppListTag);
		ApplyDotNyan = true;	//ディレクトリ変化がなくても強制的に .nyanfi を適用
		CurPath[OppListTag] = exclede_delimiter_if_root(dir);
		if (DirHistCsrPos && idx!=-1) ListBoxSetIndex(lp, idx);
	}
	set_RedrawOn(lp);
}

//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::UpdateCurDrive(
	UnicodeString drv,	//末尾に \ が無い場合はルート
	int tag)			//リストタグ	(default = -1 : CurListTag)
{
	if (tag==-1) tag = CurListTag;
	TListBox *lp = FileListBox[tag];
	set_RedrawOff(lp);
	{
		RecoverFileList2();
		CurPath[tag] = drv;
	}
	set_RedrawOn(lp);
	SetFileInf();
}

//---------------------------------------------------------------------------
//反対側を親ディレクトリに
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::OppToParent()
{
	UnicodeString lnam = ExcludeTrailingPathDelimiter(CurPath[OppListTag]);
	if (is_root_dir(lnam)) return;

	FCurPath[OppListTag] = IncludeTrailingPathDelimiter(get_parent_path(CurPath[OppListTag]));
	UpdateList(FileList[OppListTag], CurPath[OppListTag], OppListTag);
	SetDirWatch(CurPath[OppListTag], OppListTag);
	assign_FileListBox(FileListBox[OppListTag], FileList[OppListTag], -1, FlScrPanel[OppListTag]);
	IndexOfFileList(lnam, OppListTag);
	RepaintList(OppListTag);
}

//---------------------------------------------------------------------------
//ファイルリストをリストボックスに割り当て
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::AssignFileList(
	TStringList *lst, int tag,
	UnicodeString last_nam, int last_idx, int last_top)	// (default = EmptyStr, -1, -1);
{
	ApplyPathMask(lst, tag);
	SortList(lst, tag);
	SetFlItemWidth(lst, tag);

	//リストボックスに割り当て
	TListBox *lp = FileListBox[tag];
	if (last_idx==-1) last_idx = lp->ItemIndex;
	if (last_top==-1) last_top = lp->TopIndex;

	set_RedrawOff(lp);
	{
		lp->Count = lst->Count;
		FlScrPanel[tag]->UpdateKnob();

		if (USAME_TS(last_nam, "..")) {
			lp->ItemIndex = 0;
		}
		else if (!last_nam.IsEmpty()) {
			int idx = lst->IndexOf(ExcludeTrailingPathDelimiter(last_nam));
			if (idx!=-1) ListBoxSetIndex(lp, idx);
		}
		else {
			lp->TopIndex  = last_top;
			lp->ItemIndex = std::min(last_idx, lp->Count - 1);
		}

		if (tag==CurListTag) lp->SetFocus();
		RepaintList(tag);
	}
	set_RedrawOn(lp);
	if (tag==CurListTag) SetFileInf();
}

//---------------------------------------------------------------------------
//アーカイブのファイルリストを取得
//---------------------------------------------------------------------------
bool __fastcall TNyanFiForm::ChangeArcFileList(UnicodeString anam, UnicodeString dnam, int tag,
	UnicodeString last_nam)
{
	flist_stt *lst_stt = &ListStt[tag];
	cursor_HourGlass();

	if (usr_ARC->OpenArc(anam)) {
		TListBox *lp = FileListBox[tag];
		int last_idx = lst_stt->is_Arc? lp->ItemIndex : 0;
		int last_top = lst_stt->is_Arc? lp->TopIndex : 0;
		lst_stt->is_Arc  = true;
		UpdateBgImage();

		TStringList *lst = ArcFileList[tag];
		clear_FileList(lst);
		//戻り用
		file_rec *fp   = cre_new_up_rec(tag);
		fp->is_virtual = true;
		fp->arc_name   = lst_stt->arc_Name;
		fp->f_time	   = get_file_age(fp->arc_name);
		lst->AddObject(fp->f_name, (TObject*)fp);

		arc_find_inf inf;
		if (usr_ARC->FindFirstEx(dnam, &inf)) {
			do {
				UnicodeString fnam = inf.f_name;
				if (fnam.IsEmpty() || (inf.is_dir && lst->IndexOf(dnam + fnam)!=-1)) continue;

				//項目を作成
				file_rec *fp   = cre_new_file_rec();
				fp->tag 	   = tag;
				fp->is_virtual = true;
				fp->p_name	   = dnam;
				fp->f_name	   = dnam + fnam;
				fp->n_name	   = fnam;
				fp->arc_name   = lst_stt->arc_Name;
				fp->r_name.sprintf(_T("%s/%s"), fp->arc_name.c_str(), fp->f_name.c_str());
				fp->is_dir	   = inf.is_dir;
				fp->f_time	   = inf.f_time;
				fp->f_attr	   = inf.f_attr;
				fp->attr_str   = get_file_attr_str(fp->f_attr);
				//ディレクトリ
				if (fp->is_dir) {
					fp->b_name = get_dir_name(fp->f_name);
				}
				//ファイル
				else {
					fp->b_name = get_base_name(fp->f_name);
					fp->f_ext  = get_extension(fp->f_name);
					fp->f_size = inf.f_size;
				}
				lst->AddObject(fp->f_name, (TObject*)fp);
			} while (usr_ARC->FindNextEx(&inf));
		}
		usr_ARC->CloseArc();

		ApplySelMask(lst, tag, dnam);
		AssignFileList(lst, tag, last_nam, last_idx, last_top);
	}
	else {
		lst_stt->is_Arc = false;
	}

	cursor_Default();
	return lst_stt->is_Arc;
}

//---------------------------------------------------------------------------
#if !defined(_WIN64)
bool __fastcall TNyanFiForm::ChangeSpiArcList(UnicodeString anam, UnicodeString dnam, int tag,
	UnicodeString last_nam)
{
	flist_stt *lst_stt = &ListStt[tag];
	cursor_HourGlass();

	try {
		spi_info *sp = SPI->FindPlugin(anam, true);	if (!sp) Abort();
		TListBox *lp = FileListBox[tag];
		int last_idx = lst_stt->is_Arc? lp->ItemIndex : 0;
		int last_top = lst_stt->is_Arc? lp->TopIndex : 0;
		lst_stt->is_Arc  = true;
		UpdateBgImage();

		TStringList *lst = ArcFileList[tag];
		clear_FileList(lst);
		//戻り用
		file_rec *fp   = cre_new_up_rec(tag);
		fp->is_virtual = true;
		fp->arc_name   = lst_stt->arc_Name;
		fp->f_time	   = get_file_age(fp->arc_name);
		lst->AddObject(fp->f_name, (TObject*)fp);

		//一覧を取得
		char astr[MAX_PATH];
		strcpy(astr, AnsiString(anam).c_str());

		HANDLE lphInfo;
		fileInfo  *pinf  = NULL;
		fileInfoW *pinfW = NULL;
		if (sp->GetArchiveInfoW) {
			if (sp->GetArchiveInfoW(anam.c_str(), 0, 0, &lphInfo)!=0) Abort();
			pinfW = reinterpret_cast<fileInfoW *>(lphInfo);
		}
		else {
			if (sp->GetArchiveInfo((LPSTR)astr, 0, 0, &lphInfo)!=0) Abort();
			pinf = reinterpret_cast<fileInfo *>(lphInfo);
		}

		for (int f_idx=0; ; f_idx++) {
			UnicodeString fnam, pnam;
			__int64 fsz;
			time_t  ftm;

			if (pinfW) {
				fileInfoW *ipW = &pinfW[f_idx];	if  (ipW->method[0]=='\0') break;
				fnam = ipW->filename;
				pnam = ipW->path;
				fsz  = ipW->filesize;
				ftm  = ipW->timestamp;
			}
			else {
				fileInfo *ip = &pinf[f_idx];	if  (ip->method[0]=='\0') break;
				fnam = ip->filename;
				pnam = ip->path;
				fsz  = ip->filesize;
				ftm  = ip->timestamp;
			}
			if (!pnam.IsEmpty()) continue;

			//項目を作成
			file_rec *fp   = cre_new_file_rec();
			fp->tag 	   = tag;
			fp->is_virtual = true;
			fp->p_name	   = dnam;
			fp->f_name	   = dnam + fnam;
			fp->n_name	   = fnam;
			fp->arc_name   = lst_stt->arc_Name;
			fp->r_name.sprintf(_T("%s/%s"), fp->arc_name.c_str(), fp->f_name.c_str());
			fp->f_ext	   = get_extension(fp->f_name);
			fp->b_name	   = get_base_name(fp->f_name);
			fp->f_ext	   = get_extension(fp->f_name);
			fp->f_size	   = fsz;

			//更新日時
			if ((int)ftm != 0) {
				struct tm *f_t = localtime(&ftm);
				fp->f_time = TDateTime(f_t->tm_year + 1900, f_t->tm_mon + 1, f_t->tm_mday,
										f_t->tm_hour, f_t->tm_min, f_t->tm_sec, 0);
			}

			lst->AddObject(fp->f_name, (TObject*)fp);
		}

		ApplySelMask(lst, tag, dnam);
		AssignFileList(lst, tag, last_nam, last_idx, last_top);
	}
	catch (...) {
		RecoverFileList(tag);
	}

	cursor_Default();
	return lst_stt->is_Arc;
}
#endif
//---------------------------------------------------------------------------
bool __fastcall TNyanFiForm::ChangeArcFileListEx(UnicodeString anam, UnicodeString dnam, int tag,
	UnicodeString last_nam)
{
#if defined(_WIN64)
	return ChangeArcFileList(anam, dnam, tag, last_nam);
#else
	return SPI->TestFExt(get_extension(anam), true) ? ChangeSpiArcList( anam, dnam, tag, last_nam)
													: ChangeArcFileList(anam, dnam, tag, last_nam);
#endif
}

//---------------------------------------------------------------------------
//代替データストリームリストを更新
//---------------------------------------------------------------------------
bool __fastcall TNyanFiForm::ChangeAdsList(UnicodeString fnam, int tag)
{
	flist_stt *lst_stt = &ListStt[tag];
	lst_stt->is_ADS    = true;
	lst_stt->ads_Name  = fnam;
	UpdateBgImage();

	TStringList *lst = AdsFileList[tag];
	clear_FileList(lst);

	//戻り用
	file_rec *fp = cre_new_up_rec(tag);
	fp->f_time	 = get_file_age(fnam);
	fp->p_name	 = fnam;
	lst->AddObject(fp->f_name, (TObject*)fp);

	WIN32_FIND_STREAM_DATA sd;
	HANDLE hFS = ::FindFirstStreamW(fnam.c_str(), FindStreamInfoStandard, &sd, 0);
	if (hFS!=INVALID_HANDLE_VALUE) {
		do {
			UnicodeString snam = get_tkn(sd.cStreamName, ":$DATA");
			if (remove_top_s(snam, ":") && !snam.IsEmpty()) {
				//項目を作成
				file_rec *fp = cre_new_file_rec();
				fp->tag 	 = tag;
				fp->p_name	 = fnam;
				fp->f_name	 = fp->r_name = fnam + ":" + snam;
				fp->n_name	 = snam;
				fp->is_ads	 = true;
				fp->is_dir	 = false;
				fp->f_size	 = ((__int64)sd.StreamSize.HighPart<<32) + sd.StreamSize.LowPart;
				fp->f_time	 = get_file_age(fp->f_name);
				fp->f_attr	 = file_GetAttr(fp->f_name);
				fp->attr_str = get_file_attr_str(fp->f_attr);
				fp->b_name	 = get_base_name(snam);
				fp->f_ext	 = get_extension(snam);
				lst->AddObject(fp->f_name, (TObject*)fp);
			}
		} while (::FindNextStreamW(hFS, &sd));
		::FindClose(hFS);
	}

	ApplySelMask(lst, tag, extract_file_path(fnam));
	AssignFileList(lst, tag, "..");
	return true;
}

//---------------------------------------------------------------------------
//FTP のファイルリストを取得
//---------------------------------------------------------------------------
bool __fastcall TNyanFiForm::ChangeFtpFileList(int tag, UnicodeString dnam, UnicodeString last_nam)
{
	flist_stt *lst_stt = &ListStt[tag];
	GlobalErrMsg = EmptyStr;

	try {
		if (!IdFTP1->Connected()) Abort();

		cursor_HourGlass();
		lst_stt->is_FTP = true;
		UpdateBgImage();

		//ディレクトリの変更
		dnam = yen_to_slash(dnam);
		if (!dnam.IsEmpty()) {
			if (USAME_TS(dnam, "..")) IdFTP1->ChangeDirUp(); else IdFTP1->ChangeDir(dnam);
			add_FTPLogMsg();
		}
		set_CurFTPPath();
		if (tag==CurListTag) SetCurStt(tag);

		TStringList *lst = FileList[tag];
		clear_FileList(lst);
		if (!USAME_TS(CurFTPPath, "\\")) {
			file_rec *fp = cre_new_up_rec(tag);
			fp->is_ftp	 = true;
			fp->p_name	 = CurFTPPath;
			fp->attr_str = "_____";
			lst->AddObject(fp->f_name, (TObject*)fp);
		}

		//一覧の取得
		try {
			IdFTP1->List();
			TIdFTPListItems *items = IdFTP1->DirectoryListing;
			for (int i=0; i<items->Count; ++i) {
				TIdFTPListItem *ftpItem = items->Items[i];
				TIdDirItemType typ = ftpItem->ItemType;
				if (typ!=ditDirectory && typ!=ditFile && typ!=ditSymbolicLink && typ!=ditSymbolicLinkDir) continue;

				UnicodeString fnam = ftpItem->FileName;
				if (ContainsStr("..", fnam)) continue;

				file_rec *fp = cre_new_file_rec();
				fp->tag 	 = tag;
				fp->is_ftp	 = true;
				fp->p_name	 = CurFTPPath;
				fp->f_name	 = CurFTPPath + fnam;
				fp->n_name	 = fnam;
				fp->r_name.sprintf(_T("%s/%s"), IdFTP1->Host.c_str(), yen_to_slash(fp->f_name).c_str());
				fp->is_dir	 = (typ==ditDirectory || typ==ditSymbolicLinkDir || typ==ditSymbolicLink); //?
				fp->is_sym	 = (typ==ditSymbolicLink || typ==ditSymbolicLinkDir);
				fp->f_time	 = ftpItem->ModifiedDate;
				//パーミッション
				UnicodeString pbuf = get_tkn_m(ftpItem->Data, _T("UNIX.mode="), _T(";"));
				if (pbuf.Length()==4) {
					UnicodeString abuf = StringOfChar(_T('-'), 10);
					abuf[1] = fp->is_sym? 'l' : fp->is_dir? 'd' : '-';
					int v1 = pbuf.SubString(2, 1).ToIntDef(0);
					int v2 = pbuf.SubString(3, 1).ToIntDef(0);
					int v3 = pbuf.SubString(4, 1).ToIntDef(0);
					if (v1 & 0x04) abuf[2]  = 'r';
					if (v1 & 0x02) abuf[3]  = 'w';
					if (v1 & 0x01) abuf[4]  = 'x';
					if (v2 & 0x04) abuf[5]  = 'r';
					if (v2 & 0x02) abuf[6]  = 'w';
					if (v2 & 0x01) abuf[7]  = 'x';
					if (v3 & 0x04) abuf[8]  = 'r';
					if (v3 & 0x02) abuf[9]  = 'w';
					if (v3 & 0x01) abuf[10] = 'x';
					fp->attr_str = abuf;
				}
				else {
					fp->attr_str = ftpItem->PermissionDisplay;
				}

				//ディレクトリ
				if (fp->is_dir) {
					fp->b_name = get_dir_name(fp->f_name);
				}
				//ファイル
				else {
					fp->b_name = get_base_name(fp->f_name);
					fp->f_ext  = get_extension(fp->f_name);
					fp->f_size = ftpItem->Size;
				}
				lst->AddObject(fp->f_name, (TObject*)fp);
			}
		}
		catch (...) {
			GlobalErrMsg = IdFTP1->LastCmdResult->Text->Text;
			add_FTPLogMsg();
		}

		//空の場合ダミーを追加
		if (lst->Count==0) {
			file_rec *fp = cre_new_file_rec(EmptyStr, tag);
			lst->AddObject(fp->f_name, (TObject*)fp);
		}

		ApplySelMask(lst, tag);
		AssignFileList(lst, tag, last_nam);
		cursor_Default();
	}
	catch (...) {
		cursor_Default();
		GlobalErrMsg = IdFTP1->LastCmdResult->Text->Text;
		add_FTPLogMsg();
	}

	return GlobalErrMsg.IsEmpty();
}

//---------------------------------------------------------------------------
//ワークリストを更新
//---------------------------------------------------------------------------
int __fastcall TNyanFiForm::ChangeWorkList(
	int  tag,
	bool check)		//存在チェック/更新		(default = true)
{
	if (ScrMode!=SCMD_FLIST) return WorkList->Count;

	flist_stt *cur_stt = &ListStt[tag];
	cur_stt->is_Arc  = false;
	cur_stt->is_ADS  = false;
	cur_stt->is_Find = false;
	bool ini_flag = !cur_stt->is_Work;
	cur_stt->is_Work = true;
	UpdateBgImage();

	WorkListHasSep = false;
	if (check) {
		int i = 0;
		while (i<WorkList->Count) {
			file_rec *fp = (file_rec*)WorkList->Objects[i];
			fp->tag = tag;
			fp->inf_list->Clear();
			if (fp->is_dummy) {
				if (is_separator(fp->alias)) WorkListHasSep = true;
				i++;
			}
			else if (NoCheckWorkUnc && StartsStr("\\\\", fp->p_name)) {
				fp->f_size	 = -1;
				fp->f_time	 = 0;
				fp->f_attr	 = 0;
				fp->attr_str = get_file_attr_str(fp->f_attr);
				i++;
			}
			else if (!is_InvalidUnc(fp->p_name) && file_exists(fp->f_name)) {
				if (!fp->is_dir) fp->f_size = get_file_size(fp->f_name);
				fp->f_time	 = get_file_age(fp->f_name);
				fp->f_attr	 = file_GetAttr(fp->f_name);
				fp->attr_str = get_file_attr_str(fp->f_attr);
				i++;
			}
			else {
				if (AutoDelWorkList) {
					del_FileListItem(WorkList, i);
				}
				else {
					inv_file_rec(fp);
					i++;
				}
			}
		}
	}
	else {
		for (int i=0; i<WorkList->Count; i++) {
			file_rec *fp = (file_rec*)WorkList->Objects[i];
			fp->tag = tag;
			if (fp->is_dummy && is_separator(fp->alias)) WorkListHasSep = true;
		}
	}

	//空の場合ダミーを追加
	if (WorkList->Count==0) {
		file_rec *fp = cre_new_file_rec(EmptyStr, tag);
		WorkList->AddObject(fp->f_name, (TObject*)fp);
	}
	//不要なダミーは削除
	else {
		int i = 0;
		while (i<WorkList->Count) {
			file_rec *fp = (file_rec*)WorkList->Objects[i];
			if (fp->is_dummy && fp->alias.IsEmpty()) del_FileListItem(WorkList, i); else i++;
		}
		//必要なら末尾にダミーを追加
		if (RegWorkCsrPos) {
			file_rec *fp = cre_new_file_rec(EmptyStr, tag);
			WorkList->AddObject(fp->f_name, (TObject*)fp);
		}
	}

	if (WorkListFiltered) ApplySelMask(WorkList, tag);
	SortList(WorkList, tag);
	SetFlItemWidth(WorkList, tag);

	//リストボックスに割り当て
	TListBox *lp = FileListBox[tag];
	int idx = lp->ItemIndex;
	if (ini_flag) {
		//履歴からカーソル位置を復元
		TStringDynArray itm_buf = record_of_csv_list(WorkListHistory, WorkListName, 0, 2);
		if (itm_buf.Length==2) idx = itm_buf[1].ToIntDef(0);
	}
	update_FileListBox(WorkList, tag, idx);
	if (tag==CurListTag) lp->SetFocus();
	RepaintList(tag);

	SetDirCaption(tag);
	if (tag==CurListTag) SetFileInf();

	return WorkList->Count;
}
//---------------------------------------------------------------------------
//ワークリストを読み込む
//---------------------------------------------------------------------------
bool __fastcall TNyanFiForm::SetWorkList(
	UnicodeString fnam,		//ワークリストファイル名		 (default = EmptyStr : 現在のリスト)
	bool load_only)			//読み込みのみで画面は更新しない (default = false)
{
	if (fnam.IsEmpty()) fnam = WorkListName;
	if (fnam.IsEmpty()) return false;

	cursor_HourGlass();
	bool res = load_WorkList(fnam);
	if (res) {
		if (ScrMode==SCMD_FLIST) {
			if (!load_only) {
				int tag = CurListTag;
				if (CurStt->is_Work) {
					RecoverFileList(tag);
				}
				else if (OppStt->is_Work) {
					tag = OppListTag;
					RecoverFileList(tag);
				}

				ChangeWorkList(tag, false);
			}
		}
		else if (ScrMode==SCMD_IVIEW) {
			if (isViewWork) {
				SetViewFileList(true, true);
			}
			else {
				if (SameText(WorkListName, to_absolute_name(HomeWorkList)))
					ShowHintAndStatus("ホームワークリストを開きました。");
				else
					ShowHintAndStatus(
						UnicodeString().sprintf(_T("ワークリスト[%s]を開きました。"), get_base_name(WorkListName).c_str()));
			}
		}
	}
	cursor_Default();
	return res;
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::CheckChangeWorkList(int tag)
{
	if (!WorkListName.IsEmpty()) {
		TDateTime dt = get_file_age(WorkListName);
		if (dt!=WorkListTime) {
			UnicodeString msg;
			msg = "ワークリストが更新されています\r\n";
			msg.cat_sprintf(_T("%s → %s\r\n読み込み直しますか?"),
				FormatDateTime(TimeStampFmt, WorkListTime).c_str(),
				FormatDateTime(TimeStampFmt, dt).c_str());
			if (msgbox_Sure(msg, SureWorkList || WorkListChanged, true)) {
				if (!load_WorkList(WorkListName)) SetActionAbort(USTR_WlistCantOpen);
			}
			WorkListTime = dt;
		}
	}

	ChangeWorkList(tag);
}

//---------------------------------------------------------------------------
//最新の情報に更新
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ReloadList(
	int tag,				//リストタグ	(default = -1 : 左右とも更新)
	UnicodeString fnam)		//カーソル位置
{
	if (!Initialized || UnInitializing || DisReload || ScrMode!=SCMD_FLIST) return;

	int idx[MAX_FILELIST], top[MAX_FILELIST];
	UnicodeString lnam[MAX_FILELIST];
	for (int i=0; i<MAX_FILELIST; i++) {
		idx[i]	= FileListBox[i]->ItemIndex;
		top[i]	= FileListBox[i]->TopIndex;
		TStringList *lst = GetFileList(i);
		lnam[i] = (idx[i]>=0 && idx[i]<lst->Count)? lst->Strings[idx[i]] : EmptyStr;
	}

	if (tag==-1 || tag==0) set_RedrawOff(FileListBox[0]);
	if (tag==-1 || tag==1) set_RedrawOff(FileListBox[1]);
	{
		for (int i=0; i<MAX_FILELIST; i++) {
			flist_stt *lst_stt = &ListStt[i];
			if (tag!=-1 && tag!=i) continue;
			if (i==CurListTag && CurWorking) continue;
			if (lst_stt->is_Arc) continue;

			//グラフ表示等の解除
			lst_stt->show_f_d_cnt = lst_stt->dir_graph = lst_stt->dsk_graph = false;

			//検索結果
			if (!IsDiffList() && lst_stt->is_Find) {
				lst_stt->find_DICON? FindFolderIconCore(i) :
				lst_stt->find_HLINK? FindHardLinkCore(lst_stt->find_Name, i) :
				lst_stt->find_MARK ? FindMarkCore(i) :
				lst_stt->find_TAG  ? FindTagCore(i) : FindFileCore(lst_stt->find_Dir, i);
			}
			//代替データストリーム
			else if (lst_stt->is_ADS) {
				ChangeAdsList(lst_stt->ads_Name, i);
			}
			//FTP
			else if (lst_stt->is_FTP) {
				ChangeFtpFileList(i);
			}
			//ワークリスト
			else if (lst_stt->is_Work) {
				ChangeWorkList(i);
			}
			//ファイルリスト
			else {
				UnicodeString dnam = CurPath[i];
				//ディレクトリが無くなっていたら親へ(UNCは除く)
				if (!StartsStr("\\\\", dnam)) {
					if (!dir_exists(dnam)) dnam = get_parent_path(dnam);
				}

				//Git情報のキャッシュを削除
				UnicodeString g_nam = get_GitTopPath(dnam);
				if (!g_nam.IsEmpty()) {
					int idx = GitInfList->IndexOfName(g_nam);
					if (idx!=-1) GitInfList->Delete(idx);
				}

				CurPath[i] = dnam;
			}

			//カーソル位置を設定
			if (!IsDiffList()) {
				if (!fnam.IsEmpty() && i==CurListTag)
					IndexOfFileList(fnam, tag, top[i]);
				else if (IndexOfFileList(lnam[i], i, top[i])==-1) {
					FileListBox[i]->TopIndex = top[i];
					ListBoxSetIndex(FileListBox[i], idx[i]);
				}
			}
		}
	}
	if (tag==-1 || tag==0) set_RedrawOn(FileListBox[0]);
	if (tag==-1 || tag==1) set_RedrawOn(FileListBox[1]);

	if (tag==-1 || tag==CurListTag) SetFileInf();
}

//---------------------------------------------------------------------------
//ファイルリストを復帰
//  仮想ディレクトリ、検索結果リスト、ワークリスト、FTPから戻る場合に使用
//  FTPの場合は切断も行う
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::RecoverFileList(
	int tag)	// (default = CurListTag)
{
	flist_stt *lst_stt = &ListStt[tag];
	if (!lst_stt->is_Arc && !lst_stt->is_ADS && !lst_stt->is_Find && !lst_stt->is_Work && !lst_stt->is_FTP) return;

	TListBox *lp = FileListBox[tag];
	set_RedrawOff(lp);
	{
		bool ret_arc = false;
		UnicodeString last_fnam;

		SelMaskList[tag]->Clear();

		//仮想ディレクトリから抜ける
		if (lst_stt->is_Arc) {
			//反対側が仮想でなければすべて削除
			if (!ListStt[(tag==0)? 1 : 0].is_Arc) {
				ClearTempArc();
				lst_stt->arc_RetList->Clear();
			}
			//そうでなければ指定側のみ削除
			else {
				for (;;) {
					if (lst_stt->arc_SubPath.IsEmpty()) {
						if (lst_stt->arc_RetList->Count==0) break;
						ClearTempArc(ExtractFilePath(lst_stt->arc_Name));
						UnicodeString lbuf = lst_stt->arc_RetList->Strings[0];
						lst_stt->arc_RetList->Delete(0);
						lst_stt->arc_Name	 = get_pre_tab(lbuf);
						lst_stt->arc_SubPath = get_post_tab(lbuf);
					}
					else {
						lst_stt->arc_SubPath = get_parent_path(lst_stt->arc_SubPath);
					}
				}
			}

			last_fnam = lst_stt->arc_Name;
			ClearTempArcList(tag);
			lst_stt->arc_Name	 = EmptyStr;
			lst_stt->arc_DspPath = EmptyStr;
			ret_arc = (tag==CurListTag);
		}
		//代替データストリームから抜ける
		else if (lst_stt->is_ADS) {
			last_fnam = lst_stt->ads_Name;
			lst_stt->ads_Name = EmptyStr;
		}
		//結果リストから抜ける
		else if (lst_stt->is_Find) {
			ClearTempArcList(tag);
		}
		//FTP切断
		else if (lst_stt->is_FTP) {
			try {
				if (IdFTP1->Connected()) IdFTP1->Disconnect();
			}
			catch (...) {
				SetActionAbort(_T("FTP切断に失敗しました。"));
			}
		}
		//ワークリスト
		else if (lst_stt->is_Work) {
			if (WorkListFiltered && !SetWorkList(EmptyStr, true)) SetActionAbort(USTR_WlistCantOpen);

			if (!WorkListName.IsEmpty()) {
				//履歴を更新
				for (;;) {
					int idx = indexof_csv_list(WorkListHistory, WorkListName, 0);
					if (idx!=-1) WorkListHistory->Delete(idx); else break;
				}
				WorkListHistory->Insert(0, UnicodeString().sprintf(_T("\"%s\",%u"), WorkListName.c_str(), lp->ItemIndex));
			}
		}

		lst_stt->is_Arc  = false;
		lst_stt->is_ADS  = false;
		lst_stt->is_Work = false;
		lst_stt->is_FTP  = false;
		lst_stt->is_Find = false;
		FindDiff = false;

		FCurPath[tag] = CheckAvailablePath(CurPath[tag], tag);
		UpdateList(FileList[tag], CurPath[tag], tag);

		//リストボックスに割り当て
		update_FileListBox(FileList[tag], tag);

		if (IndexOfFileList(last_fnam)==-1) {
			//履歴からカーソル位置を復帰
			if (DirHistCsrPos) {
				TStringDynArray itm_buf = record_of_csv_list(get_DirHistory(TabControl1->TabIndex, tag), CurPath[tag], 0, 2);
				if (itm_buf.Length==2) ListBoxSetIndex(lp, itm_buf[1].ToIntDef(0));
			}
			else lp->ItemIndex = 0;
		}

		if (MainPanel->Visible && tag==CurListTag) lp->SetFocus();

		//イベント: 仮想ディレクトリを閉じた直後
		if (ret_arc) ExeEventCommand(OnArcClosed);

		RepaintList(tag);
	}
	set_RedrawOn(lp);
	if (tag==CurListTag) SetFileInf();
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::RecoverFileList2(
	int tag)	// -1: 左右とも適用	(default = CurListTag)
{
	if (IsDiffList()) {
		for (int i=0; i<MAX_FILELIST; i++) {
			RecoverFileList(i);
			clear_FileList(TmpBufList[i]);
		}
	}
	else {
		for (int i=0; i<MAX_FILELIST; i++) {
			if (tag==-1 || tag==i) RecoverFileList(i);
		}
	}
}

//---------------------------------------------------------------------------
//選択中ファイルを削除
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::DeleteSelFiles(TStringList *lst)
{
	UnicodeString cmd = "DEL";
	std::unique_ptr<TStringList> tsk_lst(new TStringList());
	for (int i=0; i<lst->Count; i++) {
		file_rec *fp = (file_rec*)lst->Objects[i];
		if (!fp->selected) continue;
		tsk_lst->Add(UnicodeString().sprintf(_T("%s\t%s"),
			cmd.c_str(), (fp->is_dir? IncludeTrailingPathDelimiter(fp->f_name) : fp->f_name).c_str()));
		fp->selected = false;
	}

	if (tsk_lst->Count>0) {
		UnicodeString dnam = GetCurPathStr();
		std::unique_ptr<TStringList> dir_lst(new TStringList());
		get_SyncDstList(dnam, dir_lst.get(), true);
		for (int i=0; i<dir_lst->Count; i++) {
			std::unique_ptr<TStringList> t_buf(new TStringList());
			t_buf->Assign(tsk_lst.get());
			if (i>0) {
				for (int j=0; j<t_buf->Count; j++) {
					UnicodeString tprm = ReplaceText(t_buf->Strings[j], "\t" + dnam, "\t" + dir_lst->Strings[i]);
					UnicodeString fnam = ExcludeTrailingPathDelimiter(get_post_tab(tprm));
					t_buf->Strings[j]  = file_exists(fnam)? tprm : EmptyStr;
				}
				int k = 0;
				while (k<t_buf->Count) if (t_buf->Strings[k].IsEmpty()) t_buf->Delete(k); else k++;
				if (t_buf->Count==0) continue;
			}
			TaskConfig  *cp = NULL;
			TTaskThread *tp = CreTaskThread(&cp);
			if (cp) {
				cp->TaskList->Assign(t_buf.get());
				cp->CmdStr	 = TaskCmdList->Values[cmd];
				cp->DistPath = dnam;
				cp->InfStr	 = dnam;
				ActivateTask(tp, cp);
			}
		}
	}
}
//---------------------------------------------------------------------------
//指定ファイルを削除
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::DeleteFileP(file_rec *fp)
{
	if (!fp || fp->is_dummy || fp->f_name.IsEmpty()) return;

	UnicodeString cmd  = "DEL";
	UnicodeString dnam = GetCurPathStr();
	std::unique_ptr<TStringList> dir_lst(new TStringList());
	get_SyncDstList(dnam, dir_lst.get(), true);
	for (int i=0; i<dir_lst->Count; i++) {
		UnicodeString tprm;
		tprm.sprintf(_T("%s\t%s"),
				cmd.c_str(), (fp->is_dir? IncludeTrailingPathDelimiter(fp->f_name) : fp->f_name).c_str());

		if (i>0) {
			tprm = ReplaceText(tprm, "\t" + dnam, "\t" + dir_lst->Strings[i]);
			if (!file_exists(ExcludeTrailingPathDelimiter(get_post_tab(tprm)))) continue;
		}

		TaskConfig  *cp = NULL;
		TTaskThread *tp = CreTaskThread(&cp);
		if (cp) {
			cp->TaskList->Add(tprm);
			cp->CmdStr	 = TaskCmdList->Values[cmd];
			cp->DistPath = dnam;
			cp->InfStr	 = dnam;
			ActivateTask(tp, cp);
		}
	}
}

//---------------------------------------------------------------------------
//指定ファイルを解凍コピー (同名処理付、xCopyMode に対応)
//---------------------------------------------------------------------------
bool __fastcall TNyanFiForm::UnpackCopyCore(
	UnicodeString anam,		//アーカイブのファイル名
	UnicodeString snam,		//アーカイブのサブディレクトリ名
	UnicodeString files, 	//ファイル名リスト
	UnicodeString rnam,		//レスポンスファイル名
	UnicodeString dst_dir, 	//コピー先
	TStringList *f_lst, 	//ファイルリスト
	TStringList *d_lst)		//(空)ディレクトリのリスト
{
	try {
		GlobalErrMsg = EmptyStr;
		gCopyCancel  = false;

		int a_copy_mode = (xCopyMode>=0)? xCopyMode : gCopyMode;
		gCopyAll  = (xCopyMode>=0);
		xCopyMode = -1;

		//一時ディレクトリを作成
		dst_dir = IncludeTrailingPathDelimiter(dst_dir);
		int n = 0;
		UnicodeString tmp_dir;
		while (file_exists(tmp_dir.sprintf(_T("%s" TMP_ARC_F), dst_dir.c_str(), n))) n++;
		tmp_dir = IncludeTrailingPathDelimiter(tmp_dir);
		if (!dir_exists(tmp_dir) && !create_ForceDirs(tmp_dir)) UserAbort(USTR_CantMakeTmpDir);

		//一時解凍
		UnicodeString err_msg;
		SetDirWatch(false);
		//直接指定
		if (!files.IsEmpty()) {
			if (!is_X64() && SPI->TestFExt(get_extension(anam), true)) {
				if (!SPI->UnPack(anam, files, tmp_dir)) err_msg = LoadUsrMsg(USTR_FaildTmpUnpack);
			}
			else {
				if (!usr_ARC->UnPack(anam, tmp_dir, files, true, !ShowArcCopyProg, true)) err_msg = usr_ARC->ErrMsg;
			}
		}
		//レスポンスファイル指定
		if (!rnam.IsEmpty()) {
			if (!is_X64() && SPI->TestFExt(get_extension(anam), true)) {
				if (!SPI->UnPack(anam, "@" + rnam, tmp_dir))
					err_msg = LoadUsrMsg(USTR_FaildTmpUnpack);
			}
			else {
				if (!usr_ARC->UnPack(anam, tmp_dir, add_quot_if_spc("@" + rnam), true, !ShowArcCopyProg, true))
					err_msg = usr_ARC->ErrMsg;
			}
		}
		SetDirWatch(true);

		//一時ディレクトリからコピー
		if (err_msg.IsEmpty()) {
			//空ディレクトリの作成
			for (int i=0; i<d_lst->Count; i++) {
				UnicodeString dnam = d_lst->Strings[i];
				if (!snam.IsEmpty()) remove_top_text(dnam, snam);
				dnam = dst_dir + dnam;
				if (!dir_exists(dnam)) {
					UnicodeString msg  = make_LogHdr(_T("CREATE"), dnam, true);
					if (!create_ForceDirs(dnam)) set_LogErrMsg(msg);
					AddLog(msg);
				}
			}

			std::unique_ptr<TStringList> tmp_lst(new TStringList());
			get_files(tmp_dir, _T("*.*"), tmp_lst.get(), true);

			std::unique_ptr<TStringList> log_buf(new TStringList());
			int ok_cnt = 0, er_cnt = 0, sk_cnt = 0;
			for (int i=0; i<tmp_lst->Count; i++) {
				UnicodeString tmp_fnam = tmp_lst->Strings[i];
				UnicodeString dst_fnam = tmp_fnam;
				remove_top_text(dst_fnam, tmp_dir);

				//余計なファイルはスキップ
				if (f_lst->IndexOf(dst_fnam)==-1) continue;

				UnicodeString src_fnam = anam + "\\" + dst_fnam;
				UnicodeString msg = make_LogHdr(_T("COPY"), src_fnam);
				if (!snam.IsEmpty()) remove_top_text(dst_fnam, snam);
				dst_fnam = dst_dir + dst_fnam;
				UnicodeString dst_snam = ExtractFilePath(dst_fnam);

				//ディレクトリ属性の異なる同名対象が存在
				if (dir_exists(dst_fnam) || file_exists_x(ExcludeTrailingPathDelimiter(dst_snam))) {
					er_cnt++;
					set_LogErrMsg(msg, LoadUsrMsg(USTR_NgSameName));
					log_buf->Text = log_buf->Text + " >" + msg;
					continue;
				}

				if (!dir_exists(dst_snam) && !create_ForceDirs(dst_snam)) {
					set_LogErrMsg(msg);
				}
				else {
					bool s_flag = file_exists(dst_fnam);
					bool o_flag = false, n_flag = false;

					//同名ファイルの処理
					if (s_flag) {
						UnicodeString dnam	  = ExtractFilePath(dst_fnam);
						UnicodeString cpy_nam = ExtractFileName(dst_fnam);
						if (!gCopyAll) {
							TaskSttTimer->Enabled = false;
							SameNameDlg->Caption  = LoadUsrMsg(USTR_SameName, _T("解凍コピー"));
							SameNameDlg->TaskNo   = -1;
							SameNameDlg->CopyMode = gCopyMode;
							SameNameDlg->CopyAll  = gCopyAll;
							SameNameDlg->RenameEdit->Text = cpy_nam;
							SameNameDlg->IsSamePath = false;
							SameNameDlg->CurSrcName = src_fnam;
							SameNameDlg->CurSrcSize = get_file_size(tmp_lst->Strings[i]);
							SameNameDlg->CurSrcTime = get_file_age(tmp_lst->Strings[i]);
							SameNameDlg->CurDstName = dst_fnam;
							SameNameDlg->CurDstSize = get_file_size(dst_fnam);
							SameNameDlg->CurDstTime = get_file_age(dst_fnam);
							if (SameNameDlg->ShowModal()==mrCancel) {
								AddLog(_T("コピー中断"), true);
								gCopyCancel = true;
							}
							else {
								gCopyMode = a_copy_mode = SameNameDlg->CopyMode;
								gCopyAll  = SameNameDlg->CopyAll;
								gCopyFmt  = AutoRenFmt;
								cpy_nam   = SameNameDlg->RenameEdit->Text;
							}
							TaskSttTimer->Enabled = true;
							if (gCopyCancel) break;
						}

						switch (a_copy_mode) {
						case CPYMD_OW:		//上書き
							msg[1] = 'O';
							o_flag = true;
							break;
						case CPYMD_NEW:		//最新なら
							if (is_NewerTime(get_file_age(tmp_lst->Strings[i]), get_file_age(dst_fnam))) {
								msg[1] = 'N';
								o_flag = true;
							}
							else {
								if (LogHideSkip) msg = EmptyStr; else msg[1] = 'S';
							}
							break;
						case CPYMD_SKIP:	//スキップ
							if (LogHideSkip) msg = EmptyStr; else msg[1] = 'S';
							break;
						case CPYMD_AUT_REN:	//自動的に名前を変更
							dst_fnam = format_CloneName(gCopyFmt, tmp_fnam, dnam, false);
							set_RenameLog(msg, dst_fnam);
							n_flag = true;
							break;
						case CPYMD_MAN_REN:	//名前を変更
							dst_fnam = dnam + cpy_nam;
							if (!file_exists(dst_fnam)) {
								set_RenameLog(msg, cpy_nam);
								n_flag = true;
							}
							else set_LogErrMsg(msg, LoadUsrMsg(USTR_DuplicateName));
							break;
						}
					}

					if (!s_flag || o_flag || n_flag) {
						if (move_File(tmp_lst->Strings[i], dst_fnam)) {
							ok_cnt++;
						}
						else {
							er_cnt++;
							set_LogErrMsg(msg);
						}
					}
					else sk_cnt++;
				}

				//ログのバッファリング
				if (!msg.IsEmpty()) {
					log_buf->Text = log_buf->Text + " >" + msg;
					if (i%32==0) {	//***
						AddLogStrings(log_buf.get());
						log_buf->Clear();
					}
				}
			}	//end of for

			if (log_buf->Count>0) AddLogStrings(log_buf.get());
			if (!gCopyCancel) EndLog(_T("コピー"), get_res_cnt_str(ok_cnt, er_cnt, sk_cnt));
		}

		//一時ファイルを削除
		std::unique_ptr<TStringList> tmp_lst(new TStringList());
		get_files(tmp_dir, _T("*.*"), tmp_lst.get(), true);
		for (int i=0; i<tmp_lst->Count; i++) {
			UnicodeString tnam = tmp_lst->Strings[i];
			if (set_FileWritable(tnam)) DeleteFile(tnam);
		}
		delete_Dirs(tmp_dir);

		if (!err_msg.IsEmpty()) throw EAbort(err_msg);
		return true;
	}
	catch (EAbort &e) {
		GlobalErrMsg = e.Message;
		AddLog(GlobalErrMsg);
		return false;
	}
}

//---------------------------------------------------------------------------
//ファイル情報を表示
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ViewFileInf(file_rec *fp, 
	bool force)		//強制的に取得 (default = false)
{
	//ファイル情報の取得が必要か
	bool need_inf;

	if (!fp || fp->is_dummy) {
		need_inf = false;
	}
	else {
		need_inf = force;
		if (!need_inf) {
			if (ScrMode==SCMD_IVIEW)
				need_inf = ImgSidePanel->Visible;
			else if (SubPanel->Visible)
				need_inf = (InfListPanel->Visible || (ShowTextPreview && test_TxtFile(fp->f_name)));
		}
		if (!need_inf) need_inf = (StatusBar1->Visible && ContainsStr(SttBarFmt, "$PR("));
	}

	ViewInfCnt++;

	//--------------------------------------------------
	//ファイル情報
	//--------------------------------------------------
	int tx_idx = TxtPrvKeepIndex? TxtPrvListBox->ItemIndex : 0;
	int tx_top = TxtPrvKeepIndex? TxtPrvListBox->TopIndex  : 0;

	if (!LockTxtPrv) {
		TxtPrvListBox->Count = 0;
		TxtPrvBuff->Clear();

		TxtTailListBox->Count = 0;
		TxtTailBuff->Clear();

		TxtPrvFile = EmptyStr;
	}

	std::unique_ptr<TStringList> i_lst(new TStringList());
	if (fp) {
		//仮想ディレクトリ内のファイルを一時解凍
		if (!fp->is_dir && fp->is_virtual && !fp->failed && fp->f_attr!=faInvalid) {
			if (force || (need_inf && ViewArcInf && (test_FileExt(fp->f_ext, FEXT_ARCVIEW) || is_Viewable(fp)))) {
				if (usr_ARC->IsRunning(fp->arc_name))
					FinfSkipped = true;	//アーカイバ動作中の場合スキップ
				else
					fp->failed = !SetTmpFile(fp);
			}
		}
		//FTPで強制取得ならダウンロード
		else if (fp->is_ftp) {
			if (force && !file_exists(fp->tmp_name))
				fp->tmp_name = DownloadFtpCore(fp);
		}

		//キャッシュされた情報があればそれを表示
		if (!force && !fp->is_dir && !fp->is_ftp && fp->inf_list->Count>0) {
			i_lst->Assign(fp->inf_list);
		}
		//なければ取得
		else if (!FinfSkipped && need_inf) {
			if (has_KeyDownMsg()) {
				FinfSkipped = true;	//未処理のキー入力がある場合スキップ
			}
			else {
				if (fp->is_up) {	//git status に対するの抑止
					SetDirWatch(false);
					GetFileInfList(fp, force);
					SetDirWatch(true);
				}
				else {
					GetFileInfList(fp, force);
				}
				i_lst->Assign(fp->inf_list);
			}
		}

		//隠す項目を削除
		UnicodeString fext = fp->is_dir? UnicodeString("\\") : def_if_empty(fp->f_ext, ".");
		UnicodeString hlst = HideInfItems->Values[fext];
		if (!hlst.IsEmpty()) {
			int i = 3;
			while (i<i_lst->Count) {
				UnicodeString inam = Trim(get_tkn(i_lst->Strings[i], _T(": ")));
				if (test_word_i(inam, hlst)) i_lst->Delete(i); else i++;
			}
		}

		//テキストプレビュー
		if (ShowTextPreview && !fp->prv_text.IsEmpty()) {
			UnicodeString fnam = test_LnkExt(fp->f_ext)? fp->r_name : fp->f_name;
			if (!is_ViewableFext(get_extension(fnam)) && !IsSwatchbook(fnam)) {
				SetTxtPreview(fnam, fp->prv_text, fp->tail_text, tx_idx);
				if (TxtPrvKeepIndex) TxtPrvListBox->TopIndex = tx_top;
			}
		}
	}

	//テキストプレビューの表示
	TxtPrvListPanel->Visible = (TxtPrvListBox->Count>0);

	//末尾プレビューの表示
	if (TxtTailListBox->Count>0) {
		if (!TxtTailListPanel->Visible) {
			TxtTailListPanel->Visible = true;
			TxtPrvSplitter->Visible	  = true;
			TxtPrvSplitter->Align	  = alTop;
			TxtTailListPanel->Align   = alBottom;
			TxtPrvSplitter->Align	  = alBottom;
		}
	}
	else {
		TxtTailListPanel->Visible = false;
		TxtPrvSplitter->Visible	  = false;
	}

	//リストボックスに割り当て
	TListBox *lp = GetCurInfListBox();
	assign_InfListBox(lp, i_lst.get(), (ScrMode==SCMD_IVIEW)? ImgInfScrPanel : InfScrPanel);

	//ステータスバー表示
	SetSttBarInf(fp);

	//--------------------------------------------------
	//イメージプレビュー表示
	//--------------------------------------------------
	if (ScrMode==SCMD_FLIST && ImgViewThread) {
		
		bool no_prv = (!fp || fp->failed || TxtPrvListPanel->Visible || !PreviewPanel->Visible);
		if (!no_prv && !force) {
			//イメージプレビューを表示しないパスのチェック
			no_prv = is_NoInfPath(fp, NoImgPrvPath);
			if (!no_prv && !fp->is_dir) {
				//表示する拡張子
				if (!FExtImgPrv.IsEmpty()) no_prv = !test_FileExt(fp->f_ext, FExtImgPrv);
				//表示しない拡張子
				if (!no_prv) no_prv = test_FileExtSize(fp->f_ext, FExtNoImgPrv, fp->f_size);
			}
		}

		if (!no_prv) {
			SetPrvImgCursor(false);
			PreviewSttLabel->Visible = false;

			UnicodeString fnam, fext;
			bool is_dir, is_video;
			//ショートカット
			if (test_LnkExt(fp->f_ext)) {
				fnam   = fp->r_name;
				is_dir = dir_exists(fnam);
				fext   = is_dir? EmptyStr : get_extension(fp->r_name);
				is_video = fp->is_video;
				//fp->img_ori, fp->is_video は反映されている
			}
			//通常
			else {
				//フォルダアイコン
				if (fp->is_dir && !ShowDirJumboIco && !fp->is_virtual && !fp->is_ftp) {
					fnam = get_FolderIconName(fp->f_name);
					is_dir = false;
					is_video = false;
				}
				//その他
				if (fnam.IsEmpty()) {
					is_dir = fp->is_dir;
					fnam   = (fp->is_virtual || fp->is_ftp)? fp->tmp_name :
							 fp->is_up? ExcludeTrailingPathDelimiter(fp->p_name) : fp->f_name;
					is_video = fp->is_video;
				}
				fext = get_extension(fnam);
			}

			if (file_exists(fnam) && (is_dir || !is_Processing(fnam, is_video))) {
				//動画
				if (is_video) {
					ImgViewThread->AddRequest(_T("VIDEO"), fnam);
				}
				//GIF
				else if (PreviewAniGif && test_GifExt(fext)) {
					ImgBuff->Handle = NULL;
					ImgViewThread->AddRequest(_T("EMPTY"));
					try {
						std::unique_ptr<TGIFImage> gif_buf(new TGIFImage());
						gif_buf->LoadFromFile(fnam);
						gif_buf->Animate	 = true;
						gif_buf->Transparent = true;
						PreviewImage->Picture->Assign(gif_buf.get());
						PreviewImage->Transparent  = true;
						PreviewImage->Align 	   = alClient;
						PreviewImage->Center	   = true;
						PreviewImage->Proportional = true;
					}
					catch (...) {
						PreviewImage->Picture->Assign(NULL);
					}
				}
				//画像
				else if (is_ViewableFext(fext)) {
					ImgViewThread->AddRequest(_T("ROTATION"), 0);
					ImgViewThread->AddRequest(_T("EXIFORI"),  fp->img_ori);
					ImgViewThread->AddRequest(_T("FILE"), fnam);
				}
				//PSP (サムネイル)
				else if (test_PspExt(fext)) {
					ImgViewThread->AddRequest(_T("FILE"), fnam);
				}
				//MP3、FLAC (埋め込み画像)
				else if (test_Mp3Ext(fext) || test_FlacExt(fext)) {
					ImgViewThread->AddRequest(_T("FILE"), fnam);
				}
				//フォルダ (特大アイコン、可能ならサムネイル)
				else if (is_dir && ShowDirJumboIco) {
					ImgViewThread->AddRequest(_T("FILE"), IncludeTrailingPathDelimiter(fnam));
				}
				//ZIP (画像)
				else if (ShowInZipImg && usr_ARC->HasZipImg(fnam, get_img_fext())) {
					ImgViewThread->AddRequest(_T("FILE"), fnam);
				}
				//その他 (アイコン/フォント/色見本)
				else {
					if (test_FileExt(fext, FEXT_ICONVIEW)) {
						int ixn = (int)::ExtractIcon(HInstance, fnam.c_str(), -1);
						if (ixn>1) add_PropLine(_T("アイコン数"), ixn, lp->Items);
					}

					//背景をクリア
					std::unique_ptr<Graphics::TBitmap> v_bmp(new Graphics::TBitmap());
					TCanvas *cv = v_bmp->Canvas;
					v_bmp->SetSize(PreviewImage->ClientWidth, PreviewImage->ClientHeight);
					cv->Brush->Color = col_bgImage;
					cv->FillRect(PreviewImage->ClientRect);
					PreviewImage->Picture->Bitmap->Assign(v_bmp.get());

					//読込中メッセージ
					TLabel *lp = PreviewSttLabel;
					lp->Caption 	= "読込中...";
					lp->Font->Color = col_Teal;
					lp->Top 		= PreviewPanel->ClientHeight - lp->Height - 4;
					lp->Left		= 8;
					lp->Visible 	= true;

					//スレッドを設定
					ImgViewThread->ViewBuff->Assign(v_bmp.get());
					if (is_dir) fnam = IncludeTrailingPathDelimiter(fnam);
					ImgViewThread->AddRequest(_T("USEBUF"), fnam);
				}
			}
			else ImgViewThread->AddRequest(_T("CLEAR"));
		}
		else ImgViewThread->AddRequest(_T("CLEAR"));
	}

	ViewInfCnt--;
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ViewCurFileInf()
{
	file_rec *cfp = GetCurFrecPtr(true, true);
	if (cfp) ViewFileInf(cfp, true);
}

//---------------------------------------------------------------------------
//2ストローク操作を中断
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::CancelKeySeq()
{
	KeyHintTimer->Enabled = false;
	KeyHint->ReleaseHandle();
	MsgHint->ReleaseHandle();
	SetSttBarInf();
	FirstKey   = EmptyStr;
	Wait2ndKey = false;
}
//---------------------------------------------------------------------------
//2ストローク操作の処理
//---------------------------------------------------------------------------
UnicodeString __fastcall TNyanFiForm::TwoStrokeSeq(WORD &Key, TShiftState Shift)
{
	UnicodeString id_str = GetModeIdStr() + ":";
	if (id_str.IsEmpty()) return EmptyStr;

	UnicodeString key_str = get_KeyStr(Key);	if (key_str.IsEmpty()) return EmptyStr;
	key_str = get_ShiftStr(Shift) + key_str;

	//2ストローク目
	if (Wait2ndKey) {
		Wait2ndKey = false;
		key_str.sprintf(_T("%s~%s"), FirstKey.c_str(), get_KeyStr(Key).c_str());
		CancelKeySeq();
		//有効？
		UnicodeString key_n = id_str + key_str;
		UnicodeString key_s = (ScrMode==SCMD_FLIST)? "F:SELECT+" + key_str : EmptyStr;
		if (KeyFuncList->Values[key_n].IsEmpty() && KeyFuncList->Values[key_s].IsEmpty()) {
			if (!equal_ESC(get_tkn_r(key_n, '~'))) {
				if (ShowNoKeyHint)
					SttBarWarn(UnicodeString().sprintf(_T("[%s] には割り当てられていません。"), get_tkn_r(key_n, ':').c_str()));
				key_str = EmptyStr;
				Key = 0;
			}
		}
	}
	//1ストローク目
	else if (is_FirstKey(id_str, key_str)) {
		FirstKey   = key_str;
		Wait2ndKey = true;
		StatusBar1->Panels->Items[0]->Text = "2ストロークキー: " + FirstKey + "~";
		if (ShowKeyHint) {
			KeyHintTimer->Interval = KeyHintTime;
			KeyHintTimer->Enabled  = true;
		}
		Key = 0;
	}

	return key_str;
}

//---------------------------------------------------------------------------
TPoint __fastcall TNyanFiForm::CurListItemPos()
{
	return get_ListItemPos(FileListBox[CurListTag]);
}

//---------------------------------------------------------------------------
//ファイルリストの描画
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::FileListDrawItem(TWinControl *Control, int Index, TRect &Rect,
		TOwnerDrawState State)
{
	TListBox *lp = (TListBox*)Control;
	int tag = lp->Tag;
	flist_stt *lst_stt = &ListStt[tag];
	TStringList *lst   = GetFileList(tag);
	TStringList *o_lst = GetFileList((tag==0)? 1 : 0);

	file_rec *fp = (Index<lst->Count)? (file_rec*)lst->Objects[Index] : NULL;
	if (!fp) return;

	file_rec *d_fp = IsDiffList()? ((Index<o_lst->Count)? (file_rec*)o_lst->Objects[Index] : NULL) : NULL;

	//一時的ビットマップに一旦描画(ちらつき防止)
	TRect tmp_rc = Rect;
	OffsetRect(tmp_rc, 0, -tmp_rc.Top);

	std::unique_ptr<Graphics::TBitmap> tmp_bmp(new Graphics::TBitmap());
	tmp_bmp->SetSize(Rect.Width(), tmp_rc.Height());
	TCanvas *tmp_cv = tmp_bmp->Canvas;
	tmp_cv->Font->Assign(lp->Font);
	bool is_irreg = IsIrregularFont(tmp_cv->Font);

	TPenStyle csr_style = psClear;
	if (Index==lp->ItemIndex
		&& (ActiveControl==FileListBox[0] || ActiveControl==FileListBox[1] || ActiveControl==FilterComboBox))
	{
		if (tag==CurListTag &&
			(State.Contains(odFocused) || KeepCurCsr>0 || lst_stt->is_Filter
				|| GeneralInfoDlg->Visible || FileInfoDlg->Visible || (OptionDlg && OptionDlg->Visible)))
		{
			if (KeepCurCsr>0) KeepCurCsr--;
			csr_style = psSolid;
		}
		else if (tag==OppListTag) {
			if (IsDiffList()) {
				csr_style = psDot;
			}
			else {
				if (OppStt->is_Work && RegWorkCsrPos && (NotSortWorkList || WorkListHasSep)) {
					csr_style = psDot; 
				}
				else {
					file_rec *cfp = GetCurFrecPtr(true);
					file_rec *ofp = GetOppFrecPtr();
					if (cfp && ofp) {
						if (CurStt->is_Find || CurStt->is_Work) {
							UnicodeString c_fnam = cfp->f_name;
							if (contains_Slash(c_fnam)) c_fnam = get_tkn_r(c_fnam, '/');
							if (SameText(c_fnam, ofp->f_name) && (!cfp->is_dir || CurStt->find_DirLink)) csr_style = psDot;
						}
						else if (DrawOppCsr>0) {
							DrawOppCsr--;
							csr_style = psDot; 
						}
					}
				}
			}
		}
	}

	//背景
	TColor bg_nrm = get_FlBgColor(lst_stt, Index);
	tmp_cv->Brush->Color = fp->selected? ((CurListTag==tag)? lst_stt->color_selItem : col_oppItem) :
						(lst_stt->is_IncSea && !lst_stt->is_Filter && fp->matched)? col_matchItem : bg_nrm;
	if (!HideBgImg[tag] && BgImgMode>0 && tmp_cv->Brush->Color==bg_nrm && !BgBuff[tag]->Empty) {
		tmp_cv->CopyRect(tmp_rc, BgBuff[tag]->Canvas, Rect);
		tmp_cv->Brush->Style = bsClear;
	}
	else {
		tmp_cv->Brush->Style = bsSolid;
		tmp_cv->FillRect(tmp_rc);
		tmp_cv->Brush->Style = bsClear;
	}

	//カーソル行背景
	if (csr_style==psSolid && CursorAlpha>0) {
		alpha_blend_Rect(tmp_cv, 0, 0, tmp_rc.Width(), tmp_rc.Height(), lst_stt->color_Cursor, CursorAlpha);
	}

	if (fp->is_dummy && is_separator(fp->alias)) {
		//ワークリストのセパレータ
		TRect sp_rc = tmp_rc;
		sp_rc.Right = lst_stt->lxp_right;
		draw_Separator(tmp_cv, sp_rc, bg_nrm);
	}
	else {
		//拡張子色
		TColor col_x = fp->is_dummy? col_InvItem : get_ExtColor(fp->f_ext);
		//名前色
		TColor col_f = fp->is_dummy? col_InvItem : (fp->is_sym && SymColorToName)? col_SymLink : get_FileColor(fp, col_x);

		bool use_fgSel = (fp->selected && col_fgSelItem!=col_None);

		//表示位置
		bool use_ico = (IconMode==1) || (fp->is_dir && IconMode==2);
		int w_half = lst_stt->lwd_half;
		int w_file = w_half * 8;
		int x_base = ScaledInt(use_ico? 20 : ((fp->is_dir && !DirBraStr.IsEmpty())? 4 : 8));
		int w_date = std::max(lst_stt->lxp_time - lst_stt->lwd_size - x_base - w_half, w_file + lst_stt->lwd_fext);

		int yp = tmp_rc.Top;
		int dy = ListInterLn - CursorWidth;
		if (!has_Leading(tmp_cv) && dy>0) yp += dy;

		bool draw_time = false;
		bool nochk_unc = lst_stt->is_Work && NoCheckWorkUnc && StartsStr("\\\\", fp->p_name);

		if (!HideSizeTime) {
			//ディレクトリ容量グラフ
			if (fp->is_dir && lst_stt->cur_total>0 &&
				((lst_stt->dir_graph && fp->f_size>=0) ||											//対カレント
				 (lst_stt->dsk_graph && (fp->f_size>=0 || fp->is_up) && lst_stt->drive_Total>0)))	//対ドライブ
			{
				//パーセント値
				float r_dir = lst_stt->dir_graph ? 1.0 * fp->f_size / lst_stt->cur_total
												 : 1.0 * (fp->is_up? lst_stt->cur_total : fp->f_size) / lst_stt->drive_Total;
				UnicodeString per_str;
				per_str.sprintf(_T("%4.1f"), r_dir * 100.0);
				tmp_cv->Font->Color = col_fgList;
				int w_p4 = get_CharWidth(tmp_cv, 4, 2);
				if (is_irreg) w_p4 += 4;
				int x_grph = lst_stt->lxp_time + w_p4;
				int w_per  = tmp_cv->TextWidth(per_str);
				if (is_irreg) w_per += per_str.Length();
				tmp_cv->TextOut(x_grph - w_per - ScaledInt(2), yp, per_str);
				//グラフ
				TRect g_rc = tmp_rc;
				g_rc.Left = x_grph; g_rc.Right = x_grph + lst_stt->lwd_time - w_p4;
				g_rc.Top += 4; g_rc.Bottom -= ListInterLn;
				draw_BarGraph(tmp_cv, g_rc, r_dir);
			}
			//ディレクトリ内のファイル、ディレクトリ数
			else if (fp->is_dir && fp->f_size>=0 && lst_stt->show_f_d_cnt) {
				//ファイル数
				UnicodeString cnt_str = fp->f_count;
				int w_cnt = tmp_cv->TextWidth(cnt_str);
				if (is_irreg) w_cnt += cnt_str.Length();
				int xp;
				if (TimeStampFmt.Length()>10) {
					xp = lst_stt->lxp_time + lst_stt->lwd_time*4/7 - w_cnt;
					tmp_cv->Font->Color = col_fgList;
					tmp_cv->TextOut(xp, yp, cnt_str);
					//ディレクトリ数
					cnt_str = fp->d_count;
					w_cnt = tmp_cv->TextWidth(cnt_str);
					if (is_irreg) w_cnt += cnt_str.Length();
					tmp_cv->Font->Color = col_Folder;
				}
				else {
					tmp_cv->Font->Color = col_fgList;
				}

				xp = lst_stt->lxp_time + lst_stt->lwd_time - w_cnt;
				tmp_cv->TextOut(xp, yp, cnt_str);
			}
			//タイムスタンプ
			else if (!fp->is_dummy && !(fp->is_ftp && fp->is_up) && fp->f_attr!=faInvalid && !nochk_unc) {
				draw_time = true;
			}
		}

		//名前
		UnicodeString dsp_name = fp->b_name;
		if (lst_stt->is_Work && !fp->alias.IsEmpty()) dsp_name = fp->alias;

		UnicodeString hs_ch = ">";	//半角空白記号用の一時置換文字
		UnicodeString zs_ch = "<";	//全角空白記号用の一時置換文字
		if (ShowSpace) {
			//名前以外の空白と区別するために置換
			dsp_name = ReplaceStr(dsp_name, " ",  hs_ch);
			dsp_name = ReplaceStr(dsp_name, "　", zs_ch);
		}

		dsp_name = ReplaceStr(dsp_name, L"\u202e", "|");	//RLO --> | (警告表示)
		if (fp->is_dir && !use_ico) dsp_name = DirBraStr + dsp_name + DirKetStr;

		int w_name;
		if (HideSizeTime) {
			w_name = lst_stt->lxp_right - x_base - w_half;
			if (!fp->is_dir) w_name -= lst_stt->lwd_fext;
		}
		else {
			w_name = fp->is_dir? w_date : std::max(w_date - lst_stt->lwd_fext, w_file);
		}
		dsp_name = minimize_str(dsp_name, tmp_cv, w_name, OmitEndOfName);


		TColor bg_name = (d_fp && d_fp->is_dummy)? col_DifferN :
					IniFile->IsMarked(fp->r_name)? col_bgMark : col_None;
		if (bg_name!=col_None) {
			TRect mrc  = tmp_rc;
			mrc.Left   = x_base;
			mrc.Right  = (HideSizeTime? lst_stt->lxp_right : lst_stt->lxp_size) - w_half;
			mrc.Bottom = yp + tmp_cv->TextHeight("Q");
			tmp_cv->Brush->Color = bg_name;	//マーク / 相違箇所
			tmp_cv->FillRect(mrc);
			tmp_cv->Brush->Style = bsClear;
		}

		if (!dsp_name.IsEmpty()) {
			int xp = x_base;
			SpaceTextOut(dsp_name, tmp_cv, xp, yp, (use_fgSel? col_fgSelItem : col_f));
		}

		//拡張子
		if (!fp->is_dir) {
			UnicodeString dsp_ext = ReplaceStr(fp->f_ext, L"\u202e", "|");	//RLO --> | (警告表示)
			int x_fext;
			if (NoSpaceFExt) {
				int w_nam = tmp_cv->TextWidth(dsp_name);
				if (is_irreg) w_nam += dsp_name.Length();
				int w_ext = (HideSizeTime? lst_stt->lxp_right : lst_stt->lxp_size) - x_base - w_half - w_nam;
				x_fext = x_base + w_nam;
				dsp_ext = minimize_str(dsp_ext, tmp_cv, w_ext, true);
			}
			else {
				x_fext = HideSizeTime? lst_stt->lxp_right - lst_stt->lwd_fext - w_half : lst_stt->lxp_fext;
				dsp_ext = minimize_str(dsp_ext, tmp_cv, lst_stt->lwd_fext, true);
			}

			if (ShowSpace) {
				dsp_ext = ReplaceStr(dsp_ext, " ",  hs_ch);
				dsp_ext = ReplaceStr(dsp_ext, "　", zs_ch);
			}

			if (!use_fgSel && (PriorFExtCol || ColorOnlyFExt || (fp->is_sym && SymColorToName)))
				tmp_cv->Font->Color = col_x;

			SpaceTextOut(dsp_ext, tmp_cv, x_fext, yp, tmp_cv->Font->Color);
		}

		//サイズ/ タイムスタンプ
		if (!HideSizeTime && !fp->is_dummy && !nochk_unc) {
			__int64 fsize = (lst_stt->dsk_graph && fp->is_up)? lst_stt->cur_total : fp->f_size;
			UnicodeString sz_str = get_FileSizeStr(fsize);
			if (ShowDirType && Trim(sz_str).IsEmpty() && fp->is_dir) {
				sz_str = fp->is_jct? "<JCT>" : fp->is_sym? "<SYM>" : "<DIR>";
			}

			int w_sz = tmp_cv->TextWidth(sz_str);
			if (is_irreg) w_sz += sz_str.Length();
			int x_sz = lst_stt->lxp_size + lst_stt->lwd_size - w_sz - w_half;

			//ディレクトリ比較結果
			if (IsDiffList() && !fp->is_up) {
				TRect mrc  = tmp_rc;
				mrc.Bottom = yp + tmp_cv->TextHeight("Q");

				//サイズ
				if (d_fp && !d_fp->is_dummy) {
					//相違箇所の背景
					if (fp->f_size!=d_fp->f_size) {
						mrc.Left  = lst_stt->lxp_size;
						mrc.Right = mrc.Left + lst_stt->lwd_size - w_half;
						tmp_cv->Brush->Color = col_Differ;
						tmp_cv->FillRect(mrc);
						tmp_cv->Brush->Style = bsClear;
					}
				}
				tmp_cv->Font->Color = use_fgSel? col_fgSelItem : get_SizeColor(fsize, col_f);
				tmp_cv->TextOut(x_sz, yp, sz_str);
	
				//タイムスタンプ
				if (draw_time) {
					if (d_fp && !d_fp->is_dummy) {
						//相違箇所の背景
						if (fp->f_time!=d_fp->f_time) {
							mrc.Left  = lst_stt->lxp_time;
							mrc.Right = mrc.Left + lst_stt->lwd_time;
							tmp_cv->Brush->Color = (fp->f_time>d_fp->f_time)? col_DifferN : col_Differ;
							tmp_cv->FillRect(mrc);
							tmp_cv->Brush->Style = bsClear;
						}
					}
					tmp_cv->Font->Color = use_fgSel? col_fgSelItem : get_TimeColor(fp->f_time, col_f);
					tmp_cv->TextOut(lst_stt->lxp_time, yp, FormatDateTime(TimeStampFmt, fp->f_time));
				}
			}
			//通常
			else {
				//サイズ
				tmp_cv->Font->Color = use_fgSel? col_fgSelItem : get_SizeColor(fsize, col_f);
				tmp_cv->TextOut(x_sz, yp, sz_str);
				//タイムスタンプ
				if (draw_time) {
					tmp_cv->Font->Color = use_fgSel? col_fgSelItem : get_TimeColor(fp->f_time, col_f);
					tmp_cv->TextOut(lst_stt->lxp_time, yp, FormatDateTime(TimeStampFmt, fp->f_time));
				}
			}
		}

		//場所/タグ (検索結果リスト)
		if (lst_stt->is_Find && !HideSizeTime && !fp->is_dummy && !fp->is_up) {
			int xp = lst_stt->lxp_path;
			//タグ
			if (lst_stt->find_TAG && FindTagsColumn) {
				usr_TAG->DrawTags(fp->tags, tmp_cv, xp, yp, RevTagCololr? col_bgFind : col_None);
			}
			//場所
			else if (FindPathColumn) {
				UnicodeString pstr = fp->p_name;
				remove_top_text(pstr, lst_stt->find_Path);
				pstr = get_MiniPathName(pstr, lst_stt->lwd_path - w_half, tmp_cv->Font);
				tmp_cv->Font->Color = use_fgSel? col_fgSelItem : fp->is_dummy? col_InvItem : col_Folder;
				PathNameOut(pstr, tmp_cv, xp, yp);
			}
		}

		//アイコン
		if (use_ico) draw_SmallIcon(fp, tmp_cv, 2, std::max(yp + (int)(tmp_cv->TextHeight("I") - SIcoSize)/2, 0));
	}

	//カーソル
	if (csr_style!=psClear) {
		//カーソルを描画
		int xp_r = HideScrBar? ((tag==1)? R_Panel->ClientWidth : L_Panel->ClientWidth) : tmp_rc.Right;
		int p_wd = (csr_style==psSolid)? CursorWidth : 1;
		if (p_wd==0 && CursorAlpha==0) p_wd = 1;
		if (p_wd>0) draw_Line(tmp_cv, 0, tmp_rc.Bottom - 2, xp_r, tmp_rc.Bottom - 2, p_wd, lst_stt->color_Cursor, csr_style);
	}

	//描画
	lp->Canvas->Draw(Rect.Left, Rect.Top, tmp_bmp.get());
	if (State.Contains(odFocused)) lp->Canvas->DrawFocusRect(Rect);
}

//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::FileListBoxEnter(TObject *Sender)
{
	TListBox *lp = (TListBox*)Sender;

	flist_stt *cur_stt = &ListStt[lp->Tag];

	if (!cur_stt->is_Arc && !cur_stt->is_Find && !cur_stt->is_Work && !cur_stt->is_FTP) {
		if (!CheckUncPath(CurPath[lp->Tag])) CurPath[lp->Tag] = CheckAvailablePath(EmptyStr, lp->Tag);
	}

	SetCurStt(lp->Tag);

	LastIndex[CurListTag] = lp->ItemIndex;

	//カレント側の幅を維持
	if (Initialized && KeepCurListWidth) {
		//上下
		if (DivFileListUD) {
			int r_hi = LRSplitter->Height;
			if (TabPanel->Visible) r_hi += TabPanel->Height;
			if (HdrPanel->Visible) r_hi += HdrPanel->Height;
			int opp_hi = ListPanel->ClientHeight - CurListHeight - r_hi;
			if (CurListHeight>0 && abs(L_Panel->Height - R_Panel->Height)>2) {
				L_Panel->Height = (CurListTag==0)? CurListHeight : opp_hi;
			}
		}
		//左右
		else {
			int opp_wd = ListPanel->ClientWidth - CurListWidth - LRSplitter->Width;
			if (CurListWidth>0 && abs(opp_wd - CurListWidth)>2) {
				L_Panel->Width = (CurListTag==0)? CurListWidth : opp_wd;
			}
		}
	}

	SetFileInf();
	UpdateFKeyBtn();
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::FileListBoxExit(TObject *Sender)
{
	if (CurStt->is_IncSea) ExitIncSearch(); else InvalidateFileList();

	CancelKeySeq();
}

//---------------------------------------------------------------------------
//ファイルリストヘッダのマウス操作
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::FileListHeaderSectionClick(THeaderControl *HeaderControl,
		THeaderSection *Section)
{
	if ((CurStt->is_Work && (NotSortWorkList || WorkListHasSep))
		|| (CurStt->is_Find && CurStt->find_DUPL) || IsDiffList())
	{
		SetActionAbort();  return;
	}

	int tag = HeaderControl->Tag;
	bool chg_tag = false;
	if (tag!=CurListTag) {
		if (tag==0) ToLeftAction->Execute(); else ToRightAction->Execute();
		tag = CurListTag;
		chg_tag = true;
	}

	file_rec *fp = GetCurFrecPtr();
	UnicodeString fnam = (fp && !fp->is_dummy)? fp->f_name : EmptyStr;

	flist_stt *lst_stt = &ListStt[tag];

	int  last_mode = SortMode[tag];
	bool last_path = lst_stt->find_PathSort;
	if (Section->Index==4) {
		lst_stt->find_PathSort = true;
	}
	else {
		lst_stt->find_PathSort = false;
		switch (Section->Index) {
		case 0: SortMode[tag] = 0; break;
		case 1: SortMode[tag] = 1; break;
		case 2: SortMode[tag] = 3; break;
		case 3: SortMode[tag] = 2; break;
		}
	}

	//昇順/降順切り替え
	if (!chg_tag && (last_mode==SortMode[tag] && last_path==lst_stt->find_PathSort)) {
		switch (Section->Index) {
		case 0: FlOdrDscName[tag] = !FlOdrDscName[tag]; break;
		case 1: FlOdrDscName[tag] = !FlOdrDscName[tag]; break;
		case 2: FlOdrSmall[tag]   = !FlOdrSmall[tag];	break;
		case 3: FlOdrOld[tag]	  = !FlOdrOld[tag];		break;
		case 4: FlOdrDscPath[tag] = !FlOdrDscPath[tag]; break;
		}
	}

	RepaintList(tag, fnam, true);
}

//---------------------------------------------------------------------------
//ファイルリストのマウス操作
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::FileListBoxMouseDown(TObject *Sender, TMouseButton Button, TShiftState Shift, int X, int Y)
{
	if (DblClicked || ExeCmdsBusy) return;

	if (CurWorking) {
		FileListBox[WorkingTag]->SetFocus();
		return;
	}

	if (FindBusy) {
		FileListBox[FindTag]->SetFocus();
		return;
	}

	CancelKeySeq();

	TListBox *lp = (TListBox*)Sender;
	if (lp->Tag!=CurListTag) {
		if (lp->Tag==0) ToLeftAction->Execute(); else ToRightAction->Execute();
	}
	if (Shift.Contains(ssRight)) {
		int idx = lp->ItemAtPos(Point(X, Y), true);
		if (idx!=-1) lp->ItemIndex = idx;
	}

	SetCurStt(lp->Tag);
	MoveTag   = lp->Tag;
	MoveIndex = lp->ItemIndex;
	MoveCnt   = 1;

	//マウスによる選択
	TStringList *lst = GetCurList(true);
	file_rec *cfp = GetFrecPtr(lp, lst);
	if (cfp) {
		if (SelectByMouse && Shift.Contains(ssLeft) && !Shift.Contains(ssAlt)) {
			bool has_icon = (IconMode==1 || (IconMode==2 && cfp->is_dir));
			//ファイル名主部までの範囲
			int b_wd;
			if (cfp->is_dummy && is_separator(cfp->alias))	//ワークリストのセパレータ
				b_wd = get_CharWidth(lp->Canvas, 12);		//***
			else {
				b_wd = lp->Canvas->TextWidth(cfp->b_name);
				if 		(has_icon)							  b_wd += get_IcoWidth();
				else if (cfp->is_dir && !DirBraStr.IsEmpty()) b_wd += lp->Canvas->TextWidth(DirBraStr) + 4;
				else										  b_wd += Scaled8;
			}

			//アイコン部分で個別に選択
			if (SelectIconSngl && has_icon && X<get_IcoWidth()) {
				set_select(cfp, !cfp->selected);
			}
			//通常選択
			else if (cfp->selected || !SelectBaseOnly || X<b_wd) {
				//Left
				if (!Shift.Contains(ssShift) && !Shift.Contains(ssCtrl)) {
					if (!cfp->selected) ClrSelect(lst);
					set_select(cfp);
				}
				//Ctrl + Left
				else if (!Shift.Contains(ssShift) && Shift.Contains(ssCtrl)) {
					set_select_r(cfp);
				}
				//Shift + Left
				else if (Shift.Contains(ssShift) && !Shift.Contains(ssCtrl)) {
					ClrSelect(lst);
					if		(LastIndex[CurListTag]==-1)			LastIndex[CurListTag] = lp->ItemIndex;
					else if (LastIndex[CurListTag]>=lp->Count)	LastIndex[CurListTag] = lp->Count - 1;
					if (LastIndex[CurListTag]<lp->ItemIndex) {
						for (int i=LastIndex[CurListTag]; i<=lp->ItemIndex; i++)
							set_select((file_rec*)lst->Objects[i]);
					}
					else  {
						for (int i=lp->ItemIndex; i<=LastIndex[CurListTag]; i++)
							set_select((file_rec*)lst->Objects[i]);
					}
				}
			}
			else if (!Shift.Contains(ssShift) && !Shift.Contains(ssCtrl)) {
				ClrSelect(lst);
			}
		}
		else if (Shift.Contains(ssRight)) {
			if (!cfp->selected) ClrSelect(lst);
		}
	}
	else {
		ClrSelect(lst);
	}

	LastIndex[CurListTag] = lp->ItemIndex;
	lp->Repaint();
	SetDriveInfo();
	SetFileInf();
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::FileListBoxMouseUp(TObject *Sender, TMouseButton Button, TShiftState Shift, int X, int Y)
{
	if (DblClicked) {
		DblClicked = false;
	}
	else {
		MoveCnt 	 = 0;
		MoveTag 	 = -1;
		MoveIndex	 = -1;
		DragStartTag = -1;
		ActionParam  = EmptyStr;

		if (CurWorking || FindBusy || ExeCmdsBusy) return;

		//コンテキストメニューの表示
		if (Button==mbRight) {
			R_Clicked = true;
			TListBox *lp = (TListBox*)Sender;
			//カーソル位置項目上か?
			RClickAtCur = (lp->ItemAtPos(Point(X, Y), true)==lp->ItemIndex);
			if (!OnFlRClick.IsEmpty())
				//イベント: ファイルリストで右クリック
				ExeEventCommandMP(OnFlRClick);
			else {
				InhReload++;
				ContextMenuAction->Execute();
			}
			lp->Repaint();
			RClickAtCur = false;
		}

		R_Clicked = false;
	}
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::FileListBoxDblClick(TObject *Sender)
{
	if (CurWorking || FindBusy || ExeCmdsBusy || usr_ARC->Busy) return;

	DblClicked = true;

	bool on_body = false;
	TListBox *lp = (TListBox*)Sender;
	TPoint p = lp->ScreenToClient(Mouse->CursorPos);
	int idx = lp->ItemAtPos(p, true);
	if (idx!=-1) {
		TStringList *lst = GetCurList(true);
		file_rec *cfp = (idx<lst->Count)? (file_rec*)lst->Objects[idx] : NULL;
		if (cfp && !cfp->is_dummy) {
			int b_wd = lp->Canvas->TextWidth(cfp->b_name);
			if (IconMode==1 || (IconMode==2 && cfp->is_dir)) b_wd += get_IcoWidth();
			else if (cfp->is_dir && !DirBraStr.IsEmpty()) 	 b_wd += lp->Canvas->TextWidth(DirBraStr) + 4;
			else										  	 b_wd += Scaled8;
			on_body = (p.x < b_wd);
		}
	}

	if (!on_body && !OnFlExDClick.IsEmpty()) {
		ExeEventCommand(OnFlExDClick);
		return;
	}
	if (idx==-1) return;

	ActionParam = EmptyStr;
	bool res = true;
	switch (DblClickFlMode) {
	case 0: res = ExeCmdAction(OpenStandardAction);	break;
	case 1: res = ExeCmdAction(OpenByWinAction);	break;
	case 2: res = ExeCmdAction(OpenByAppAction);	break;
	}
	if (!res) SttBarWarn(ActionErrMsg);
}

//---------------------------------------------------------------------------
//ファイルリストからドラッグ＆ドロップ
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::FileListBoxMouseMove(TObject *Sender, TShiftState Shift, int X, int Y)
{
	if ((!Shift.Contains(ssLeft) && !Shift.Contains(ssRight))) { DragStartTag = -1;  return; }

	TListBox *lp = (TListBox*)Sender;
	if (MoveTag==lp->Tag) lp->ItemIndex = MoveIndex;
	if (MoveCnt==0 || ++MoveCnt<6) return;	//***
	MoveCnt = 0;

	if (CurWorking || FindBusy || ExeCmdsBusy
		|| CurStt->is_Find || CurStt->is_Arc || CurStt->is_ADS || CurStt->is_FTP)
			return;

	//ワークリスト
	if (CurStt->is_Work) {
		if (NotSortWorkList || WorkListHasSep) {
			//項目の並べ替え
			if (lp->ItemAtPos(Point(X, Y), true)>=0) lp->BeginDrag(false, -1);
			PrevListIdx = -1;
		}
		return;
	}

	//ドラッグ対象のリストを作成
	std::unique_ptr<TStringList> flst(new TStringList());
	if (GetCurObjList(flst.get())>0) {
		InvalidateFileList();

		//イベント: ファイルリストからドラッグ開始時
		ExeEventCommand(OnDragStart);

		DragStartTag = lp->Tag;
		usr_SH->DoFilesDragDrop(CurPath[CurListTag], flst.get(), lp->Tag);

		//イベント: ファイルリストからドラッグ完了時
		ExeEventCommand(OnDragEnd);
	}
	else DragStartTag = -1;
}

//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::FileListBoxDragOver(TObject *Sender, TObject *Source, int X, int Y,
	TDragState State, bool &Accept)
{
	if (CurWorking || FindBusy || ExeCmdsBusy) return;

	TListBox *lp = (TListBox*)Sender;
	Accept = (Source==Sender) && (lp->ItemIndex!=-1);  if (!Accept) return;

	int idx = lp->ItemAtPos(Point(X, Y), true);
	draw_ListItemLine(lp, PrevListIdx);		//直前のドロップ先表示を消去
	draw_ListItemLine(lp, idx);				//新しいドロップ先表示を描画

	PrevListIdx = idx;
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::FileListBoxDragDrop(TObject *Sender, TObject *Source, int X, int Y)
{
	if (CurWorking || FindBusy || ExeCmdsBusy) return;

	TListBox *lp = (TListBox*)Sender;
	draw_ListItemLine(lp, PrevListIdx);		//直前のドロップ先表示を消去

	if (CurStt->is_Work && WorkListFiltered) { SetActionAbort(USTR_WorkFiltered); return; }

	//ワークリストの並べ替え
	if (CurStt->is_Work && (NotSortWorkList || WorkListHasSep)) {
		int idx = lp->ItemAtPos(Point(X, Y), true);
		if (idx!=-1) {
			if (GetSelCount(WorkList)>0) {
				//選択項目を切り取って待避
				std::unique_ptr<TStringList> lst(new TStringList());
				int ins_idx = idx;
				int i = 0;
				while (i<WorkList->Count) {
					file_rec *fp = (file_rec*)WorkList->Objects[i];
					if (fp->selected) {
						lst->AddObject(WorkList->Strings[i], (TObject*)fp);
						WorkList->Delete(i);
						if (i<ins_idx) ins_idx--;
					}
					else i++;
				}
				if (ins_idx<idx) ins_idx++;
				//移動先に挿入
				for (int i=lst->Count-1; i>=0; i--) {
					file_rec *fp = (file_rec*)lst->Objects[i];
					fp->selected = false;
					WorkList->InsertObject(ins_idx, lst->Strings[i], (TObject*)fp);
				}
			}
			else {
				WorkList->Move(lp->ItemIndex, idx);
			}

			ChangeWorkList(CurListTag);
			rqWorkListDirInf = !WorkListChanged;
			WorkListChanged  = true;
			lp->ItemIndex	 = idx;
		}
	}
}

//---------------------------------------------------------------------------
//ファイルリストのキー操作
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::FileListKeyDown(TObject *Sender, WORD &Key, TShiftState Shift)
{
	if (!Initialized || UnInitializing || CurWorking) return;

	if (ViewInfCnt>0) {
		Key = 0; return;
	}

	if (get_KeyStr(Key).IsEmpty()) return;

	TListBox *lp = (TListBox*)Sender;
	int idx = lp->ItemIndex;
	if (idx==-1 && lp->Count>0) lp->ItemIndex = idx = 0;
	if (idx==-1) return;

	SetCurStt(lp->Tag);
	LastIndex[CurListTag] = idx;

	TStringList *lst = GetCurList(true);

	//警告メッセージ/背景色をクリア
	TPanel *stt_panel = (CurListTag==0)? L_StatPanel : R_StatPanel;
	if (stt_panel->Tag==SHOW_WARN_TAG) {
		SetDrivePanel(CurListTag, DriveInf[CurListTag]);
		stt_panel->Tag = 0;
	}
	if (StatusBar1->Tag==SHOW_WARN_TAG) {
		StatusBar1->Tag = 0;
		StatusBar1->Repaint();
	}

	//キー
	UnicodeString KeyStr = (CurStt->is_IncSea || ExeCmdsBusy)? get_KeyStr(Key, Shift) : TwoStrokeSeq(Key, Shift);
	if (KeyStr.IsEmpty()) return;

	UnicodeString CmdStr  = Key_to_CmdF(KeyStr);
	UnicodeString CmdStrS = KeyFuncList->Values["F:SELECT+" + KeyStr];
	CancelHelp = (!CmdStr.IsEmpty() || !CmdStrS.IsEmpty()) && EndsStr("F1", KeyStr);

	ActionParam  = EmptyStr;
	fromFileList = true;

	try {
		//インクリメンタルサーチ
		if (CurStt->is_IncSea) {
			FileListIncSearch(KeyStr);
			Key = 0;
		}
		//検索中...
		else if (FindBusy) {
			if		(equal_ESC(KeyStr))						FindAborted = true;		//中断
			else if (contained_wd_i(ONFIND_CMD, CmdStr))	ExeCommandAction(CmdStr);
			else if (equal_ENTER(KeyStr))					ExeCommandAction("OpenStandard");
			else											UserAbort(USTR_ProcBusy);
		}
		//計算中...
		else if (CalcBusy) {
			if (equal_ESC(KeyStr)) CalcAborted = true;		//中断
			else				   UserAbort(USTR_ProcBusy);
		}
		//ExeCommands実行中...
		else if (ExeCmdsBusy) {
			if (!XCMD_Debugging && equal_ESC(KeyStr)) {
				if (msgbox_Sure(USTR_CancelCmdQ, true, true)) XCMD_Aborted = true;
			}
			else if (USAME_TI(CmdStr, "TaskMan")) {
				MsgHint->ReleaseHandle();
				TaskManAction->Execute();
			}
			Key = 0;
		}
		//タブをドラッグ中
		else if (DragTabIndex!=-1) {
			if (equal_ESC(KeyStr)) {
				DragTabIndex = HotTabIndex = -1;
				TabControl1->Cursor = crDefault;
			}
		}
		//仮想ディレクトリ/ 検索結果リスト/ ワークリストから抜ける
		else if (equal_ESC(KeyStr) && (CurStt->is_Arc || CurStt->is_ADS || CurStt->is_Find || CurStt->is_Work)
			&& !USAME_TI(get_CmdStr((GetSelCount(lst)>0)? CmdStrS : CmdStr), "ExeCommands"))
		{
			bool ret_wrk = CurStt->is_Work;
			RecoverFileList2();
			if (ret_wrk && WorkToDirHist) AddDirHistory(CurPath[CurListTag], CurListTag);
		}
		//------------------------------------------
		//コマンド処理
		//------------------------------------------
		else if (GetSelCount(lst)>0 && ExeCommandAction(CmdStrS))
			Key = 0;
		else if (ExeCommandAction(CmdStr))
			Key = 0;
		//------------------------------------------
		//キー処理
		//------------------------------------------
		else if (USAME_TI(KeyStr, "Alt+F4"))		//標準の終了
			ReqClose = true;
		//頭文字サーチ
		else if (is_IniSeaKey(KeyStr)) {	//KeyStr に正規表現パターンが返る
			int f_idx = find_NextFile(lst, idx, EmptyStr, KeyStr, false, true);
			if (f_idx!=-1) {
				ListBoxSetIndex(lp, f_idx);
				SetFileInf();
			}
		}
		//F:Enter キーの処理
		else if (equal_ENTER(KeyStr)) {
			if (!ExeCmdAction(OpenStandardAction)) ActionAbort();
		}
		//コンテキストメニュー
		else if (contained_wd_i(KeysStr_Popup, KeyStr)) {
			ContextMenuAction->Execute();
		}
		if (!is_DialogKey(Key)) Key = 0;
	}
	catch (EAbort &e) {
		Key = 0;
		SttBarWarn(e.Message);
	}

	fromFileList = false;
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::FileListKeyPress(TObject *Sender, System::WideChar &Key)
{
	Key = 0;
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::FileListBoxKeyUp(TObject *Sender, WORD &Key, TShiftState Shift)
{
	if (IsDiffList() && !has_KeyDownMsg()) FileListBox[OppListTag]->Repaint();
}

//---------------------------------------------------------------------------
//インクリメンタルサーチのマッチ数を取得/リストの絞り込み
//---------------------------------------------------------------------------
int __fastcall TNyanFiForm::set_IncSeaStt(
	bool sel_sw, 		//マッチしたら選択				(default = false)
	bool smsk_sw)		//選択マスクを設定して絞り込み	(default = false)
{
	int match_cnt = 0;
	CurStt->incsea_Ptn = usr_Migemo->GetRegExPtn(CurStt->is_Migemo, CurStt->incsea_Word);

	TStringList *sm_lst = SelMaskList[CurListTag];
	if (smsk_sw) sm_lst->Clear();

	FlScrPanel[CurListTag]->KeyWordChanged(EmptyStr, 0);

	TStringList *lst = GetCurList();
	if ((CurStt->is_Migemo && !CurStt->incsea_Ptn.IsEmpty()) ||
	    (!CurStt->is_Migemo && !CurStt->incsea_Word.IsEmpty()))
	{
		FlScrPanel[CurListTag]->KeyWordChanged(CurStt->incsea_Word, lst->Count);

		TRegExOptions opt;
		if (!IncSeaCaseSens) opt << roIgnoreCase;
		int i = 0;
		while (i<lst->Count) {
			file_rec *fp = (file_rec*)lst->Objects[i];
			if (!fp->is_up && !fp->is_dummy) {
				UnicodeString lbuf = (!fp->alias.IsEmpty())? (fp->alias + fp->f_ext) : fp->n_name;
				if (CurStt->find_TAG && FindTagsColumn) lbuf.cat_sprintf(_T("\t%s"), fp->tags.c_str());
				fp->matched = CurStt->is_Migemo ? TRegEx::IsMatch(lbuf, CurStt->incsea_Ptn, opt)
												: contains_word_and_or(lbuf, CurStt->incsea_Word, IncSeaCaseSens);
				if (fp->matched) {
					if (sel_sw) fp->selected = true;
					match_cnt++;
				}
				else if (sel_sw) fp->selected = false;
			}

			if (smsk_sw) {
				//選択マスクを設定して絞り込み
				if (fp->matched) {
				 	sm_lst->Add(fp->f_name);
				 	i++;
				}
				else del_FileListItem(lst, i);
			}
			else {
				if (fp->matched) FlScrPanel[CurListTag]->AddHitLine(i);
				i++;
			}
		}

		if (smsk_sw && lst->Count==0) {
			//空の場合ダミーを追加
			file_rec *fp = cre_new_file_rec(EmptyStr, CurListTag);
			lst->AddObject(fp->f_name, (TObject*)fp);
		}
	}
	else {
		for (int i=0; i<lst->Count; i++) ((file_rec*)lst->Objects[i])->matched = false;
	}

	//ディレクトリ比較結果を反対側に反映
	if (IsDiffList()) CurToOppDiffList();

	return match_cnt;
}

//---------------------------------------------------------------------------
//インクリメンタルサーチでのキー処理
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::FileListIncSearch(UnicodeString keystr)
{
	TListBox     *lp = FileListBox[CurListTag];
	TPanel   *stt_pp = (CurListTag==0)? L_StatPanel : R_StatPanel;
	TStringList *lst = GetCurList();
	file_rec    *cfp = GetCurFrecPtr();
	UnicodeString cur_fnam = is_selectable(cfp)? cfp->f_name : EmptyStr;

	UnicodeString CmdStr = KeyFuncList->Values["S:" + keystr];
	ActionParam = get_PrmStr(CmdStr);
	CmdStr		= get_CmdStr(CmdStr);
	CancelHelp	= !CmdStr.IsEmpty() && EndsStr("F1", keystr);

	bool chg_wd = false;

	//キー割り当て一覧
	if (USAME_TI(CmdStr, "KeyList")) {
		KeyListAction->Execute();
		CmdStr = KeyListDlg->CommandStr;
		if (CmdStr.IsEmpty()) return;
	}

	//サーチモードから抜ける
	if (USAME_TI(CmdStr, "IncSearchExit") || equal_ESC(keystr)) {
		ExitIncSearch();
		return;
	}
	//キーワードをクリア
	else if (USAME_TI(CmdStr, "ClearIncKeyword")) {
		CurStt->incsea_Word = EmptyStr;
		chg_wd = true;
	}
	//Migemoモード切替
	else if (contained_wd_i(_T("MigemoMode|NormalMode"), CmdStr)) {
		CurStt->is_Migemo = USAME_TI(CmdStr, "MigemoMode")? (!CurStt->is_Migemo && usr_Migemo->DictReady) : false;
		CurStt->incsea_Word = EmptyStr;
		(CurStt->is_Filter? LastMigemoModeF : LastMigemoMode) = CurStt->is_Migemo;
		chg_wd = true;
	}
	//選択/解除
	else if (contained_wd_i(_T("Select|SelectDown"), CmdStr)) {
		if (is_selectable(cfp)) {
			cfp->selected = !cfp->selected;
			if (SameText(CmdStr, "SelectDown") || CurStt->is_Filter) CmdStr = "IncSearchDown";
		}
	}
	else if (USAME_TI(CmdStr, "ClearAll")) {
		ClrSelect(lst);
	}
	//インクリメンタルサーチのマッチ項目を選択
	else if (USAME_TI(CmdStr, "IncMatchSelect")) {
		set_IncSeaStt(true);
	}
	//オプション設定
	else if (USAME_TI(CmdStr, "OptionDlg"))
		OptionDlgAction->Execute();
	//ヘルプ
	else if (USAME_TI(CmdStr, "HelpContents"))
		HelpContentsAction->Execute();
	//キーワード履歴
	else if (USAME_TI(CmdStr, "KeywordHistory")) {
		try {
			if (CurStt->is_Migemo) Abort();
			//マッチ可能なものを抽出
			std::unique_ptr<TStringList> kw_lst(new TStringList());
			for (int i=0; i<IncSeaHistory->Count; i++) {
				UnicodeString kwd = IncSeaHistory->Strings[i];
				for (int j=0; j<lst->Count; j++) {
					file_rec *fp = (file_rec*)lst->Objects[j];
					UnicodeString fnam = (!fp->alias.IsEmpty())? (fp->alias + fp->f_ext) : fp->n_name;
					if (IncSeaCaseSens? ContainsStr(fnam, kwd) : ContainsText(fnam, kwd)) {
						kw_lst->Add(kwd); break;
					}
				}
			}
			if (kw_lst->Count==0) Abort();

			ExePopMenuList(kw_lst.get(), true, stt_pp);
			if (PopMenuIndex!=-1) {
				CurStt->incsea_Word = kw_lst->Strings[PopMenuIndex];
				chg_wd = true;
			}
		}
		catch (...) {
			beep_Warn();
			return;
		}
	}
	//キーワード更新
	else {
		chg_wd = update_IncSeaWord(CurStt->incsea_Word, keystr, true);
	}

	//検索
	int match_cnt;
	if (CurStt->is_Filter) {
		if (chg_wd) {
			//絞り込み解除
			ResetIncSeaFilter(CurListTag);
			if (IsDiffList()) ResetIncSeaFilter(OppListTag);
			//絞り込み
			match_cnt = set_IncSeaStt(false, true);
			WorkListFiltered = CurStt->is_Work? (match_cnt>0) : false;

			//リストボックスの更新
			lp->Count = lst->Count;
			if (IndexOfFileList(cur_fnam)==-1) lp->ItemIndex = 0;
			FlScrPanel[CurListTag]->UpdateKnob();
		}
		else {
			match_cnt = GetMatchCount(lst);
		}
	}
	else {
		match_cnt = set_IncSeaStt();
	}

	bool csr_up   = (USAME_TI(CmdStr, "IncSearchUp")   || equal_UP(keystr));
	bool csr_down = (USAME_TI(CmdStr, "IncSearchDown") || equal_DOWN(keystr));
	bool csr_top  = USAME_TI(CmdStr,  "IncSearchTop");

	//フィルタマスクモード
	if (CurStt->is_Filter) {
		//カーソル移動
		if 		(csr_up)	ListBoxCursorUp(lp);
		else if (csr_down)	ListBoxCursorDown(lp);
		else if (csr_top)	ListBoxTop(lp);

		if (chg_wd || csr_down || csr_up || csr_top) {
			lp->Repaint();
			SetFileInf();
		}
	}
	//通常モード
	else if (!CurStt->incsea_Word.IsEmpty()) {
		int s_idx = csr_top? 0 : lp->ItemIndex;  if (s_idx==-1) s_idx = 0;

		//マッチ数=1ならそこに移動
		if (match_cnt==1) {
			for (int i=0; i<lst->Count; i++) {
				if (((file_rec*)lst->Objects[i])->matched) {
					ListBoxSetIndex(lp, i);  break;
				}
			}
		}
		//マッチ数>1ならサーチ
		else if (match_cnt>1) {
			//下方 向へサーチ
			if (chg_wd || csr_down || csr_top) {
				if (chg_wd && s_idx>0) s_idx--;
				int idx = find_NextFile(lst, s_idx, EmptyStr, 
							CurStt->is_Migemo? CurStt->incsea_Ptn : CurStt->incsea_Word,
							false, IncSeaLoop, IncSeaCaseSens, CurStt->is_Migemo,
							CurStt->find_TAG && FindTagsColumn);
				if (idx!=-1) ListBoxSetIndex(lp, idx);
			}
			//上方向へサーチ
			else if (csr_up) {
				int idx = find_PrevFile(lst, s_idx, EmptyStr,
							CurStt->is_Migemo? CurStt->incsea_Ptn : CurStt->incsea_Word,
							false, IncSeaLoop, IncSeaCaseSens, CurStt->is_Migemo,
							CurStt->find_TAG && FindTagsColumn);
				if (idx!=-1) ListBoxSetIndex(lp, idx);
			}
		}

		//結果
		if (chg_wd || csr_down || csr_up) {
			//見つかった
			if (match_cnt>0) {
				SetFileInf();
			}
			//見つからなかった
			else if (!CurStt->is_Migemo) {
				stt_pp->Caption = " サーチ: " + ReplaceStr(CurStt->incsea_Word, "&", "&&");
				stt_pp->Color = col_bgWarn;  stt_pp->Repaint();
				beep_Warn();  Sleep(250);
				stt_pp->Color = col_bgList;
				delete_end(CurStt->incsea_Word);
				set_IncSeaStt();
			}
		}
	}

	lp->Invalidate();

	//マッチ総数、選択数を表示
	UnicodeString stt_str;
	stt_str.sprintf(_T("%s"), CurStt->is_Migemo? _T(" Migemo: ") : CurStt->is_Filter? _T(" フィルタ: ") : _T(" サーチ: "));
	stt_str += CurStt->incsea_Word;
	stt_str = ReplaceStr(stt_str, "&", "&&");

	UnicodeString inf_str;
	//マッチ数
	if (match_cnt==1) {
		inf_str += "1/1";
	}
	else if (match_cnt>1) {
		int cnt = 0, pos = 0;
		for (int i=0; i<lst->Count; i++) {
			if (((file_rec*)lst->Objects[i])->matched) {
				cnt++;
				if (i==lp->ItemIndex) {
					pos = cnt;  break;
				}
			}
		}
		if (pos>0) inf_str.cat_sprintf(_T("%u"), pos); else inf_str += "_";
		inf_str.cat_sprintf(_T("/%u"), match_cnt);
	}

	//選択数
	int s_cnt = GetSelCount(lst);
	if (s_cnt>0) {
		if (!inf_str.IsEmpty()) inf_str += " ";
		inf_str.cat_sprintf(_T("(%u Selected)"), s_cnt);
	}

	if (!inf_str.IsEmpty()) stt_str += ("\t" + inf_str);

	stt_pp->Caption = stt_str;
	stt_pp->Repaint();

	//マッチ数1で抜ける
	if (IncSeaMatch1Exit && match_cnt==1 && !CurStt->is_Filter && !CurStt->is_Migemo) ExitIncSearch();
}

//---------------------------------------------------------------------------
bool __fastcall TNyanFiForm::ExeCmdAction(TAction *ap, UnicodeString prm)
{
	int last_idx = CurListTag;
	int last_top = FileListBox[CurListTag]->TopIndex;

	TPanel *pp = (CurListTag==0)? L_DirPanel : R_DirPanel;
	UnicodeString last_pnam = pp->Caption;

	if (!prm.IsEmpty()) ActionParam = prm;
	ActionOk = true;
	ap->Execute();
	ActionParam = EmptyStr;

	//スクロール時に背景を隠す
	if (BgImgHideScr && last_idx==CurListTag) {
		if (SameText(last_pnam, pp->Caption)) {
			if (last_top!=FileListBox[CurListTag]->TopIndex && !HideBgImg[CurListTag]) {
				HideBgImg[CurListTag] = true;
				InvalidateFileList();
			}
		}
		else RestoreBgImg();
	}

	return ActionOk;
}

//---------------------------------------------------------------------------
//ファイラーのコマンドアクションを実行
//  アクションの Name は、コマンド名 + Action になっている
//---------------------------------------------------------------------------
bool __fastcall TNyanFiForm::ExeCommandAction(
	UnicodeString cmd,	//コマンド
	UnicodeString prm)	//パラメータ	(default = EmptyStr)
{
	if (cmd.IsEmpty()) return false;

	if (prm.IsEmpty() && !starts_Dollar(cmd)) {
		prm = exclude_quot(get_PrmStr(cmd));
		cmd = get_CmdStr(cmd);
	}

	//エイリアス
	if (USAME_TI(cmd, "Close")) {
		cmd = "Exit";
	}
	else if (USAME_TI(cmd, "ExtractImage")) {
		cmd = "ExtractMp3Img";
	}
	else if (USAME_TI(cmd, "ListFileInfo")) {
		cmd = "ShowFileInfo";
		prm = "SD";
	}
	else if (USAME_TI(cmd, "OpenCtrlPanel")) {
		cmd = "OpenByExp";
		prm = "shell:ControlPanelFolder";
	}

	ActionParam = extract_ExeParam(prm, &ActionDesc);

	bool handled = false;
	WatchDirTimer->Enabled = false;

	try {
		//メニュー/ツール・エイリアス
		if (starts_Dollar(cmd)) {
			handled = ExeAlias(cmd);
			if (!ActionOk && !ActionErrMsg.IsEmpty()) SttBarWarn(ActionErrMsg);
		}
		//アクション
		else {
			for (int i=0; i<ActionList1->ActionCount && !handled; i++) {
				TAction *ap = (TAction*)ActionList1->Actions[i];
				if (!USAME_TI(ap->Category, "Command")) continue;
				if (SameText(cmd, get_tkn(ap->Name, _T("Action")))) {
					if (!ExeCmdAction(ap)) SttBarWarn(ActionErrMsg);
					handled = true;
				}
			}
			if (!handled) ActionErrMsg = "不明なコマンドです。";
		}
	}
	catch (...) {
		SetInternalException(cmd, ActionParam);
		handled = true;
	}

	if (!UnInitializing) WatchDirTimer->Enabled = true;
	return handled;
}

//---------------------------------------------------------------------------
//エイリアスまたはコマンドを実行
//---------------------------------------------------------------------------
bool __fastcall TNyanFiForm::ExeAliasOrCommands(UnicodeString cmds)
{
	try {
		if (starts_Dollar(cmds)) {
			ExeAlias(cmds);
			if (!ActionOk && !ActionErrMsg.IsEmpty()) ActionAbort();
		}
		else if (!ExeCommandsCore(cmds)) GlobalAbort();
		return true;
	}
	catch (EAbort &e) {
		GlobalErrMsg = e.Message;
		return false;
	}
}
//---------------------------------------------------------------------------
//イベント用コマンドの実行
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ExeEventCommand(UnicodeString cmds, UnicodeString opt, UnicodeString fnam)
{
	if (FindBusy || ExeCmdsBusy || cmds.IsEmpty() || StartsStr(';', cmds)) return;

	ActionOptStr = opt;
	if (!ExeAliasOrCommands(cmds)) SetActionAbort(GlobalErrMsg);
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ExeEventCommandMP(UnicodeString cmds)
{
	ExeEventCommand(cmds, "MousePos");
}

//---------------------------------------------------------------------------
//一覧ダイアログ、ファイル情報、関数／ユーザ定義文字列／マーク行一覧、拡張子別一覧
//  に対してTVコマンドを実行
//---------------------------------------------------------------------------
bool __fastcall TNyanFiForm::ExeListBoxCommandV(UnicodeString cmd, HWND hWnd)
{
	bool handled  = false;
	bool rq_close = USAME_TI(cmd, "Close");

	//一覧ダイアログ
	if (GeneralInfoDlg->Visible) {
		TListBox *lp = GeneralInfoDlg->GenListBox;
		if (rq_close) {
			GeneralInfoDlg->ModalResult = mrCancel;
		}
		else if (hWnd==lp->Handle || hWnd==GeneralInfoDlg->FilterEdit->Handle) {
			if (!GeneralInfoDlg->FileName.IsEmpty() && contained_wd_i(_T("PrevFile|NextFile"), cmd)) {
				GeneralInfoDlg->Perform(WM_SETREDRAW, 0, (NativeInt)0);	//切り替わり時、画面が消えないように
				GeneralInfoDlg->RetStr = cmd;
				GeneralInfoDlg->ModalResult = mrRetry;
			}
			else if (ExeCmdListBox(lp, cmd)) {
				GeneralInfoDlg->SetStatusBar();
				GeneralInfoDlg->ListScrPanel->UpdateKnob();
			}
		}
		handled = true;
	}
	//ファイル情報
	else if (FileInfoDlg->Visible) {
		TListBox *lp = FileInfoDlg->InfListBox;
		if (rq_close) {
			FileInfoDlg->ModalResult = mrCancel;
		}
		else if (hWnd==lp->Handle) {
			if (contained_wd_i(_T("PrevFile|NextFile"), cmd)) {
				FileInfoDlg->Perform(WM_SETREDRAW, 0, (NativeInt)0);	//切り替わり時、画面が消えないように
				FileInfoDlg->CmdStr = cmd;
				FileInfoDlg->ModalResult = mrRetry;
			}
			else ExeCmdListBox(lp, cmd);
		}
	}
	//関数／ユーザ定義文字列／マーク行一覧
	else if (FuncListDlg->Visible) {
		TListBox *lp = FuncListDlg->FuncListBox;
		if (rq_close) {
			FuncListDlg->ModalResult = mrCancel;
		}
		else if (hWnd==lp->Handle || hWnd==FuncListDlg->FilterEdit->Handle) {
			int idx = lp->ItemIndex;
			ExeCmdListBox(lp, cmd);
			if (idx!=lp->ItemIndex) FuncListDlg->FuncListBoxClick(lp);
			FuncListDlg->ListScrPanel->UpdateKnob();
		}
		handled = true;
	}
	//拡張子別一覧
	else if (FileExtensionDlg && FileExtensionDlg->Visible) {
		if (rq_close) {
			FileExtensionDlg->ModalResult = mrCancel;
		}
		else if (hWnd==FileExtensionDlg->InfoListBox->Handle) {
			if (ExeCmdListBox(FileExtensionDlg->InfoListBox, cmd))
				FileExtensionDlg->InfoListBoxClick(NULL);
		}
		else if (hWnd==FileExtensionDlg->FileListBox->Handle) {
			ExeCmdListBox(FileExtensionDlg->FileListBox, cmd);
		}
		handled = true;
	}

	return handled;
}

//---------------------------------------------------------------------------
//ExPopupMenu を表示
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ShowExPopupMenu(TPoint p)
{
	ClearKeyBuff(true);
	ExPopupMenu->Popup(p.x, p.y);
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ShowExPopupMenu()
{
	TPoint p = ActionOptIsMousePos()? Mouse->CursorPos : 
			  ActionOptIsButtonPos()? ButtonPos : FileListBox[CurListTag]->ClientToScreen(Point(10, 10));
	ActionOptStr = EmptyStr;
	ShowExPopupMenu(p);
}

//---------------------------------------------------------------------------
//アクションのパラメータを調べる
//---------------------------------------------------------------------------
bool __fastcall TNyanFiForm::TestActionParam(const _TCHAR *prm)
{
	TStringDynArray lst = split_strings_semicolon(ActionParam);

	for (int i=0; i<lst.Length; i++) if (SameText(prm, lst[i])) return true;
	return false;
}
//---------------------------------------------------------------------------
bool __fastcall TNyanFiForm::TestDelActionParam(const _TCHAR *prm)
{
	TStringDynArray lst = split_strings_semicolon(ActionParam);
	int idx = -1;
	for (int i=0; i<lst.Length && idx==-1; i++) if (SameText(prm, lst[i])) idx = i;

	//該当パラメータがあったら削除
	if (idx!=-1) {
		UnicodeString lbuf;
		for (int i=0; i<lst.Length; i++) if (i!=idx) cat_str_semicolon(lbuf, lst[i]);
		ActionParam = lbuf;
	}

	return (idx!=-1);
}

//---------------------------------------------------------------------------
//コマンドアクションの Abort 例外処理
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::SetActionAbort(UnicodeString msg)
{
	CurWorking = false;
	ProgressPanel->Visible = false;

	if (contained_wd_i(_T("SKIP|HANDLED"), msg)) return;

	if (StartsText("Abort", msg) || USAME_TI(msg, "Operation aborted")) msg = EmptyStr;
	ActionOk = false;  ActionErrMsg = msg;

	SttBarWarn(ActionErrMsg);
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::SetActionAbort(const _TCHAR *msg)
{
	SetActionAbort(UnicodeString(msg));
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::SetActionAbort(unsigned id)
{
	SetActionAbort(LoadUsrMsg(id));
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ActionAbort()
{
	throw EAbort(ActionErrMsg);
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::GlobalAbort()
{
	throw EAbort(GlobalErrMsg);
}
//---------------------------------------------------------------------------
//ログに「予期せぬ例外」を表示
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::SetInternalException(UnicodeString cmd, UnicodeString prm)
{
	UnicodeString msg = SysErrorMessage(EVENT_E_INTERNALEXCEPTION);
	SetActionAbort(msg);
	UnicodeString tmp;
	if (!cmd.IsEmpty()) tmp.sprintf(_T("E %s"), cmd.c_str());
	if (!prm.IsEmpty()) tmp.cat_sprintf(_T("_%s"), prm.c_str());
	AddLog(tmp.cat_sprintf(_T("\r\n    %s"), msg.c_str()));
}

//---------------------------------------------------------------------------
//トグル動作のアクションをパラメータで設定
//---------------------------------------------------------------------------
bool __fastcall TNyanFiForm::SetToggleAction(bool &sw)
{
	sw = TEST_ActParam("ON")? true : TEST_ActParam("OFF")? false : !sw;
	return sw;
}

//---------------------------------------------------------------------------
//コマンドパラメータ用書式文字列の展開
//---------------------------------------------------------------------------
UnicodeString __fastcall TNyanFiForm::FormatParam(UnicodeString fmt)
{
	UnicodeString ret_str;
	file_rec *cfp = GetCurFrecPtr(true);

	while (!fmt.IsEmpty()) {
		WideChar c = split_top_wch(fmt);
		if (c=='\\') {
			if (StartsStr("DT(", fmt) || StartsStr("TS(", fmt)) {
				TDateTime dt = (StartsStr("TS(", fmt) && cfp)? cfp->f_time : Now();
				ret_str += FormatDateTime(split_in_paren(fmt), dt);
			}
			else {
				c = split_top_wch(fmt);
				if 		(c=='C')		ret_str += get_dir_name(CurPath[CurListTag]);
				else if (c=='N' && cfp)	ret_str += cfp->b_name;
				else if (c=='E' && cfp)	ret_str += get_tkn_r(cfp->f_ext, '.');
				else if (c=='\\')		ret_str += "\\";
			}
		}
		else ret_str.cat_sprintf(_T("%c"), c);
	}
	return ret_str;
}

//---------------------------------------------------------------------------
//ActionParam にしたがってクリップボートにコピー/一覧表示/ファイル出力
//！失敗した場合 Abort 例外
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ClipSaveList(TStringList *lst, const _TCHAR *tit)
{
	//クリップボートにコピー
	if (TEST_ActParam("CC")) {
		copy_to_Clipboard(lst->Text);
	}
	//一覧表示
	else if (TEST_ActParam("LS")) {
		GeneralInfoDlg->Caption = tit;
		GeneralInfoDlg->GenInfoList->Assign(lst);
		GeneralInfoDlg->ShowModal();
	}
	else {
		//ファイル出力
		UnicodeString fnam = to_absolute_name(FormatParam(ActionParam), CurPath[CurListTag]);
		if (!fnam.IsEmpty()) {
			if (!saveto_TextUTF8(fnam, lst)) UserAbort(USTR_FaildSave);
			AddLog("  SAVE " + fnam);
		}
	}
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ClipSaveList(
	TStringList *lst, const _TCHAR *tit, bool sw_cc, bool sw_ls, UnicodeString fnam)
{
	//クリップボートにコピー
	if (sw_cc) {
		copy_to_Clipboard(lst->Text);
	}

	//一覧表示
	if (sw_ls) {
		GeneralInfoDlg->Caption = tit;
		GeneralInfoDlg->GenInfoList->Assign(lst);
		GeneralInfoDlg->ShowModal();
	}

	//ファイル出力
	if (!fnam.IsEmpty()) {
		UnicodeString fnam = to_absolute_name(FormatParam(ActionParam), CurPath[CurListTag]);
		if (!fnam.IsEmpty()) {
			if (!saveto_TextUTF8(fnam, lst)) UserAbort(USTR_FaildSave);
			AddLog("  SAVE " + fnam);
		}
	}
}


//---------------------------------------------------------------------------
//ExeCommands コマンドの実行
//---------------------------------------------------------------------------
bool __fastcall TNyanFiForm::ExeCommandsCore(
	UnicodeString cmds,		//コマンド (先頭が @ ならコマンドファイル)
	UnicodeString f_name,	//対象ファイル名		(default=EmptyStr)
	bool debug_sw)			//デバッグモードで実行	(default = false)
{
	GlobalErrMsg = EmptyStr;

	if (ExeCmdsBusy) { GlobalErrMsg = "コマンド実行中です";  return false; }

	//@ だけならカーソル位置のコマンドファイルを実行
	UnicodeString tmp = cmds;
	split_dsc(tmp);
	if (USAME_TS(tmp, "@")) {
		try {
			if (CurStt->is_FTP) UserAbort(USTR_CantOperate);
			file_rec *cfp = GetCurFrecPtr();
			if (!cfp || cfp->is_dir || !test_NbtExt(cfp->f_ext)) TextAbort(_T(".nbt ファイルではありません。"));
			if (cfp->is_virtual && !SetTmpFile(cfp)) UserAbort(USTR_FaildTmpUnpack);
			cmds = "@" + (cfp->is_virtual? cfp->tmp_name : cfp->f_name);
			ActionOptStr = "ListItemPos";
		}
		catch (EAbort &e) {
			GlobalErrMsg = e.Message;
			return false;
		}
	}

	bool ok = false;
	UnicodeString msg;

	//--------------------------
	//単独の通常コマンドを実行
	//--------------------------
	if (is_OneNrmCmd(cmds)) {
		try {
			XCMD_cmd = get_CmdStr(cmds);
			XCMD_prm = cv_env_str(get_PrmStr(cmds));
			bool handled = false;
			switch (ScrMode) {
			case SCMD_FLIST: case SCMD_GREP:
				if (LogListBox->Focused()) handled = ExeCommandL(XCMD_cmd, XCMD_prm);
				if (!handled)			   handled = ExeCommandAction(XCMD_cmd, XCMD_prm);
				break;
			case SCMD_TVIEW:
				handled = ExeCommandV(XCMD_cmd, XCMD_prm); break;
			case SCMD_IVIEW:
				handled = ExeCommandI(XCMD_cmd, XCMD_prm); break;
			}
			if (!handled) ActionAbort();
			if (!ActionOk && !ActionErrMsg.IsEmpty()) ActionAbort();
			ok = true;
		}
		catch (EAbort &e) {
			GlobalErrMsg = e.Message;
			msg.sprintf(_T("E %s%s"), cmds.c_str(), get_LogErrMsg(GlobalErrMsg).c_str());
			AddLog(msg);
		}
		ActionOptStr = EmptyStr;
		return ok;
	}

	//--------------------------
	//ExeCommands 実行
	//--------------------------
	//初期化
	XCMD_Initialize(ActionOptStr);
	XCMD_fromGrep = fromGrep;
	ExeCmdsBusy   = true;
	UnicodeString ExtraCmd, LastCmd;

	try {
		//コマンドリストを作成
		XCMD_xlp = XCMD_AddCmdsList(cmds);
		if (!XCMD_xlp->ErrMsg.IsEmpty()) throw EAbort(XCMD_xlp->ErrMsg);

		//補助コマンドのリスト(XCMD_cmd → cmd_id 変換用)
		std::unique_ptr<TStringList> scmd_lst(new TStringList());
		scmd_lst->Text = XCMD_SubCmds;

		if (debug_sw && !XCMD_xlp->FileName.IsEmpty()) {
			XCMD_Debugging = true;
			if (!DebugForm) DebugForm = new TDebugForm(this);	//初回に動的作成
			if (!DebugForm->Visible) DebugForm->Show();
		}

		UnicodeString exe_fnam, exe_prm, exe_wdir, exe_opt;

		while (!XCMD_xlp->EndOfCmds && !ReqClose && !XCMD_Aborted) {
			Application->ProcessMessages();
			if (!XCMD_xlp->Preproc(XCMD_cmd, XCMD_prm)) continue;
			int cmd_id = scmd_lst->IndexOf(XCMD_cmd);
			if (!USAME_TI(XCMD_cmd, "Exit")) LastCmd = XCMD_cmd;

			//デバッグ設定
			if (cmd_id==XCMDID_Debug) {
				if (XCMD_xlp->FileName.IsEmpty()) UserAbort(USTR_InvalidCmd);

				if (USAME_TI(XCMD_prm, "ON")) {
					XCMD_Debugging = true;
					if (!DebugForm) DebugForm = new TDebugForm(this);	//初回に動的作成
					if (!DebugForm->Visible) DebugForm->Show();
				}
				else if (USAME_TI(XCMD_prm, "OFF"))	{
					if (DebugForm) DebugForm->Close();
					XCMD_Debugging = false;
				}
				else if (USAME_TI(XCMD_prm, "BP")) {
					XCMD_Debug_Go  = false;
					XCMD_ShowDebugInf();
				}
				else if (StartsText("WL<<", XCMD_prm)) {
					UnicodeString vnam = get_tkn_r(XCMD_prm, _T("<<"));
					if (!vnam.IsEmpty()) XCMD_WatchList->Add(vnam);
				}
				else UserAbort(USTR_SyntaxError);

				if (!XCMD_Debugging) SetFileInf();
				XCMD_xlp->IncPC();
				continue;
			}

			//デバッグモード
			if (XCMD_Debugging) {
				bool breaked = false;
				if		(XCMD_Debug_Exit)	XCMD_Debugging	= false;
				else if (XCMD_Debug_Quit)	XCMD_Debugging	= false;
				else if	(XCMD_Debug_Step)	XCMD_Debug_Step = false;
				else if (XCMD_Debug_Go)		;
				else if (XCMD_Debug_List) { XCMD_Debug_List = false;
					XCMD_ListVar();  breaked = true;
				}
				else if (XCMD_Debug_Help) { XCMD_Debug_Help = false;
					HtmlHelpTopic(_T(HELPTOPIC_XC) _T("#Debug"));
					breaked = true;
				}
				else breaked = true;

				if (XCMD_Debugging) {
					//情報を更新
				 	XCMD_set_cfp(
				 		(f_name.IsEmpty() && ScrMode==SCMD_GREP && fromViewer)? TxtViewer->FileName : f_name,
						CurStt->is_FTP? CurFTPPath : CurPath[CurListTag],
						GetCurFrecPtr());
					XCMD_set_Var(_T("OppPath"), CurPath[OppListTag]);
					XCMD_upd_Var();

					if (DebugForm->Visible) DebugForm->SetFocus();

					//待機
					if (breaked) {
						XCMD_EchoLn();
						while (!XCMD_Debug_Go && !XCMD_Debug_Exit && !XCMD_Debug_Quit
								&& !XCMD_Debug_Step && !XCMD_Debug_List && !XCMD_Debug_Help)
						{
							Application->ProcessMessages();
						}
						continue;
					}
				}
				else {
					SetFileInf();
				}

				//状態表示
				XCMD_ShowDebugInf();

				if (XCMD_Debug_Exit) break;	//実行中断
			}

			//通常モード
			if (!XCMD_Debugging) {
			 	XCMD_set_cfp(
			 		(f_name.IsEmpty() && ScrMode==SCMD_GREP && fromViewer)? TxtViewer->FileName : f_name,
					CurStt->is_FTP? CurFTPPath : CurPath[CurListTag],
					GetCurFrecPtr());
				if (XCMD_FileChanged) { SetFileInf();  XCMD_FileChanged = false; }
				XCMD_set_Var(_T("OppPath"), CurPath[OppListTag]);
				XCMD_upd_Var();
				XCMD_EchoLn();
			}

			//終了/再起動
			if (ScrMode==SCMD_FLIST && contained_wd_i(_T("Close|Restart"), XCMD_cmd)) {
				ExtraCmd = XCMD_cmd;
				if (!XCMD_prm.IsEmpty()) ExtraCmd.cat_sprintf(_T("_%s"), XCMD_prm.c_str());
				break;
			}
			//呼び出し
			else if (cmd_id==XCMDID_JumpCommands || cmd_id==XCMDID_CallCommands) {
				XCMD_AddCmdsList(XCMD_prm, cmd_id==XCMDID_CallCommands);
				if (!XCMD_xlp->ErrMsg.IsEmpty()) throw EAbort(XCMD_xlp->ErrMsg);
				continue;
			}
			else if (cmd_id==XCMDID_ReturnCommands) {
				if (XCMD_Return()) continue; else break;
			}
			//ポップアップメニュー
			else if (cmd_id==XCMDID_PopupMenu) {
				XCMD_set_Var(_T("MenuIndex"), 0);
				XCMD_set_Var(_T("MenuStr"),   EmptyStr);
				std::unique_ptr<TStringList> m_buf(new TStringList());
				m_buf->Text = XCMD_VarList->Values[XCMD_prm];
				if (m_buf->Count==0) TextAbort(_T("メニュー項目がありません。"));
				ExePopMenuList(m_buf.get(), true);
				XCMD_xlp->IncPC();
				continue;
			}

			//制御文
			if (!XCMD_Control()) {
				TListBox    *lp  = FileListBox[CurListTag];
				TStringList *lst = (ScrMode==SCMD_FLIST)? GetFileList(CurListTag) : NULL;

				//------------------
				//補助コマンド
				//------------------
				switch (cmd_id) {
				case XCMDID_Set:			XCMD_Set(XCMD_prm);								break;
				case XCMDID_Add:			XCMD_Add(XCMD_prm);								break;
				case XCMDID_Ins:			XCMD_Ins(XCMD_prm);								break;
				case XCMDID_Mid:			XCMD_Mid(XCMD_prm);								break;
				case XCMDID_Right:			XCMD_Right(XCMD_prm);							break;
				case XCMDID_Trim:			XCMD_Trim(XCMD_prm);							break;
				case XCMDID_Input:			XCMD_Input(XCMD_prm);							break;
				case XCMDID_Edit:			XCMD_Edit(XCMD_prm);							break;
				case XCMDID_ListVar:		XCMD_ListVar();									break;
				case XCMDID_AppendBuffer:	XCMD_AppendBuffer(to_absolute_name(XCMD_prm, XCMD_cur_path));	break;
				case XCMDID_FilterBuffer:	XCMD_FilterBuffer(XCMD_prm);					break;
				case XCMDID_ReplaceBuffer:	XCMD_ReplaceBuffer(XCMD_prm);					break;
				case XCMDID_SetClipboard: 	Clipboard()->AsText = XCMD_prm;					break;
				case XCMDID_Test:			XCMD_matched = XCMD_Test(XCMD_prm);				break;
				case XCMDID_MatchName:		XCMD_match_Str(XCMD_prm, XCMD_cur_bnam);		break;
				case XCMDID_MatchDir:		XCMD_match_Str(XCMD_prm, XCMD_cur_path);		break;
				case XCMDID_MatchBuffer:	XCMD_match_Buffer(XCMD_prm);					break;
				case XCMDID_MatchExt:		XCMD_MatchExt(XCMD_prm, XCMD_cur_fext);			break;
				case XCMDID_SearchDown:		XCMD_SearchDown(XCMD_prm, lp, lst);				break;
				case XCMDID_SearchDownF:	XCMD_SearchDown(XCMD_prm, lp, lst, true,false);	break;
				case XCMDID_SearchDownD:	XCMD_SearchDown(XCMD_prm, lp, lst, false,true);	break;
				case XCMDID_SearchUp:		XCMD_SearchUp(XCMD_prm, lp, lst);				break;
				case XCMDID_SearchUpF:		XCMD_SearchUp(XCMD_prm, lp, lst, true, false);	break;
				case XCMDID_SearchUpD:		XCMD_SearchUp(XCMD_prm, lp, lst, false, true);	break;
				case XCMDID_FileExists:		XCMD_matched = file_exists(to_absolute_name(XCMD_prm, XCMD_cur_path));	break;
				case XCMDID_PushIndex:		XCMD_PushIndex(lp);								break;
				case XCMDID_PopIndex:		XCMD_PopIndex(lp);								break;
				case XCMDID_PushTopIndex:	XCMD_PushTopIndex(lp);							break;
				case XCMDID_PopTopIndex:	XCMD_PopTopIndex(lp);							break;
				case XCMDID_PushVar:		XCMD_PushVar(XCMD_prm);							break;
				case XCMDID_PopVar:			XCMD_PopVar(XCMD_prm);							break;
				case XCMDID_SetFileTime:	XCMD_SetFileTime(XCMD_prm);						break;
				case XCMDID_Random:			XCMD_Random(XCMD_prm);							break;
				case XCMDID_ReadINI:		XCMD_ReadINI(XCMD_prm);							break;
				case XCMDID_WriteINI:		XCMD_WriteINI(XCMD_prm);						break;
				case XCMDID_Sleep:			XCMD_Sleep(XCMD_prm);							break;
				case XCMDID_Timer:			XCMD_Timer(XCMD_prm);							break;
				case XCMDID_Redraw:			XCMD_Redraw(XCMD_prm);							break;
				case XCMDID_ActivateWnd:	XCMD_matched = XCMD_ActivateWnd(XCMD_prm);		break;
				case XCMDID_Nop:															break;

				//Grep
				case XCMDID_GrepSetMask:	GrepMaskComboBox->Text = XCMD_prm;				break;
				case XCMDID_GrepStart:		GrepStartAction->Execute();						break;

				//エコー
				case XCMDID_EchoOn:
					XCMD_echo_on  = true;
					XCMD_echo_lno = USAME_TI(XCMD_prm, "LN");
					XCMD_EchoLn();
					break;
				case XCMDID_EchoOff:		XCMD_echo_on = false;	break;
				case XCMDID_EchoT:			StartLog(XCMD_prm);		break;
				case XCMDID_Echo:			AddLog(XCMD_prm);		break;
				case XCMDID_MsgOff:			XCMD_MsgOff = true;		break;

				//Buffer に読み込み
				case XCMDID_LoadBuffer:
					{
						UnicodeString dnam = ExtractFilePath(XCMD_prm);
						if (dnam.IsEmpty()) dnam = XCMD_cur_path;
						UnicodeString fnam = ExtractFileName(XCMD_prm);
						if (fnam.IsEmpty() || ContainsStr(fnam, "*") || ContainsStr(fnam, "?")) {
							UnicodeString fltr;
							if (!fnam.IsEmpty())
								fltr.sprintf(_T("指定したマスク(%s)|%s"), fnam.c_str(), fnam.c_str());
							else
								fltr = F_FILTER_TXT;
							UserModule->PrepareOpenDlg(_T("Buffer に読み込む"), fltr.c_str(), NULL, dnam);
							UserModule->OpenDlgToStr(XCMD_prm);
						}
						XCMD_LoadBuffer(to_absolute_name(XCMD_prm, dnam));
					}
					break;

				//Buffer を保存
				case XCMDID_SaveBuffer:
					if (XCMD_prm.IsEmpty()) {
						UserModule->SaveTxtDlg->Title	   = LoadUsrMsg(USTR_SaveAs, _T("Buffer"));
						UserModule->SaveTxtDlg->InitialDir = ExcludeTrailingPathDelimiter(SaveTxtPath);
						unsigned int code_page = XCMD_GetCodePage();
						for (int i=0; i<MAX_SAVE_CODEPAGES; i++) {
							if (SaveCodePages[i].page==code_page) {
								UserModule->SaveTxtDlg->EncodingIndex = i;  break;
							}
						}
						if (UserModule->SaveTxtDlg->Execute()) {
							SaveTxtPath = ExtractFilePath(UserModule->SaveTxtDlg->FileName);
							XCMD_prm = UserModule->SaveTxtDlg->FileName;
						}
					}
					XCMD_SaveBuffer(to_absolute_name(XCMD_prm, XCMD_cur_path));
					break;

				//Buffer をリスト表示
				case XCMDID_ListBuffer:
					GeneralInfoDlg->HdrLnStr = extract_prm_RegExPtn(XCMD_prm);
					GeneralInfoDlg->Caption  = XCMD_prm;
					GeneralInfoDlg->GenInfoList->Text = XCMD_GetBuffer();
					GeneralInfoDlg->ShowModal();
					break;

				//書式文字列を解決
				case XCMDID_Format: case XCMDID_FormatDT: case XCMDID_FormatDI: case XCMDID_FormatFN:
					if (!ContainsStr(XCMD_prm, "=")) UserAbort(USTR_SyntaxError);
					{
						UnicodeString vnam = split_tkn(XCMD_prm, '=');
						if (vnam.IsEmpty()) UserAbort(USTR_SyntaxError);
						XCMD_VarList->Values[vnam] =
							  (cmd_id==XCMDID_Format) ? FormatExtTool(exclude_quot(XCMD_prm)) : 
							(cmd_id==XCMDID_FormatDT) ? format_DateTimeEx(exclude_quot(XCMD_prm), Now()) :
							(cmd_id==XCMDID_FormatDI) ? GetDriveInfo(CurListTag, true, true, exclude_quot(XCMD_prm)) :
											XCMD_cfp  ? GetCopyFileNames(XCMD_prm, false, XCMD_cfp) : EmptyStr;
					}
					break;

				//強制コピーモード
				case XCMDID_SetCopyMode:
					xCopyMode = pos_i(XCMD_prm.SubString(1, 1), "ONSR") - 1;
					if (xCopyMode==-1) UserAbort(USTR_IllegalParam);
					break;

				//ShellExecute
				case XCMDID_SetExeFile:		exe_fnam = XCMD_prm;	break;
				case XCMDID_SetExeParam:	exe_prm  = XCMD_prm;	break;
				case XCMDID_SetExeDir:		exe_wdir = XCMD_prm;	break;
				case XCMDID_SetExeOpt:		exe_opt  = XCMD_prm;	break;
				case XCMDID_ShellExecute:
					{
						if (!exe_prm.IsEmpty()) exe_prm = FormatExtTool(exe_prm);
						exe_wdir = !exe_wdir.IsEmpty()? FormatExtTool(exe_wdir) : XCMD_cur_path;

						if (contains_wd_i(exe_opt, _T("W|O"))) {
							msg.sprintf(_T("　%s"), ExtractFileName(exe_fnam).c_str());
							if (!exe_prm.IsEmpty()) msg.cat_sprintf(_T(" %s"), exe_prm.c_str());
							msg += " 実行中...\r\n　しばらくお持ちください\r\n";
							ShowMessageHint(msg, col_bgHint, false, true);
						}
						bool res = XCMD_ShellExe(exe_fnam, exe_prm, exe_wdir, exe_opt);
						MsgHint->ReleaseHandle();
						exe_fnam = exe_prm = exe_wdir = exe_opt = EmptyStr;
						if (!res) GlobalAbort();
					}
					break;

				//Git
				case XCMDID_Git:
					{
						if (CmdGitExe.IsEmpty()) throw EAbort(LoadUsrMsg(USTR_NotFound, _T("git.exe")));
						if (USAME_TS(XCMD_prm, "#")) XCMD_prm = "--version";
						cursor_HourGlass();
						bool res = XCMD_ShellExe(CmdGitExe, XCMD_prm, XCMD_cur_path, "OLH");
						cursor_Default();
						if (!res) GlobalAbort();
					}
					break;

				//キー待ち
				case XCMDID_WaitForKey:
					{
						UnicodeString kstr = WaitForKey();
						if (!XCMD_prm.IsEmpty()) XCMD_VarList->Values[XCMD_prm] = kstr;
					}
					break;

				//タスクの終了待ち
				case XCMDID_WaitForTask: case XCMDID_WaitForTask2:
					ShowMessageHint(_T("タスクの終了待ち..."), col_bgHint, false, true, true);
					for (;;) {
						Application->ProcessMessages();
						if (XCMD_Aborted) {
							MsgHint->ReleaseHandle();  UserAbort(USTR_Canceled);
						}
						//タスクの状態チェック
						bool busy = false;
						for (int i=0; i<MAX_TASK_THREAD && !busy; i++) {
							TTaskThread *tp = TaskThread[i];
							if (tp && ((cmd_id==XCMDID_WaitForTask2) || tp->ID>XCMD_last_task_id)) busy = true;
						}
						if (!busy && TaskReserveList->Count==0) break;
						Sleep(1);
					}
					MsgHint->ReleaseHandle();
					break;

				//メッセージ/ヒント表示など
				case XCMDID_MsgBox: case XCMDID_MsgBoxYN: case XCMDID_MsgBoxYNC:
										XCMD_MsgBox(XCMD_cmd, XCMD_prm);				break;
				case XCMDID_Hint: {
						bool not_hide = remove_top_s(XCMD_prm, '!');
						ShowMessageHint(XCMD_prm, col_bgHint, false, not_hide);
					}
					break;
				case XCMDID_Warn:		SttBarWarn(XCMD_prm);							break;
				case XCMDID_PlaySound:	XCMD_PlaySound(XCMD_prm);						break;
				case XCMDID_FlashWin:	XCMD_FlashWin(XCMD_prm);						break;

				//Download
				case XCMDID_Download:
					{
						XCMD_set_Var(_T("DownloadName"), EmptyStr);
						bool h2t = ContainsStr(XCMD_prm, ">>");
						UnicodeString url = split_tkn(XCMD_prm, _T(">>"));
						if (EndsStr('/', url)) url += "index.htm";
						UnicodeString fnam = TempPathA + ExtractFileName(slash_to_yen(url));
						if (DownloadWorkProgress(url, fnam)==mrOk) {
							//HTML→テキスト変換
							if (h2t && test_HtmlExt(get_extension(fnam))) {
								//読込
								std::unique_ptr<TStringList> f_buf(new TStringList());
								int codepage = load_text_ex(fnam, f_buf.get());
								if (codepage==0) UserAbort(USTR_FaildLoad);
								//変換
								cursor_HourGlass();
								std::unique_ptr<HtmConv> htmcnv(new HtmConv());
								ini_HtmConv_def(htmcnv.get(), fnam);
								if (test_FileExt(get_extension(XCMD_prm), _T(".md"))) htmcnv->ToMarkdown = true;
								htmcnv->HtmBuf->Assign(f_buf.get());
								htmcnv->CodePage = codepage;
								htmcnv->Convert();
								cursor_Default();
								//保存
								UnicodeString tnam = !XCMD_prm.IsEmpty()?
												to_absolute_name(exclude_quot(XCMD_prm), XCMD_cur_path) :
												ChangeFileExt(fnam, ".txt");
								std::unique_ptr<TEncoding> enc(TEncoding::GetEncoding(codepage));
								if (!saveto_TextFile(tnam, htmcnv->TxtBuf, enc.get())) UserAbort(USTR_FaildSave);
								fnam = tnam;
							}
							XCMD_set_Var(_T("DownloadName"), fnam);
						}
					}
					break;

				//SendCommands
				case XCMDID_SendCommands:
					{
						HWND hNextWnd = get_NyanFiWnd(1);
						if (hNextWnd) {
							COPYDATASTRUCT cd;
							cd.dwData = CPYDTID_EXECMDS;
							cd.cbData = sizeof(_TCHAR) * (XCMD_prm.Length() + 1);
							cd.lpData = XCMD_prm.c_str();
							::SendMessage(hNextWnd, WM_COPYDATA, 0, (LPARAM)&cd);
						}
					}
					break;

				//一般コマンド
				default: {
						bool handled = false;
						switch (ScrMode) {
						case SCMD_FLIST: case SCMD_GREP:
							if (LogListBox->Focused()) handled = ExeCommandL(XCMD_cmd, XCMD_prm);
							if (!handled)			   handled = ExeCommandAction(XCMD_cmd, XCMD_prm);
							break;
						case SCMD_TVIEW:
							handled = ExeCommandV(XCMD_cmd, XCMD_prm);	break;
						case SCMD_IVIEW:
							handled = ExeCommandI(XCMD_cmd, XCMD_prm);	break;
						}
						if (!handled) ActionAbort();
						if (!ActionOk && !ActionErrMsg.IsEmpty()) ActionAbort();
					}
				}

				XCMD_xlp->IncPC();
			}
		} // End of 実行ループ

		//必要ならファイル情報を更新
		if (ScrMode==SCMD_FLIST) {
			file_rec *cfp = GetCurFrecPtr();
			if (is_selectable(cfp))
				XCMD_cur_f_name = (cfp->is_virtual && SetTmpFile(cfp, true))? cfp->tmp_name : cfp->f_name;
			else
				XCMD_cur_f_name = EmptyStr;
			if (!SameText(XCMD_cur_f_name, XCMD_VarList->Values["FileName"]))
				SetFileInf();
			else
				if (XCMD_Debugging) XCMD_ShowDebugInf();
		}
		ok = true;
	}
	//エラー処理
	catch (EAbort &e) {
		GlobalErrMsg = e.Message;
	}
	catch (...) {
		GlobalErrMsg = SysErrorMessage(EVENT_E_INTERNALEXCEPTION);
	}

	if (XCMD_Debugging) XCMD_ShowDebugInf(GlobalErrMsg);

	if (!ok) {
		msg = "E ";
		if (XCMD_xlp) {
			if (!XCMD_xlp->FileName.IsEmpty()) {
				msg += ExtractFileName(XCMD_xlp->FileName);
				if (XCMD_xlp->LineNo>0) msg.cat_sprintf(_T("(%u) "), XCMD_xlp->LineNo);
			}
			msg += XCMD_xlp->CmdStr;
		}
		msg += get_LogErrMsg(GlobalErrMsg);
		AddLog(msg);
	}

	//終了処理
	XCMD_Uninitialize();
	ExeCmdsBusy  = false;
	ActionOptStr = EmptyStr;
	xCopyMode	 = -1;

	if (ok) {
		if (!ExtraCmd.IsEmpty()) {
			ExeCommandAction(ExtraCmd);
		}
		else if ((ScrMode==SCMD_FLIST)
			&& contained_wd_i(
				_T("FindDirDlg|FindFileDirDlg|FindFileDlg|FindFolderIcon|FindHardLink|FindMark|FindTag|MaskFind"), LastCmd)
			&& CurStt->is_Find)
		{
			//イベント: 検索結果リストが表示された直後
			ExeEventCommand(OnFindOpend);
		}
	}

	return ok;
}

//---------------------------------------------------------------------------
//PopupMenu コマンドの処理
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ExeCmdsMenuClick(TObject *Sender)
{
	TMenuItem *mp = (TMenuItem*)Sender;
	PopMenuIndex  = mp->Tag;
	if (ExeCmdsBusy) {
		UnicodeString s = mp->Caption;
		s = ReplaceStr(s, "&&", "\f");
		s = replace_regex(s, _T("\\s*\\(&\\w\\)\\s*"), null_TCHAR);
		s = replace_regex(s, _T("([^&]?)&([^& ])"), _T("\\1\\2"));
		s = ReplaceStr(s, "\f", "&");
		XCMD_set_Var(_T("MenuStr"),   Trim(s));
		XCMD_set_Var(_T("MenuIndex"), PopMenuIndex + 1);
	}
}

//---------------------------------------------------------------------------
//ログのコマンドを実行
//---------------------------------------------------------------------------
bool __fastcall TNyanFiForm::ExeCommandL(UnicodeString cmd, UnicodeString prm)
{
	if (cmd.IsEmpty()) return false;

	if (prm.IsEmpty()) {
		prm = get_PrmStr(cmd);
		cmd = get_CmdStr(cmd);
	}

	ActionParam = prm;
	ActionOk	= true;

	if (ExeCmdListBox(LogListBox, cmd))
		;
	else if (contained_wd_i(
		_T("CancelAllTask|ClearLog|HelpContents|KeyList|ToLeft|ToRight|TaskMan|ViewLog|OptionDlg"), cmd))
			ExeCommandAction(cmd, ActionParam);
	//エラー検索
	else if (contained_wd_i(_T("NextErr|PrevErr"), cmd)) {
		bool down = USAME_TI(cmd, "NextErr");
		cursor_HourGlass();
		TListBox *lp = LogListBox;
		int idx0 = lp->ItemIndex;
		if (idx0==-1) idx0 = 0;
		int idx1 = -1;
		UnicodeString ptn = "^.>([ECW]|(     [45]\\d{2})) .*";
		for (int i = (down? idx0 + 1 : idx0 - 1); i>=0 && i<lp->Count; i += (down? 1 : -1))
			if (TRegEx::IsMatch(lp->Items->Strings[i], ptn)) { idx1 = i; break; }
		if (idx1!=-1) {
			lp->ItemIndex = idx1;
			lp->Repaint();
		}
		else beep_Warn();
		cursor_Default();
	}
	else return false;

	return true;
}

//---------------------------------------------------------------------------
//ログのキー操作
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::LogListBoxKeyDown(TObject *Sender, WORD &Key, TShiftState Shift)
{
	if (CurWorking || FindBusy) return;

	TListBox *lp = (TListBox*)Sender;
	UnicodeString KeyStr = get_KeyStr(Key, Shift);
	UnicodeString cmd_L  = KeyFuncList->Values["L:" + KeyStr];
	UnicodeString cmd_F  = Key_to_CmdF(KeyStr);

	if		(!cmd_L.IsEmpty())				ExeCommandL(cmd_L);
	else if (ExeCmdListBox(lp, cmd_F))		;
	else if	(is_ToRightOpe(KeyStr, cmd_F))	ExeCmdAction(ToRightAction);
	else if (is_ToLeftOpe(KeyStr, cmd_F))	ExeCmdAction(ToLeftAction);
	else if (SameText(KeyStr, KeyStr_Copy)) Log_EditCopy->Execute();
	//右クリックメニュー
	else if (contained_wd_i(KeysStr_Popup, KeyStr)) show_PopupMenu(lp);
	else return;

	Key = 0;
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::LogListBoxKeyPress(TObject *Sender, System::WideChar &Key)
{
	Key = 0;
}

//---------------------------------------------------------------------------
//ログのマウス操作
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::LogListBoxMouseMove(TObject *Sender, TShiftState Shift, int X, int Y)
{
	TListBox *lp = (TListBox*)Sender;
	int idx = lp->ItemAtPos(Point(X, Y), true);
	UnicodeString msg;
	if (idx!=-1) {
		UnicodeString lbuf = lp->Items->Strings[idx];
		if (lp->Canvas->TextWidth(lbuf)>lp->ClientWidth) msg = lbuf;
	}
	if (lp->Hint!=msg) {
		Application->CancelHint();
		lp->Hint = msg;
	}
}

//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::PreviewImageDblClick(TObject *Sender)
{
	//イベント: イメージプレビューをダブルクリック
	ExeEventCommand(OnImgDClick);
}
//---------------------------------------------------------------------------


//■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
// ファイラーのアクション
//■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

//---------------------------------------------------------------------------
//バージョン情報
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::AboutNyanFiActionExecute(TObject *Sender)
{
	if (!AboutBox) AboutBox = new TAboutBox(this);	//初回に動的作成
	AboutBox->Version->Caption	  = VersionStr + (is_X64()? " (x64)" : " (x86)");
	AboutBox->Copyright->Caption  = usr_SH->get_PropStr(Application->ExeName, "著作権");
	AboutBox->SupportURL->Caption = SUPPORT_URL;
	AboutBox->ShowModal();
}

//---------------------------------------------------------------------------
//タグの追加
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::AddTagActionExecute(TObject *Sender)
{
	try {
		if (CurStt->is_Arc || CurStt->is_ADS || CurStt->is_FTP) UserAbort(USTR_CantOperate);

		usr_TAG->Recycle();

		UnicodeString tags;
		if (!ActionParam.IsEmpty()) {
			tags = ActionParam;
			if (USAME_TS(tags, ";")) {
				InputExDlg->IpuntExMode = INPEX_ADD_TAG;
				InputExDlg->InputComboBox->Text = EmptyStr;
				if (InputExDlg->ShowModal()!=mrOk) SkipAbort();;
				tags = InputExDlg->InputComboBox->Text;
			}
		}
		else {
			if (!TagManDlg) TagManDlg = new TTagManDlg(this);	//初回に動的作成
			TagManDlg->CmdStr = "AddTag";
			TagManDlg->TagEdit->Text = EmptyStr;
			if (TagManDlg->ShowModal()!=mrOk) SkipAbort();
			tags = TagManDlg->TagEdit->Text;
		}
		if (tags.IsEmpty()) SkipAbort();

		SetTags(tags, true);
	}
	catch (EAbort &e) {
		SetActionAbort(e.Message);
	}
}

//---------------------------------------------------------------------------
//ウィンドウを透過表示
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::AlphaBlendActionExecute(TObject *Sender)
{
	if (ActionParam.IsEmpty()) {
		AlphaBlend = AlphaForm = false;
		AlphaBlendValue = AlphaValue = 255;
	}
	else {
		unsigned int a;
		bool x_sw = false;
		if (TEST_ActParam("IN"))
			a = inputbox_ex_n(_T("透過表示"), _T("透明度"), AlphaBlendValue, 255);
		else {
			x_sw = remove_top_s(ActionParam, '^');
			a = ActionParam.ToIntDef(255);
		}
		if ((x_sw && AlphaBlend) || a>=255) {
			AlphaBlendValue = AlphaValue = 255;
			AlphaBlend = AlphaForm = false;
		}
		else {
			AlphaBlendValue = AlphaValue = a;
			AlphaBlend = AlphaForm = true;
		}
	}
}

//---------------------------------------------------------------------------
//アプリケーション一覧
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::AppListActionExecute(TObject *Sender)
{
	UnicodeString s = ActionParam;

	if (!AppListDlg) AppListDlg = new TAppListDlg(this);	//初回に動的作成
	AppListDlg->OnlyAppList  = TEST_ActParam("AO");
	AppListDlg->OnlyLauncher = TEST_ActParam("LO") || TEST_ActParam("LI");
	AppListDlg->ToAppList	 = TEST_ActParam("FA");
	AppListDlg->ToLauncher	 = TEST_ActParam("FL");
	AppListDlg->ToIncSea	 = TEST_ActParam("FI") || TEST_ActParam("LI");

	int res = mrNone;
	do {
		int res = AppListDlg->ShowModal();
		if (res==mrOk) {
			if (!AppListDlg->FocusClass.IsEmpty()) {
				//指定クラスのフォームにフォーカス
				for (int i=0; i<Screen->FormCount; i++) {
					TForm *fp = Screen->Forms[i];
					if (!fp->Visible) continue;
					if (fp->ClassNameIs(AppListDlg->FocusClass)) {
						if (fp->WindowState==wsMinimized) fp->WindowState = wsNormal;
						fp->SetFocus(); break;
					}
				}
			}
			else {
				if (!AppListDlg->JumpFileName.IsEmpty() || !AppListDlg->JumpPathName.IsEmpty() || AppListDlg->isNyan) {
					::ShowWindow(Handle, SW_SHOWNORMAL);
					::SetForegroundWindow(Handle);
				}
				//実行ファイル位置へ
				if		(!AppListDlg->JumpFileName.IsEmpty())	JumpToList(CurListTag, AppListDlg->JumpFileName);
				//ランチャーのディレクトリへ
				else if (!AppListDlg->JumpPathName.IsEmpty())	UpdateCurPath(AppListDlg->JumpPathName);
				//実行
				else if (!AppListDlg->LaunchFileName.IsEmpty())	{
					UnicodeString fnam = AppListDlg->LaunchFileName;
					//コマンドファイル
					if (test_NbtExt(get_extension(fnam))) {
						if (!ExeCommandsCore("@" + fnam)) SetActionAbort(GlobalErrMsg);
					}
					//一般
					else Execute_ex(fnam);
				}
				//他アプリに切り替え
				else if (!AppListDlg->isNyan && AppListChgMin)	Application->Minimize();
			}
		}
		else if (res==mrRetry) Application->Minimize();
		else if (res==mrClose) ExitAction->Execute();
	} while (res==mrRetry);
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::AppListActionUpdate(TObject *Sender)
{
	((TAction*)Sender)->Enabled = (!AppListDlg || (AppListDlg && !AppListDlg->Visible));
}

//---------------------------------------------------------------------------
//履歴の移動
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::MoveDirHistCore(bool is_back)
{
	try {
		TStringList *h_lst = get_DirHistory();
		int *h_ptr = get_DirHistPtr();
		if (!h_lst || !h_ptr) SkipAbort();

		bool changed = false;
		//戻る
		if (is_back) {
			if (*h_ptr < h_lst->Count-1) {
				++(*h_ptr);  changed = true;
			}
			else if (*h_ptr >= h_lst->Count) {
				*h_ptr = h_lst->Count - 1;
			}
		}
		//進む
		else {
			if (*h_ptr>0 && (*h_ptr - 1)<h_lst->Count) {
				--(*h_ptr);  changed = true;
			}
		}

		if (changed) {
			if (!is_back) InhDirHist++;
			{
				TStringDynArray itm_buf = get_csv_array(h_lst->Strings[*h_ptr], 2, true);
				UnicodeString dnam = itm_buf[0];
				//ディレクトリ
				if (ends_PathDlmtr(dnam)) {
					UpdateCurPath(dnam, itm_buf[1].ToIntDef(0), is_back);
					if (!GlobalErrMsg.IsEmpty()) GlobalAbort();
				}
				//ワークリスト
				else if (test_NwlExt(get_extension(dnam))) {
					SaveWorkListAction->Execute();
					if (!SetWorkList(dnam)) UserAbort(USTR_WlistCantOpen);
				}
			}
			if (!is_back) InhDirHist--;
		}
	}
	catch (EAbort &e) {
		SetActionAbort(e.Message);
	}
}
//---------------------------------------------------------------------------
//履歴を戻る
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::BackDirHistActionExecute(TObject *Sender)
{
	if (!WorkToDirHist && CurStt->is_Work)
		RecoverFileList();
	else
		MoveDirHistCore(true);
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::BackDirHistActionUpdate(TObject *Sender)
{
	TStringList *h_lst = get_DirHistory();
	int *h_ptr = get_DirHistPtr();

	((TAction*)Sender)->Enabled =
		(h_lst && h_ptr) ? (h_lst->Count>0 && *h_ptr<h_lst->Count-1 && !CurStt->is_Arc && !CurStt->is_Find && !CurStt->is_FTP)
						 : false;
}
//---------------------------------------------------------------------------
//履歴を進む
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ForwardDirHistActionExecute(TObject *Sender)
{
	MoveDirHistCore(false);
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ForwardDirHistActionUpdate(TObject *Sender)
{
	TStringList *h_lst = get_DirHistory();
	int *h_ptr = get_DirHistPtr();

	((TAction*)Sender)->Enabled =
		(h_lst && h_ptr) ? (h_lst->Count>0 && *h_ptr>0 && !CurStt->is_Arc && !CurStt->is_Find && !CurStt->is_FTP)
						 : false;
}

//---------------------------------------------------------------------------
//背景画像の表示モード設定
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::BgImgModeActionExecute(TObject *Sender)
{
	bool x_sw = remove_top_s(ActionParam, '^');
	if		(TEST_ActParam("OFF"))	BgImgMode = 0;
	else if (TEST_ActParam("1"))	BgImgMode = (x_sw && BgImgMode==1)? 0 : 1;
	else if (TEST_ActParam("2"))	BgImgMode = (x_sw && BgImgMode==2)? 0 : 2;
	else if (TEST_ActParam("3"))	BgImgMode = (x_sw && BgImgMode==3)? 0 : 3;
	else SetActionAbort();

	UpdateBgImage(true, true);
}

//---------------------------------------------------------------------------
//バイナリ編集
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::BinaryEditActionExecute(TObject *Sender)
{
	try {
		if (TestCurIncDir()) UserAbort(USTR_IncludeDir);

		TStringList *lst = GetCurList();
		int sel_cnt = fromOpenStd? 0 : GetSelCount(lst);
		UnicodeString editor = get_actual_path(BinaryEditor);
		if (!file_exists(editor)) UserAbort(USTR_AppNotFound);
		std::unique_ptr<TStringList> s_lst(new TStringList());
		UnicodeString fnam = (sel_cnt>0)? GetSelFileStr(lst, true, false, s_lst.get()) : GetCurFileStr();
		ActionOk = Execute_ex(editor, fnam);
		if (ActionOk) {
			if (s_lst->Count>0) AddToRecentFile(s_lst.get()); else AddToRecentFile(fnam);
		}
	}
	catch (EAbort &e) {
		SetActionAbort(e.Message);
	}
}
//---------------------------------------------------------------------------
//境界を左に移動
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::BorderLeftActionExecute(TObject *Sender)
{
	if (DivFileListUD) {
		L_Panel->Height = std::max(L_Panel->Height - BorderMoveWidth, 0);
	}
	else {
		L_Panel->Width = std::max(L_Panel->Width - BorderMoveWidth, 0);
		L_TopPanel->Width = L_Panel->Width - (RelPanel->Width - LRSplitter->Width)/2;
	}

	InvalidateFileList(0);
	InvalidateFileList(1);
}
//---------------------------------------------------------------------------
//境界を右に移動
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::BorderRightActionExecute(TObject *Sender)
{
	if (DivFileListUD) {
		int lh = L_Panel->Height + BorderMoveWidth;
		if (lh>ListPanel->ClientHeight) lh = ListPanel->ClientHeight;
		L_Panel->Height = lh;
	}
	else {
		int lw = L_Panel->Width + BorderMoveWidth;
		if (lw>ListPanel->ClientWidth) lw = ListPanel->ClientWidth;
		L_Panel->Width = lw;
		L_TopPanel->Width = L_Panel->Width - (RelPanel->Width - LRSplitter->Width)/2;
	}

	InvalidateFileList(0);
	InvalidateFileList(1);
}

//---------------------------------------------------------------------------
//ディレクトリの容量計算
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::CalcDirSizeCore(
	file_rec *fp,
	TStringList *r_lst,		//[o] 結果リスト(タブ区切り, Object=サイズ)		(default = NULL)
	__int64 *total_sz,		//[o] 合計サイズ(逐次加算)						(default = NULL)
	__int64 *total_c_sz,	//[o] 合計圧縮サイズ(逐次加算)					(default = NULL)
	int *total_f_cnt,		//[o] 総ファイル数(逐次加算)					(default = NULL)
	int *total_d_cnt)		//[o] 総ディレクトリ数(逐次加算)				(default = NULL)
{
	if (!fp || fp->f_attr==faInvalid || fp->is_up) return;

	if (fp->is_dir) {
		UnicodeString msg;
		SttWorkMsg(msg.sprintf(_T("ディレクトリ容量を計算中... [%s]"), fp->b_name.c_str()), CalcTag);

		int f_cnt = 0, d_cnt = 0;
		__int64 o_sz = 0;
		__int64 c_sz = 0;

		fp->f_size  = fp->is_virtual? get_ArcDirSize(fp->arc_name, fp->f_name, &f_cnt, &d_cnt)
								    : get_DirSize(fp->f_name, &f_cnt, &d_cnt, &o_sz, &c_sz);
		fp->o_size	= o_sz;
		fp->c_size	= fp->is_virtual? fp->f_size : c_sz;
		fp->f_count = f_cnt;
		fp->d_count = d_cnt;

		if (total_f_cnt) *total_f_cnt += f_cnt;
		if (total_d_cnt) *total_d_cnt += d_cnt;
		if (total_sz)	 *total_sz	  += fp->f_size;
		if (total_c_sz)	 *total_c_sz  += fp->c_size;

		if (r_lst) {
			UnicodeString lbuf;
			lbuf.sprintf(_T("[%s]\t%s\t%s\t%s"),
					fp->b_name.c_str(),
					get_FileSizeStr(fp->f_size).c_str(),
					get_size_str_B(f_cnt, 10).c_str(),
					get_size_str_B(d_cnt, 8).c_str());

			__int64 *v = new __int64;
			*v = fp->f_size;
			r_lst->AddObject(lbuf, (TObject*)v);
		}
	}
}
//---------------------------------------------------------------------------
//CalcDirSize〜用の結果ソート用比較関数
//  Objects 設定されている __int64 サイズ値を比較
//---------------------------------------------------------------------------
int oder_CalcDirSize;	//ソート順 1=昇順、-1=降順、0=なし

int __fastcall comp_CalcDirSize(TStringList *List, int Index1, int Index2)
{
	__int64 *p1 = (__int64*)List->Objects[Index1];
	__int64 *p2 = (__int64*)List->Objects[Index2];

	__int64 sz1 = p1? *p1 : 0;
	__int64 sz2 = p2? *p2 : 0;

	int res;
	if (sz1==sz2)
		res = StrCmpLogicalW(List->Strings[Index1].c_str(), List->Strings[Index2].c_str());
	else
		res = (sz2 < sz1)? 1 : -1;

	return res * oder_CalcDirSize;
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::CalcDirSizeActionExecute(TObject *Sender)
{
	try {
		bool calc_all = false;
		if (USAME_TI(ActionOptStr, "All")) {
			calc_all = true;
			ActionOptStr = EmptyStr;
		}

		if (!calc_all && !TestCurIncDir()) Abort();
		if (CurStt->is_Find && CurStt->find_HLINK) UserAbort(USTR_CantOperate);
		if (TestCurIncFindVirtual() || CurStt->is_FTP) UserAbort(USTR_OpeNotSuported);

		TStringList *lst = GetCurList(true);
		bool lst_sel = ListSelected(lst);
		if (!calc_all && !lst_sel && !GetCurFrecPtr()) Abort();

		bool out_log 		 = TEST_DEL_ActParam("LO");
		bool out_clip		 = TEST_DEL_ActParam("CC");
		bool out_list		 = TEST_DEL_ActParam("LS");
		CurStt->show_f_d_cnt = TEST_DEL_ActParam("FC");						//ファイル、ディレクトリ数表示
		CurStt->dir_graph	 = TEST_DEL_ActParam("SG");						//グラフ表示(対カレント)
		CurStt->dsk_graph	 = TEST_DEL_ActParam("DG") && !CurStt->is_Arc;	//グラフ表示(対ドライブ)
		oder_CalcDirSize	 = TEST_DEL_ActParam("SA")? 1 : TEST_DEL_ActParam("SD")? -1 : 0;	//サイズソート
		UnicodeString outfnam = ActionParam;

		CalcBusy = true;
		ShowMessageHint(USTR_CalculatingESC, col_bgHint, false, true);
		if (out_log) StartLog(_T("計算開始"));

		//計算
		std::unique_ptr<TStringList> r_lst(new TStringList());
		__int64 total_sz	= 0;	//合計サイズ
		__int64 total_d_csz = 0;	//合計圧縮サイズ(ディレクトリ)
		__int64 total_f_csz = 0;	//合計圧縮サイズ(ファイル)
		int total_f_cnt 	= 0;	//総ファイル数
		int total_d_cnt 	= 0;	//総ディレクトリ数
		int cur_idx = FileListBox[CurListTag]->ItemIndex;

		for (int i=0; i<lst->Count && !CalcAborted; i++) {
			file_rec *fp = (file_rec*)lst->Objects[i];
			if (calc_all || fp->selected || (!lst_sel && i==cur_idx)) {
				//容量計算 (Objects に結果を __int64 で設定)
				if (fp->is_dir)
					CalcDirSizeCore(fp, r_lst.get(), &total_sz, &total_d_csz, &total_f_cnt, &total_d_cnt);
				else
					total_f_csz += ((fp->f_attr & faCompressed)? get_comp_size(fp->f_name) : fp->f_size);
				fp->selected = false;
				InvalidateFileList();
			}
		}
		CurStt->cmp_total = calc_all? (total_d_csz + total_f_csz) : -1;

		//サイズによるソート
		if (oder_CalcDirSize!=0) r_lst->CustomSort(comp_CalcDirSize);
		for (int i=0; i<r_lst->Count; i++) delete (__int64*)r_lst->Objects[i];

		//表示更新
		if (SortMode[CalcTag]==3 || DirSortMode[CalcTag]==3) RepaintList(CurListTag, EmptyStr, true);
		InvalidateFileList(CalcTag);
		SetDriveFileInfo(CalcTag);
		CalcBusy = false;
		if (UnInitializing) Abort();
		if (CalcAborted) SttBarWarnUstr(USTR_Canceled);

		//結果を出力
		if (out_log || out_clip || out_list || !outfnam.IsEmpty()) {
			//整形
			int max_len = format_res_list(r_lst.get(), 4, 18);
			//合計
			UnicodeString hr_str = make_RuledLine(4, max_len - 2, (ShowByteSize? 15 : 11), 9, 7);
			UnicodeString tmp;
			r_lst->Add(hr_str);
			r_lst->Add(tmp.sprintf(_T("%*s%s%s%s"),
						max_len, _T("Total  "),
						get_FileSizeStr(total_sz).c_str(),
						get_size_str_B(total_f_cnt, 10).c_str(),
						get_size_str_B(total_d_cnt, 8).c_str()));

			if (total_d_csz<total_sz)
				r_lst->Add(tmp.sprintf(_T("%*s%s"), max_len, _T("Compressed  "), get_FileSizeStr(total_d_csz).c_str()));

			//ヘッダ
			r_lst->Insert(0, hr_str);
			r_lst->Insert(0, tmp.sprintf(_T("%-*s %-*s %-9s Subdirs"), max_len - 2,
							_T("Directory Name"), (ShowByteSize? 15 : 11), _T("Size"), _T("Files")));
			r_lst->Insert(0, CurPath[CurListTag]);
			//ログ出力
			if (out_log) {
				AddLogStrings(r_lst.get());
				AddLog(CalcAborted? _T("計算中断") : _T("計算終了"), true);
			}
			//コピー/一覧表示/ファイル出力
			ClipSaveList(r_lst.get(), _T("ディレクトリ容量"), out_clip, out_list, outfnam);
		}

		if (!CalcAborted) SttWorkMsg(EmptyStr, CalcTag);
	}
	catch (EAbort &e) {
		SetActionAbort(e.Message);
	}
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::CalcDirSizeAllActionExecute(TObject *Sender)
{
	ActionOptStr = "All";
	CalcDirSizeAction->Execute();
}

//---------------------------------------------------------------------------
//電卓
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::CalculatorActionExecute(TObject *Sender)
{
	if (!Calculator) Calculator = new TCalculator(this);	//初回に動的作成

	bool use_cb = TEST_DEL_ActParam("CB");

	UnicodeString s;
	if (!ActionParam.IsEmpty()) {
		s = ActionParam;
	}
	else if (!use_cb) {
		if (ScrMode==SCMD_FLIST && CurStt->sel_size>0)
			s = get_size_str_B(CurStt->sel_size, 0);
		else if (ScrMode==SCMD_TVIEW)
			s = TxtViewer->get_SelText();
	}

	if (use_cb) {
		if (s.IsEmpty()) s = Clipboard()->AsText;
		Calculator->CalcLine(s, true);
		copy_to_Clipboard(Calculator->OutputLine);
	}
	else {
		Calculator->InitialLine = s;
		Calculator->ShowModal();
	}
}

//---------------------------------------------------------------------------
//すべてのタスクを中止
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::CancelAllTaskActionExecute(TObject *Sender)
{
	for (int i=0; i<MAX_TASK_THREAD; i++) {
		TTaskThread *tp = TaskThread[i];
		if (tp) tp->TaskCancel = true;
	}
	TaskReserveList->ClearAll();
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::CancelAllTaskActionUpdate(TObject *Sender)
{
	((TAction*)Sender)->Enabled = (get_BusyTaskCount()>0);
}

//---------------------------------------------------------------------------
//ドライブの変更
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ChangeDriveActionExecute(TObject *Sender)
{
	try {
		if (ActionParam.IsEmpty()) UserAbort(USTR_NoParameter);
		UnicodeString dstr; dstr.sprintf(_T("%s:\\"), ActionParam.c_str());
		if (!dir_exists(dstr)) SysErrAbort(ERROR_INVALID_DRIVE);
		UpdateCurDrive(dstr);
		if (!GlobalErrMsg.IsEmpty()) GlobalAbort();
	}
	catch (EAbort &e) {
		SetActionAbort(e.Message);
	}
}
//---------------------------------------------------------------------------
//ディレクトリの変更
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ChangeDirActionExecute(TObject *Sender)
{
	try {
		if (ActionParam.IsEmpty()) UserAbort(USTR_NoParameter);
		UnicodeString dnam = to_absolute_name(cv_env_str(ActionParam), CurPath[CurListTag]);
		int atr = file_GetAttr(dnam);
		if (atr==faInvalid) SysErrAbort(ERROR_PATH_NOT_FOUND);

		UnicodeString fnam;
		if (!(atr & faDirectory)) {
			fnam = dnam;
			dnam = ExtractFilePath(dnam);
		}
		dnam = IncludeTrailingPathDelimiter(dnam);
		UpdateCurPath(dnam, fnam);
		if (!GlobalErrMsg.IsEmpty()) GlobalAbort();
	}
	catch (EAbort &e) {
		SetActionAbort(e.Message);
	}
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ChangeOppDirActionExecute(TObject *Sender)
{
	try {
		if (ActionParam.IsEmpty()) UserAbort(USTR_NoParameter);
		UnicodeString dnam = to_absolute_name(cv_env_str(ActionParam), CurPath[OppListTag]);
		if (!dir_exists(dnam)) SysErrAbort(ERROR_PATH_NOT_FOUND);
		UpdateOppPath(dnam);
		if (!GlobalErrMsg.IsEmpty()) GlobalAbort();
	}
	catch (EAbort &e) {
		SetActionAbort(e.Message);
	}
}

//---------------------------------------------------------------------------
//登録ディレクトリを開く
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ChangeRegDirActionExecute(TObject *Sender)
{
	try {
		if (ActionParam.IsEmpty()) UserAbort(USTR_NoParameter);
		UnicodeString dnam = get_RegDirItem(ActionParam[1]);
		if (dnam.IsEmpty()) Abort();
		UpdateCurPath(dnam);
		if (!GlobalErrMsg.IsEmpty()) GlobalAbort();
	}
	catch (EAbort &e) {
		SetActionAbort(e.Message);
	}
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ChangeOppRegDirActionExecute(TObject *Sender)
{
	try {
		if (ActionParam.IsEmpty()) UserAbort(USTR_NoParameter);
		UnicodeString dnam = get_RegDirItem(ActionParam[1]);
		if (dnam.IsEmpty()) Abort();
		UpdateOppPath(dnam);
		if (!GlobalErrMsg.IsEmpty()) GlobalAbort();
	}
	catch (EAbort &e) {
		SetActionAbort(e.Message);
	}
}

//---------------------------------------------------------------------------
//すべての選択状態を解除
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ClearAllActionExecute(TObject *Sender)
{
	TStringList *lst = GetCurList();
	if (ListSelected(lst)) {
		ClrSelect(lst);
		RepaintList(CurListTag);
	}

	if (TEST_ActParam("AL")) {
		lst = GetOppList();
		if (ListSelected(lst)) {
			ClrSelect(lst);
			RepaintList(OppListTag);
		}
	}
}

//---------------------------------------------------------------------------
//すべてのマークを解除
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ClearMarkActionExecute(TObject *Sender)
{
	if (TEST_ActParam("AC")) {
		if (msgbox_Sure(USTR_ClrAllMarkQ, !(ExeCmdsBusy && XCMD_MsgOff)))
			IniFile->ClearAllMark();
	}
	else {
		TStringList *lst = GetCurList();
		for (int i=0; i<lst->Count; i++) {
			file_rec *fp = (file_rec*)lst->Objects[i];
			if (is_selectable(fp)) IniFile->FileMark(fp->r_name, 0);
		}

		switch (ScrMode) {
		case SCMD_FLIST:
			RepaintList(CurListTag);
			if (EqualDirLR()) ReloadList(OppListTag);
			break;
		case SCMD_IVIEW:
			ThumbnailGrid->Repaint();
			break;
		}
	}
}

//---------------------------------------------------------------------------
//ログをクリア
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ClearLogActionExecute(TObject *Sender)
{
	LogBufList->Clear();
	LogListBox->Count = 0;
	LogScrPanel->UpdateKnob();
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::LogActionUpdate(TObject *Sender)
{
	TAction *ap = (TAction*)Sender;
	ap->Visible = ScrMode==SCMD_FLIST;
	ap->Enabled = ap->Visible && LogListBox->Count>0;
}

//---------------------------------------------------------------------------
//マスクを解除
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ClearMaskActionExecute(TObject *Sender)
{
	TStringList *sm_lst = SelMaskList[CurListTag];

	if (CurStt->is_Find || CurStt->is_Work) {
		if (sm_lst->Count>0) ExeCommandAction("SelMask", "CA");
		return;
	}

	UnicodeString fnam = GetCurFileName();
	if (sm_lst->Count>0)
		sm_lst->Clear();
	else if (!PathMask[CurListTag].IsEmpty())
		PathMask[CurListTag] = EmptyStr;
	else return;

	RefreshCurPath(fnam);
}

//---------------------------------------------------------------------------
//コマンドファイル一覧
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::CmdFileListActionExecute(TObject *Sender)
{
	file_rec *cfp = GetCurFrecPtr();
	CmdFileListDlg->CmdFileName = (cfp && test_NbtExt(cfp->f_ext))? cfp->f_name : EmptyStr;
	CmdFileListDlg->ToFilter = TEST_ActParam("FF");
	CmdFileListDlg->ShowModal();
	//結果は CmdRequestList で実行
}

//---------------------------------------------------------------------------
//コマンドプロンプト
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::CommandPromptActionExecute(TObject *Sender)
{
	if (!Execute_ex("cmd.exe", EmptyStr, CurPath[CurListTag]))
		SetActionAbort(USTR_FaildExec);
}

//---------------------------------------------------------------------------
//同名ファイルの比較
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::CompareDlgActionExecute(TObject *Sender)
{
	TStringList *c_lst = GetCurList(true);
	TStringList *o_lst = GetOppList();
	UnicodeString top_fnam;

	UnicodeString pnam0, pnam1, msg;
	if (CurStt->is_Find)
		pnam0 = (c_lst->Count==1)? ExtractFilePath(c_lst->Strings[0]) : CurPath[CurListTag] + "(結果リスト)";
	else
		pnam0 = CurStt->is_Arc? CurStt->arc_Name : CurPath[CurListTag];

	if (OppStt->is_Find)
		pnam1 = (o_lst->Count==1)? ExtractFilePath(o_lst->Strings[0]) : CurPath[OppListTag] + "(結果リスト)";
	else
		pnam1 = OppStt->is_Arc? OppStt->arc_Name : CurPath[OppListTag];

	//ダイアログを出さず、名前のみ比較
	if (TEST_ActParam("NC")) {
		StartLog(msg.sprintf(_T("比較開始  %s  |  %s"), pnam0.c_str(), pnam1.c_str()));
		std::unique_ptr<TStringList> log_buf(new TStringList());
		bool cmp_dir = IniFile->ReadBoolGen(_T("CompDir"));
		int hit_cnt = 0;
		for (int c_i=0; c_i<c_lst->Count; c_i++) {
			file_rec *cfp = (file_rec*)c_lst->Objects[c_i];
			if (!is_selectable(cfp)) continue;
			cfp->selected = false;
			if (cfp->is_dir && !cmp_dir) continue;
			for (int o_i=0; o_i<o_lst->Count; o_i++) {
				file_rec *ofp = (file_rec*)o_lst->Objects[o_i];
				if (!is_selectable(ofp)) continue;
				if (ofp->is_dir && !cmp_dir) continue;
				if (cfp->is_dir != ofp->is_dir) continue;
				if (SameText(cfp->n_name, ofp->n_name)) {
					cfp->selected = true;
					if (top_fnam.IsEmpty()) top_fnam = cfp->f_name;
					hit_cnt++;
					log_buf->Add(" >" + make_LogHdr("HIT", cfp->f_name));
				}
			}
		}
		RepaintList(CurListTag);
		IndexOfFileList(top_fnam);
		AddLogStrings(log_buf.get());
		AddLog(msg.sprintf(_T("比較終了  HIT: %u"), hit_cnt));
	}
	//ダイアログで条件を指定して比較
	else {
		//すべてのディレクトリがサイズを持っているか？
		bool alldir_has_size = true;
		for (int i=0; i<c_lst->Count && alldir_has_size; i++) {
			file_rec *fp = (file_rec*)c_lst->Objects[i];
			if (is_selectable(fp) && fp->is_dir && fp->f_size==-1) alldir_has_size = false;
		}
		for (int i=0; i<o_lst->Count && alldir_has_size; i++) {
			file_rec *fp = (file_rec*)o_lst->Objects[i];
			if (is_selectable(fp) && fp->is_dir && fp->f_size==-1) alldir_has_size = false;
		}

		if (!FileCompDlg) FileCompDlg = new TFileCompDlg(this);	//初回に動的作成
		FileCompDlg->AllDirHasSize = alldir_has_size;
		FileCompDlg->SelMaskCheckBox->Enabled = (IsCurFList() || CurStt->is_Arc);

		InhReload++;
		if (FileCompDlg->ShowModal()==mrOk) {
			int  t_mode  = FileCompDlg->TimeRadioGroup->ItemIndex;
			int  s_mode  = FileCompDlg->SizeRadioGroup->Enabled? FileCompDlg->SizeRadioGroup->ItemIndex : 0;
			int  h_mode  = FileCompDlg->HashRadioGroup->Enabled? FileCompDlg->HashRadioGroup->ItemIndex : 0;
			int  i_mode  = FileCompDlg->IdRadioGroup->Enabled?   FileCompDlg->IdRadioGroup->ItemIndex   : 0;
			bool cmp_dir = FileCompDlg->CmpDirCheckBox->Checked;
			bool cmp_arc = FileCompDlg->CmpArcCheckBox->Checked;
			bool sel_opp = FileCompDlg->SelOppCheckBox->Checked;
			bool sel_rev = FileCompDlg->ReverseCheckBox->Checked;
			bool sel_msk = FileCompDlg->SelMaskCheckBox->Checked;
			UnicodeString idstr = get_word_i_idx(HASH_ID_STR, FileCompDlg->AlgRadioGroup->ItemIndex);

			try {
				CurWorking = true;
				ShowMessageHint(USTR_ProcessingESC, col_bgHint, false, true);
				SttWorkMsg(_T("同名ファイルの比較中..."), CurListTag);
				StartLog(msg.sprintf(_T("比較開始  %s  |  %s"), pnam0.c_str(), pnam1.c_str()));
				if (t_mode>0) {
					msg = "  タイム: ";
					switch (t_mode) {
					case 1: msg += "不一致";	break;
					case 2: msg += "一致";		break;
					case 3: msg += "新しい";	break;
					case 4: msg += "古い";		break;
					}
					AddLog(msg);
				}
				if (s_mode>0) {
					msg = "  サイズ: ";
					switch (s_mode) {
					case 1: msg += "不一致";	break;
					case 2: msg += "一致";		break;
					case 3: msg += "大きい";	break;
					case 4: msg += "小さい";	break;
					}
					AddLog(msg);
				}
				if (h_mode>0) {
					msg.sprintf(_T("ハッシュ: %s "), idstr.c_str());
					switch (h_mode) {
					case 1: msg += "不一致";	break;
					case 2: msg += "一致";		break;
					}
					AddLog(msg);
				}
				if (i_mode>0) {
					msg = "  同一性: ";
					switch (i_mode) {
					case 1: msg += "不一致";	break;
					case 2: msg += "一致";		break;
					}
					AddLog(msg);
				}

				ClrSelect(c_lst);
				RepaintList(CurListTag);
				if (sel_opp) {
					ClrSelect(o_lst);
					RepaintList(OppListTag);
				}

				std::unique_ptr<TStringList> log_buf(new TStringList());
				int hit_cnt = 0, err_cnt = 0;
				for (int c_i=0; c_i<c_lst->Count; c_i++) {
					file_rec *cfp = (file_rec*)c_lst->Objects[c_i];
					if (!is_selectable(cfp)) continue;
					if (cfp->is_dir && !cmp_dir) continue;

					bool c_is_arc = !cfp->is_dir && test_ArcExt(cfp->f_ext);
					for (int o_i=0; o_i<o_lst->Count; o_i++) {
						file_rec *ofp = (file_rec*)o_lst->Objects[o_i];
						if (!is_selectable(ofp)) continue;
						if (ofp->is_dir && !cmp_dir) continue;
						bool o_is_arc = !ofp->is_dir && test_ArcExt(ofp->f_ext);
						if (!cmp_arc && (cfp->is_dir!=ofp->is_dir)) continue;

						if (is_KeyPress_ESC()) {
							ClearKeyBuff(true);
							UserAbort(USTR_Canceled);
						}

						//同名
						UnicodeString c_name = (c_is_arc && ofp->is_dir)? cfp->b_name : cfp->n_name;
						UnicodeString o_name = (o_is_arc && cfp->is_dir)? ofp->b_name : ofp->n_name;
						if (SameText(c_name, o_name)) {
							msg = make_LogHdr("COMP", cfp->f_name);
							//タイムスタンプ
							bool t_flag;
							if (t_mode==0) {
								t_flag = true;
							}
							else {
								bool same_t = WithinPastMilliSeconds(cfp->f_time, ofp->f_time, TimeTolerance);
								t_flag = (t_mode==1)? !same_t :
										 (t_mode==2)?  same_t :
										 (t_mode==3)? (!same_t && cfp->f_time>ofp->f_time) :
										 (t_mode==4)? (!same_t && cfp->f_time<ofp->f_time) : false;
							}

							//サイズ
							__int64 c_size = cfp->f_size;
							__int64 o_size = ofp->f_size;
							__int64 org_size;
							int f_cnt;
							if (c_is_arc && ofp->is_dir && usr_ARC->GetArcInfo(cfp->f_name, &f_cnt, &org_size))
								c_size = org_size;
							if (o_is_arc && cfp->is_dir && usr_ARC->GetArcInfo(ofp->f_name, &f_cnt, &org_size))
								o_size = org_size;

							bool s_flag = (s_mode==1)? (c_size != o_size) :
										  (s_mode==2)? (c_size == o_size) :
										  (s_mode==3)? (c_size >  o_size) :
										  (s_mode==4)? (c_size <  o_size) : true;

							//ハッシュ
							bool h_flag = false;
							if (h_mode>0) {
								try {
									if (cfp->f_size==ofp->f_size) {
										UnicodeString fnam0, fnam1;
										if (cfp->is_virtual) {
											if (!SetTmpFile(cfp)) UserAbort(USTR_FaildTmpUnpack);
											fnam0 = cfp->tmp_name;
										}
										else fnam0 = cfp->f_name;
										if (ofp->is_virtual) {
											if (!SetTmpFile(ofp)) UserAbort(USTR_FaildTmpUnpack);
											fnam1 = ofp->tmp_name;
										}
										else fnam1 = ofp->f_name;

										//簡易チェック
										UnicodeString hash_c = get_HashStr(fnam0, idstr, true);
										UnicodeString hash_o = get_HashStr(fnam1, idstr, true);
										if (hash_c.IsEmpty() || hash_o.IsEmpty()) EmptyAbort();
										if (cfp->f_size<=FILE_RBUF_SIZE) {
											cfp->hash = hash_c;
											ofp->hash = hash_o;
										}

										//不一致
										if (h_mode==1) {
											h_flag = !SameStr(hash_c, hash_o);
											if (!h_flag && cfp->f_size>FILE_RBUF_SIZE) {
												cfp->hash = get_HashStr(fnam0, idstr, false, true);
												if ((int)GetLastError()==E_ABORT) TextAbort(_T("CANCELED"));
												ofp->hash = get_HashStr(fnam1, idstr, false, true);
												if ((int)GetLastError()==E_ABORT) TextAbort(_T("CANCELED"));
												if (cfp->hash.IsEmpty() || ofp->hash.IsEmpty()) EmptyAbort();;
												h_flag = !SameStr(cfp->hash, ofp->hash);
											}
										}
										//一致
										else {
											h_flag = SameStr(hash_c, hash_o);
											if (h_flag && cfp->f_size>FILE_RBUF_SIZE) {
												cfp->hash = get_HashStr(fnam0, idstr, false, true);
												if ((int)GetLastError()==E_ABORT) TextAbort(_T("CANCELED"));
												ofp->hash = get_HashStr(fnam1, idstr, false, true);
												if ((int)GetLastError()==E_ABORT) TextAbort(_T("CANCELED"));
												if (cfp->hash.IsEmpty() || ofp->hash.IsEmpty()) EmptyAbort();;
												h_flag = SameStr(cfp->hash, ofp->hash);
											}
										}

										//カレント側ファイル情報へ反映
										if (cfp->inf_list->Count==0) GetFileInfList(cfp);
									}
								}
								catch (EAbort &e) {
									if (USAME_TS(e.Message, "CANCELED")) UserAbort(USTR_Canceled);
									set_LogErrMsg(msg, e.Message);
									log_buf->Text = log_buf->Text + " >" + msg;
									h_flag = false;
								}
							}
							else h_flag = true;

							//同一性
							bool i_flag = (i_mode==1)? !is_IdenticalFile(cfp->f_name, ofp->f_name) :
										  (i_mode==2)? is_IdenticalFile(cfp->f_name, ofp->f_name) : true;

							//結果
							cfp->selected = t_flag && s_flag && h_flag && i_flag;
							if (cfp->selected) {
								hit_cnt++;
								log_buf->Add(" >" + make_LogHdr("HIT", cfp->f_name));
								if (sel_opp) ofp->selected = cfp->selected;
							}
							if (top_fnam.IsEmpty() && cfp->selected) top_fnam = cfp->f_name;
						}
					}
				}

				CurWorking = false;
				SttWorkMsg(EmptyStr, CurListTag);
				AddLogStrings(log_buf.get());
				msg.sprintf(_T("比較終了  HIT: %u"), hit_cnt);
				if (err_cnt>0) msg.cat_sprintf(_T("  ERR:%u"), err_cnt);
				AddLog(msg, true);

				//結果を反転
				if (sel_rev) {
					for (int i=0; i<c_lst->Count; i++) {
						file_rec *fp = (file_rec*)c_lst->Objects[i];
						if (!is_selectable(fp)) continue;
						if (fp->is_dir && !cmp_dir) continue;
						fp->selected = !fp->selected;
					}

					if (sel_opp) {
						for (int i=0; i<o_lst->Count; i++) {
							file_rec *fp = (file_rec*)o_lst->Objects[i];
							if (!is_selectable(fp)) continue;
							if (fp->is_dir && !cmp_dir) continue;
							fp->selected = !fp->selected;
						}
					}
				}
			}
			catch (EAbort &e) {
				SetActionAbort(e.Message);
			}

			//選択項目だけを残す(選択マスク)
			if (sel_msk && (IsCurFList() || CurStt->is_Arc)) {
				ExeCommandAction("SelMask", "OP");
			}
			//通常
			else {
				RepaintList(CurListTag);
				IndexOfFileList(top_fnam);
				if (sel_opp) RepaintList(OppListTag);
			}

			MsgHint->ReleaseHandle();
			cursor_Default();
		}
		InhReload = 0;
	}
}

//---------------------------------------------------------------------------
//ハッシュ値の比較
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::CompareHashActionExecute(TObject *Sender)
{
	try {
		if (CurStt->is_Work || OppStt->is_Work || CurStt->is_FTP || OppStt->is_FTP) UserAbort(USTR_CantOperate);
		if (TestCurIncDir()) UserAbort(USTR_IncludeDir);
		if (TestCurIncFindVirtual()) UserAbort(USTR_OpeNotSuported);

		bool is_OS = TEST_DEL_ActParam("OS");
		UnicodeString idstr = def_if_empty(ActionParam, "MD5");

		TStringList *lst0 = GetCurList(true);
		TStringList *lst1 = GetOppList();
		int sel_cnt0 = GetSelCount(lst0);
		int sel_cnt1 = GetSelCount(lst1);

		if (sel_cnt0>0 && sel_cnt1>0 && sel_cnt0!=sel_cnt1) TextAbort(_T("左右の選択数が異なっています。"));
		if (sel_cnt0==0 && sel_cnt1>0) Abort();

		CurWorking = true;
		BeginWorkProgress(_T("ハッシュ値の比較"), EmptyStr, ListPanel);

		std::unique_ptr<TStringList> c_lst(new TStringList());	//カレント側対象リスト
		std::unique_ptr<TStringList> o_lst(new TStringList());	//反対側対象リスト

		//カレント側対象リストを作成
		if (sel_cnt0>0) {
			GetSelList(lst0, c_lst.get(), true, true);
		}
		else {
			file_rec *cfp = GetCurFrecPtr(true);
			if (cfp) c_lst->AddObject(cfp->f_name, (TObject*)cfp);
		}
		if (c_lst->Count==0) Abort();

		//ファイル名最大幅を取得
		int w_fn = 0;
		for (int i=0; i<c_lst->Count; i++) {
			file_rec *fp = (file_rec*)c_lst->Objects[i];
			max_len_half(w_fn, LogFullPath? fp->f_name : fp->n_name);
		}

		//反対側対象リストを作成
		if (sel_cnt1>0) GetSelList(lst1, o_lst.get(), true, true);
		if (o_lst->Count==0) {
			//同名ファイルを探す
			for (int i=0; i<c_lst->Count; i++) {
				UnicodeString fnam = ((file_rec*)c_lst->Objects[i])->n_name;
				file_rec *fp1 = NULL;
				for (int j=0; j<lst1->Count && !fp1; j++) {
					file_rec *fp = (file_rec*)lst1->Objects[j];
					if (SameText(fp->n_name, fnam)) fp1 = fp;
				}
	
				if (fp1) {
					o_lst->AddObject(fp1->f_name, (TObject*)fp1);
					if (LogFullPath) max_len_half(w_fn, fp1->f_name);
				}
				else {
					o_lst->Add(EmptyStr);
				}
			}
		}

		UnicodeString pnam0, msg;
		if (CurStt->is_Find)
			pnam0 = (c_lst->Count==1)? ExtractFilePath(c_lst->Strings[0]) : CurPath[CurListTag] + "(結果リスト)";
		else
			pnam0 = CurStt->is_Arc? CurStt->arc_Name : CurPath[CurListTag];

		UnicodeString pnam1;
		if (OppStt->is_Find)
			pnam1 = (o_lst->Count==1)? ExtractFilePath(o_lst->Strings[0]) : CurPath[OppListTag] + "(結果リスト)";
		else
			pnam1 = OppStt->is_Arc? OppStt->arc_Name : CurPath[OppListTag];

		StartLog(msg.sprintf(_T("比較開始  %s  |  %s"), pnam0.c_str(), pnam1.c_str()));

		int ok_cnt = 0, er_cnt = 0, ng_cnt = 0;
		for (int i=0; i<c_lst->Count; i++) {
			PosWorkProgress(i, c_lst->Count);

			file_rec *fp0 = (file_rec*)c_lst->Objects[i];
			file_rec *fp1 = (file_rec*)o_lst->Objects[i];

			if (CurStt->is_Find || OppStt->is_Find) {	//結果リストの場合は個々にパスも表示
				AddLog(msg.sprintf(_T("%s  |  %s"),
						ExtractFilePath(c_lst->Strings[i]).c_str(),
						ExtractFilePath(o_lst->Strings[i]).c_str()));
			}

			//カレント側の取得
			UnicodeString fnam0;
			if (fp0->is_virtual) {
				if (!SetTmpFile(fp0)) UserAbort(USTR_FaildTmpUnpack);
				fnam0 = fp0->tmp_name;
			}
			else {
				fnam0 = fp0->f_name;
			}

			UnicodeString hash0 = get_HashStr(fnam0, idstr, false, true);
			if ((int)GetLastError()==E_ABORT) UserAbort(USTR_Canceled);
			msg = make_LogHdr(idstr, fnam0, false, w_fn);
			if (!hash0.IsEmpty()) {
				fp0->hash = hash0;
				msg.cat_sprintf(_T("  %s"), hash0.c_str());
			}
			else set_LogErrMsg(msg);
			AddLog(msg);

			//反対側の取得
			UnicodeString fnam1;
			if (!fp1) {
				fnam1 = EmptyStr;
			}
			else if (fp1->is_virtual) {
				if (!SetTmpFile(fp1)) UserAbort(USTR_FaildTmpUnpack);
				fnam1 = fp1->tmp_name;
			}
			else {
				fnam1 = fp1->f_name;
			}

			UnicodeString hash1;
			if (!fnam1.IsEmpty()) {
				hash1 = get_HashStr(fnam1, idstr, false, true);
				if ((int)GetLastError()==E_ABORT) UserAbort(USTR_Canceled);
				msg = make_LogHdr(idstr, fnam1, false, w_fn);
				if (!hash1.IsEmpty()) {
					fp1->hash = hash1;
					msg.cat_sprintf(_T("  %s"), hash1.c_str());
				}
				else set_LogErrMsg(msg);
				AddLog(msg);
			}

			//結果表示
			if (fnam1.IsEmpty()) {
				er_cnt++; msg = "E        同名ファイルがありません";
			}
			else if (hash0.IsEmpty() || hash1.IsEmpty()) {
				er_cnt++; msg = "E        取得に失敗しました";
			}
			else if (SameStr(hash0, hash1)) {
				ok_cnt++; msg = "         一致しました";
			}
			else {
				ng_cnt++; msg = "W        一致しません";
				//反対側で選択
				if (is_OS) {
					fp1->selected = true;
					if (ng_cnt==1) IndexOfFileList(o_lst->Strings[i], OppListTag);
					InvalidateFileList(OppListTag);
					SetDriveInfo(OppListTag);
				}
			}
			AddLog(msg);
		}

		//単独同名なら反対側に点線カーソル
		if (c_lst->Count==1 && sel_cnt1==0) {
			int idx = IndexOfFileList(o_lst->Strings[0], OppListTag);
			if (idx!=-1) {
				TListBox *lp = FileListBox[CurListTag];
				int itm_p = lp->ItemIndex - lp->TopIndex;
				lp = FileListBox[OppListTag];
				lp->ItemIndex = idx;
				lp->TopIndex  = std::max(idx - itm_p, 0);
				DrawOppCsr++;
			}
			ViewCurFileInf();
		}

		CurWorking = false;
		InvalidateFileList(OppListTag);
		EndLog(_T("比較"), get_res_cnt_str(ok_cnt, er_cnt, 0, ng_cnt));
		EndWorkProgress();
	}
	catch (EAbort &e) {
		SetActionAbort(e.Message);
	}
}

//---------------------------------------------------------------------------
//ディレクトリのNTFS圧縮
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::CompressDirActionExecute(TObject *Sender)
{
	file_rec *cfp = cre_new_file_rec(GetCurFrecPtr(true));

	try {
		if (CurStt->is_Arc || CurStt->is_ADS || CurStt->is_FTP) UserAbort(USTR_CantOperate);

		std::unique_ptr<TStringList> tsk_lst(new TStringList());
		UnicodeString cmd = "DCOMP";
		TStringList *lst = GetCurList(true);
		//選択あり
		if (GetSelCount(lst)>0) {
			for (int i=0; i<lst->Count; i++) {
				file_rec *fp = (file_rec*)lst->Objects[i]; 
				if (!fp->is_dir || !fp->selected) continue;
				tsk_lst->Add(cmd + "\t" + fp->f_name);
				fp->selected = false;
			}
			RepaintList(CurListTag);
		}
		//カーソル位置
		else {
			if (cfp->f_name.IsEmpty() || cfp->is_dummy || !cfp->is_dir)  Abort();
			tsk_lst->Add(cmd + "\t" + cfp->f_name);
		}

		//タスク開始
		if (tsk_lst->Count>0) {
			TaskConfig  *cp = NULL;
			TTaskThread *tp = CreTaskThread(&cp);	if (cp==NULL) Abort();
			cp->TaskList->Assign(tsk_lst.get());
			cp->DirComp_sw	   = !TEST_ActParam("UN");
			cp->DirComp_ext_sw = !TEST_ActParam("AL");
			cp->CmdStr	 = TaskCmdList->Values[cmd];
			cp->DistPath = GetCurPathStr();
			cp->InfStr	 = cp->DistPath;
			ActivateTask(tp, cp);
		}
	}
	catch (EAbort &e) {
		SetActionAbort(e.Message);
	}

	del_file_rec(cfp);
}

//---------------------------------------------------------------------------
//コンテキストメニュー
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ContextMenuActionExecute(TObject *Sender)
{
	try {
		if (CurStt->is_Arc || CurStt->is_ADS || CurStt->is_Find || CurStt->is_FTP) Abort();
		UnicodeString dnam = CurPath[CurListTag];

		std::unique_ptr<TStringList> ex_item(new TStringList());
		bool ins_ren = true;

		//対象リストを作成
		std::unique_ptr<TStringList> flst(new TStringList());
		GetSelList(GetCurList(), flst.get(), false);

		//ワークリストでは対象が一つの場合のみ対応
		if (flst->Count>1 && CurStt->is_Work) Abort();

		if (flst->Count==0) {
			if (!R_Clicked || RClickAtCur) {
				file_rec *cfp = GetCurFrecPtr(true, true);
				if (cfp && !cfp->is_up && !cfp->is_dummy) {
					flst->Add(cfp->n_name);
					if (CurStt->is_Work) dnam = cfp->p_name;
				}
			}
			//有効なカーソル項目上でなければカレントを対象に
			if (flst->Count==0 && !CurStt->is_Work) {
				flst->Add(get_dir_name(dnam));
				dnam = get_parent_path(dnam);
				ins_ren = false;
			}
		}
		if (flst->Count==0) Abort();

		//追加項目
		if (!ActionParam.IsEmpty()) {
			if (!load_MenuFile(ActionParam, ex_item.get())) UserAbort(USTR_FileNotOpen);
			if (ex_item->Count>0 && !USAME_TS(ex_item->Strings[0], "!")) ex_item->Insert(0, "-");
		}
		if (ins_ren) ex_item->Insert(0, "名前の変更(&M)\tRenameDlg");

		//メニューを表示
		if (!R_Clicked) Mouse->CursorPos = CurListItemPos();
		R_Clicked = false;
		SetCurrentDir(dnam);

		ClearKeyBuff(true);
		UnicodeString res_str = usr_SH->ShowContextMenu(Handle, dnam, flst.get(), ex_item.get());
		TStringDynArray m_buf = split_strings_tab(res_str);
		if (m_buf.Length>1 && !ExeCommandsCore(m_buf[1])) GlobalAbort();
	}
	catch (EAbort &e) {
		SetActionAbort(e.Message);
	}

	ActionOptStr = EmptyStr;
	SetCurrentDir(CurPath[CurListTag]);
}

//---------------------------------------------------------------------------
//ディレクトリのコピー
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::CopyDirActionExecute(TObject *Sender)
{
	file_rec *cfp = cre_new_file_rec(GetCurFrecPtr(true));

	try {
		TStringList *lst = GetCurList(true);
		int sel_cnt = GetSelCount(lst);
		if (sel_cnt==0 && (cfp->f_name.IsEmpty() || cfp->is_dummy)) Abort();

		if (!IsCurFList())		UserAbort(USTR_CantOperate);
		if (!TestCurIncDir())	UserAbort(USTR_NoObject);

		bool is_to = false;
		UnicodeString dst_dir = GetDistDir(false, &is_to);
		if (!is_to && !IsOppFList())		UserAbort(USTR_CantOperate);
		if (is_drive_protected(dst_dir))	SysErrAbort(ERROR_WRITE_PROTECT);

		//クリップボードにディレクトリ名をコピー
		if (TEST_ActParam("CC") || TEST_ActParam("LS")) {
			CurWorking = true;
			ShowMessageHint(USTR_WaitForReady, col_bgHint, false, true);
			//対象ディレクトリの取得
			std::unique_ptr<TStringList> d_lst(new TStringList());
			if (sel_cnt>0) {
				for (int i=0; i<lst->Count; i++) {
					file_rec *fp = (file_rec*)lst->Objects[i];
					if (!fp->selected || !fp->is_dir) continue;
					d_lst->Add(fp->f_name);
					fp->selected = false;
				}
				RepaintList(CurListTag);
			}
			else d_lst->Add(cfp->f_name);
			//サブディレクトリ検索
			std::unique_ptr<TStringList> sbuf(new TStringList());
			for (int i=0; i<d_lst->Count; i++) {
				sbuf->Add(d_lst->Strings[i]);
				get_SubDirs(d_lst->Strings[i], sbuf.get());
			}
			sbuf->Sort();
			CurWorking = false;
			//コピー/一覧表示/ファイル出力
			ClipSaveList(sbuf.get(), _T("ディレクトリ名一覧"));
			SkipAbort();
		}

		//通常コピー
		bool sure_copy = (ExeCmdsBusy && XCMD_MsgOff)? false : SureCopy;
		std::unique_ptr<TStringList> tsk_lst(new TStringList());
		UnicodeString cmd = "CPYDIR";
		UnicodeString tprm;
		//選択項目
		if (sel_cnt>0) {
			if (!msgbox_Sure(LoadUsrMsg(USTR_CopyQ, USTR_SelectedItem), sure_copy)) SkipAbort();
			for (int i=0; i<lst->Count; i++) {
				file_rec *fp = (file_rec*)lst->Objects[i];
				if (!fp->selected || !fp->is_dir) continue;
				tsk_lst->Add(tprm.sprintf(_T("%s\t%s\t%s"), cmd.c_str(), fp->f_name.c_str(), dst_dir.c_str()));
				fp->selected = false;
			}
			RepaintList(CurListTag);
		}
		//カーソル位置
		else {
			if (!msgbox_Sure(LoadUsrMsg(USTR_CopyQ, get_DispName(cfp)), sure_copy)) SkipAbort();
			tsk_lst->Add(tprm.sprintf(_T("%s\t%s\t%s"), cmd.c_str(), cfp->f_name.c_str(), dst_dir.c_str()));
		}

		//タスク開始
		if (tsk_lst->Count>0) {
			TaskConfig  *cp = NULL;
			TTaskThread *tp = CreTaskThread(&cp);	if (!cp) Abort();
			cp->TaskList->Assign(tsk_lst.get());
			cp->KeepTime = TEST_ActParam("KT");
			cp->CmdStr	 = TaskCmdList->Values[cmd];
			cp->DistPath = dst_dir;
			cp->InfStr.sprintf(_T("%s ---> %s"), GetCurPathStr().c_str(), dst_dir.c_str());
			ActivateTask(tp, cp);
		}
	}
	catch (EAbort &e) {
		SetActionAbort(e.Message);
	}

	del_file_rec(cfp);
}

//---------------------------------------------------------------------------
//ファイル情報のコピー
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::CopyFileInfoActionExecute(TObject *Sender)
{
	try {
		if (isViewClip) {
			if (!ImgSidePanel->Visible) Abort();
			copy_to_Clipboard(ImgInfListBox->Items->Text);
		}
		else {
			file_rec *fp = GetCurFrecPtr(false, true);  if (!fp) Abort();
			if (fp->inf_list->Count==0) {
				ViewFileInf(fp, true);
				GetFileInfList(fp, true);
				if (fp->inf_list->Text.IsEmpty()) Abort();
			}
			copy_to_Clipboard(fp->inf_list->Text);
			InfListBox->ClearSelection();
		}
	}
	catch (EAbort &e) {
		SetActionAbort(e.Message);
	}
}

//---------------------------------------------------------------------------
//コピー/一覧表示用のファイル名を取得
//---------------------------------------------------------------------------
UnicodeString __fastcall TNyanFiForm::GetCopyFileNames(
	UnicodeString fmt,	//書式
	bool all_files,		//すべてのファイル	(default = false)
	file_rec *cfp,		//特定項目を指定	(default = NULL)
	TStringList *r_lst)	//リスト			(default = NULL)
{
	CurWorking = true;
	BeginWorkProgress(_T("ファイル名などの取得"), EmptyStr, FileListBox[CurListTag]);
	int start_cnt = GetTickCount();

	std::unique_ptr<TStringList> c_lst(new TStringList());
	TStringList *lst = GetCurList();
	//すべてのファイル
	if (all_files) {
		for (int i=0; i<lst->Count; i++) {
			file_rec *fp = (file_rec*)lst->Objects[i];
			if (!fp->is_dummy && !fp->is_dir) c_lst->AddObject(fp->f_name, (TObject*)fp);
		}
	}
	//特定のファイル
	else if (cfp) {
		c_lst->AddObject(cfp->f_name, (TObject*)cfp);
	}
	//選択中かカーソル位置
	else {
		//選択中
		GetSelList(lst, c_lst.get(), true, true);
		//カーソル位置
		if (c_lst->Count==0) {
			TListBox *lp = FileListBox[CurListTag];
			int idx = lp->ItemIndex;
			if (idx!=-1) {
				file_rec *fp = (file_rec*)lst->Objects[lp->ItemIndex];
				c_lst->AddObject(fp->f_name, (TObject*)fp);
			}
		}
	}

	bool is_spc = ContainsStr(fmt, "$L");				//空白区切り
	bool is_qut = is_spc;								//引用符で囲む
	bool is_fmt = !ContainsStr(fmt, "$X") && !is_spc;	//整形
	bool is_esc = ContainsStr(fmt, "$\\");				//\をエスケープ

	//各最大幅を取得
	int w_p = 0, w_u = 0, w_m = 0, w_f = 0, w_b = 0, w_n = 0, w_e = 0;
	if (is_fmt) {
		for (int i=0; i<c_lst->Count; i++) {
			file_rec *fp = (file_rec*)c_lst->Objects[i];
			if (fp->is_up) {
				UnicodeString pnam = get_parent_path(fp->p_name);
				UnicodeString fnam = ExcludeTrailingPathDelimiter(fp->p_name);
				max_len_half(w_p, pnam);
				max_len_half(w_u, NetDriveName_to_UNC(pnam));
				max_len_half(w_m, UNC_to_NetDriveName(pnam));
				max_len_half(w_b, ExtractFileName(fnam));
				max_len_half(w_n, ExtractFileName(fnam));
				max_len_half(w_f, fnam);
			}
			else {
				max_len_half(w_p, fp->p_name);
				max_len_half(w_u, NetDriveName_to_UNC(fp->p_name));
				max_len_half(w_m, UNC_to_NetDriveName(fp->p_name));
				max_len_half(w_b, fp->n_name);
				max_len_half(w_e, fp->f_ext);
				max_len_half(w_n, fp->b_name);
				max_len_half(w_f, fp->f_name);
			}
		}
	}

	//コピー文字列の作成
	UnicodeString cpystr;
	for (int i=0; i<c_lst->Count; i++) {
		PosWorkProgress(i, c_lst->Count);

		file_rec *fp = (file_rec*)c_lst->Objects[i];

		//画像サイズ
		unsigned int i_wd = 0, i_hi = 0;
		if (!fp->is_dir && fp->f_attr!=faInvalid && contains_wd_i(fmt, _T("$W|$H")))
			get_img_size(fp->f_name, &i_wd, &i_hi);

		//書式文字列の展開
		UnicodeString rstr;
		UnicodeString fstr = fmt;
		while (!fstr.IsEmpty()) {
			WideChar c = split_top_wch(fstr);
			if (c=='$') {
				c = split_top_wch(fstr);
				UnicodeString fnam = fp->is_up? ExtractFileDir(fp->f_name)  : fp->f_name;
				UnicodeString pnam = fp->is_up? get_parent_path(fp->p_name) : fp->p_name;
				if (fp->is_ftp) {
					fnam = yen_to_slash(fnam);
					pnam = yen_to_slash(pnam);
				}
				UnicodeString s;
				int w_fmt = 0;

				switch (c) {
				case 'P': case 'U': case 'M': case 'F':	//パス名(+ファイル名)
					switch (c) {
					case 'P': s = pnam;						 w_fmt = w_p; break;
					case 'U': s = NetDriveName_to_UNC(pnam); w_fmt = w_u; break;
					case 'M': s = UNC_to_NetDriveName(pnam); w_fmt = w_m; break;
					case 'F': s = fnam;						 w_fmt = w_f; break;
					}
					if (is_esc) s = ReplaceStr(s, "\\", "\\\\");
					break;

				case 'B':	//パス無ファイル名
					s = ExtractFileName(fnam);
					w_fmt = w_b;
					break;
				case 'N':	//パス無ファイル名主部
					s = fp->is_up? ExtractFileName(fnam) : fp->b_name;
					w_fmt = w_n;
					break;
				case 'E':	//拡張子
					s = fp->is_dir? UnicodeString(" ") : fp->f_ext;
					w_fmt = w_e;
					break;
				case '$':
					s = "$";
					break;

				case 'A':	//属性
					if (fp->f_attr==faInvalid) break;
					s.sprintf(_T("%s%s"), (fp->is_dir? _T("D") : _T("_")), fp->attr_str.c_str());
					break;
				case 'S':	//サイズ
					if (fp->f_attr==faInvalid) break;
					s = get_FileSizeStr(fp->f_size, !is_fmt);
					break;
				case 'Y':	//バイトサイズ
					if (fp->f_attr==faInvalid) break;
					s.sprintf(_T("%llu"), fp->f_size);
					break;
				case 'T':	//タイムスタンプ
					if (fp->f_attr==faInvalid) break;
					s = FormatDateTime(TimeStampFmt, fp->f_time);
					break;
				case 'D':	//タイムスタンプ(書式指定)
					if (fp->f_attr==faInvalid) break;
					s = FormatDateTime(split_in_paren(fstr), fp->f_time);
					break;
				case 'W':	//画像サイズ
					if (fp->f_attr==faInvalid) break;
					if (i_wd>0) s.sprintf(_T("%u"), i_wd);
					break;
				case 'H':
					if (fp->f_attr==faInvalid) break;
					if (i_hi>0) s.sprintf(_T("%u"), i_hi);
					break;
				case 'R':	//プロパティ
					{
						UnicodeString titstr = split_in_paren(fstr);
						if (fp->f_attr==faInvalid) break;
						if (fp->inf_list->Count==0) GetFileInfList(fp, true);
						s = get_FileInfValue(fp, titstr);
					}
					break;
				case 'G':	//ハッシュ
					{
						UnicodeString idstr = split_in_paren(fstr);
						if (fp->is_dir || fp->f_attr==faInvalid) break;
						UnicodeString hash	= get_HashStr(fnam, idstr);
						if (hash.IsEmpty()) break;
						fp->hash =hash;
						if (fp->inf_list->Count==0) GetFileInfList(fp);
						s = hash;
					}
					break;
				}

				if (!s.IsEmpty()) rstr += (is_fmt && w_fmt>0)? align_l_str(s ,w_fmt) : s;
			}
			else rstr.cat_sprintf(_T("%c"), c);
		}

		rstr = TrimRight(rstr);
		if (is_qut) rstr = UnicodeString().sprintf(_T("\"%s\""), rstr.c_str());

		if (r_lst) {
			UnicodeString lbuf = rstr + "\t" + fp->f_name;
			if (fp->is_dir) lbuf = IncludeTrailingPathDelimiter(lbuf);
			r_lst->Add(lbuf);
		}

		if (i>0) cpystr.cat_sprintf(_T("%s"), is_spc? _T(" ") : _T("\r\n"));
		cpystr += rstr;
		fp->selected = false;
	}

	if (c_lst->Count>1 && !is_spc) cpystr += "\r\n";

	CurWorking = false;
	InvalidateFileList();
	SetDriveFileInfo(CurListTag);

	EndWorkProgress(EmptyStr, EmptyStr, ((GetTickCount() - start_cnt)<500)? 0 : 500);

	return cpystr;
}

//---------------------------------------------------------------------------
//ファイル名のコピー
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::CopyFileNameActionExecute(TObject *Sender)
{
	UnicodeString fmt;
	if		(ActionParam.IsEmpty())	fmt = "$F";
	else if (TEST_ActParam("FN"))	fmt = "$B";
	else							fmt = ActionParam;

	UnicodeString cpystr = GetCopyFileNames(fmt);
	if (!cpystr.IsEmpty()) {
		copy_to_Clipboard(cpystr);
		if (ContainsStr(fmt, "$O")) {
			UserModule->SaveTxtDlg->Title		  = LoadUsrMsg(USTR_SaveAs, _T("クリップボード内容"));
			UserModule->SaveTxtDlg->InitialDir	  = ExcludeTrailingPathDelimiter(SaveTxtPath);
			UserModule->SaveTxtDlg->EncodingIndex = SaveEncIndex;
			if (UserModule->SaveTxtDlg->Execute()) {
				SaveTxtPath  = ExtractFilePath(UserModule->SaveTxtDlg->FileName);
				SaveEncIndex = UserModule->SaveTxtDlg->EncodingIndex;

				std::unique_ptr<TStringList> fbuf(new TStringList());
				fbuf->Text = cpystr;

				if (!saveto_TextFile(UserModule->SaveTxtDlg->FileName, fbuf.get(), SaveEncIndex))
					msgbox_ERR(LoadUsrMsg(USTR_FaildSave));
			}
		}
	}
}

//---------------------------------------------------------------------------
//行数カウント
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::CountLinesActionExecute(TObject *Sender)
{
	try {
		if (CurStt->is_FTP)  UserAbort(USTR_CantOperate);
		if (TestCurIncDir()) UserAbort(USTR_IncludeDir);

		TStringList *lst = GetCurList(true);
		bool lst_sel = ListSelected(lst);
		if (!lst_sel && !GetCurFrecPtr()) Abort();

		CalcBusy = true;
		StartLog(_T("カウント開始"));
		SttWorkMsg(_T("行数をカウント中..."), CalcTag);

		ShowMessageHint(USTR_CalculatingESC, col_bgHint, false, true);
		std::unique_ptr<TStringList> f_buf(new TStringList());
		std::unique_ptr<TStringList> r_lst(new TStringList());
		UnicodeString msg;
		int total_f_cnt = 0, total_l_cnt = 0, total_s_cnt = 0, total_r_cnt = -1, total_b_cnt = 0;
		int er_cnt	= 0;
		int cur_idx = FileListBox[CurListTag]->ItemIndex;

		for (int i=0; i<lst->Count && !CalcAborted; i++) {
			Application->ProcessMessages();
			file_rec *fp = (file_rec*)lst->Objects[i];
			if (fp->selected || (!lst_sel && i==cur_idx)) {
				UnicodeString fnam;
				if (fp->is_virtual) {
					if (SetTmpFile(fp)) fnam = fp->tmp_name;
				}
				else {
					fnam = fp->f_name;
				}

				int code_page = 0;
				if (!fnam.IsEmpty() && is_TextFile(fnam, &code_page))
					code_page = load_text_ex(fnam, f_buf.get(), code_page);

				if (code_page!=0) {
					int r_cnt, b_cnt;
					int l_cnt = CountListLines(f_buf.get(), fp->f_name, &r_cnt, &b_cnt);
					bool has_rem = (r_cnt!=-1);	//コメント有
					int s_cnt = l_cnt - (has_rem? r_cnt + b_cnt : b_cnt);
					r_lst->Add(msg.sprintf(_T("%s\t%s%s%s%s"), fp->n_name.c_str(),
								get_size_str_B(l_cnt, 10).c_str(), get_size_str_B(s_cnt, 10).c_str(),
								(has_rem? get_size_str_B(r_cnt, 10) : UnicodeString("       ---")).c_str(),
								get_size_str_B(b_cnt, 10).c_str()));
					total_l_cnt += l_cnt;
					total_s_cnt += s_cnt;
					if (has_rem) {
						if (total_r_cnt==-1) total_r_cnt = 0;
						total_r_cnt += r_cnt;
					}
					total_b_cnt += b_cnt;
					fp->selected = false;
				}
				else {
					r_lst->Add(msg.sprintf(_T("%s\t ERROR"), fp->n_name.c_str()));
					er_cnt++;
				}

				total_f_cnt++;
				InvalidateFileList();
			}
		}
		RepaintList(CurListTag);
		CalcBusy = false;
		if (CalcAborted) SttBarWarnUstr(USTR_Canceled);

		//整形
		int max_len = format_res_list(r_lst.get());
		//合計
		UnicodeString hr_str = make_RuledLine(5, max_len, 9, 9, 9, 9);
		r_lst->Add(hr_str);
		msg.sprintf(_T("%-*s%8u%s%s%s%s"), max_len - 10, _T("合計"), total_f_cnt,
			get_size_str_B(total_l_cnt, 10).c_str(), get_size_str_B(total_s_cnt, 10).c_str(),
			((total_r_cnt!=-1)? get_size_str_B(total_r_cnt, 10) : UnicodeString("       ---")).c_str(),
			get_size_str_B(total_b_cnt, 10).c_str());
		if (er_cnt>0) msg.cat_sprintf(_T("  ERR:%u"), er_cnt);
		r_lst->Add(msg);
		//比率
		if (total_l_cnt>0) {
			msg.sprintf(_T("%-*s %8.1f%% "), max_len + 8, _T("比率"), 100.0*total_s_cnt/total_l_cnt);
			if (total_r_cnt!=-1)
				msg.cat_sprintf(_T("%8.1f%%"), 100.0*total_r_cnt/total_l_cnt);
			else
				msg += "      ---";
			msg.cat_sprintf(_T("%9.1f%%"), 100.0*total_b_cnt/total_l_cnt);
			r_lst->Add(msg);
		}
		//ヘッダ
		r_lst->Insert(0, hr_str);
		r_lst->Insert(0, msg.sprintf(_T("ファイル名%*s     行数      有効  コメント      空白"), max_len - 9, _T(" ")));
		r_lst->Insert(0, CurPath[CurListTag]);
		//ログ出力
		AddLogStrings(r_lst.get());
		AddLog(CalcAborted? _T("カウント中断") : _T("カウント終了"), true);
		AddLogCr();
		//コピー/一覧表示/ファイル出力
		ClipSaveList(r_lst.get(), _T("行数カウント"));

		if (!CalcAborted) SttWorkMsg(EmptyStr, CalcTag);
	}
	catch (EAbort &e) {
		SetActionAbort(e.Message);
	}
}

//---------------------------------------------------------------------------
//ディレクトリの作成
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::CreateDirActionExecute(TObject *Sender)
{
	try {
		if (USAME_TI(ActionOptStr, "Force")) {
			ActionOptStr = EmptyStr;
		}
		else {
			if (CurStt->is_Arc) UserAbort(USTR_OpeNotSuported);
			if (CurStt->is_ADS || CurStt->is_Work) UserAbort(USTR_CantOperate);
			if (CurStt->is_Find) Abort();
		}

		bool do_cd = CreDirChg;	//作成後カレント変更
		UnicodeString inpstr, inpstr2;
		//入力指定
		if (ActionParam.IsEmpty() || TEST_DEL_ActParam("IN")) {
			InputExDlg->IpuntExMode = INPEX_CRE_DIR;
			InputExDlg->InputComboBox->Text = FormatParam(ActionParam);
			XCMD_ModalResult = InputExDlg->ShowModal();
			if (XCMD_ModalResult!=mrOk) SkipAbort();
			inpstr = InputExDlg->InputComboBox->Text;
			do_cd  = remove_top_s(inpstr, '/')? false :
					 (remove_end_s(inpstr, '/') || remove_end_s(inpstr, '\\'))? true : CreDirChg;
		}
		//パラメータ指定
		else {
			if (remove_top_s(ActionParam, '/')) do_cd = false;
			if (remove_end_s(ActionParam, '/') || remove_end_text(ActionParam, "\\")) do_cd = true;
			inpstr2 = FormatParam(get_tkn_r(ActionParam, _T("\\-")));
			inpstr	= FormatParam(get_tkn(ActionParam, _T("\\-")));
		}
		inpstr  = Trim(inpstr);
		inpstr2 = Trim(inpstr2);
		if (ReplaceStr(inpstr + inpstr2, "\\", "").IsEmpty()) SkipAbort();

		if (!inpstr.IsEmpty() || !inpstr2.IsEmpty()) {
			//禁止文字／ユーザ定義文字の変換
			if (CreDirCnvChar && !inpstr.IsEmpty()) {
				for (int i=0; i<CnvCharList->Count; i++) {
					UnicodeString sch = CnvCharList->Names[i];	if (sch.IsEmpty()) continue;
					inpstr = ReplaceStr(inpstr, sch, CnvCharList->ValueFromIndex[i]);
				}
			}
			inpstr += inpstr2;

			UnicodeString msg;
			//FTP
			if (CurStt->is_FTP) {
				UnicodeString dnam = inpstr;
				if (!IdFTP1->Connected()) { RecoverFileList();  Abort(); }
				StartLog(_T("作成開始"));
				msg = make_CreateLog(dnam);
				try {
					IdFTP1->MakeDir(dnam);
					add_FTPLogMsg(msg);
					//ディレクトリ変更
					if (do_cd) IdFTP1->ChangeDir(dnam);
				}
				catch (...) {
					msg[1] = 'E';
					add_FTPLogMsg(msg);
				}
				if (!ChangeFtpFileList()) GlobalAbort();
			}
			//その他
			else {
				bool has_drv = !ExtractFileDrive(inpstr).IsEmpty();
				UnicodeString dnam = to_absolute_name(inpstr, CurPath[CurListTag]);
				if (has_drv) {
					StartLog(_T("作成開始"));
					msg = make_CreateLog(dnam);
				}
				else {
					StartLog(msg.sprintf(_T("作成開始  %s"), CurPath[CurListTag].c_str()));
					msg = contains_PathDlmtr(inpstr)? make_CreateLog(inpstr) : make_LogHdr(_T("CREATE"), dnam, true);
				}
				SetLastError(NO_ERROR);
				if		(dir_exists(dnam)) msg[1] = 'S';
				else if (!create_ForceDirs(dnam)) set_LogErrMsg(msg);
				AddLog(msg);
				if (msg[1]=='E') throw EAbort(LoadUsrMsg(USTR_CantCreDir, inpstr));
				ReloadList(CurListTag, dnam); 
				if (EqualDirLR()) ReloadList(OppListTag);
				if (do_cd) CurPath[CurListTag] = IncludeTrailingPathDelimiter(dnam);
			}
			EndLog(_T("作成"));
		}
	}
	catch (EAbort &e) {
		SetActionAbort(e.Message);
	}
	catch (...) {
		SetInternalException();
	}
}
//---------------------------------------------------------------------------
//ディレクトリ一括作成ダイアログ
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::CreateDirsDlgActionExecute(TObject *Sender)
{
	if (!IsCurFList()) {
		SetActionAbort(USTR_CantOperate); return;
	}

	if (!CreateDirsDlg) CreateDirsDlg = new TCreateDirsDlg(this);	//初回に動的作成
	if (CreateDirsDlg->ShowModal()==mrOk) {
		cursor_HourGlass();
		StartLog(_T("作成開始"));
		TStrings *lst = CreateDirsDlg->ListMemo->Lines;
		int ok_cnt = 0, er_cnt = 0;
		for (int i=0; i<lst->Count; i++) {
			UnicodeString dnam = lst->Strings[i];
			if (ExtractFileName(dnam).IsEmpty()) continue;
			bool has_drv = !ExtractFileDrive(dnam).IsEmpty();
			dnam = to_absolute_name(dnam, CurPath[CurListTag]);
			UnicodeString msg = make_CreateLog(dnam);
			if (has_drv || IsCurFList()) {
				SetLastError(NO_ERROR);
				if		(dir_exists(dnam)) msg[1] = 'S';
				else if (!create_ForceDirs(dnam)) set_LogErrMsg(msg);
			}
			else set_LogErrMsg(msg, LoadUsrMsg(USTR_CantOperate));
			AddLog(msg);
			((msg[1]=='E')? er_cnt : ok_cnt)++;
		}
		EndLog(_T("作成"), get_res_cnt_str(ok_cnt, er_cnt));
		cursor_Default();
	}
}

//---------------------------------------------------------------------------
//ハードリンクの作成
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::CreateHardLinkActionExecute(TObject *Sender)
{
	try {
		NotConvertAbort();
		if (EqualDirLR()) UserAbort(USTR_SameDirLR);

		UnicodeString fs;
		if (!SameText(get_VolumeInfo(CurPath[CurListTag], &fs), get_VolumeInfo(CurPath[OppListTag]))
			|| !SameText(fs, "NTFS"))
				UserAbort(USTR_CantOperate);

		TStringList *lst = GetCurList();
		bool lst_sel = ListSelected(lst);
		if (!lst_sel && !GetCurFrecPtr()) Abort();

		CurWorking = true;
		UnicodeString dst_dir = GetCurPathStr(OppListTag);
		UnicodeString msg;
		StartLog(msg.sprintf(_T("ハードリンク作成開始  %s\t%s"), GetSrcPathStr().c_str(), dst_dir.c_str()));

		bool ow_all = (xCopyMode==0);	//すべて上書き
		bool sk_all = (xCopyMode==2);	//すべてスキップ
		xCopyMode	= -1;

		int ok_cnt = 0, er_cnt = 0, sk_cnt = 0;
		int cur_idx = FileListBox[CurListTag]->ItemIndex;
		for (int i=0; i<lst->Count; i++) {
			file_rec *fp = (file_rec*)lst->Objects[i];
			if ((fp->selected || (!lst_sel && i==cur_idx)) && fp->f_attr!=faInvalid) {
				msg.sprintf(_T("  CREATE %s"), fp->n_name.c_str());
				UnicodeString lnam = dst_dir + fp->n_name;
				//同名処理
				if (file_exists(lnam)) {
					if (SameText(fp->p_name, dst_dir)) {
						set_LogErrMsg(msg, "同名のハードリンクは作れません。");
					}
					else if (!ow_all && !sk_all) {
						bool all_checked = false;
						int res = msgbox_SureAll(
									UnicodeString().sprintf(_T("同名ファイル [%s] があります。\n削除して置き換えますか?"),
									fp->n_name.c_str()),
									all_checked);
						if (res==mrCancel) SkipAbort();
						if (res==mrYes) {
							if (!delete_File(lnam, DelUseTrash)) set_LogErrMsg(msg);
							msg[1] = 'O';
							ow_all = all_checked;
						}
						else {
							msg[1] = 'S';
							sk_all = all_checked;
						}
					}
					else {
						if (ow_all) {
							if (!delete_File(lnam, DelUseTrash)) set_LogErrMsg(msg);
							msg[1] = 'O';
						}
						else if (sk_all) {
							msg[1] = 'S';
						}
					}
				}
				//ハードリンク作成
				if (msg[1]!='E' && msg[1]!='S') {
					if (::CreateHardLink((dst_dir + fp->n_name).c_str(), fp->f_name.c_str(), NULL)) {
						fp->selected = false;
						InvalidateFileList();
					}
					else set_LogErrMsg(msg);
				}

				((msg[1]=='E')? er_cnt : (msg[1]=='S')? sk_cnt : ok_cnt)++;
				AddLog(msg);
			}
		}
		CurWorking = false;
		ReloadList();
		EndLog(_T("作成"), get_res_cnt_str(ok_cnt, er_cnt, sk_cnt));
		if (er_cnt>0) UserAbort(USTR_FaildProc);
	}
	catch (EAbort &e) {
		SetActionAbort(e.Message);
	}
}

//---------------------------------------------------------------------------
//シンボリック/ジャンクションの作成
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::CreateLinkCore(UnicodeString lnk_type)
{
	try {
		if (SameText(lnk_type, "SYM") && !IsAdmin) TextAbort(_T("管理者権限が必要です。"));
		if (CurStt->is_Arc || CurStt->is_ADS || CurStt->is_FTP || !IsOppFList()) UserAbort(USTR_CantOperate);
		if (EqualDirLR()) UserAbort(USTR_SameDirLR);
		if (SameText(lnk_type, "JNC") && TestCurIncNotDir()) UserAbort(USTR_CantOperate);

		UnicodeString fs;
		get_VolumeInfo(CurPath[OppListTag], &fs);
		if (!SameText(fs, "NTFS")) UserAbort(USTR_CantOperate);

		TStringList *lst = GetCurList();
		bool lst_sel = ListSelected(lst);
		if (!lst_sel && !GetCurFrecPtr()) Abort();

		CurWorking = true;
		UnicodeString dst_dir = GetCurPathStr(OppListTag);
		UnicodeString msg = SameText(lnk_type, "SYM")? "シンボリックリンク" : "ジャンクション";
		StartLog(msg.cat_sprintf(_T("作成開始  %s\t%s"), GetSrcPathStr().c_str(), dst_dir.c_str()));

		int ok_cnt = 0, er_cnt = 0;
		int cur_idx = FileListBox[CurListTag]->ItemIndex;
		for (int i=0; i<lst->Count; i++) {
			file_rec *fp = (file_rec*)lst->Objects[i];
			if ((fp->selected || (!lst_sel && i==cur_idx)) && fp->f_attr!=faInvalid) {
				msg.sprintf(_T("  CREATE %s"), fp->n_name.c_str());
				UnicodeString lnam = dst_dir + fp->n_name;
				bool res = SameText(lnk_type, "SYM")?
								(::CreateSymbolicLinkW(lnam.c_str(), fp->f_name.c_str(), fp->is_dir? 1 : 0)!=0) :
								cre_Junction(lnam, fp->f_name);
				if (res) {
					fp->selected = false;
					InvalidateFileList();
				}
				else set_LogErrMsg(msg);

				((msg[1]=='E')? er_cnt : ok_cnt)++;
				AddLog(msg);
			}
		}
		CurWorking = false;
		ReloadList();
		EndLog(_T("作成"), get_res_cnt_str(ok_cnt, er_cnt));
		if (er_cnt>0) UserAbort(USTR_FaildProc);
	}
	catch (EAbort &e) {
		SetActionAbort(e.Message);
	}
}

//---------------------------------------------------------------------------
//ジャンクションの作成
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::CreateJunctionActionExecute(TObject *Sender)
{
	CreateLinkCore("JNC");
}
//---------------------------------------------------------------------------
//シンボリックリンクの作成
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::CreateSymLinkActionExecute(TObject *Sender)
{
	CreateLinkCore("SYM");
}

//---------------------------------------------------------------------------
//ショートカットの作成
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::CreateShortcutActionExecute(TObject *Sender)
{
	try {
		if (CurStt->is_Arc || CurStt->is_ADS || CurStt->is_FTP || !IsOppFList()) UserAbort(USTR_CantOperate);

		CurWorking = true;
		UnicodeString dst_dir = GetCurPathStr(OppListTag);
		UnicodeString msg;
		StartLog(msg.sprintf(_T("ショートカット作成開始  %s\t%s"), GetSrcPathStr().c_str(), dst_dir.c_str()));
		int ok_cnt = 0, er_cnt = 0;

		TStringList *lst = GetCurList();
		bool lst_sel = ListSelected(lst);
		if (!lst_sel && !GetCurFrecPtr()) Abort();

		int cur_idx = FileListBox[CurListTag]->ItemIndex;
		for (int i=0; i<lst->Count; i++) {
			file_rec *fp = (file_rec*)lst->Objects[i];
			if ((fp->selected || (!lst_sel && i==cur_idx)) && fp->f_attr!=faInvalid) {
				msg = "  CREATE ";
				UnicodeString lnam = dst_dir + ChangeFileExt(fp->n_name, ".lnk");
				msg += ExtractFileName(lnam);
				if (usr_SH->CreateShortCut(lnam, fp->f_name)) {
					fp->selected = false;
					InvalidateFileList();
				}
				else {
					set_LogErrMsg(msg);
				}
				((msg[1]=='E')? er_cnt : ok_cnt)++;
				AddLog(msg);
			}
		}
		CurWorking = false;

		ReloadList(OppListTag);
		EndLog(_T("作成"), get_res_cnt_str(ok_cnt, er_cnt));
		if (er_cnt>0) UserAbort(USTR_FaildProc);
	}
	catch (EAbort &e) {
		SetActionAbort(e.Message);
	}
}

//---------------------------------------------------------------------------
//テストファイルの作成
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::CreateTestFileActionExecute(TObject *Sender)
{
	try {
		if (!IsCurFList()) UserAbort(USTR_CantOperate);

		InputExDlg->IpuntExMode = INPEX_CRE_TESTFILE;
		InputExDlg->InputEdit->EditLabel->Caption = "ファイル名";
		if (InputExDlg->ShowModal()!=mrOk || InputExDlg->InputEdit->Text.IsEmpty()) SkipAbort();

		//ファイル名
		UnicodeString fnam = InputExDlg->InputEdit->Text;
		UnicodeString fext = get_extension(fnam);
		UnicodeString bnam = ChangeFileExt(fnam, EmptyStr);
		//サイズ
		UnicodeString sbuf = InputExDlg->TestSizeEdit->Text;
		__int64 k = 1;
		if		(remove_end_text(sbuf, "K")) k = 1024;
		else if (remove_end_text(sbuf, "M")) k = 1024 * 1024;
		else if (remove_end_text(sbuf, "G")) k = 1024 * 1024 * 1024;
		__int64 sz = StrToInt64Def(sbuf, 0) * k;
		if (sz<=0) UserAbort(USTR_IllegalParam);
		//個数
		int cnt = InputExDlg->TestCntEdit->Text.ToIntDef(1);
		int nwd = InputExDlg->TestCntEdit->Text.Length();

		CurWorking = true;
		UnicodeString dnam = CurPath[CurListTag];
		UnicodeString msg, prm;
		StartLog(msg.sprintf(_T("テストファイル作成開始  %s"), dnam.c_str()));
		int ok_cnt = 0, er_cnt = 0;
		for (int i=0; i<cnt; i++) {
			UnicodeString tnam;
			if (cnt>1)
				tnam.cat_sprintf(_T("%s%0*u%s"), bnam.c_str(), nwd, i+1, fext.c_str());
			else
				tnam = bnam + fext;
			msg = make_LogHdr(_T("CREATE"), tnam);
			prm.sprintf(_T("file createnew %s %llu"), tnam.c_str(), sz);
			DWORD exit_code;
			if (!Execute_ex("fsutil", prm, dnam, "HW", &exit_code) && exit_code!=0) msg[1] = 'E';
			((msg[1]=='E')? er_cnt : ok_cnt)++;
			AddLog(msg);
		}
		CurWorking = false;

		ReloadList();
		EndLog(_T("作成"), get_res_cnt_str(ok_cnt, er_cnt));
		if (er_cnt>0) UserAbort(USTR_FaildProc);
	}
	catch (EAbort &e) {
		SetActionAbort(e.Message);
	}
}

//---------------------------------------------------------------------------
//カーソル位置のディレクトリを反対側に開く
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::CsrDirToOppActionExecute(TObject *Sender)
{
	try {
		if (CurStt->is_FTP) UserAbort(USTR_CantOperate);
		file_rec *cfp = GetCurFrecPtr(true, true);
		if (!cfp || cfp->f_attr==faInvalid) Abort();

		//axshell.spi 用 ._sf
		if (test_FileExt(cfp->f_ext, _T("._sf"))) {
			UnicodeString dnam = get_PathFrom_SF(cfp);
			if (ExtractFileDrive(dnam).IsEmpty()) Abort();
			UpdateOppPath(dnam);
			//反対側へ
			if (TEST_ActParam("TO")) ToOppositeAction->Execute();
			SkipAbort();
		}

		if (CurStt->is_Arc) UserAbort(USTR_CantOperate);

		//ディレクトリ
	 	if (cfp->is_dir) {
			UpdateOppPath(cfp->is_up? get_parent_path(CurPath[CurListTag]) : IncludeTrailingPathDelimiter(cfp->f_name));
		}
		//アーカイブ
		else if (test_ArcExt2(cfp->f_ext)) {
			if (cfp->f_name.Length()>=MAX_PATH) SysErrAbort(ERROR_BUFFER_OVERFLOW);
			if (OppStt->is_Find || OppStt->is_Work) RecoverFileList();	//結果リスト/ワークリストから抜ける
			if (!is_AvailableArc(cfp->f_name)) UserAbort(USTR_FmtNotSuported);
			OppStt->arc_Name	= cfp->f_name;
			OppStt->arc_SubPath = EmptyStr;
			OppStt->arc_DspPath = IncludeTrailingPathDelimiter(cfp->n_name);
			if (UpdateTempArcList(OppListTag).IsEmpty()) UserAbort(USTR_CantMakeTmpDir);
			SelMaskList[OppListTag]->Clear();
			if (!ChangeArcFileListEx(OppStt->arc_Name, OppStt->arc_SubPath, OppListTag)) {
				InhReload++;
				UserAbort(USTR_ArcNotOpen);
			}
		}
		//ワークリスト
		else if (test_NwlExt(cfp->f_ext)) {
			SaveWorkListAction->Execute();
			if		(CurStt->is_Work) RecoverFileList(); 
			else if (OppStt->is_Work) RecoverFileList(OppListTag);
			cursor_HourGlass();
			if (!load_WorkList(cfp->f_name)) UserAbort(USTR_WlistCantOpen);
			ChangeWorkList(OppListTag);
			cursor_Default();
		}
		//ライブラリ
		else if (test_LibExt(cfp->f_ext)) {
			if (!PopSelLibrary(cfp->f_name, OppListTag)) UserAbort(USTR_DirNotFound);
		}
		else Abort();

		//反対側へ
		if (TEST_ActParam("TO")) ToOppositeAction->Execute();
	}
	catch (EAbort &e) {
		SetActionAbort(e.Message);
	}
}

//---------------------------------------------------------------------------
//カレントを反対側のパスに
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::CurrFromOppActionExecute(TObject *Sender)
{
	if (OppStt->is_Find || OppStt->is_Work || OppStt->is_FTP) {
		SetActionAbort();
	}
	else {
		if (!IsCurFList()) RecoverFileList();

		if (!EqualDirLR()) {
			CurPath[CurListTag] = exclede_delimiter_if_root(CurPath[OppListTag]);
			CurStt->LibraryInfo = OppStt->LibraryInfo;
			CurStt->LibSubPath	= OppStt->LibSubPath;
			SetDirCaption(CurListTag);
			SetFileInf();
		}

		//選択状態の反映
		if (TEST_ActParam("SL")) {
			std::unique_ptr<TStringList> o_lst(new TStringList());
			GetSelList(GetOppList(), o_lst.get(), true, true);
			TStringList *c_lst = GetCurList(true);
			ClrSelect(c_lst);
			for (int i=0; i<o_lst->Count; i++) {
				file_rec *ofp = (file_rec*)o_lst->Objects[i];
				int idx = c_lst->IndexOf(ofp->f_name);
				if (idx!=-1) ((file_rec*)c_lst->Objects[idx])->selected = true;
			}
			InvalidateFileList();
		}
	}
}
//---------------------------------------------------------------------------
//反対側をカレントのパスに
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::CurrToOppActionExecute(TObject *Sender)
{
	if (CurStt->is_Arc || CurStt->is_ADS || CurStt->is_FTP || OppStt->is_Find) {
		SetActionAbort(); return;
	}

	if (OppStt->is_Arc || OppStt->is_ADS || OppStt->is_Work || OppStt->is_FTP) RecoverFileList(OppListTag);

	if (CurStt->is_Find || CurStt->is_Work) {
		file_rec *cfp = GetCurFrecPtr();
		if (cfp) {
			TListBox *lp = FileListBox[OppListTag];
			ApplyDotNyan = true;	//ディレクトリが変化しなくても強制的に .nyanfi を適用
			if (!cfp->is_dir || CurStt->find_DirLink) {
				if (cfp->is_virtual) {
					if (!JumpToList(OppListTag, cfp->f_name)) GlobalAbort();
				}
				else {
					if (!is_dir_accessible(cfp->p_name)) {
						SetActionAbort(); return;
					}

					UnicodeString pnam = exclede_delimiter_if_root(cfp->p_name);
					if (!SameText(CurPath[OppListTag], pnam)) CurPath[OppListTag] = pnam;
					IndexOfFileList(cfp->f_name, OppListTag);
				}
			}
			else {
				if (!is_dir_accessible(cfp->f_name)) {
					SetActionAbort(); return;
				}

				UnicodeString pnam = IncludeTrailingPathDelimiter(cfp->f_name);
				if (!SameText(CurPath[OppListTag], pnam)) CurPath[OppListTag] = pnam;
				lp->ItemIndex = 0;
			}
			lp->Invalidate();
		}
	}
	else {
		UpdateOppPath(CurPath[CurListTag]);
		OppStt->LibraryInfo = CurStt->LibraryInfo;
		OppStt->LibSubPath	= CurStt->LibSubPath;
		SetDirCaption(OppListTag);

		//選択状態の反映
		if (TEST_ActParam("SL")) {
			std::unique_ptr<TStringList> c_lst(new TStringList());
			GetSelList(GetCurList(true), c_lst.get(), true, true);
			TStringList *o_lst = GetOppList();
			ClrSelect(o_lst);
			for (int i=0; i<c_lst->Count; i++) {
				file_rec *cfp = (file_rec*)c_lst->Objects[i];
				int idx = o_lst->IndexOf(cfp->f_name);
				if (idx!=-1) ((file_rec*)o_lst->Objects[idx])->selected = true;
			}
			InvalidateFileList(OppListTag);
		}
	}

	SetCurTab(true);

	//反対側へ
	if (TEST_ActParam("TO")) ToOppositeAction->Execute();
}

//---------------------------------------------------------------------------
//カーソルを下に移動
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::CursorDownActionExecute(TObject *Sender)
{
	TListBox *lp = FileListBox[CurListTag];		if (lp->Count<2) return;
	if (LoopFilerCursor && lp->ItemIndex==lp->Count-1) {
		CursorTopAction->Execute();
	}
	else {
		int last_idx = lp->ItemIndex;
		ExeCmdListBox(lp, _T("CursorDown"), ActionParam);
		if (lp->ItemIndex!=last_idx) SetDriveFileInfo(CurListTag, false, false);
	}
}
//---------------------------------------------------------------------------
//選択しながらカーソルを下に移動
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::CursorDownSelActionExecute(TObject *Sender)
{
	TListBox *lp = FileListBox[CurListTag]; if (lp->ItemIndex==lp->Count-1) return;
	file_rec *fp = GetCurFrecPtr(); if (fp) fp->selected = true;
	CursorDownAction->Execute();
	fp = GetCurFrecPtr(); if (fp) fp->selected = true;
	lp->Selected[lp->ItemIndex] = !lp->Selected[lp->ItemIndex];	//表示更新のため
	SetDriveFileInfo(CurListTag, false);
}
//---------------------------------------------------------------------------
//カーソルを上に移動
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::CursorUpActionExecute(TObject *Sender)
{
	TListBox *lp = FileListBox[CurListTag];	if (lp->Count<2) return;
	if (LoopFilerCursor && lp->ItemIndex==0) {
		CursorEndAction->Execute();
	}
	else {
		int last_idx = lp->ItemIndex;
		ExeCmdListBox(lp, _T("CursorUp"), ActionParam);
		if (lp->ItemIndex!=last_idx) SetDriveFileInfo(CurListTag, false, false);
	}
}
//---------------------------------------------------------------------------
//選択しながらカーソルを上に移動
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::CursorUpSelActionExecute(TObject *Sender)
{
	TListBox *lp = FileListBox[CurListTag];	if (lp->ItemIndex<=0) return;
	file_rec *fp = GetCurFrecPtr(); if (fp) fp->selected = true;
	CursorUpAction->Execute();
	fp = GetCurFrecPtr(); if (fp) fp->selected = true;
	lp->Selected[lp->ItemIndex] = !lp->Selected[lp->ItemIndex];	//表示更新のため
	SetDriveFileInfo(CurListTag, false);
}

//---------------------------------------------------------------------------
//カーソルを最上行に移動
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::CursorTopActionExecute(TObject *Sender)
{
	TListBox *lp = FileListBox[CurListTag];
	if (lp->Count>1) {
		lp->ItemIndex = 0;
		lp->Invalidate();
		SetDriveFileInfo(CurListTag, false, false);
	}
}
//---------------------------------------------------------------------------
//選択しながらカーソルを最上行に移動
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::CursorTopSelActionExecute(TObject *Sender)
{
	TListBox    *lp  = FileListBox[CurListTag];
	TStringList *lst = GetCurList();
	for (int i=lp->ItemIndex; i>=0; i--) set_select((file_rec*)lst->Objects[i]);
	lp->ItemIndex = 0;
	lp->Invalidate();
	SetDriveFileInfo(CurListTag, false);
}

//---------------------------------------------------------------------------
//カーソルを最下行に移動
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::CursorEndActionExecute(TObject *Sender)
{
	TListBox *lp = FileListBox[CurListTag];
	if (lp->Count>1) {
		lp->ItemIndex = lp->Count - 1;
		lp->Invalidate();
		SetDriveFileInfo(CurListTag, false, false);
	}
}
//---------------------------------------------------------------------------
//選択しながらカーソルを最下行に移動
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::CursorEndSelActionExecute(TObject *Sender)
{
	TListBox    *lp  = FileListBox[CurListTag];
	TStringList *lst = GetCurList();
	for (int i=lp->ItemIndex; i<lp->Count; i++) set_select((file_rec*)lst->Objects[i]);
	lp->ItemIndex = lp->Count - 1;
	lp->Invalidate();
	SetDriveFileInfo(CurListTag, false);
}

//---------------------------------------------------------------------------
//日付条件にあうファイルを選択
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::DateSelectActionExecute(TObject *Sender)
{
	try {
		if (ActionParam.IsEmpty()) UserAbort(USTR_NoParameter);

		TDateTime dt;
		int cnd = get_DateCond(ActionParam, dt);
		if (cnd<=0) UserAbort(USTR_IllegalDtCond);

		//選択
		int s_idx = -1;
		TStringList *lst = GetCurList();
		for (int i=0; i<lst->Count; i++) {
			file_rec *fp = (file_rec*)lst->Objects[i];
			if (!is_selectable(fp)) continue;
			fp->selected = false;
			if (fp->is_dir) continue;
			//比較
			TValueRelationship res = System::Dateutils::CompareDate(fp->f_time, dt);
			switch (cnd) {
			case 1: fp->selected = (res==LessThanValue);	break;
			case 2: fp->selected = (res==EqualsValue);		break;
			case 3: fp->selected = (res==GreaterThanValue);	break;
			}
			if (s_idx==-1 && fp->selected) s_idx = i;
		}

		if (s_idx!=-1) FileListBox[CurListTag]->ItemIndex = s_idx;
		RepaintList(CurListTag);
	}
	catch (EAbort &e) {
		SetActionAbort(e.Message);
	}
}

//---------------------------------------------------------------------------
//コマンドファイルのデバッグ
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::DebugCmdFileActionExecute(TObject *Sender)
{
	try {
		UnicodeString fnam;
		if (!ActionParam.IsEmpty()) {
			remove_top_AT(ActionParam);
			fnam = to_absolute_name(exclude_quot(ActionParam));
		}
		else if (ScrMode==SCMD_FLIST) {
			file_rec *fp = GetCurFrecPtr(true);
			if (!fp || !test_NbtExt(fp->f_ext)) Abort();
			fnam = fp->f_name;
		}
		if (!file_exists(fnam)) SysErrAbort(ERROR_FILE_NOT_FOUND);

		if (!ExeCommandsCore("@" + fnam, EmptyStr, true)) GlobalAbort();
	}
	catch (EAbort &e) {
		SetActionAbort(e.Message);
	}
}

//---------------------------------------------------------------------------
//選択マスクから項目を削除
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::DelSelMaskActionExecute(TObject *Sender)
{
	if (!IsCurFList()) { SetActionAbort(USTR_OpeNotSuported); return; }

	TStringList *lst = GetCurList(true);
	if (GetSelCount(lst)==0) {
		TListBox *lp = FileListBox[CurListTag];
		lp->Perform(WM_SETREDRAW, 0, (NativeInt)0);
		set_select(GetFrecPtr(lp, lst));
		ListBoxCursorDown(lp);
		lp->Perform(WM_SETREDRAW, 1, (NativeInt)0);
	}
	for (int i=0; i<lst->Count; i++) set_select_r((file_rec*)lst->Objects[i]);

	SelMaskAction->Execute();
}

//---------------------------------------------------------------------------
//タグの削除
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::DelTagActionExecute(TObject *Sender)
{
	try {
		if (CurStt->is_Arc || CurStt->is_ADS || CurStt->is_FTP) UserAbort(USTR_CantOperate);

		usr_TAG->Recycle();
		SetTags(EmptyStr);
	}
	catch (EAbort &e) {
		SetActionAbort(e.Message);
	}
}

//---------------------------------------------------------------------------
//振り分けダイアログ
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::DistributionDlgActionExecute(TObject *Sender)
{
	try {
		if (CurStt->is_Arc || CurStt->is_ADS || CurStt->is_Work || CurStt->is_FTP) UserAbort(USTR_CantOperate);

		if (!DistributionDlg) DistributionDlg = new TDistributionDlg(this);	//初回に動的作成

		//対象を取得
		TStringList *lst = GetCurList(true);
		bool sel_sw = (GetSelCount(lst)>0);
		if (lst->Count>0) {
			std::unique_ptr<TStringList> src_lst(new TStringList());
			for (int i=0; i<lst->Count; i++) {
				file_rec *fp = (file_rec*)lst->Objects[i];
				if (fp->is_up || fp->is_dummy)	continue;
				if (sel_sw && !fp->selected)	continue;
				UnicodeString fnam = fp->f_name;
				if (fp->is_dir) fnam = IncludeTrailingPathDelimiter(fnam);
				src_lst->Add(fnam);
			}
			if (src_lst->Count==0) UserAbort(USTR_NoObject);
			DistributionDlg->ItemList->Assign(src_lst.get());
		}

		//直ちにコピー
		if (TEST_DEL_ActParam("XC"))	{
			DistributionDlg->ImmediateExe = true;
			DistributionDlg->IsMove 	  = false;
		}
		//直ちに移動
		else if (TEST_DEL_ActParam("XM"))	{
			DistributionDlg->ImmediateExe = true;
			DistributionDlg->IsMove 	  = true;
		}
		//カーソル位置のファイル名をマスク欄に、反対パスを振り分け先欄に設定
		else if (TEST_DEL_ActParam("SN"))	{
			DistributionDlg->TitleEdit->Text	 = EmptyStr;
			DistributionDlg->DistrMaskEdit->Text = ExtractFileName(GetCurFileName());
			DistributionDlg->DistrDirEdit->Text  = ReplaceStr(ExcludeTrailingPathDelimiter(CurPath[OppListTag]), "\\", "\\\\");
		}

		//振り分け登録ファイルの指定
		if (!ActionParam.IsEmpty()) {
			UnicodeString fnam = to_relative_name(ActionParam);
			if (USAME_TI(get_extension(fnam), ".ini")) IniFile->WriteStrGen(_T("DistrDlgFileName"), fnam);
		}

		DistributionDlg->OppPath = GetCurPathStr(OppListTag);

		//ダイアログ
		if (DistributionDlg->ShowModal()==mrOk) {
			UnicodeString src_dir = GetCurPathStr();
			UnicodeString dst_dir = GetCurPathStr(OppListTag);
			//タスク登録
			UnicodeString msg, cmd;
			if (DistributionDlg->SkipCount>0) StartLog(msg.sprintf(_T("振分準備  %s"), src_dir.c_str()));
			std::unique_ptr<TStringList> tsk_lst(new TStringList());
			std::unique_ptr<TStringList> war_lst(new TStringList());
			cmd.sprintf(_T("%s"), DistributionDlg->IsMove? _T("MOV") : _T("CPY"));
			UnicodeString tprm;
			TStringList *dstr_lst = DistributionDlg->DistrList;
			for (int i=0; i<dstr_lst->Count; i++) {
				UnicodeString lbuf = dstr_lst->Strings[i];
				UnicodeString fnam = split_pre_tab(lbuf);
				UnicodeString dnam = IncludeTrailingPathDelimiter(lbuf.IsEmpty()? dst_dir : to_absolute_name(lbuf, dst_dir));
				if (!DistributionDlg->CreDistrDirCheckBox->Checked && !dir_exists(dnam)) {
					msg = make_LogHdr(DistributionDlg->IsMove? _T("MOVE") : _T("COPY"), fnam);
					msg[1] = 'W';
					msg.cat_sprintf(_T("\r\n    [%s] が存在しません。"), dnam.c_str());
					AddLog(msg);
				}
				else
					tsk_lst->Add(tprm.sprintf(_T("%s\t%s\t%s"), cmd.c_str(), fnam.c_str(), dnam.c_str()));
			}
			dstr_lst->Clear();

			//タスク開始
			if (tsk_lst->Count>0) {
				TaskConfig  *cp = NULL;
				TTaskThread *tp = CreTaskThread(&cp);	if (cp==NULL) Abort();
				cp->TaskList->Assign(tsk_lst.get());
				cp->Distribute_sw = true;
				cp->CopyMode = DistributionDlg->SameNameComboBox->ItemIndex;
				cp->CopyAll  = true;
				cp->CopyFmt  = AutoRenFmt;
				cp->CmdStr	 = "振分" + TaskCmdList->Values[cmd];
				cp->DistPath = dst_dir;
				cp->InfStr.sprintf(_T("%s ---> %s"), src_dir.c_str(), dst_dir.c_str());
				cp->DstPosMode = TEST_ActParam("OP")? 1 : 0;
				ActivateTask(tp, cp);
			}
		}
	}
	catch (EAbort &e) {
		SetActionAbort(e.Message);
	}
}

//---------------------------------------------------------------------------
//ディレクトリの比較
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::DiffDirActionExecute(TObject *Sender)
{
	try {
		if (!IsCurFList() || !IsOppFList()) UserAbort(USTR_CantOperate);
		if (EqualDirLR()) UserAbort(USTR_SameDirLR);

		clear_FindStt(CurStt);
		clear_FindStt(OppStt);
		UnicodeString src_mask = "*.*";
		UnicodeString exc_mask = EmptyStr;
		UnicodeString exc_dir  = EmptyStr;
		bool		  sub_sw   = true;

		if (!TEST_ActParam("AL")) {
			if (!DiffDirDlg) DiffDirDlg = new TDiffDirDlg(this);	//初回に動的作成
			DiffDirDlg->SrcDirEdit->Text = CurPath[CurListTag];
			DiffDirDlg->DstDirEdit->Text = CurPath[OppListTag];
			if (DiffDirDlg->ShowModal()!=mrOk) SkipAbort();
			src_mask = DiffDirDlg->IncMaskComboBox->Text;
			exc_mask = DiffDirDlg->ExcMaskComboBox->Text;
			sub_sw	 = DiffDirDlg->SubDirCheckBox->Checked;
			exc_dir  = DiffDirDlg->DiffExcDirComboBox->Text;
		}

		FindBusy = true;
		FindDiff = true;

		UnicodeString msg;
		StartLog(msg.sprintf(_T("ディレクトリ比較開始  %s\t%s"), CurPath[CurListTag].c_str(), CurPath[OppListTag].c_str()));
		SttWorkMsg(_T("対象取得中..."), FindTag);
		ShowMessageHint("　対象取得中...\n　しばらくお持ちください。", col_bgHint, false, true);
		AddLog(msg.sprintf(_T("  対象マスク: %s"), src_mask.c_str()));
		AddLog(msg.sprintf(_T("  除外マスク: %s"), exc_mask.c_str()));
		msg = "  サブディレクトリも対象";
		if (!exc_dir.IsEmpty()) msg.cat_sprintf(_T(" (除外マスク: %s)"), exc_dir.c_str());
		AddLog(msg);

		//結果リストの初期化
		TStringList *r_lst_c = ResultList[CurListTag];	clear_FileList(r_lst_c);
		TStringList *r_lst_o = ResultList[OppListTag];	clear_FileList(r_lst_o);

		//対象ファイルの取得
		std::unique_ptr<TStringList> flst_c(new TStringList());
		std::unique_ptr<TStringList> flst_o(new TStringList());
		TStringDynArray msk_lst = split_strings_semicolon(src_mask);
		for (int i=0; i<msk_lst.Length; i++) {
			UnicodeString mask = msk_lst[i];
			get_all_files_ex(CurPath[CurListTag], mask, flst_c.get(),
				sub_sw, 99, exc_dir, ShowHideAtr, ShowSystemAtr);
			get_all_files_ex(CurPath[OppListTag], mask, flst_o.get(),
				sub_sw, 99, exc_dir, ShowHideAtr, ShowSystemAtr);
			if (is_KeyPress_ESC()) Abort();
		}

		//除外マスク
		TStringDynArray exc_lst = split_strings_semicolon(exc_mask);
		for (int i=0; i<exc_lst.Length; i++) {
			UnicodeString mask = exc_lst[i];
			int j = 0;
			while (j<flst_c->Count) {
				if (str_match(mask, ExtractFileName(flst_c->Strings[j]))) flst_c->Delete(j); else j++;
			}
			j = 0;
			while (j<flst_o->Count) {
				if (str_match(mask, ExtractFileName(flst_o->Strings[j]))) flst_o->Delete(j); else j++;
			}
		}
		AddLog(msg.sprintf(_T("  比較元対象ファイル数:%6u"), flst_c->Count));
		AddLog(msg.sprintf(_T("  比較先対象ファイル数:%6u"), flst_o->Count));

		try {
			msg = "比較処理中...";
			SttWorkMsg(msg, FindTag);
			ShowMessageHintEsc(msg);
			int chk_cnt = 250;	//***

			//基準パス部分を除いた名前リストを作成
			std::unique_ptr<TStringList> nlst_c(new TStringList());
			flst_c->Sort();
			for (int i=0; i<flst_c->Count; i++)
				nlst_c->Add(get_tkn_r(flst_c->Strings[i], CurPath[CurListTag]));

			std::unique_ptr<TStringList> nlst_o(new TStringList());
			flst_o->Sort();
			for (int i=0; i<flst_o->Count; i++)
				nlst_o->Add(get_tkn_r(flst_o->Strings[i], CurPath[OppListTag]));

			//カレントから比較
			//！この時点で nlst_o はソートされている(Find を考慮、flst_o と一致)
			for (int i=0; i<flst_c->Count; i++) {
				int idx_o;
				if (nlst_o->Find(nlst_c->Strings[i], idx_o)) {
					r_lst_o->Add(flst_o->Strings[idx_o]);
					flst_o->Delete(idx_o);
					nlst_o->Delete(idx_o);
				}

				r_lst_c->Add(flst_c->Strings[i]);

				if (i%chk_cnt==0 && is_KeyPress_ESC()) Abort();
			}

			//反対側から
			for (int i=0; i<flst_o->Count; i++) r_lst_o->Add(flst_o->Strings[i]);

			//不在項目を追加
			nlst_c->Clear();
			for (int i=0; i<r_lst_c->Count; i++)
				nlst_c->Add(get_tkn_r(r_lst_c->Strings[i], CurPath[CurListTag]));

			nlst_o->Clear();
			for (int i=0; i<r_lst_o->Count; i++)
				nlst_o->Add(get_tkn_r(r_lst_o->Strings[i], CurPath[OppListTag]));

			std::unique_ptr<TStringList> name_a(new TStringList());
			nlst_o->Sort();	//！Find のためにソート
			for (int i=0; i<nlst_c->Count; i++) {
				UnicodeString name_c = nlst_c->Strings[i];
				int idx;  if (nlst_o->Find(name_c, idx)) continue;
				name_a->Add(name_c);
				r_lst_o->Add(CurPath[OppListTag] + name_c);
				if (i%chk_cnt==0 && is_KeyPress_ESC()) Abort();
			}
			nlst_o->AddStrings(name_a.get());
			nlst_o->Sort();

			nlst_c->Sort();	//Find のためにソート
			for (int i=0; i<nlst_o->Count; i++) {
				UnicodeString name_o = nlst_o->Strings[i];
				int idx;  if (nlst_c->Find(name_o, idx)) continue;
				r_lst_c->Add(CurPath[CurListTag] + name_o);
				if (i%chk_cnt==0 && is_KeyPress_ESC()) Abort();
			}

			if (r_lst_c->Count!=r_lst_o->Count) UserAbort(USTR_FaildProc);

			//ファイルリスト用オブジェクトを設定
			r_lst_c->Sort();
			r_lst_o->Sort();

			//一致する項目を除く
			chk_cnt = 50;	//***
			int i=0, j = 0;
			while (i<r_lst_c->Count) {
				//r_lst_c/o のオブジェクトを設定
				r_lst_c->Objects[i] = (TObject*)cre_new_file_rec(r_lst_c->Strings[i], CurListTag, true);
				file_rec *cfp = (file_rec *)r_lst_c->Objects[i];
				r_lst_o->Objects[i] = (TObject*)cre_new_file_rec(r_lst_o->Strings[i], OppListTag, true);
				file_rec *ofp = (file_rec *)r_lst_o->Objects[i];

				if (cfp->is_dummy || ofp->is_dummy
					|| !WithinPastMilliSeconds(cfp->f_time, ofp->f_time, TimeTolerance)
					|| cfp->f_size!=ofp->f_size)
				{
					i++;
				}
				else {
					del_FileListItem(r_lst_c, i);
					del_FileListItem(r_lst_o, i);
				}

				j++;
				if (j%chk_cnt==0 && is_KeyPress_ESC()) Abort();
			}

			msg = "比較終了";

			if (r_lst_c->Count>0) {
				//リストボックスに割り当て
				for (int i=0; i<MAX_FILELIST; i++) {
					flist_stt *lst_stt = &ListStt[i];
					lst_stt->is_Find	   = true;
					lst_stt->find_Path	   = CurPath[i];
					lst_stt->find_Mask	   = src_mask;
					lst_stt->find_PathSort = FindPathColumn;
					FlOdrDscPath[i] 	   = false;

					//戻り用
					file_rec *fp = cre_new_up_rec(i);
					fp->f_time = Now();
					fp->p_name = lst_stt->find_Path;
					ResultList[i]->InsertObject(0, fp->f_name, (TObject*)fp);

					TListBox *lp = FileListBox[i];
					lp->Color = col_bgFind;
					lp->Count = 1;
					UpdateBgImage();

					SortList(ResultList[i], i);
					SetFlItemWidth(ResultList[i], i);
					update_FileListBox(ResultList[i], i, 0);
					SetDirCaption(i);
					SetDriveFileInfo(i);
				}

				RepaintList();
				SetFileInf();
				msg.cat_sprintf(_T("  DIFF: %u"), r_lst_c->Count - 1);

				SaveToTmpBufList();	//現在のリストを待避
			}
			else {
				msg += "  違いは見つかりません。";
				SttWorkMsg(msg, FindTag);
			}
		}
		catch (EAbort &e) {
			msg = "比較中断";
			SttWorkMsg(msg, FindTag);
		}
		AddLog(msg, true);

		FindBusy = false;
	}
	catch (EAbort &e) {
		SetActionAbort(e.Message);
	}
}

//---------------------------------------------------------------------------
//ディレクトリ履歴
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::DirHistoryActionExecute(TObject *Sender)
{
	if (TEST_ActParam("AC")) {
		if (msgbox_Sure(LoadUsrMsg(USTR_DelHistoryQ, get_LRUD_str() + "側")),
			!(ExeCmdsBusy && XCMD_MsgOff))
				clear_DirHistory();
		return;
	}

	if (TEST_ActParam("GC")) {
		if (msgbox_Sure(LoadUsrMsg(USTR_DelHistoryQ, _T("全体")), true, true)) AllDirHistory->Clear();
		return;
	}

	try {
		CheckDirHistory();

		if (!DirHistoryDlg) DirHistoryDlg = new TDirHistoryDlg(this);	//初回に動的作成
		DirHistoryDlg->IsAllDirHist  = TEST_ActParam("GA") || TEST_ActParam("GS");
		DirHistoryDlg->IsFindDirHist = TEST_ActParam("FM");

		TStringList *h_lst;
		if (DirHistoryDlg->IsAllDirHist || DirHistoryDlg->IsFindDirHist) {
			h_lst = AllDirHistory;
			//ソート
			if ((TEST_ActParam("GS") || TEST_ActParam("FM")) && h_lst->Count>0) {
				h_lst->Sort();
				//重複を削除
				UnicodeString laststr = get_csv_item(h_lst->Strings[0], 0);
				int i = 1;
				while (i<h_lst->Count) {
					UnicodeString lbuf = get_csv_item(h_lst->Strings[i], 0);
					if (SameStr(laststr, lbuf)) {
						h_lst->Delete(i);
					}
					else {
						laststr = lbuf;  i++;
					}
				}
			}
		}
		else {
			h_lst = get_DirHistory();
		}

		if (h_lst && h_lst->Count>0) {
			if (DirHistoryDlg->ShowModal()==mrOk && !DirHistoryDlg->WorkListName.IsEmpty()) {
				SaveWorkListAction->Execute();
				if (!SetWorkList(DirHistoryDlg->WorkListName)) UserAbort(USTR_WlistCantOpen);
			}
		}
	}
	catch (EAbort &e) {
		SetActionAbort(e.Message);
	}
}
//---------------------------------------------------------------------------
//ディレクトリ・スタック
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::DirStackActionExecute(TObject *Sender)
{
	if (DirStack->Count>0) {
		if (!DirHistoryDlg) DirHistoryDlg = new TDirHistoryDlg(this);	//初回に動的作成
		DirHistoryDlg->IsDirStack = true;
		DirHistoryDlg->ShowModal();
	}
}

//---------------------------------------------------------------------------
//.nyanfi ファイルの設定
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::DotNyanDlgActionExecute(TObject *Sender)
{
	if (IsCurFList()) {
		//再適用
		if (TEST_ActParam("RS")) {
			ApplyDotNyan = true;
			CurPath[CurListTag] = CurPath[CurListTag];
		}
		//設定ダイアログ
		else {
			if (!DotNyanDlg) DotNyanDlg = new TDotNyanDlg(this);	//初回に動的作成
			DotNyanDlg->DotNyanName = get_dotNaynfi(CurPath[CurListTag]);
			if (DotNyanDlg->ShowModal()==mrOk) {
				ApplyDotNyan = true;
				CurPath[CurListTag] = CurPath[CurListTag];
			}
		}
	}
	else SetActionAbort();
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::DotNyanDlgActionUpdate(TObject *Sender)
{
	TAction *ap = (TAction*)Sender;
	ap->Visible = ScrMode==SCMD_FLIST;
	ap->Enabled = ap->Visible && IsCurFList();
	ap->Checked = file_exists(get_dotNaynfi(CurPath[CurListTag]));

	//※Checked がボタンに反映されない場合がある現象に対処(バグ?)
	if (ToolBarF->Visible) {
		for (int i=0; i<ToolBarF->ButtonCount; i++) {
			if (USAME_TI(get_csv_item(ToolBtnList->Strings[i], 1), "DotNyanDlg"))
				ToolBarF->Buttons[i]->Down = ap->Checked;
		}
	}
}

//---------------------------------------------------------------------------
//ドライブ使用率推移
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::DriveGraphActionExecute(TObject *Sender)
{
	try {
		if (!IsCurFList()) UserAbort(USTR_OpeNotSuported);

		UnicodeString dnam;
		if (!ActionParam.IsEmpty())
			dnam.sprintf(_T("%c:"), ActionParam[1]);
		else
			dnam = ExtractFileDrive(CurPath[CurListTag]);
		if (!is_drive_accessible(dnam)) Abort();
		if (StartsStr("\\", dnam)) Abort();

		if (!DriveGraph) DriveGraph = new TDriveGraph(this);	//初回に動的作成
		DriveGraph->DriveName = dnam;
		DriveGraph->ShowModal();
	}
	catch (EAbort &e) {
		SetActionAbort(e.Message);
	}
}

//---------------------------------------------------------------------------
//ドライブ一覧
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::DriveListActionExecute(TObject *Sender)
{
	//ボリューム名を更新
	for (int i=0; i<DriveInfoList->Count; i++) {
		drive_info *dp = (drive_info *)DriveInfoList->Objects[i];
		if (dp->accessible) dp->volume = get_VolumeInfo(dp->drive_str);
	}

	if (TEST_ActParam("ND"))
		PopupDriveMenu();
	else if (TEST_ActParam("NS"))
		PopupDriveMenu(CurListTag, false, true);
	else {
		if (!SelDriveDlg) SelDriveDlg = new TSelDriveDlg(this);	//初回に動的作成
		SelDriveDlg->ShowModal();
	}
}

//---------------------------------------------------------------------------
//NyanFi の二重起動
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::DuplicateActionExecute(TObject *Sender)
{
	if (!Execute_ex(Application->ExeName, EmptyStr, ExePath, TEST_ActParam("RA")? "A" : ""))
		SetActionAbort(USTR_FaildExec);
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::DuplicateActionUpdate(TObject *Sender)
{
	TAction *ap = (TAction*)Sender;
	ap->Visible = Initialized;
	ap->Enabled = ap->Visible && MultiInstance;
}

//---------------------------------------------------------------------------
//構文強調表示定義ファイルの編集
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::EditHighlightActionExecute(TObject *Sender)
{
	if (!ExeCommandsCore(UnicodeString().sprintf(_T("FileEdit_\"%s\""), UserHighlight->FileName.c_str())))
		 SetActionAbort(GlobalErrMsg);
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::EditHighlightActionUpdate(TObject *Sender)
{
	TAction *ap = (TAction*)Sender;
	ap->Visible = ScrMode==SCMD_FLIST || ScrMode==SCMD_TVIEW;
	ap->Enabled = ap->Visible && FileExists(UserHighlight->FileName);
}

//---------------------------------------------------------------------------
//最近編集したファイル一覧
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::EditHistoryActionExecute(TObject *Sender)
{
	bool is_edit = USAME_TI(((TAction*)Sender)->Name, "EditHistoryAction");

	if (TEST_ActParam("AC")) {
		if (msgbox_Sure(USTR_DelHistoryQ, !(ExeCmdsBusy && XCMD_MsgOff), true))
			(is_edit? TextEditHistory : TextViewHistory)->Clear();
		return;
	}

	try {
		EditHistoryDlg->ToFilter = TEST_ActParam("FF");
		EditHistoryDlg->isView	 = !is_edit;
		int res = EditHistoryDlg->ShowModal();
		UnicodeString fnam = EditHistoryDlg->EditFileName;
		if (res==mrOk) {
			//編集
			if (USAME_TI(EditHistoryDlg->CmdStr, "FileEdit")) {
				if (!open_by_TextEditor(fnam)) GlobalAbort();
			}
			//閲覧
			else if (USAME_TI(EditHistoryDlg->CmdStr, "TextViewer")) {
				if (ScrMode==SCMD_TVIEW) TxtViewer->add_ViewHistory();
				if (!SetAndOpenTxtViewer(fnam)) UserAbort(USTR_FileNotOpen);
			}
		}
		//移動
		else if (res==mrClose) {
			if (!JumpToList(CurListTag, fnam)) GlobalAbort();
		}
	}
	catch (EAbort &e) {
		SetActionAbort(e.Message);
	}
}

//---------------------------------------------------------------------------
//CD/DVDドライブ のトレイを開く
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::EjectActionExecute(TObject *Sender)
{
	MCI_OPEN_PARMS mci_prm;
	mci_prm.lpstrDeviceType = (LPCTSTR)MCI_DEVTYPE_CD_AUDIO;
	DWORD flag = MCI_OPEN_TYPE|MCI_OPEN_TYPE_ID|MCI_OPEN_SHAREABLE|MCI_WAIT;

	UnicodeString dstr = ActionParam;
	//ドライブを指定
	if (!dstr.IsEmpty()) {
		dstr += ":";
		mci_prm.lpstrElementName = dstr.c_str();
		flag |= MCI_OPEN_ELEMENT;
	}
	//複数ならポップアップメニューで処理
	else if (PopupDriveMenu(CurListTag, true)) return;

	//単独ならここで処理
	if (::mciSendCommand(0, MCI_OPEN, flag, (DWORD)&mci_prm) == 0) {
		::mciSendCommand(mci_prm.wDeviceID, MCI_SET, MCI_SET_DOOR_OPEN, NULL);
		::mciSendCommand(mci_prm.wDeviceID, MCI_CLOSE, MCI_WAIT, NULL);
	}
}

//---------------------------------------------------------------------------
//ドライブの取り外し
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::EjectDriveActionExecute(TObject *Sender)
{
	try {
		if (ActionParam.IsEmpty()) UserAbort(USTR_NoParameter);

		UnicodeString c_drv = get_drive_str(CurPath[CurListTag]);
		UnicodeString o_drv = get_drive_str(CurPath[OppListTag]);

		UnicodeString dstr;
		if (TEST_ActParam(".")) dstr = c_drv; else dstr.sprintf(_T("%s:\\"), ActionParam.c_str());

		//取り外し可能かチェック
		drive_info *dp = get_DriveInfo(dstr);
		bool is_vd = (dp && dp->is_virtual);	//仮想ドライブ
		if (!is_vd && !EjectDrive(dstr, false)) TextAbort(_T("このドライブは取り外せません。"));

		//使用可能な前のドライブに移動
		if (SameText(c_drv, dstr) || SameText(o_drv, dstr)) {
			std::unique_ptr<TStringList> d_list(new TStringList());
			if (get_available_drive_list(d_list.get())==0) Abort();
			int idx = -1;
			for (int i=d_list->Count-1; i>=0 && idx==-1; i--)
				if (CompareText(dstr, d_list->Strings[i])>0) idx = i;
			if (idx==-1) idx = d_list->Count - 1;
			if (SameText(c_drv, dstr)) UpdateCurDrive(d_list->Strings[idx], CurListTag);
			if (SameText(o_drv, dstr)) UpdateCurDrive(d_list->Strings[idx], OppListTag);
		}

		//取り外し
		if (is_vd) {
			if (!::DefineDosDevice(DDD_REMOVE_DEFINITION, ExcludeTrailingPathDelimiter(dstr).c_str(), NULL))
				UserAbort(USTR_FaildProc);
		}
		else {
			if (!EjectDrive(dstr, true)) UserAbort(USTR_FaildProc);
		}

		ShowHintAndStatus(ActionParam + "ドライブを取り外しました。");
	}
	catch (EAbort &e) {
		SetActionAbort(e.Message);
	}
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ExeEjectDrive(UnicodeString dstr)
{
	ActionParam = dstr.SubString(1, 1);
	EjectDriveAction->Execute();
}

//---------------------------------------------------------------------------
//ごみ箱を空にする
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::EmptyTrashActionExecute(TObject *Sender)
{
	DWORD dwFlags = 0;
	bool sure_del = (ExeCmdsBusy && XCMD_MsgOff)? false : SureDelete;
	if (!sure_del) dwFlags |= SHERB_NOCONFIRMATION;
	SHEmptyRecycleBin(Handle, NULL, dwFlags);
}

//---------------------------------------------------------------------------
//コマンドラインの実行
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ExeCommandLineActionExecute(TObject *Sender)
{
	file_rec *cfp = cre_new_file_rec(GetCurFrecPtr(true));

	if (!ExeCmdDlg) ExeCmdDlg = new TExeCmdDlg(this);	//初回に動的作成
	ExeCmdDlg->FileRec	   = cfp;
	ExeCmdDlg->inp_CurName = TEST_ActParam("FN");
	ExeCmdDlg->inp_LastCmd = TEST_ActParam("LC");

	if (ExeCmdDlg->ShowModal()==mrOk) {
		CurWorking = true;
		try {
			UnicodeString cmdln = Trim(ExeCmdDlg->ExeComboBox->Text);
			if (cmdln.IsEmpty()) Abort();

			if (ExeCmdDlg->LogStdOutCheckBox->Checked) {
				AddLogCr();	AddLog(make_LogHdr(_T("EXEC"), cmdln));
			}

			//カレントディレクトリを設定
			SetCurrentDir(CurPath[CurListTag]);

			//管理者として実行/権限昇格ダイアログを表示
			if (ExeCmdDlg->RunAsCheckBox->Checked || ExeCmdDlg->UacDlgCheckBox->Checked) {
				UnicodeString fnam = split_file_param(cmdln);
				UnicodeString prm  = cmdln;
				UnicodeString opt;
				if (ExeCmdDlg->RunAsCheckBox->Checked) opt = "A";
				if (!Execute_ex(fnam, prm, CurPath[CurListTag], opt)) {
					AddLog("E " + get_LogErrMsg(LoadUsrMsg(USTR_FaildExec), false));
					UserAbort(USTR_FaildExec);
				}
			}
			//通常実行
			else {
				//オプションを設定
				UnicodeString opt;
				if (ExeCmdDlg->LogStdOutCheckBox->Checked || ExeCmdDlg->CopyStdOutCheckBox->Checked
					|| ExeCmdDlg->ListStdOutCheckBox->Checked || ExeCmdDlg->SaveStdOutCheckBox->Checked)
						opt = "O";
				if (ExeCmdDlg->LogStdOutCheckBox->Checked) opt += "L";

				std::unique_ptr<TStringList> o_lst(new TStringList());
				if (Execute_cmdln(cmdln, CurPath[CurListTag], opt, NULL, o_lst.get())) {
					if (o_lst->Count>0) {
						//クリップボートにコピー
						if (ExeCmdDlg->CopyStdOutCheckBox->Checked) copy_to_Clipboard(o_lst->Text);
						//ファイルに保存
						if (ExeCmdDlg->SaveStdOutCheckBox->Checked) {
							if (!saveto_TextFile(to_absolute_name(ExeCmdDlg->SaveNameEdit->Text), o_lst.get()))
								UserAbort(USTR_FaildSave);
						}
						//一覧で表示
						if (ExeCmdDlg->ListStdOutCheckBox->Checked) {
							set_FormTitle(GeneralInfoDlg, _T("実行結果"));
							GeneralInfoDlg->GenInfoList->Assign(o_lst.get());
							GeneralInfoDlg->ShowModal();
						}
					}
				}
				else {
					if (ExeCmdDlg->LogStdOutCheckBox->Checked) AddLog("E " + get_LogErrMsg(GlobalErrMsg, false));
					UserAbort(USTR_FaildExec);
				}
				if (ExeCmdDlg->LogStdOutCheckBox->Checked) AddLogCr();
			}
		}
		catch (EAbort &e) {
			SetActionAbort(e.Message);
		}
		CurWorking = false;
	}

	del_file_rec(cfp);
}

//---------------------------------------------------------------------------
//指定したコマンドを実行
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ExeCommandsActionExecute(TObject *Sender)
{
	if (!ExeAliasOrCommands(ActionParam)) SetActionAbort(GlobalErrMsg);
}
//---------------------------------------------------------------------------
//追加メニューの実行
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ExeExtMenuActionExecute(TObject *Sender)
{
	int idx = get_IndexFromAccKey(ExtMenuList, ActionParam);
	if (idx==-1) {
		SetActionAbort(SysErrorMessage(ERROR_MENU_ITEM_NOT_FOUND));
	}
	else {
		//サブメニューを表示
		if (StartsStr(">", get_csv_item(ExtMenuList->Strings[idx], 0))) {
			ExPopupMenu->Items->Clear();
			IconImgListP->Clear();
			SetExtMenuItem(ExPopupMenu->Items, ExtMenuList, EXTMENU_BASE, idx);
			ShowExPopupMenu();
		}
		//項目を実行
		else if (!ExeExtMenuItem(idx)) {
			SetActionAbort(GlobalErrMsg);
		}
	}
}
//---------------------------------------------------------------------------
//外部ツールの実行
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ExeExtToolActionExecute(TObject *Sender)
{
	int idx = get_IndexFromAccKey(ExtToolList, ActionParam);
	if (idx==-1) {
		SetActionAbort(SysErrorMessage(ERROR_MENU_ITEM_NOT_FOUND));
	}
	else {
		//サブメニューを表示
		if (StartsStr(">", get_csv_item(ExtToolList->Strings[idx], 0))) {
			ExPopupMenu->Items->Clear();
			IconImgListP->Clear();
			SetExtMenuItem(ExPopupMenu->Items, ExtToolList, EXTTOOL_BASE, idx);
			ShowExPopupMenu();
		}
		//項目を実行
		else if (!ExeExtToolItem(idx)) {
			SetActionAbort(GlobalErrMsg);
		}
	}
}
//---------------------------------------------------------------------------
//ツールボタンの実行
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ExeToolBtnActionExecute(TObject *Sender)
{
	try {
		TStringList *lst = GetCurBtnList();  if (!lst) Abort();
		int idx = ActionParam.ToIntDef(0);
		if (idx<1 || idx>lst->Count) UserAbort(USTR_IllegalParam);
		idx--;
		ActionOptStr = EmptyStr;
		if (!ExeAliasOrCommands(get_csv_item(lst->Strings[idx], 1))) GlobalAbort();
	}
	catch (EAbort &e) {
		SetActionAbort(e.Message);
	}
}

//---------------------------------------------------------------------------
//終了
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ExitActionExecute(TObject *Sender)
{
	NotSaveINI = ReqKeepDupl = false;
	if (TEST_ActParam("NS")) NotSaveINI  = true;
	if (TEST_ActParam("NX")) ReqKeepDupl = true;
	ReqClose = false;
	cursor_HourGlass();
	Close();
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ExitActionUpdate(TObject *Sender)
{
	((TAction*)Sender)->Enabled = !CurWorking && !FindBusy && !CalcBusy && !ExeCmdsBusy;
}
//---------------------------------------------------------------------------
//二重起動された NyanFi を終了
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ExitDuplActionExecute(TObject *Sender)
{
	if (!CloseOtherNyanFi()) SetActionAbort(USTR_FaildProc);
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ExitDuplActionUpdate(TObject *Sender)
{
	((TAction*)Sender)->Enabled = IsPrimary && MultiInstance;
}

//---------------------------------------------------------------------------
//拡張ポップアップメニュー
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ExPopupMenuActionExecute(TObject *Sender)
{
	ClearKeyBuff(true);

	bool is_menu, is_tool;
	if		(TEST_ActParam("MN")) { is_menu = true;  is_tool = false; }
	else if (TEST_ActParam("TL")) { is_menu = false; is_tool = true;  }
	else						  { is_menu = true;  is_tool = true;  }

	ExPopupMenu->Items->Clear();
	IconImgListP->Clear();
	if (is_menu) SetExtMenuItem(ExPopupMenu->Items, ExtMenuList, EXTMENU_BASE);
	if (is_tool) SetExtMenuItem(ExPopupMenu->Items, ExtToolList, EXTTOOL_BASE);
	ShowExPopupMenu();
}

//---------------------------------------------------------------------------
//リスト幅を左右均等に
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::EqualListWidthActionExecute(TObject *Sender)
{
	ActionParam  = "50";
	ActionOptStr = "Left";
	WidenCurListAction->Execute();
}

//---------------------------------------------------------------------------
//HTMLヘルプ(.chm)からソースを抽出
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ExtractChmSrcActionExecute(TObject *Sender)
{
	try {
		if (CurStt->is_ADS || CurStt->is_FTP || !IsOppFList()) UserAbort(USTR_CantOperate);
		file_rec *cfp = GetCurFrecPtr();
		if (!cfp || cfp->is_dir || !test_FileExt(cfp->f_ext, _T(".chm"))) Abort();
		if (cfp->is_virtual && !SetTmpFile(cfp)) UserAbort(USTR_FaildTmpUnpack);

		UnicodeString fnam  = cfp->is_virtual? cfp->tmp_name : cfp->f_name;
		UnicodeString o_dir = CurPath[OppListTag];
		if (ContainsStr(fnam, " ") || ContainsStr(o_dir, " ")) TextAbort(_T("空白を含む名前には対応していません。"));

		UnicodeString msg;
		if (msgbox_Sure(
			msg.sprintf(_T("%s のHTMLソースを抽出しますか?"), ExtractFileName(fnam).c_str()), SureOtherActiv()))
		{
			std::unique_ptr<TStringList> tsk_lst(new TStringList());
			UnicodeString cmd = "EXTCHM";
			tsk_lst->Add(UnicodeString().sprintf(_T("%s\t%s\t%s"), cmd.c_str(), fnam.c_str(), o_dir.c_str()));
			TaskConfig  *cp = NULL;
			TTaskThread *tp = CreTaskThread(&cp);	if (!cp) Abort();
			cp->TaskList->Assign(tsk_lst.get());
			cp->CmdStr	 = TaskCmdList->Values[cmd];
			cp->DistPath = o_dir;
			cp->InfStr.sprintf(_T("%s ---> %s"), ExtractFileName(fnam).c_str(), o_dir.c_str());
			ActivateTask(tp, cp);
		}
	}
	catch (EAbort &e) {
		SetActionAbort(e.Message);
	}
}

//---------------------------------------------------------------------------
//アニメGIFからビットマップを抽出
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ExtractGifBmpActionExecute(TObject *Sender)
{
	try {
		NotConvertAbort();

		TStringList *lst = GetCurList(true);
		bool lst_sel = ListSelected(lst);
		if (!lst_sel && !GetCurFrecPtr()) Abort();

		//選択あり
		if (lst_sel) {
			for (int i=0; i<lst->Count; i++) {
				file_rec *fp = (file_rec*)lst->Objects[i];
				if (fp->selected && !test_GifExt(fp->f_ext)) UserAbort(USTR_FmtNotSuported);
			}
		}
		//カーソル位置
		else {
			file_rec *cfp = GetCurFrecPtr();
			if (cfp && !test_GifExt(cfp->f_ext)) UserAbort(USTR_FmtNotSuported);
		}

		UnicodeString msg;
		if (msgbox_Sure(LoadUsrMsg(USTR_Extract, _T("ビットマップ")), SureOtherActiv())) {
			StartLog(msg.sprintf(_T("抽出開始  %s\t%s"), GetSrcPathStr().c_str(), CurPath[OppListTag].c_str()));
			CurWorking = true;
			int i_cnt = 0, err_cnt = 0;
			int cur_idx = FileListBox[CurListTag]->ItemIndex;
			for (int i=0; i<lst->Count; i++) {
				file_rec *fp = (file_rec*)lst->Objects[i];
				if (fp->selected || (!lst_sel && i==cur_idx)) {
					msg = make_LogHdr(_T("GIFBMP"), fp);
					try {
						std::unique_ptr<TGIFImage> gif_buf(new TGIFImage());
						gif_buf->LoadFromFile(fp->f_name);
						TGIFImageList *gif_lst = gif_buf->Images;
						if (lst->Count>0) {
							int ixn = 0;
							UnicodeString tmp;
							for (int j=0; j<gif_lst->Count; j++) {
								Graphics::TBitmap *bmp = gif_lst->Frames[j]->Bitmap;
								if (bmp->Empty) continue;
								bmp->SaveToFile(
									tmp.sprintf(_T("%s%s_%03u.bmp"), CurPath[OppListTag].c_str(), fp->b_name.c_str(), j));
								ixn++; i_cnt++;
							}
							msg.cat_sprintf(_T("  %u"), ixn);
						}
						else msg[1] = 'N';
					}
					catch (...) {
						msg[1] = 'E';
						err_cnt++;
					}
					AddLog(msg);
					fp->selected = false;
					InvalidateFileList();
				}
			}
			CurWorking = false;
			ReloadList(OppListTag);
			if (EqualDirLR()) ReloadList(CurListTag); else RepaintList(CurListTag);
			if (i_cnt==0)  UserAbort(USTR_NoObject);
			EndLog(_T("抽出"), get_res_cnt_str(i_cnt, err_cnt));
			if (err_cnt>0) UserAbort(USTR_FaildProc);
		}
	}
	catch (EAbort &e) {
		SetActionAbort(e.Message);
	}
}

//---------------------------------------------------------------------------
//アイコンの抽出
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ExtractIconActionExecute(TObject *Sender)
{
	try {
		NotConvertAbort();

		TStringList *lst = GetCurList(true);
		bool lst_sel = ListSelected(lst);
		if (!lst_sel && !GetCurFrecPtr()) Abort();

		//選択あり
		if (lst_sel) {
			for (int i=0; i<lst->Count; i++) {
				file_rec *fp = (file_rec*)lst->Objects[i];
				if (fp->selected && !is_ExtractIcon(fp)) UserAbort(USTR_FmtNotSuported);
			}
		}
		//カーソル位置
		else {
			file_rec *cfp = GetCurFrecPtr();
			if (cfp && !is_ExtractIcon(cfp)) UserAbort(USTR_FmtNotSuported);
		}

		UnicodeString msg;
		if (msgbox_Sure(LoadUsrMsg(USTR_Extract, _T("アイコン")), SureOtherActiv())) {
			StartLog(msg.sprintf(_T("抽出開始  %s\t%s"), GetSrcPathStr().c_str(), CurPath[OppListTag].c_str()));
			CurWorking = true;
			UnicodeString prm = ActionParam;
			bool get_small = remove_top_text(prm, _T("SI"));
			int i_idx = prm.ToIntDef(-1);
			int i_cnt = 0, err_cnt = 0;
			int cur_idx = FileListBox[CurListTag]->ItemIndex;
			for (int i=0; i<lst->Count; i++) {
				file_rec *fp = (file_rec*)lst->Objects[i];
				if (fp->selected || (!lst_sel && i==cur_idx)) {
					msg = make_LogHdr(_T("ICON"), fp);
					int ixn = (int)::ExtractIcon(HInstance, fp->f_name.c_str(), -1);
					int ix0 = (i_idx>=0)? i_idx : 0;
					if (ixn>0) {
						bool ok = true;
						bool get_one = (i_idx>=0);
						UnicodeString tmp;
						for (int j=ix0; j<ixn && ok; j++) {
							HICON icons[1];
							if (::ExtractIconEx(fp->f_name.c_str(), j,
								(get_small? NULL : icons), (get_small? icons : NULL), 1)==1)
							{
								std::unique_ptr<Graphics::TIcon> icn(new Graphics::TIcon());
								icn->Handle = icons[0];
								try {
									icn->SaveToFile(
										tmp.sprintf(_T("%s%s_%03u.ico"), CurPath[OppListTag].c_str(), fp->b_name.c_str(), j));
									i_cnt++;
								}
								catch (...) {
									err_cnt++;
									ok = false;
								}
							}
							if (get_one) break;
						}
						msg.cat_sprintf(_T("  %u"), ixn);
						if (!ok) msg[1] = 'E';
					}
					else msg[1] = 'N';
					AddLog(msg);
					fp->selected = false;
					InvalidateFileList();
				}
			}
			CurWorking = false;
			ReloadList(OppListTag);
			if (EqualDirLR()) ReloadList(CurListTag); else RepaintList(CurListTag);
			if (i_cnt==0)  UserAbort(USTR_NoObject);
			EndLog(_T("抽出"), get_res_cnt_str(i_cnt, err_cnt));
			if (err_cnt>0) UserAbort(USTR_FaildProc);
		}
	}
	catch (EAbort &e) {
		SetActionAbort(e.Message);
	}
}

//---------------------------------------------------------------------------
//MP3の埋め込み画像を抽出 (ExtractImage)
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ExtractMp3ImgActionExecute(TObject *Sender)
{
	try {
		NotConvertAbort();

		TStringList *lst = GetCurList(true);
		bool lst_sel = ListSelected(lst);
		if (!lst_sel && !GetCurFrecPtr()) Abort();

		//選択あり
		if (lst_sel) {
			for (int i=0; i<lst->Count; i++) {
				file_rec *fp = (file_rec*)lst->Objects[i];
				if (fp->selected && !test_Mp3Ext(fp->f_ext) && !test_FlacExt(fp->f_ext))
					UserAbort(USTR_FmtNotSuported);
			}
		}
		//カーソル位置
		else {
			file_rec *cfp = GetCurFrecPtr();
			if (cfp && !test_Mp3Ext(cfp->f_ext) && !test_FlacExt(cfp->f_ext)) UserAbort(USTR_FmtNotSuported);
		}

		if (msgbox_Sure(LoadUsrMsg(USTR_Extract, _T("埋め込み画像")), SureOtherActiv())) {
			UnicodeString msg;
			StartLog(msg.sprintf(_T("抽出開始  %s\t%s"), GetSrcPathStr().c_str(), CurPath[OppListTag].c_str()));
			CurWorking = true;
			int i_cnt = 0;
			int cur_idx = FileListBox[CurListTag]->ItemIndex;
			for (int i=0; i<lst->Count; i++) {
				file_rec *fp = (file_rec*)lst->Objects[i];
				if (fp->selected || (!lst_sel && i==cur_idx)) {
					msg = make_LogHdr(_T("IMAGE"), fp);
					UnicodeString fnam = CurPath[OppListTag] + fp->b_name;
					bool ok = test_Mp3Ext(fp->f_ext)?
								ID3_GetImage(fp->f_name, NULL, fnam) : get_FlacImage(fp->f_name, NULL, fnam);
					if (ok) {
						fp->selected = false;	i_cnt++;
					} else msg[1] = 'N';
					AddLog(msg);
					InvalidateFileList();
				}
			}
			CurWorking = false;
			ReloadList(OppListTag);
			if (EqualDirLR()) ReloadList(CurListTag); else RepaintList(CurListTag);
			if (i_cnt==0) UserAbort(USTR_NoObject);
			EndLog(_T("抽出"), get_res_cnt_str(i_cnt));
		}
	}
	catch (EAbort &e) {
		SetActionAbort(e.Message);
	}
}

//---------------------------------------------------------------------------
//ファイルの編集
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::FileEditActionExecute(TObject *Sender)
{
	UnicodeString fext, fnam;
	try {
		TStringList *lst   = GetCurList();
		UnicodeString dnam = CurPath[CurListTag];
		std::unique_ptr<TStringList> s_lst(new TStringList());
		std::unique_ptr<TStringList> o_lst(new TStringList());
		bool is_os  = TEST_DEL_ActParam("OS") && !OpenOnlyCurEdit && !fromOpenStd;
		GlobalErrMsg = EmptyStr;

		if (isViewClip) {
			//クリップボードを一時ファイルに保存
			std::unique_ptr<Graphics::TBitmap> bmp(new Graphics::TBitmap());
			bmp->Assign(ImgViewThread->ImgBuff);
			fnam = TempPathA + CLIP_BMP_FILE;
			fext = get_extension(fnam);
			bmp->SaveToFile(fnam);
		}
		else {
			if (!ActionParam.IsEmpty()) {
				fnam = to_absolute_name(exclude_quot(ActionParam), CurPath[CurListTag]);
				if (!file_exists(fnam)) SysErrAbort(ERROR_FILE_NOT_FOUND);
				fext = get_extension(fnam);
				fnam = add_quot_if_spc(fnam);
			}
			else {
				file_rec *rfp = fromOpenStd? GetCurFrecPtr(true) : GetCurRepFrecPtr();
				if (!rfp) Abort();
				int sel_cnt = (OpenOnlyCurEdit || fromOpenStd)? 0 : GetSelCount(lst);
				if (TestCurIncDir(OpenOnlyCurEdit)) UserAbort(USTR_IncludeDir);
				fext = rfp->f_ext;
				fnam = (sel_cnt>0)? GetSelFileStr(lst, true, false, s_lst.get()) : GetCurFileStr();
				//反対側
				if (is_os) {
					UnicodeString snam = GetSelFileStr(GetOppList(), true, false, o_lst.get());
					if (!snam.IsEmpty()) fnam.cat_sprintf(_T(" %s"), snam.c_str());
				}
			}
		}

		//その他のエディタとの関連付けをチェック
		TStringDynArray etc_lst;
		for (int i=0; i<EtcEditorList->Count; i++) {
			if (!test_FileExt(fext, EtcEditorList->Names[i])) continue;
			UnicodeString edtr = exclude_quot(EtcEditorList->ValueFromIndex[i]);
			if (!starts_Dollar(edtr) || contains_PathDlmtr(edtr)) edtr = get_actual_path(edtr);
			add_dyn_array(etc_lst, edtr);
		}

		if (etc_lst.Length>0) {
			if (test_FileExt(fext, FExtImgEidt)) add_dyn_array(etc_lst, get_actual_path(ImageEditor), true);
			if (test_FileExt(fext, FEXT_TEXT))   add_dyn_array(etc_lst, get_actual_path(TextEditor),  true);
		}
		UnicodeString editor = get_MenuItemStr(etc_lst);

		if (!editor.IsEmpty()) {
			if (USAME_TS(editor, "SKIP")) SkipAbort();
			if (starts_Dollar(editor) && !contains_PathDlmtr(editor)) {
				ExeAlias(editor);
				if (!ActionOk && !ActionErrMsg.IsEmpty()) ActionAbort();
			}
			else {
				ActionOk = Execute_ex(editor, fnam, dnam);
			}
		}
		//イメージエディタ
		else if (test_FileExt(fext, FExtImgEidt)) {
			editor = get_actual_path(ImageEditor);
			if (!file_exists(editor)) UserAbort(USTR_AppNotFound);
			if (ImageEditSgl && s_lst->Count>0) {
				int ok_cnt = 0;
				for (int i=0; i<s_lst->Count; i++) {
					if (Execute_ex(editor, s_lst->Strings[i], dnam)) ok_cnt++;
				}
				for (int i=0; i<o_lst->Count; i++) {
					if (Execute_ex(editor, o_lst->Strings[i], dnam)) ok_cnt++;
				}
				ActionOk = (ok_cnt==(s_lst->Count + o_lst->Count));
			}
			else {
				ActionOk = Execute_ex(editor, fnam, dnam);
			}
		}
		//テキストエディタ
		else {
			UnicodeString snam = fnam;
			if (remove_top_s(snam, '\"'))
				snam = get_tkn(snam, '\"');
			else
				snam = get_tkn(snam, ' ');

			if (is_Processing(snam)) UserAbort(USTR_FileNotOpen);
			if (!is_TextFile(snam))  UserAbort(USTR_NoEditor);
			editor = get_actual_path(TextEditor);
			if (!file_exists(editor)) UserAbort(USTR_AppNotFound);

			ActionOk = Execute_ex(editor, fnam, dnam);
			if (ActionOk && !CurStt->is_Arc) {
				//編集履歴を更新
				if ((s_lst->Count + o_lst->Count)>0) {
					for (int i=0; i<s_lst->Count; i++) add_TextEditHistory(s_lst->Strings[i]);
					for (int i=0; i<o_lst->Count; i++) add_TextEditHistory(o_lst->Strings[i]);
				}
				else add_TextEditHistory(fnam);
			}
		}

		if (ActionOk) {
			if (s_lst->Count>0) AddToRecentFile(s_lst.get()); else AddToRecentFile(fnam);
			if (o_lst->Count>0) AddToRecentFile(o_lst.get());
		}
		else {
			if (!GlobalErrMsg.IsEmpty()) GlobalAbort(); else UserAbort(USTR_FaildExec);
		}

		if (!DontClrSelEdit) {
			if (s_lst->Count>0) {
				ClrSelect(lst);
				RepaintList(CurListTag);
			}
			if (o_lst->Count>0) {
				ClrSelect(GetOppList());
				RepaintList(OppListTag);
			}
		}
	}
	catch (EAbort &e) {
		SetActionAbort(e.Message);
		if (!ActionErrMsg.IsEmpty()) {
			UnicodeString msg = make_LogHdr(_T("EDIT"), fnam);
			set_LogErrMsg(msg, ActionErrMsg);
			AddLog(msg);
		}
	}
}

//---------------------------------------------------------------------------
//拡張子別一覧
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::FileExtListActionExecute(TObject *Sender)
{
	try {
		if (CurStt->is_Arc || CurStt->is_FTP) UserAbort(USTR_CantOperate);

		UnicodeString pnam;
		if (TEST_ActParam("CP")) {
			file_rec *fp = GetCurFrecPtr(true, true);
			if (!fp || !fp->is_dir) UserAbort(USTR_NoObject);
			pnam = fp->is_up? CurPath[CurListTag] : IncludeTrailingPathDelimiter(fp->f_name);
		}
		else {
			pnam = CurPath[CurListTag];
		}

		ClearAllAction->Execute();

		if (!FileExtensionDlg) FileExtensionDlg = new TFileExtensionDlg(this);	//初回に動的作成
		FileExtensionDlg->PathName = pnam;
		if (FileExtensionDlg->ShowModal()==mrOk) {
			//マスク検索
			if (!FileExtensionDlg->FextMask.IsEmpty()) {
				ActionParam = FileExtensionDlg->FextMask;
				MaskFindAction->Execute();
			}
			//移動
			else {
				RepaintList();
			 	if (!ExeCmdAction(JumpToAction, FileExtensionDlg->FileName)) ActionAbort();
			}
		}
	}
	catch (EAbort &e) {
		SetActionAbort(e.Message);
	}
}

//---------------------------------------------------------------------------
//ファイルリストのみを表示
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::FileListOnlyActionExecute(TObject *Sender)
{
	SubPanel->Visible = !SetToggleAction(IsPrimary? ShowFileListOnly : ShowFileListOnly2);
	set_PanelAlign(SubPanel, ListSubSplitter, LayoutMode, SplitterWidth);
	if (SubPanel->Visible) {
		LogListBox->ItemIndex = LogListBox->Count - 1;
		FileListBox[CurListTag]->SetFocus();
		SetFileInf();
	}
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::FileListOnlyActionUpdate(TObject *Sender)
{
	TAction *ap = (TAction*)Sender;
	ap->Visible = ScrMode==SCMD_FLIST;
	ap->Checked = ap->Visible && (IsPrimary? ShowFileListOnly : ShowFileListOnly2);
}

//---------------------------------------------------------------------------
//ファイル名を指定して実行
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::FileRunActionExecute(TObject *Sender)
{
	if (!ActionParam.IsEmpty()) {
		UnicodeString prm;
		UnicodeString s = Trim(add_quot_if_spc(ActionParam));
		if (remove_top_s(s, '\"')) {
			prm = "\"\" ";
			if (remove_end_s(s, '\"')) {
				if (s.Pos(" /")>1) {
					prm.cat_sprintf(_T("\"%s\" /%s"), get_tkn(s, " /").c_str(), get_tkn_r(s, " /").c_str());
				}
				else {
					TRegExOptions opt; opt << roIgnoreCase;
					TMatch mt = TRegEx::Match(s, "^((\\S+\\.\\w+)|control)\\s", opt);
					if (mt.Success)
						prm.cat_sprintf(_T("\"%s\" %s"), Trim(mt.Value).c_str(), get_tkn_r(s, mt.Value).c_str());
					else
						prm.cat_sprintf(_T("\"%s\""), s.c_str());
				}
			}
			else {
				prm.cat_sprintf(_T("\"%s\""), split_tkn(s, '\"').c_str());
				prm.cat_sprintf(_T(" \"%s\""), s.c_str());
			}
		}
		else {
			prm = s;
		}

		if (!Execute_ex("cmd", "/c start " + prm, CurPath[CurListTag], "H"))
			SetActionAbort(USTR_FaildExec);
	}
	else if (!usr_SH->ShowFileRun()) {
		SetActionAbort();
	}
}

//---------------------------------------------------------------------------
//フィルタ
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::FilterActionExecute(TObject *Sender)
{
	if (CurStt->is_Work && WorkListChanged) SaveWorkListAction->Execute();

	if (TEST_DEL_ActParam("CA")) ExeCommandAction("SelMask", "CA");

	CurStt->is_Filter	= true;
	CurStt->filter_sens = TEST_DEL_ActParam("CS");

	SaveToTmpBufList();	//現在のリストを待避

	SetDrivePanel(CurListTag);

	TPanel *stt_pp = (CurListTag==0)? L_StatPanel : R_StatPanel;
	FilterComboBox->Left  = get_CharWidth_Font(DrvInfFont, 10);
	FilterComboBox->Width = std::max(stt_pp->ClientWidth - get_CharWidth_Font(FilterComboBox->Font, 34), 60);
																	//" フィルタ   999999 Files Matched "
	FilterComboBox->Font->Color = scl_WindowText;
	FilterComboBox->Text	= EmptyStr;
	FilterComboBox->Parent	= stt_pp;
	FilterComboBox->Items->Assign(FilterHistory);
	FilterComboBox->Visible = true;
	FilterComboBox->SetFocus();
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::FilterComboBoxExit(TObject *Sender)
{
	ExitIncSearch();
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::FilterComboBoxChange(TObject *Sender)
{
	if (!CurStt->is_Filter) return;

	UnicodeString cur_fnam = GetCurFileName();

	//絞り込み解除
	ResetIncSeaFilter(CurListTag);
	if (IsDiffList()) ResetIncSeaFilter(OppListTag);

	//絞り込み
	TStringList    *lst = GetCurList();
	TStringList *sm_lst = SelMaskList[CurListTag];
	sm_lst->Clear();
	UnicodeString kwd = FilterComboBox->Text;
	if (!kwd.IsEmpty()) {
		int i = 0;
		while (i<lst->Count) {
			file_rec *fp = (file_rec*)lst->Objects[i];
			if (!fp->is_up) {
				UnicodeString lbuf = (!fp->alias.IsEmpty())? (fp->alias + fp->f_ext) : fp->n_name;
				if (CurStt->find_TAG && FindTagsColumn) lbuf.cat_sprintf(_T("\t%s"), fp->tags.c_str());
				fp->matched = contains_word_and_or(lbuf, kwd, CurStt->filter_sens);
			}
			//選択マスクを設定して絞り込み
			if (fp->matched) {
			 	sm_lst->Add(fp->f_name);
			 	i++;
			}
			else del_FileListItem(lst, i);
		}
	}
	else {
		for (int i=0; i<lst->Count; i++) ((file_rec*)lst->Objects[i])->matched = false;
	}

	int match_cnt = GetMatchCount(lst);
	WorkListFiltered = CurStt->is_Work? (match_cnt>0) : false;

	//リストボックスの更新
	TListBox *lp = FileListBox[CurListTag];
	lp->Count = lst->Count;
	if (IndexOfFileList(cur_fnam)==-1) lp->ItemIndex = 0;
	FlScrPanel[CurListTag]->UpdateKnob();

	//結果表示
	TPanel *stt_pp = (CurListTag==0)? L_StatPanel : R_StatPanel;
	UnicodeString stt_str = " フィルタ";
	if (match_cnt>0) stt_str.cat_sprintf(_T("\t%u/%u"), lp->ItemIndex + 1, match_cnt);
	stt_pp->Caption = stt_str;
	stt_pp->Repaint();

	//ディレクトリ比較結果を反対側に反映
	if (IsDiffList()) CurToOppDiffList();
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::FilterComboBoxKeyDown(TObject *Sender, WORD &Key, TShiftState Shift)
{
	UnicodeString KeyStr = get_KeyStr(Key, Shift);	if (KeyStr.IsEmpty()) return;
	UnicodeString CmdStr = KeyFuncList->Values["S:" + KeyStr];
	TListBox *lp = FileListBox[CurListTag];
	bool csr_ud  = false;

	if (equal_ESC(KeyStr) || equal_ENTER(KeyStr)) {
		if (FilterComboBox->DroppedDown)
			FilterComboBox->DroppedDown = false;
		else
			lp->SetFocus();
	}
	else if (!FilterComboBox->DroppedDown && MovListBoxFromFilter(lp, KeyStr)) {
		csr_ud = true;
	}
	else if (USAME_TI(CmdStr, "IncSearchUp")) {
		ListBoxCursorUp(lp);
		csr_ud = true;
	}
	else if (USAME_TI(CmdStr, "IncSearchDown")) {
		ListBoxCursorDown(lp);
		csr_ud = true;
	}
	else if (USAME_TI(CmdStr, "KeywordHistory"))				FilterComboBox->DroppedDown = true;
	else if (USAME_TI(CmdStr, "ClearIncKeyword"))				FilterComboBox->Text = EmptyStr;
	else if (USAME_TI(CmdStr, "ClearAll"))						ClearAllAction->Execute();
	else if (contained_wd_i(_T("Select|SelectDown"), CmdStr))	SelectAction->Execute();
	else return;

	if (csr_ud) {
		TPanel *stt_pp = (CurListTag==0)? L_StatPanel : R_StatPanel;
		UnicodeString stt_str = " フィルタ";
		int match_cnt = GetMatchCount(GetCurList());
		if (match_cnt>0) stt_str.cat_sprintf(_T("\t%u/%u"), lp->ItemIndex + 1, match_cnt);
		stt_pp->Caption = stt_str;
		stt_pp->Repaint();

		lp->Invalidate();
		SetFileInf();
	}

	Key = 0;
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::FilterComboBoxKeyPress(TObject *Sender, System::WideChar &Key)
{
	//Ctrl+C, Ctrl+V, Ctrl+X 以外を無効に
	if (Key==VK_RETURN || Key==VK_ESCAPE ||
		(is_KeyDown(VK_CONTROL) && Key!=0x03 && Key!=0x16 && (Key!=0x18 || FilterComboBox->SelText.IsEmpty())))
			Key = 0;
}

//---------------------------------------------------------------------------
//ファイル/ディレクトリ名検索
//---------------------------------------------------------------------------
int __fastcall TNyanFiForm::FindFileCore(
	bool dir_sw,	//ディレクトリ検索 (default = false);
	int tag)		//リストタグ	(default = -1 : CurListTag)
{
	FindBusy = true;
	if (tag!=-1) FindTag = tag;

	flist_stt *cur_stt = &ListStt[FindTag];

	UnicodeString msg;
	StartLog(msg.sprintf(_T("検索開始  %s"), GetSrcPathStr().c_str()));
	AddLog(msg.sprintf(_T("  マスク: %s"), cur_stt->find_Mask.c_str()));
	if (!cur_stt->find_Keywd.IsEmpty()) AddLog(msg.sprintf(_T("  検索語: %s"), cur_stt->find_Keywd.c_str()));

	ShowMessageHint(USTR_SearchingESC, col_bgHint, false, true);
	SttWorkMsg(_T("検索中..."), FindTag);

	TStringList *r_lst = ResultList[FindTag];
	std::unique_ptr<TStringList> o_lst(new TStringList());

	if (dir_sw) cur_stt->is_narrow = false;

	//絞り込みのために現在のリストをコピー
	if (cur_stt->is_narrow) {
		for (int i=1; i<r_lst->Count; i++) {
			file_rec *fp = cre_new_file_rec((file_rec*)r_lst->Objects[i]);
			o_lst->AddObject(fp->f_name, (TObject*)fp);
		}
	}

	//結果リスト初期化
	clear_FileList(r_lst);
	//戻り用
	file_rec *fp = cre_new_up_rec(FindTag);
	fp->f_time = Now();
	fp->p_name = cur_stt->find_Path;
	r_lst->AddObject(fp->f_name, (TObject*)fp);

	//リストボックス初期化(仮想)
	TListBox *lp = FileListBox[FindTag];
	TCanvas  *cv = lp->Canvas;
	cur_stt->lwd_fext = cv->TextWidth(".WWW");
	lp->Color = col_bgFind;
	lp->Count = 1;

	cur_stt->is_Find = true;
	UpdateBgImage();
	SetFlItemWidth(r_lst, FindTag);

	try {
		//絞り込み
		if (cur_stt->is_narrow) {
			if (cur_stt->find_Mask.IsEmpty()) cur_stt->find_Mask = "*.*";
			for (int i=0; i<o_lst->Count && !FindAborted; i++) {
				Application->ProcessMessages();
				file_rec *fp = (file_rec*)o_lst->Objects[i];
				if (fp->is_dummy || fp->is_dir) continue;
				if (!str_match(cur_stt->find_Mask, fp->n_name)) continue;
				if (!check_file_std(fp->n_name, fp->f_time, fp->f_size, fp->f_attr, cur_stt)) continue;
				if (!check_file_ex(fp->f_name, cur_stt)) continue;
				//条件成立
				file_rec *rp = cre_new_file_rec(fp);
				r_lst->AddObject(rp->f_name, (TObject*)rp);
				FindCount = (r_lst->Count>1)? r_lst->Count - 1 : 0;
				//拡張子の幅・位置調整
				set_FextWidth(fp, FindTag);
				//リストボックス更新(仮想)
				update_FileListBoxT(r_lst, FindTag);
				lp->SetFocus();
			}
			clear_FileList(o_lst.get());
		}
		//通常検索
		else {
			if (dir_sw) {
				for (int i=0; i<cur_stt->find_SubList->Count && !FindAborted; i++)
					get_FindListD(cur_stt->find_SubList->Strings[i], cur_stt, r_lst, FindTag);
			}
			else {
				for (int i=0; i<cur_stt->find_SubList->Count && !FindAborted; i++)
					get_FindListF(cur_stt->find_SubList->Strings[i], cur_stt, r_lst, FindTag);
			}
		}
	}
	catch (...) {
		SetActionAbort(USTR_FaildProc);
	}

	if (FindCount>0) {
		int idx = lp->ItemIndex;
		file_rec *cfp = (idx>=0 && idx<r_lst->Count-1)? (file_rec*)r_lst->Objects[idx] : NULL;
		ApplySelMask(r_lst, FindTag);
		cur_stt->find_PathSort = FindPathColumn;
		SortList(r_lst, FindTag);
		SetFlItemWidth(r_lst, FindTag);
		update_FileListBox(r_lst, FindTag, (cfp? r_lst->IndexOfObject((TObject*)cfp) : 0));
		if (tag==-1) lp->SetFocus();
		SetDirCaption(FindTag);
		SetDriveFileInfo(FindTag);
	}
	else {
		cur_stt->is_Find = false;
		ReloadList(FindTag);
	}

	SttWorkMsg(EmptyStr, FindTag);
	FindBusy = false;

	msg = FindAborted? _T("検索中断") : _T("検索終了");
	if (FindCount>0)
		msg.cat_sprintf(_T("  HIT: %u"), FindCount);
	else
		msg.cat_sprintf(_T("  %s"), LoadUsrMsg(USTR_NotFound).c_str());
	AddLog(msg, true);

	return FindAborted? -1 : FindCount;
}

//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::FindDirDlgActionExecute(TObject *Sender)
{
	if (!IsCurFList()) { SetActionAbort(USTR_OpeNotSuported); return; }

	if (OppStt->is_Find) RecoverFileList(OppListTag);

	if (!FindFileDlg) FindFileDlg = new TFindFileDlg(this);	//初回に動的作成
	FindFileDlg->FindDir = true;
	FindFileDlg->Narrow  = false;
	FindFileDlg->ToKeywd = false;
	if (FindFileDlg->ShowModal()==mrOk) {
		Repaint();
		clear_FindStt(CurStt);
		CurStt->find_Mask	 = FindFileDlg->MaskComboBox->Text;
		if (CurStt->find_Mask.IsEmpty()) CurStt->find_Mask = "*";

		CurStt->find_Dir	  = true;
		CurStt->find_SubDir   = true;
		CurStt->find_ResLink  = FindFileDlg->ResLinkCheckBox->Checked;
		CurStt->find_DirLink  = FindFileDlg->DirLinkCheckBox->Checked;
		CurStt->find_Path	  = CurPath[CurListTag];
		CurStt->find_CT_mode  = FindFileDlg->ContRadioGroup->ItemIndex;
		CurStt->find_DT_mode  = FindFileDlg->DateRadioGroup->ItemIndex;
		CurStt->find_DT_value = FindFileDlg->FindDate;
		CurStt->find_DT_str   = FindFileDlg->FindDateStr;
		CurStt->find_AT_mode  = FindFileDlg->AttrRadioGroup->ItemIndex;
		CurStt->find_AT_value = FindFileDlg->FindAttr;
		CurStt->find_Warn	  = FindFileDlg->DirWarnCheckBox->Checked;

		//選択中ディレクトリをリストアップ
		CurStt->find_SubList->Clear();
		TStringList *lst = GetCurList(true);
		for (int i=0; i<lst->Count; i++) {
			file_rec *fp = (file_rec*)lst->Objects[i];
			if (fp->selected) {
				if (fp->is_dir)
					CurStt->find_SubList->Add(fp->f_name);
				else if (test_LibExt(fp->f_ext))
					get_LibraryList(fp->f_name, CurStt->find_SubList);
			}
		}
		//選択していなければカレントを対象に
		if (CurStt->find_SubList->Count==0) {
			CurStt->find_SubList->Add(CurStt->find_Path);
			get_LibraryList(CurStt->find_Path, CurStt->find_SubList);
		}

		if (!CurStt->find_Mask.IsEmpty()) {
			int res = FindFileCore(true);
			if      (res==0)  SttBarWarnUstr(USTR_NotFound);
			else if (res==-1) SttBarWarnUstr(USTR_Canceled);
			else {
				play_sound(SoundFindFin);
				//イベント: 検索結果リストが表示された直後
				ExeEventCommand(OnFindOpend);
			}
		}
	}
}

//---------------------------------------------------------------------------
//フォルダアイコン検索
//---------------------------------------------------------------------------
int __fastcall TNyanFiForm::FindFolderIconCore(int tag)
{
	flist_stt *cur_stt = &ListStt[tag];
	TStringList *r_lst = ResultList[tag];
	clear_FileList(r_lst);

	int r_cnt = 0;
	std::unique_ptr<TStringList> i_lst(new TStringList());
	i_lst->Text = cur_stt->find_Icons;
	if (i_lst->Count==0) return 0;

	CurWorking = true;		//FindBusy は用いない
	FldIcoRWLock->BeginWrite();
	for (int i=0; i<FolderIconList->Count; i++) {
		if (i_lst->IndexOf(to_absolute_name(FolderIconList->ValueFromIndex[i]))!=-1) {
			UnicodeString dnam = IncludeTrailingPathDelimiter(FolderIconList->Names[i]);
			if (!CheckPath(dnam)) continue;

			file_rec *fp = cre_new_file_rec(dnam, CurListTag, true);
			r_lst->AddObject(fp->f_name, (TObject*)fp);
			r_cnt++;
		}
	}
	FldIcoRWLock->EndWrite();
	CurWorking = false;

	if (r_cnt>0) {
		//戻り用
		file_rec *fp = cre_new_up_rec(tag);
		fp->f_time = Now();
		fp->p_name = CurPath[tag];
		r_lst->InsertObject(0, fp->f_name, (TObject*)fp);

		//リストボックス初期化(仮想)
		TListBox *lp = FileListBox[tag];
		lp->Color = col_bgFind;
		UpdateBgImage();
		SetFlItemWidth(r_lst, tag);
		update_FileListBox(r_lst, tag, 0);
		ViewCurFileInf();
		SetDirCaption(tag);
		SetDriveFileInfo(tag);

		ExeEventCommand(OnFindOpend);
	}

	return r_cnt;
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::FindFolderIconActionExecute(TObject *Sender)
{
	try {
		if (OppStt->is_Find) RecoverFileList(OppListTag);

		if (!TagManDlg) TagManDlg = new TTagManDlg(this);	//初回に動的作成
		TagManDlg->CmdStr = "FindFolderIcon";
		if (TagManDlg->ShowModal()!=mrOk) SkipAbort();

		std::unique_ptr<TStringList> ico_lst(new TStringList());
		TCheckListBox *i_lp = TagManDlg->TagCheckListBox;
		for (int i=0; i<i_lp->Count; i++) if (i_lp->Checked[i]) ico_lst->Add(i_lp->Items->Strings[i]);
		if (ico_lst->Count==0) SkipAbort();

		clear_FindStt(CurStt);
		CurStt->is_Find 	  = true;
		CurStt->find_Path	  = CurPath[CurListTag];
		CurStt->find_DICON	  = true;
		CurStt->find_Icons	  = ico_lst->Text;
		CurStt->find_ResLink  = TagManDlg->ResLinkCheckBox->Checked;
		CurStt->find_PathSort = FindPathColumn;
		if (FindFolderIconCore(CurListTag)==0) RecoverFileList(CurListTag);
	}
	catch (EAbort &e) {
		SetActionAbort(e.Message);
	}
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::FindFolderIconActionUpdate(TObject *Sender)
{
	TAction *ap = (TAction*)Sender;
	ap->Visible = ScrMode==SCMD_FLIST;
	ap->Enabled = ap->Visible && FolderIconList->Count>0;
}

//---------------------------------------------------------------------------
//重複ファイルの検索
//---------------------------------------------------------------------------
int __fastcall comp_FileSize(TStringList *List, int Index1, int Index2)
{
	__int64 *p1 = (__int64*)List->Objects[Index1];
	__int64 *p2 = (__int64*)List->Objects[Index2];
	__int64 sz1 = p1? *p1 : 0;
	__int64 sz2 = p2? *p2 : 0;
	return (sz1 - sz2);
}
//---------------------------------------------------------------------------
int __fastcall comp_FilePath(TStringList *List, int Index1, int Index2)
{
	UnicodeString fnam1 = List->Strings[Index1];
	UnicodeString fnam2 = List->Strings[Index2];
	UnicodeString pnam1 = ExtractFilePath(fnam1);
	UnicodeString pnam2 = ExtractFilePath(fnam2);
	int res = NaturalOrder? StrCmpLogicalW(pnam1.c_str(), pnam2.c_str()) : CompareText(pnam1, pnam2);
	if (res==0) res = NaturalOrder? StrCmpLogicalW(fnam1.c_str(), fnam2.c_str()) : CompareText(fnam1, fnam2);
	return res;
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::FindDuplDlgActionExecute(TObject *Sender)
{
	try {
		if (CurStt->is_Arc || CurStt->is_ADS || CurStt->is_FTP || IsDiffList()) UserAbort(USTR_OpeNotSuported);
		if (OppStt->is_Find) RecoverFileList(OppListTag);

		if (!FindDuplDlg) FindDuplDlg = new TFindDuplDlg(this);	//初回に動的作成
		FindDuplDlg->OppPathCheckBox->Enabled = (IsOppFList() && !EqualDirLR());
		FindDuplDlg->SubDirCheckBox->Enabled  = IsCurFList();
		if (FindDuplDlg->ShowModal()!=mrOk) SkipAbort();

		CurWorking = true;
		CancelWork = false;
		FindTag    = CurListTag;

		UnicodeString msg;
		StartLog(msg.sprintf(_T("検索開始  %s"), CurPath[CurListTag].c_str()));
		SttWorkMsg(_T("重複ファイルの検索中..."), CurListTag);
		ShowMessageHintEsc("検索中...");

		__int64 max_sz		 = FindDuplDlg->MaxSizeEdit->Text.ToIntDef(64) * 1048576ul;
		CurStt->find_ResLink = FindDuplDlg->ResLinkCheckBox->Checked;
		CurStt->find_Path	 = CurPath[CurListTag];

		UnicodeString idstr = get_word_i_idx(HASH_ID_STR, FindDuplDlg->AlgRadioGroup->ItemIndex);
		AddLog(msg.sprintf(_T("  ハッシュ: %s"), idstr.c_str()));

		bool sub_sw  = (FindDuplDlg->SubDirCheckBox->Enabled && FindDuplDlg->SubDirCheckBox->Checked);
		bool exc_sym = FindDuplDlg->ExcSymCheckBox->Checked;

		//対象を取得
		std::unique_ptr<TStringList> f_lst(new TStringList());
		CancelWork = !get_NameList_objSize(GetCurList(true), f_lst.get(), sub_sw, exc_sym);

		if (!CancelWork && !EqualDirLR()
			&& FindDuplDlg->OppPathCheckBox->Enabled && FindDuplDlg->OppPathCheckBox->Checked)
		{
			AddLog(msg.sprintf(_T("  反対パス: %s"), CurPath[OppListTag].c_str()));
			if (get_NameList_objSize(GetOppList(), f_lst.get(), sub_sw, exc_sym)) {
				//重複を削除
				f_lst->Sort();
				int i = 0;
				while (i < f_lst->Count-1) {
					if (i%ESC_INTERVAL==0 && is_KeyPress_ESC()) { CancelWork = true; break; }
					if (SameText(f_lst->Strings[i], f_lst->Strings[i + 1])) {
						delete (__int64*)f_lst->Objects[i];
						f_lst->Delete(i);
					} else i++;
				}
			}
			else CancelWork = true;
		}

		if (!CancelWork) {
			f_lst->CustomSort(comp_FileSize);

			//同サイズのファイルを抽出
			ShowMessageHintEsc("サイズチェック中...");
			int idx = 0;
			bool s_flag = false;
			while (idx < f_lst->Count) {
				if (idx%ESC_INTERVAL==0 && is_KeyPress_ESC()) { CancelWork = true; break; }

				__int64 *sz = (__int64*)f_lst->Objects[idx];
				bool del = (*sz==0 || *sz>max_sz);
				if (!del) {
					if (idx < f_lst->Count-1) {
						__int64 *sz2 = (__int64*)f_lst->Objects[idx + 1];
						if (*sz==*sz2) {
							s_flag = true;
						}
						else {
							del = !s_flag;
							s_flag = false;
						}
					}
					else {
						del = !s_flag;
					}
				}

				if (del) {
					delete sz;
					f_lst->Delete(idx);
				}
				else idx++;
			}
			ShowMessageHint();
		}

		if (!CancelWork && f_lst->Count>=2) {
			//ハッシュ値を取得
			for (int ps=0; ps<2 && !CancelWork; ps++) {
				BeginWorkProgress(_T("ハッシュ値取得中..."),
					msg.sprintf(_T("%s (%u)"), (ps==0)? _T("簡易") : _T("全体"), f_lst->Count),
					FileListBox[CurListTag]);
				for (int i=0; i<f_lst->Count; i++) {
					PosWorkProgress(i, f_lst->Count);
					if (is_KeyPress_ESC()) { CancelWork = true; break; }

					__int64 *sz = (__int64*)f_lst->Objects[i];
					//1パス目 先頭32KBで簡易チェック
					if (ps==0) {
						UnicodeString fnam = f_lst->Strings[i];
						f_lst->Strings[i]  = get_HashStr(fnam, idstr, true) + "\t" + fnam;
					}
					//2パス目 全体チェック
					else if (*sz>FILE_RBUF_SIZE) {
						UnicodeString fnam = get_post_tab(f_lst->Strings[i]);
						f_lst->Strings[i]  = get_HashStr(fnam, idstr) + "\t" + fnam;
					}
				}
				EndWorkProgress(EmptyStr, " ");

				if (!CancelWork) {
					ShowMessageHint(USTR_WaitForReady, col_bgHint, false, true);
					//同ハッシュ値のファイルを抽出
					f_lst->Sort();
					int idx = 0;
					bool h_flag = false;
					while (idx < f_lst->Count) {
						bool del = false;
						if (idx < f_lst->Count-1) {
							if (SameStr(get_pre_tab(f_lst->Strings[idx]), get_pre_tab(f_lst->Strings[idx + 1]))) {
								h_flag = true;
							}
							else {
								del = !h_flag;
								h_flag = false;
							}
						}
						else {
							del = !h_flag;
						}

						if (del) {
							delete (__int64*)f_lst->Objects[idx];
							f_lst->Delete(idx);
						} else idx++;
					}
					ShowMessageHint();
				}
			}
		}

		//後片付け
		for (int i=0; i<f_lst->Count; i++) delete (__int64*)f_lst->Objects[i];

		if (!CancelWork) {
			UnicodeString res_str;
			if (f_lst->Count>=2) {
				ShowMessageHint(USTR_WaitForReady, col_bgHint, false, true);
				//ハッシュ値別リストを作成
				std::unique_ptr<TStringList> hs_lst(new TStringList());
				UnicodeString hash0;
				int idx = -1;
				for (int i=0; i<f_lst->Count; i++) {
					UnicodeString hash = get_pre_tab(f_lst->Strings[i]);
					UnicodeString fnam = get_post_tab(f_lst->Strings[i]);
					if (!SameStr(hash0, hash)) {
						hash0 = hash;
						TStringList *s_lst = new TStringList();
						s_lst->Add(fnam + "\t" + hash);
						idx = hs_lst->AddObject(fnam, (TObject*)s_lst);
					}
					else if (idx!=-1) {
						TStringList *s_lst = (TStringList *)hs_lst->Objects[idx];
						s_lst->Add(fnam + "\t" + hash);
					}
				}
				for (int i=0; i<hs_lst->Count; i++) {
					TStringList *s_lst = (TStringList *)hs_lst->Objects[i];
					s_lst->CustomSort(comp_FilePath);
					hs_lst->Strings[i] = get_pre_tab(s_lst->Strings[0]);
				}
				hs_lst->CustomSort(comp_FilePath);

				TStringList *r_lst = ResultList[FindTag];
				clear_FileList(r_lst);

				//戻り用
				file_rec *fp = cre_new_up_rec(FindTag);
				fp->f_time = Now();
				fp->p_name = CurStt->find_Path;
				r_lst->AddObject(fp->f_name, (TObject*)fp);

				for (int i=0; i<hs_lst->Count; i++) {
					//セパレータ
					if (i>0) {
						file_rec *fp = cre_new_file_rec("-");
						r_lst->AddObject(EmptyStr, (TObject*)fp);
					}
					//項目
					TStringList *s_lst = (TStringList *)hs_lst->Objects[i];
					for (int j=0; j<s_lst->Count; j++) {
						UnicodeString lbuf = s_lst->Strings[j];
						file_rec *fp = cre_new_file_rec(get_pre_tab(lbuf));
						fp->hash = get_post_tab(lbuf);
						r_lst->AddObject(fp->f_name, (TObject*)fp);
					}
				}
				for (int i=0; i<hs_lst->Count; i++) delete (TStringList*)hs_lst->Objects[i];
				res_str.cat_sprintf(_T("  HIT: %u (%u Files)"), hs_lst->Count, f_lst->Count);

				//リストボックス初期化(仮想)
				CurStt->is_Find 	  = true;
				CurStt->find_DUPL	  = true;
				CurStt->find_PathSort = FindPathColumn;
				TListBox *lp = FileListBox[FindTag];
				lp->Color = col_bgFind;
				UpdateBgImage();
				SetFlItemWidth(r_lst, FindTag);
				update_FileListBox(r_lst, FindTag, 0);
				ViewCurFileInf();
				SetDirCaption(FindTag);
				SetDriveFileInfo(FindTag);
				ShowMessageHint();
			}

			msg = "検索終了";
			if (f_lst->Count<2) {
				AddLog(msg.cat_sprintf(_T("  %s"), LoadUsrMsg(USTR_NotFound).c_str()));
				SttBarWarnUstr(USTR_NotFound);
			}
			else
				AddLog(msg + res_str, true);
			SttWorkMsg(EmptyStr, FindTag);
		}
		else {
			ClearKeyBuff(true);
			msg = "比較中断";
			SttWorkMsg(msg, FindTag);
			AddLog(msg);
			beep_Warn();
		}

		CurWorking = false;
	}
	catch (EAbort &e) {
		SttWorkMsg(EmptyStr, FindTag);
		SetActionAbort(e.Message);
	}
}

//---------------------------------------------------------------------------
//ファイル(/ディレクトリ)名検索ダイアログ
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::FindFileDlgExecute(
	bool both)			//ファイル/ディレクトリの両方を検索
{
	if (!FindFileDlg) FindFileDlg = new TFindFileDlg(this);	//初回に動的作成
	FindFileDlg->FindDir  = false;
	FindFileDlg->FindBoth = both;
	FindFileDlg->Narrow   = CurStt->is_narrow;
	FindFileDlg->NoMask   = TEST_ActParam("NM");	//マスク欄非表示
	FindFileDlg->ToKeywd  = TEST_ActParam("FK");	//検索語欄にフォーカス

	FindFileDlg->SubDirCheckBox->Checked
		= TEST_ActParam("R0")? false :
		  TEST_ActParam("R1")? true : IniFile->ReadBoolGen(_T("FindSubDir"), true);

	if (!FindFileDlg->FindBoth && !FindFileDlg->NoMask) {
		FindFileDlg->ExtraCheckBox->Checked
			= TEST_ActParam("X0")? false :
			  TEST_ActParam("X1")? true : IniFile->ReadBoolGen(_T("FindExtra"));
	}

	if (!FindFileDlg->FindBoth) {
		FindFileDlg->ArcCheckBox->Checked
			= TEST_ActParam("A0")? false :
			  TEST_ActParam("A1")? true : IniFile->ReadBoolGen(_T("FindArchive"));
	}

	if (FindFileDlg->ShowModal()==mrOk) {
		Repaint();
		clear_FindStt(CurStt);
		CurStt->find_Path	 = CurPath[CurListTag];
		CurStt->find_Both	 = FindFileDlg->FindBoth;
		CurStt->find_SubDir	 = FindFileDlg->SubDirCheckBox->Checked;
		CurStt->find_Arc	 = FindFileDlg->ArcCheckBox->Checked;
		CurStt->find_ResLink = FindFileDlg->ResLinkCheckBox->Checked;
		CurStt->find_DirLink = both? FindFileDlg->DirLinkCheckBox->Checked : false;
		CurStt->find_Mask	 = FindFileDlg->MaskComboBox->Text;
		if (CurStt->find_Mask.IsEmpty()) CurStt->find_Mask = "*.*";
		CurStt->find_Keywd	  = FindFileDlg->KeywordComboBox->Text;
		CurStt->find_RegEx	  = FindFileDlg->RegExCheckBox->Checked;
		CurStt->find_And	  = FindFileDlg->AndCheckBox->Checked;
		CurStt->find_Case	  = FindFileDlg->CaseCheckBox->Checked;
		CurStt->find_DT_mode  = FindFileDlg->DateRadioGroup->ItemIndex;
		CurStt->find_DT_value = FindFileDlg->FindDate;
		CurStt->find_DT_str   = FindFileDlg->FindDateStr;
		CurStt->find_SZ_mode  = FindFileDlg->SizeRadioGroup->ItemIndex;
		CurStt->find_SZ_value = EditToInt(FindFileDlg->SizeEdit);

		if      (FindFileDlg->KBRadioButton->Checked) CurStt->find_SZ_value *= 1024;
		else if (FindFileDlg->MBRadioButton->Checked) CurStt->find_SZ_value *= 1048576ul;
		else if (FindFileDlg->GBRadioButton->Checked) CurStt->find_SZ_value *= 1073741824ull;
		CurStt->find_AT_mode  = FindFileDlg->AttrRadioGroup->ItemIndex;
		CurStt->find_AT_value = FindFileDlg->FindAttr;

		CurStt->find_TM_mode  = FindFileDlg->hasTime? FindFileDlg->TimeRadioGroup->ItemIndex : 0;
		CurStt->find_TM_value = FindFileDlg->FindTime;

		CurStt->find_RT_mode  = FindFileDlg->hasRate? FindFileDlg->RateRadioGroup->ItemIndex : 0;
		CurStt->find_RT_value = FindFileDlg->FindRate;

		//コードページ
		if (FindFileDlg->hasCode) {
			UnicodeString lbuf = FindFileDlg->CodePageComboBox->Text;
			CurStt->find_codepage = lbuf.IsEmpty()? -1 : get_tkn(lbuf, ':').ToIntDef(0);
			CurStt->find_LineBrk  = FindFileDlg->LineBrkComboBox->Text;
			CurStt->find_BOM_mode = FindFileDlg->BomRadioGroup->Enabled? FindFileDlg->BomRadioGroup->ItemIndex : 0;
		}
		else {
			CurStt->find_codepage = -1;
			CurStt->find_LineBrk  = EmptyStr;
			CurStt->find_BOM_mode = 0;
		}

		//動画
		if (FindFileDlg->hasFrame) {
			CurStt->find_FS_mode  = FindFileDlg->FpsRadioGroup->ItemIndex;
			CurStt->find_FS_value = FindFileDlg->FindFps;
			CurStt->find_FW_mode  = FindFileDlg->FrWdRadioGroup->ItemIndex;
			CurStt->find_FW_value = FindFileDlg->FindFrWd;
			CurStt->find_FH_mode  = FindFileDlg->FrHiRadioGroup->ItemIndex;
			CurStt->find_FH_value = FindFileDlg->FindFrHi;
		}
		else CurStt->find_FS_mode = CurStt->find_FW_mode = CurStt->find_FH_mode = 0;

		//画像
		if (FindFileDlg->hasImage) {
			CurStt->find_IW_mode  = FindFileDlg->ImgWdRadioGroup->ItemIndex;
			CurStt->find_IW_value = FindFileDlg->FindImgWd;
			CurStt->find_IH_mode  = FindFileDlg->ImgHiRadioGroup->ItemIndex;
			CurStt->find_IH_value = FindFileDlg->FindImgHi;
			CurStt->find_IWH_max  = FindFileDlg->ImgMaxCheckBox->Checked;
		}
		else CurStt->find_IW_mode = CurStt->find_IH_mode = 0;

		//Exif
		if (FindFileDlg->hasExif) {
			CurStt->find_ExifKwd   = FindFileDlg->ExifKwdEdit->Text;
			CurStt->find_ExifRegEx = FindFileDlg->ExifRegExCheckBox->Checked;
			CurStt->find_ExifAnd   = FindFileDlg->ExifAndCheckBox->Checked;
			CurStt->find_ExifCase  = FindFileDlg->ExifCaseCheckBox->Checked;
			CurStt->find_LatLng    = FindFileDlg->LatLngComboBox->Text;
			//GPS
			if (!CurStt->find_LatLng.IsEmpty()) {
				try {
					UnicodeString lbuf = CurStt->find_LatLng;
					if (lbuf.Pos(':')>0) lbuf = Trim(get_tkn_r(lbuf, ':'));
					CurStt->find_GpsLat   = Trim(split_tkn(lbuf, ',')).ToDouble();
					CurStt->find_GpsLng   = Trim(lbuf).ToDouble();
					CurStt->find_GpsRange = EditToInt(FindFileDlg->GpsRangeEdit, 0);
					if (CurStt->find_GpsRange==0) Abort();
				}
				catch (...) {
					CurStt->find_LatLng = EmptyStr;
				}
			}
		}
		else CurStt->find_ExifKwd = CurStt->find_LatLng = EmptyStr;

		//WAV
		if (FindFileDlg->hasFormat) {
			CurStt->find_SR_mode  = FindFileDlg->SmplRadioGroup->ItemIndex;
			CurStt->find_SR_value = FindFileDlg->FindSmpl;
			CurStt->find_BT_mode  = FindFileDlg->BitRadioGroup->ItemIndex;
			CurStt->find_CH_mode  = FindFileDlg->ChnRadioGroup->ItemIndex;
		}
		else CurStt->find_SR_mode = CurStt->find_BT_mode = CurStt->find_CH_mode = 0;

		//ファイル情報
		if (FindFileDlg->hasProp) {
			CurStt->find_PrpKwd   = FindFileDlg->PrpKwdEdit->Text;
			CurStt->find_PrpRegEx = FindFileDlg->PrpRegExCheckBox->Checked;
			CurStt->find_PrpAnd   = FindFileDlg->PrpAndCheckBox->Checked;
			CurStt->find_PrpCase  = FindFileDlg->PrpCaseCheckBox->Checked;
		}
		else CurStt->find_PrpKwd = EmptyStr;

		//テキスト
		if (FindFileDlg->hasText) {
			CurStt->find_TxtKwd   = FindFileDlg->TxtKwdComboBox->Text;
			CurStt->find_TxtRegEx = FindFileDlg->TxtRegExCheckBox->Checked;
			CurStt->find_TxtAnd   = FindFileDlg->TxtAndCheckBox->Checked;
			CurStt->find_TxtCase  = FindFileDlg->TxtCaseCheckBox->Checked;
		}
		else CurStt->find_TxtKwd = EmptyStr;

		//アイコン
		if (FindFileDlg->hasIcon) {
			CurStt->find_IC_mode  = FindFileDlg->IconRadioGroup->ItemIndex;
			CurStt->find_IC_value = FindFileDlg->FindIcon;
		}
		else CurStt->find_IC_mode = 0;

		//タグ
		if (FindFileDlg->hasTags) {
			CurStt->find_Tags = FindFileDlg->TagsComboBox->Text;
		}
		else CurStt->find_Tags = EmptyStr;

		//リンクカウント数
		if (FindFileDlg->hasLCnt) {
			CurStt->find_HL_mode  = FindFileDlg->LCntRadioGroup->ItemIndex;
			CurStt->find_HL_value = FindFileDlg->FindLnkCnt;
		}
		else CurStt->find_HL_mode = 0;

		//その他
		if (FindFileDlg->hasOther) {
			CurStt->find_hasAds  = FindFileDlg->HasAdsCheckBox->Checked;
			CurStt->find_useProc = FindFileDlg->UseProcCheckBox->Checked;
			CurStt->find_Warn	 = FindFileDlg->NameWarnCheckBox->Checked;
		}
		else {
			CurStt->find_hasAds = CurStt->find_Warn = false;
		}

		if (!CurStt->is_narrow) {
			//選択中ディレクトリをリストアップ
			CurStt->find_SubList->Clear();
			TStringList *lst = GetCurList(true);
			for (int i=0; i<lst->Count; i++) {
				file_rec *fp = (file_rec*)lst->Objects[i];
				if (fp->selected) {
					if (fp->is_dir)
						CurStt->find_SubList->Add(fp->f_name);
					else if (test_LibExt(fp->f_ext))
						get_LibraryList(fp->f_name, CurStt->find_SubList);
				}
			}
			//選択していなければカレントを対象に
			if (CurStt->find_SubList->Count==0) {
				CurStt->find_SubList->Add(CurStt->find_Path);
				if (CurStt->find_SubDir) get_LibraryList(CurStt->find_Path, CurStt->find_SubList);
			}
		}

		if (!CurStt->find_Mask.IsEmpty()) {
			int res = FindFileCore();
			if      (res==0)  SttBarWarnUstr(USTR_NotFound);
			else if (res==-1) SttBarWarnUstr(USTR_Canceled);
			else {
				play_sound(SoundFindFin);
				//イベント: 検索結果リストが表示された直後
				ExeEventCommand(OnFindOpend);
			}
		}
	}
}

//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::FindFileDlgActionExecute(TObject *Sender)
{
	if (CurStt->is_Arc || CurStt->is_Work) {
		SetActionAbort();
	}
	else {
		if (OppStt->is_Find) RecoverFileList(OppListTag);
		CurStt->is_narrow = CurStt->is_Find;
		FindFileDlgExecute(false);
	}
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::FindFileDirDlgActionExecute(TObject *Sender)
{
	if (!IsCurFList()) { SetActionAbort(USTR_OpeNotSuported); return; }

	if (OppStt->is_Find) RecoverFileList(OppListTag);
	CurStt->is_narrow = false;
	FindFileDlgExecute(true);
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::FindDlgActionUpdate(TObject *Sender)
{
	TAction *ap = (TAction*)Sender;
	ap->Visible = ScrMode==SCMD_FLIST;
	ap->Enabled = ap->Visible && !FindBusy;
}

//---------------------------------------------------------------------------
//ハードリンクを列挙
//---------------------------------------------------------------------------
int __fastcall TNyanFiForm::FindHardLinkCore(UnicodeString fnam, int tag)
{
	CurWorking = true;		//FindBusy は用いない
	int hl_cnt = 0;

	//fsutil で一覧を取得
	UnicodeString drvstr = ExtractFileDrive(fnam);
	UnicodeString prm;
	prm.sprintf(_T("hardlink list \"%s\""), fnam.c_str());
	std::unique_ptr<TStringList> o_lst(new TStringList());
	DWORD exit_code;
	if (Execute_ex("fsutil", prm, ExtractFileDir(fnam), "OH", &exit_code, o_lst.get()) && exit_code==0) {
		hl_cnt = o_lst->Count;
		flist_stt *cur_stt = &ListStt[tag];
		cur_stt->is_Find	= true;
		cur_stt->find_HLINK = true;
		cur_stt->find_Path	= IncludeTrailingPathDelimiter(drvstr);
		cur_stt->find_Name	= fnam;

		TStringList *r_lst = ResultList[tag];
		clear_FileList(r_lst);
		//戻り用
		file_rec *fp = cre_new_up_rec(tag);
		fp->f_time = Now();
		fp->p_name = cur_stt->find_Path;
		r_lst->AddObject(fp->f_name, (TObject*)fp);

		for (int i=0; i<o_lst->Count; i++) {
			file_rec *fp = cre_new_file_rec(drvstr + o_lst->Strings[i], tag);
			if (fp) r_lst->AddObject(fp->f_name, (TObject*)fp);
		}

		ApplySelMask(r_lst, tag);
		SortList(r_lst, tag);
		SetFlItemWidth(r_lst, tag);

		//リストボックス更新(仮想)
		TListBox *lp = FileListBox[tag];
		lp->Color = col_bgFind;
		lp->Count = r_lst->Count;
		IndexOfFileList(fnam, tag);

		SetFileInf();
		SetDirCaption(tag);
		SetDriveFileInfo(tag);
	}

	CurWorking = false;

	return hl_cnt;
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::FindHardLinkActionExecute(TObject *Sender)
{
	try {
		if (CurStt->is_Arc || CurStt->is_ADS || CurStt->is_FTP || StartsStr("\\\\", CurPath[CurListTag]))
			UserAbort(USTR_CantOperate);

		file_rec *fp = GetCurFrecPtr(true);  if (!fp) Abort();
		if (fp->is_dir) UserAbort(USTR_IncludeDir);
		if (get_HardLinkCount(fp->f_name)<2) TextAbort(_T("ハードリンクではありません。"));

		if (OppStt->is_Find) RecoverFileList(OppListTag);

		clear_FindStt(CurStt);
		CurStt->find_ResLink  = TEST_DEL_ActParam("OP");
		CurStt->find_PathSort = FindPathColumn;
		if (FindHardLinkCore(fp->f_name, CurListTag)==0) Abort();
		//イベント: 検索結果リストが表示された直後
		ExeEventCommand(OnFindOpend);
	}
	catch (EAbort &e) {
		SetActionAbort(e.Message);
	}
}

//---------------------------------------------------------------------------
//マーク項目を検索
//---------------------------------------------------------------------------
int __fastcall TNyanFiForm::FindMarkCore(int tag)
{
	FindBusy = true;
	if (tag!=-1) FindTag = tag;

	flist_stt *cur_stt = &ListStt[FindTag];
	TStringList *r_lst = ResultList[FindTag];
	clear_FileList(r_lst);

	//戻り用
	file_rec *fp = cre_new_up_rec(FindTag);
	fp->f_time = Now();
	fp->p_name = cur_stt->find_Path;
	r_lst->AddObject(fp->f_name, (TObject*)fp);

	//リストボックス初期化(仮想)
	TListBox *lp = FileListBox[FindTag];
	lp->Color = col_bgFind;
	lp->Count = 1;

	//検索
	cur_stt->is_Find = true;
	UpdateBgImage();

	IniFile->CheckMarkItems();
	for (int i=0; i<IniFile->MarkIdxList->Count; i++) {
		UnicodeString dnam = IniFile->MarkIdxList->Strings[i];
		if (!CheckPath(dnam)) continue;

		TStringList *klist = (TStringList*)(IniFile->MarkIdxList->Objects[i]);
		//対象ディレクトリ以下
		if (cur_stt->find_SubList->Count>0) {
			for (int j=0; j<cur_stt->find_SubList->Count; j++) {
				if (!StartsText(cur_stt->find_SubList->Strings[j], dnam)) continue;
				for (int k=0; k<klist->Count; k++) {
					UnicodeString fnam = dnam + get_pre_tab(klist->Strings[k]);
					if (dir_exists(fnam)) fnam = IncludeTrailingPathDelimiter(fnam);
					file_rec *fp = cre_new_file_rec(fnam, FindTag);
					if (fp) r_lst->AddObject(fp->f_name, (TObject*)fp);
				}
			}
		}
		//すべて列挙
		else {
			for (int k=0; k<klist->Count; k++) {
				UnicodeString fnam = dnam + get_pre_tab(klist->Strings[k]);
				if (dir_exists(fnam)) fnam = IncludeTrailingPathDelimiter(fnam);
				file_rec *fp = cre_new_file_rec(fnam, FindTag);
				if (fp) r_lst->AddObject(fp->f_name, (TObject*)fp);
			}
		}
		FindCount = (r_lst->Count>1)? r_lst->Count - 1 : 0;
	}

	if (FindCount>0) {
		int idx = lp->ItemIndex;
		file_rec *cfp = (idx>=0 && idx<r_lst->Count-1)? (file_rec*)r_lst->Objects[idx] : NULL;
		ApplySelMask(r_lst, FindTag);
		SortList(r_lst, FindTag);
		SetFlItemWidth(r_lst, FindTag);
		update_FileListBox(r_lst, FindTag, (cfp? r_lst->IndexOfObject((TObject*)cfp) : 0));
		SetDirCaption(FindTag);
		SetDriveFileInfo(FindTag);
	}
	else {
		cur_stt->is_Find = false;
		ReloadList(FindTag);
	}

	SttWorkMsg(EmptyStr, FindTag);
	FindBusy = false;

	return FindCount;
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::FindMarkActionExecute(TObject *Sender)
{
	if (CurStt->is_Arc || CurStt->is_ADS || CurStt->is_Work || (CurStt->is_Find && !CurStt->find_MARK)) {
		SetActionAbort(USTR_CantOperate);  return;
	}

	if (OppStt->is_Find) RecoverFileList(OppListTag);

	clear_FindStt(CurStt);
	CurStt->find_MARK	  = true;
	CurStt->find_Path	  = CurPath[CurListTag];
	CurStt->find_ResLink  = TEST_ActParam("OP");
	CurStt->find_PathSort = FindPathColumn;

	//選択中ディレクトリをリストアップ
	CurStt->find_SubList->Clear();
	if (!TEST_ActParam("AL")) {
		TStringList *lst = GetCurList(true);
		for (int i=0; i<lst->Count; i++) {
			file_rec *fp = (file_rec*)lst->Objects[i];
			if (fp->is_dir && fp->selected) CurStt->find_SubList->Add(fp->f_name);
		}
		//選択していなければカレントを対象に
		if (CurStt->find_SubList->Count==0) CurStt->find_SubList->Add(CurStt->find_Path);
	}

	FindMarkCore();
	SetFileInf();
	//イベント: 検索結果リストが表示された直後
	ExeEventCommand(OnFindOpend);
}

//---------------------------------------------------------------------------
//タグ検索
//---------------------------------------------------------------------------
int __fastcall TNyanFiForm::FindTagCore(int tag)
{
	FindBusy = true;
	if (tag!=-1) FindTag = tag;

	SttWorkMsg(_T("検索中..."), FindTag);

	flist_stt *cur_stt = &ListStt[FindTag];
	TStringList *r_lst = ResultList[FindTag];
	clear_FileList(r_lst);

	std::unique_ptr<TStringList> r_buf(new TStringList());
	if (cur_stt->find_TAG_all)
		usr_TAG->GetAllList(r_buf.get());
	else
		usr_TAG->GetMatchList(cur_stt->find_Keywd, cur_stt->find_And, r_buf.get());

	FindCount = 0;
	if (r_buf->Count>0) {
		//戻り用
		file_rec *fp = cre_new_up_rec(FindTag);
		fp->f_time = Now();
		fp->p_name = cur_stt->find_Path;
		r_lst->AddObject(fp->f_name, (TObject*)fp);

		//リストボックス初期化(仮想)
		TListBox *lp = FileListBox[FindTag];
		lp->Color = col_bgFind;
		lp->Count = 1;
		cur_stt->is_Find = true;
		UpdateBgImage();

		std::unique_ptr<TStringList> ng_drv_lst(new TStringList());
		for (int i=0; i<r_buf->Count; i++) {
			UnicodeString lbuf = r_buf->Strings[i];
			UnicodeString fnam = get_pre_tab(lbuf);

			//無効なドライブはスキップ
			UnicodeString drv_str = get_drive_str(fnam);
			if (ng_drv_lst->IndexOf(drv_str)!=-1) continue;
			if (!is_drive_accessible(drv_str)) {
				ng_drv_lst->Add(drv_str);
				continue;
			}

			//存在しない項目は削除
			int attr = file_GetAttr(fnam);
			if (attr==faInvalid) {
				usr_TAG->DelItem(fnam);
				continue;
			}

			if ((attr & faDirectory)!=0) fnam = IncludeTrailingPathDelimiter(fnam);

			file_rec *fp = cre_new_file_rec(fnam, FindTag);
			fp->tags = get_post_tab(lbuf);
			r_lst->AddObject(fp->f_name, (TObject*)fp);
			FindCount++;
		}

		usr_TAG->UpdateFile();

		ApplySelMask(r_lst, FindTag);
		cur_stt->find_PathSort = FindPathColumn;
		SortList(r_lst, FindTag);
		SetFlItemWidth(r_lst, FindTag);
		update_FileListBox(r_lst, FindTag);

		SetFileInf();
		SetDirCaption(FindTag);
		SetDriveFileInfo(FindTag);
	}
	else {
		cur_stt->is_Find = false;
		ReloadList(FindTag);
	}

	SttWorkMsg(EmptyStr, FindTag);
	FindBusy = false;

	return FindCount;
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::FindTagActionExecute(TObject *Sender)
{
	try {
		if (!IsCurFList())   RecoverFileList();
		if (OppStt->is_Find) RecoverFileList(OppListTag);

		usr_TAG->Recycle();

		clear_FindStt(CurStt);
		CurStt->find_TAG  = true;
		CurStt->find_Path = CurPath[CurListTag];

		//パラメータ指定(; の場合入力ボックス)
		if (!ActionParam.IsEmpty()) {
			UnicodeString tags = ActionParam;
			if (USAME_TS(tags, "*")) {
				CurStt->find_TAG_all = true;
			}
			else if (USAME_TS(tags, ";")) {
				InputExDlg->IpuntExMode = INPEX_FIND_TAG;
				InputExDlg->InputComboBox->Text = EmptyStr;
				tags = (InputExDlg->ShowModal()==mrOk)? InputExDlg->InputComboBox->Text : EmptyStr;
				if (tags.IsEmpty()) SkipAbort();
			}
			CurStt->find_And	 = (tags.Pos('|')==0);
			CurStt->find_Keywd	 = ReplaceStr(tags, "|", ";");
			CurStt->find_ResLink = IniFile->ReadBoolGen(_T("FindTagResLink"));
		}
		//ダイアログ
		else {
			if (!TagManDlg) TagManDlg = new TTagManDlg(this);	//初回に動的作成
			TagManDlg->CmdStr = "FindTag";
			TagManDlg->TagEdit->Text = EmptyStr;
			if (TagManDlg->ShowModal()!=mrOk) SkipAbort();
			CurStt->find_Keywd	 = TagManDlg->TagEdit->Text;
			CurStt->find_And	 = TagManDlg->AndCheckBox->Checked;
			CurStt->find_ResLink = TagManDlg->ResLinkCheckBox->Checked;
		}

		CurStt->find_Keywd = usr_TAG->NormTags(CurStt->find_Keywd, false);
		if (CurStt->find_Keywd.IsEmpty()) SkipAbort();

		if (FindTagCore(CurListTag)==0) Abort();

		//イベント: 検索結果リストが表示された直後
		ExeEventCommand(OnFindOpend);
	}
	catch (EAbort &e) {
		SetActionAbort(e.Message);
	}
}

//---------------------------------------------------------------------------
//タグ名検索
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::FindTagNameActionExecute(TObject *Sender)
{
	try {
		if (!FindTagForm) FindTagForm = new TFindTagForm(this);	//初回に動的作成
		FindTagForm->TagCmd   = TEST_ActParam("EJ")? "EDIT" : "VIEW";
		FindTagForm->TagFile  = get_tags_file((ScrMode==SCMD_TVIEW)? TxtViewer->FileName : CurPath[CurListTag]);
		FindTagForm->FileName = (ScrMode==SCMD_TVIEW && TEST_ActParam("CO"))? TxtViewer->FileName : EmptyStr;
		if (FindTagForm->TagFile.IsEmpty()) throw EAbort(LoadUsrMsg(USTR_NotFound, _T("tags ファイル")));
		if (FindTagForm->ShowModal()!=mrOk) SkipAbort();
		if (!USAME_TI(FindTagForm->TagCmd, "COPY")) {
			bool is_edit = USAME_TI(FindTagForm->TagCmd, "EDIT");
			if (!FindTagForm->TagInfo.IsEmpty())
				DirectTagJumpCore(is_edit, FindTagForm->TagInfo, FindTagForm->TagFile, FindTagForm->FileName);
			else
				DirectTagJumpCore(is_edit, FindTagForm->TagName, FindTagForm->TagFile, FindTagForm->FileName);
		}
	}
	catch (EAbort &e) {
		SetActionAbort(e.Message);
	}
}

//---------------------------------------------------------------------------
//検索
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::FindTextActionExecute(TObject *Sender)
{
	FindTextDlg->fromTV = true;
	FindTextDlg->ShowModal();
}

//---------------------------------------------------------------------------
//片側のファイルリストを固定/解除
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::FixTabPathActionExecute(TObject *Sender)
{
	//固定
	if ((ActionParam.IsEmpty() && !ListStt[CurListTag].is_TabFixed) || TEST_ActParam("ON")) {
		ListStt[CurListTag].is_TabFixed = true;
		ListStt[(CurListTag==0)? 1 : 0].is_TabFixed = false;
		//復帰用にパスを待避
		TabBuff->Clear();
		for (int i=0; i<TabList->Count; i++) TabBuff->Add(TabList->Strings[i]);
	}
	//解除
	else if ((ActionParam.IsEmpty() && ListStt[CurListTag].is_TabFixed) || TEST_ActParam("OFF")) {
		ListStt[CurListTag].is_TabFixed = false;
		ListStt[OppListTag].is_TabFixed = false;

		//パスを復帰
		for (int i=0; i<TabList->Count; i++) {
			if (i<TabBuff->Count) {
				TStringDynArray itm_buf = get_csv_array(TabList->Strings[i], TABLIST_CSVITMCNT, true);
				TStringDynArray lst_buf = get_csv_array(TabBuff->Strings[i], TABLIST_CSVITMCNT, true);
				itm_buf[0] = lst_buf[0];
				itm_buf[1] = lst_buf[1];
				TabList->Strings[i] = make_csv_rec_str(itm_buf);
				SetTabStr(i);
			}
		}

		try {
			int idx = TabControl1->TabIndex;
			//反対側
			UnicodeString dnam = get_csv_item(TabList->Strings[idx], OppListTag);
			if (ends_PathDlmtr(dnam)) {
				UpdateOppPath(dnam);
				if (!GlobalErrMsg.IsEmpty()) GlobalAbort();
			}
			else if (test_NwlExt(get_extension(dnam))) {
				SaveWorkListAction->Execute();
				if (!SetWorkList(dnam, true)) UserAbort(USTR_WlistCantOpen);
				if (CurStt->is_Work) RecoverFileList();
				ChangeWorkList(OppListTag);
			}
			//カレント
			dnam = get_csv_item(TabList->Strings[idx], CurListTag);
			if (ends_PathDlmtr(dnam)) {
				UpdateCurPath(dnam);
				if (!GlobalErrMsg.IsEmpty()) GlobalAbort();
			}
			else if (test_NwlExt(get_extension(dnam))) {
				SaveWorkListAction->Execute();
				if (!SetWorkList(dnam)) UserAbort(USTR_WlistCantOpen);
			}
		}
		catch (EAbort &e) {
			SetActionAbort(e.Message);
		}
	}
	else SetActionAbort(USTR_IllegalParam);

	SetDirCaption(0);
	SetDirCaption(1);
}

//---------------------------------------------------------------------------
//カーソル位置ファイルの差分を表示
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::GitDiffActionExecute(TObject *Sender)
{
	try {
		if (!IsCurFList()) UserAbort(USTR_CantOperate);

		UnicodeString wdir = get_GitTopPath(CurPath[CurListTag]);
		if (wdir.IsEmpty()) UserAbort(USTR_NotRepository);

		file_rec *cfp = GetCurFrecPtr(true);
		if (!cfp || cfp->is_dir) Abort();

		UnicodeString fnam = cfp->f_name;
		UnicodeString path = fnam;
		remove_top_text(path, wdir);
		path = yen_to_slash(path);

		if (TEST_ActParam("XT")) {
			UnicodeString prm = "difftool -y";
			if (TEST_DEL_ActParam("HD")) prm += " HEAD";
			prm.cat_sprintf(_T(" -- %s"), path.c_str());
			if (!GitShellExe(prm, wdir)) UserAbort(USTR_FaildExec);
		}
		else {
			UnicodeString prm = "diff";
			if (TEST_DEL_ActParam("HD")) prm += " HEAD";
			prm.cat_sprintf(_T(" -- %s"), path.c_str());
			std::unique_ptr<TStringList> o_lst(new TStringList());
			DWORD exit_code;
			if (!GitShellExe(prm, wdir, o_lst.get(), &exit_code) || exit_code!=0) UserAbort(USTR_FaildProc);

			UnicodeString tit = "$ git " + sha1_to_short(prm);
			o_lst->Insert(0, tit);
			GeneralInfoDlg->Caption = tit.sprintf(_T("差分詳細 - %s"), path.c_str());
			GeneralInfoDlg->FileName = cfp->f_name;
			GeneralInfoDlg->GenInfoList->Assign(o_lst.get());
			GeneralInfoDlg->ShowModal();
		}
	}
	catch (EAbort &e) {
		SetActionAbort(e.Message);
	}
}
//---------------------------------------------------------------------------
//Gitビュアー
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::GitViewerActionExecute(TObject *Sender)
{
	try {
		if (!IsCurFList()) UserAbort(USTR_CantOperate);
		UnicodeString wdir = get_GitTopPath(CurPath[CurListTag]);
		if (wdir.IsEmpty()) UserAbort(USTR_NotRepository);

		if (!GitViewer) GitViewer = new TGitViewer(this);	//初回に動的作成
		if (TEST_DEL_ActParam("CP")) {
			file_rec *cfp = GetCurFrecPtr(true);
			if (!cfp || cfp->is_dir) Abort();
			UnicodeString path = cfp->f_name;
			remove_top_text(path, wdir);
			GitViewer->FilterName = yen_to_slash(path);
		}
		GitViewer->WorkDir = wdir;
		GitViewer->HistoryLimit = StartsText('N', ActionParam)? extract_int_def(ActionParam) : GIT_DEF_HISTLIMIT;
		SetDirWatch(false);
		TModalResult mr = GitViewer->ShowModal();
		SetDirWatch(true);
		ReloadList(CurListTag);
		if (mr==mrOk && !GitViewer->RetArcFile.IsEmpty()) {
			if (!JumpToList(OppListTag, GitViewer->RetArcFile + "/*")) GlobalAbort();
			ToOppositeAction->Execute();
		}
	}
	catch (EAbort &e) {
		SetActionAbort(e.Message);
	}
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::GitViewerActionUpdate(TObject *Sender)
{
	TAction *ap = (TAction*)Sender;
	ap->Visible = ScrMode==SCMD_FLIST && GitExists;
	ap->Enabled = ap->Visible;
}

//---------------------------------------------------------------------------
//文字列検索(GREP)を開く
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::GrepActionExecute(TObject *Sender)
{
	try {
		if (CurStt->is_Arc || CurStt->is_FTP)	 Abort();
		if (CurStt->is_Find && CurStt->find_Dir) Abort();

		bool to_res  = USAME_TI(ActionOptStr, "ToResList");
		ActionOptStr = EmptyStr;
		fromViewer	 = (ScrMode==SCMD_TVIEW);
		GrepWorkList = CurStt->is_Work;

		UnicodeString kwd;
		if		(!ActionParam.IsEmpty()) kwd = ActionParam;
		else if (fromViewer)			 kwd = get_tkn(TxtViewer->get_SelText(true), '\n');

		//イベント: 文字列検索(GREP)を開く直前
		ExeEventCommand(OnGrepOpen);

		GrepPath = CurPath[CurListTag];
		SetSttBarGrepDir();
		GrepStatusBar->Panels->Items[1]->Text = EmptyStr;
		FindBusy = false;
		SetScrMode(SCMD_GREP);

		if (GrepMaskComboBox->Enabled) GrepMaskComboBox->SetFocus();	//マスクのハイライトを解除するため
		if (to_res) {
			ResultListBox->SetFocus();
		}
		else {
			if (!kwd.IsEmpty()) {
				GrepPageControl->ActivePage = FindSheet;
				GrepFindComboBox->Text = kwd;
			}
			((GrepPageControl->ActivePage==FindSheet)? GrepFindComboBox : RepFindComboBox)->SetFocus();
		}

		bool sel_f_only = (CurStt->sel_f_cnt>0 && CurStt->sel_d_cnt==0);	//ファイルのみ選択中
		GrepMaskComboBox->Enabled = !sel_f_only;
		SubDirCheckBox->Enabled   = !sel_f_only;
		SubDirNCombo->Enabled	  = !sel_f_only;
		SkipDirEdit->Enabled	  = !sel_f_only;
		SetSttBarGrepOpt();
		GrepOptionAction->Update();
	}
	catch (EAbort &e) {
		SetActionAbort(e.Message);
	}
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::GrepActionUpdate(TObject *Sender)
{
	TAction *ap = (TAction*)Sender;
	ap->Visible = (ScrMode==SCMD_FLIST || TxtViewer->isText || USAME_TI(ActionOptStr, "ToResList"));
	ap->Enabled = ap->Visible && !FindBusy;
}

//---------------------------------------------------------------------------
//ヘルプの目次/索引
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::HelpContentsActionExecute(TObject *Sender)
{
	UnicodeString topic;
	if (TEST_ActParam("CI") || TEST_ActParam("FI")) {
		topic = TEST_ActParam("FI")? HELPTOPIC_FI : HELPTOPIC_CI;
		switch (ScrMode) {
		case SCMD_FLIST: topic += (CurStt->is_IncSea? "#IS" : "#FL");	break;
		case SCMD_TVIEW: topic += "#TV";	break;
		case SCMD_IVIEW: topic += "#IV";	break;
		}
	}
	else if (TEST_ActParam("CH")) topic = HELPTOPIC_CH;

	HtmlHelpTopic(topic.c_str());
}
//---------------------------------------------------------------------------
//コマンドの索引を表示
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::CmdIndexItemClick(TObject *Sender)
{
	HtmlHelpContext(101);
}
//---------------------------------------------------------------------------
//変更履歴を表示
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::HelpHistoryItemClick(TObject *Sender)
{
	HtmlHelpContext(109);
}

//---------------------------------------------------------------------------
//サイズと日付を隠す
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::HideSizeTimeActionExecute(TObject *Sender)
{
	SetToggleAction(HideSizeTime);
	RepaintList(0);
	RepaintList(1);
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::HideSizeTimeActionUpdate(TObject *Sender)
{
	TAction *ap = (TAction*)Sender;
	ap->Visible = (ScrMode==SCMD_FLIST);
	ap->Enabled = ap->Visible;
	ap->Checked = HideSizeTime;
}

//---------------------------------------------------------------------------
//ホームワークリストを開く
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::HomeWorkListActionExecute(TObject *Sender)
{
	try {
		SaveWorkListAction->Execute();
		if (!SetWorkList(HomeWorkList)) UserAbort(USTR_WlistCantOpen);
		//履歴に追加
		if (WorkToDirHist && CurStt->is_Work) AddDirHistory(HomeWorkList, CurListTag);
	}
	catch (EAbort &e) {
		SetActionAbort(e.Message);
	}
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::HomeWorkListActionUpdate(TObject *Sender)
{
	TAction *ap = (TAction*)Sender;
	ap->Visible = ScrMode==SCMD_FLIST || ScrMode==SCMD_IVIEW;
	ap->Enabled = !HomeWorkList.IsEmpty();
}

//---------------------------------------------------------------------------
//イメージビュアー
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ImageViewerActionExecute(TObject *Sender)
{
	try {
		if (TEST_ActParam("NN")) {
			if (CurStt->is_Arc || CurStt->is_FTP) UserAbort(USTR_CantOperate);
			file_rec *cfp = GetCurFrecPtr();
			if (!cfp || cfp->is_dummy || cfp->is_dir) Abort();

			HWND hNextWnd = get_NyanFiWnd(1);
			if (hNextWnd) {
				UnicodeString fnam = cfp->f_name;
				COPYDATASTRUCT cd;
				cd.dwData = CPYDTID_IMGVIEW;
				cd.cbData = sizeof(_TCHAR) * (fnam.Length() + 1);
				cd.lpData = fnam.c_str();
				::SendMessage(hNextWnd, WM_COPYDATA, 0, (LPARAM)&cd);
				SkipAbort();
			}
			else ActionParam = EmptyStr;
		}

		if (TEST_ActParam("CB")) {
			if (!Clipboard()->HasFormat(CF_BITMAP)) UserAbort(USTR_NoObject);

			isViewWork = false;
			if (!ViewClipImage((InitialModeI==0), (InitialModeI==1)? 100 : LastZoomRatio))
				UserAbort(USTR_FaildProc);
		}
		else {
			file_rec *cfp = GetCurFrecPtr();	if (!cfp) Abort();
			if (cfp->is_dummy || cfp->f_attr==faInvalid || cfp->is_dir) Abort();

			//アーカイブ
			if (test_ArcExt2(cfp->f_ext)) {
				UnicodeString xlst = get_img_fext();
				UnicodeString fnam = IniFile->MarkedInArc(cfp->f_name, xlst);
				if (fnam.IsEmpty()) fnam = usr_ARC->GetFirstFile(cfp->f_name, xlst);
				if (fnam.IsEmpty()) TextAbort(_T("表示可能な画像が含まれていません。"));
				if (JumpToList(CurListTag, fnam)) {
					cfp = GetCurFrecPtr();	if (!cfp) Abort();
					ViewFromArc = true;
				}
			}

			if (test_FileExt(cfp->f_ext, FExtNoIView))		TextAbort(_T("このファイルは表示しません。"));
			if (!is_Viewable(cfp) && !is_ExtractIcon(cfp))	TextAbort(_T("このファイルは表示できません。"));
			if (CurStt->is_Find && contains_Slash(cfp->f_name)) UserAbort(USTR_OpeNotSuported);

			isViewWork = CurStt->is_Work;
			if (!OpenImgViewer(cfp, (InitialModeI==0), (InitialModeI==1)? 100 : LastZoomRatio)) UserAbort(USTR_FileNotOpen);

			if (!cfp->is_ftp) {
				SetViewFileList(true, true);

				//見開きモード
				if (DoublePage) {
					ClearViewImage();
					OpenImgViewer(ViewFileList->IndexOf(ViewFileName));
				}
			}
		}
		ActionOk = true;
	}
	catch (EAbort &e) {
		SetActionAbort(e.Message);
	}
}

//---------------------------------------------------------------------------
//インクリメンタルサーチへ
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::IncSearchActionExecute(TObject *Sender)
{
	bool is_fm = TEST_DEL_ActParam("FM");

	if (is_fm && WorkListChanged) {
		if (!ExeCmdAction(SaveWorkListAction)) { SetActionAbort(ActionErrMsg); return; }
	}

	if (TEST_DEL_ActParam("CA")) ExeCommandAction("SelMask", "CA");

	CurStt->is_IncSea	= true;
	CurStt->is_Filter	= is_fm;
	CurStt->incsea_Word = EmptyStr;
	CurStt->incsea_Ptn	= EmptyStr;

	SaveToTmpBufList();	//現在のリストを待避

	if (TEST_ActParam("MM") && usr_Migemo->DictReady)
		(CurStt->is_Filter? LastMigemoModeF : LastMigemoMode) = CurStt->is_Migemo = true;
	else if (TEST_ActParam("NM"))
		(CurStt->is_Filter? LastMigemoModeF : LastMigemoMode) = CurStt->is_Migemo = false;
	else
		CurStt->is_Migemo = (CurStt->is_Filter? LastMigemoModeF : LastMigemoMode);

	SetDrivePanel(CurListTag);
}

//---------------------------------------------------------------------------
//フィルタ絞り込みを解除、選択状態を設定
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ResetIncSeaFilter(
	int tag,			//タグ
	bool set_listbox)	//リストボックスを設定	(default = false);
{
	//直前の選択状態を取得
	TStringList *lst = GetFileList(tag);
	std::unique_ptr<TStringList> sel_lst(new TStringList());
	GetSelList(lst, sel_lst.get());

	//元リストを復帰して選択状態を設定
	clear_FileList(lst);
	TStringList *tmp_lst = TmpBufList[tag];
	for (int i=0; i<tmp_lst->Count; i++) {
		file_rec *fp = cre_new_file_rec((file_rec*)tmp_lst->Objects[i]);
		fp->selected = (sel_lst->IndexOf(fp->f_name)!=-1);
		lst->AddObject(fp->f_name, (TObject*)fp);
	}

	//リストボックスを設定
	if (set_listbox) {
		FileListBox[tag]->Count = GetFileList(tag)->Count;
		FlScrPanel[tag]->UpdateKnob();
		SetDrivePanel(tag);
		if (tag==CurListTag) SetFileInf();
	}
}
//---------------------------------------------------------------------------
//現在のリストを待避
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::SaveToTmpBufList()
{
	for (int i=0; i<(IsDiffList()? MAX_FILELIST : 1); i++) {
		int tag_i = (i==0)? CurListTag : OppListTag;
		TStringList *tmp_lst = TmpBufList[tag_i];
		clear_FileList(tmp_lst);

		TStringList *lst = GetFileList(tag_i);
		for (int i=0; i<lst->Count; i++) {
			file_rec *fp = cre_new_file_rec((file_rec*)lst->Objects[i]);
			tmp_lst->AddObject(fp->f_name, (TObject*)fp);
		}
	}
}
//---------------------------------------------------------------------------
//ディレクトリ比較結果を反対側に反映
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::CurToOppDiffList()
{
	TStringList *c_lst = GetCurList(true);
	TStringList *o_lst = GetOppList();
	TStringList *c_tmp = TmpBufList[CurListTag];
	TStringList *o_tmp = TmpBufList[OppListTag];

	//元リストを復帰
	clear_FileList(o_lst);
	for (int i=0; i<o_tmp->Count; i++) {
		file_rec *fp = cre_new_file_rec((file_rec*)o_tmp->Objects[i]);
		o_lst->AddObject(fp->f_name, (TObject*)fp);
	}

	if (c_lst->Count < c_tmp->Count) {
		//選択マスクを設定
		TStringList *c_msk = SelMaskList[CurListTag];
		TStringList *o_msk = SelMaskList[OppListTag];
		o_msk->Clear();
		for (int i=0; i<c_msk->Count; i++)
			o_msk->Add(CurPath[OppListTag] + get_tkn_r(c_msk->Strings[i], CurPath[CurListTag]));

		//絞り込み
		int i = 0;
		while (i<o_lst->Count) {
			file_rec *fp = (file_rec*)o_lst->Objects[i];
			if (o_msk->IndexOf(fp->f_name)==-1) del_FileListItem(o_lst, i); else i++;
		}

		//[..]が必要なら追加
		if (c_lst->Count>0) {
			file_rec *cfp = (file_rec*)c_lst->Objects[0];
			if (cfp->is_up) {
				file_rec *ofp = (o_lst->Count>0)? (file_rec*)o_lst->Objects[0] : NULL;
				if (ofp && !ofp->is_up) {
					file_rec *fp = cre_new_file_rec(cfp);
					o_lst->InsertObject(0, fp->f_name, (TObject*)fp);
				}
			}
		}

		//空の場合ダミーを追加
		if (o_lst->Count==0) {
			file_rec *fp = cre_new_file_rec(EmptyStr, CurListTag);
			o_lst->AddObject(fp->f_name, (TObject*)fp);
		}
	}

	//リストボックスの更新
	TListBox *lp = FileListBox[OppListTag];
	lp->Count = o_lst->Count;
	lp->Repaint();
	FlScrPanel[OppListTag]->UpdateKnob();
}

//---------------------------------------------------------------------------
//インクリメンタルサーチ・モードから抜ける
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ExitIncSearch()
{
	int match_cnt = GetMatchCount(GetCurList());

	bool is_filter = FilterComboBox->Visible;
	if (is_filter) {
		CloseIME(Handle);
		FilterComboBox->Visible = false;
	}

	FlScrPanel[CurListTag]->KeyWordChanged(EmptyStr, 0);
	CurStt->is_IncSea = CurStt->is_Filter = false;

	for (int i=0; i<(IsDiffList()? MAX_FILELIST : 1); i++) {
		int tag_i = (i==0)? CurListTag : OppListTag;

		if (match_cnt==0) {
			SelMaskList[tag_i]->Clear();
			if (IsDiffList() || (CurStt->is_Work && i==0))
				ResetIncSeaFilter(tag_i, true);
			else
				ReloadList(tag_i);
		}
		else {
			if (i==0) {
				//キーワード履歴を追加
				if (is_filter) {
					add_ComboBox_history(FilterComboBox);
					FilterHistory->Assign(FilterComboBox->Items);
				}
				else if (!CurStt->is_Migemo && CurStt->incsea_Word.Length()>2) {
					int i=0;
					while (i < IncSeaHistory->Count)
						if (SameText(IncSeaHistory->Strings[i], CurStt->incsea_Word)) IncSeaHistory->Delete(i); else i++;
					IncSeaHistory->Insert(0, CurStt->incsea_Word);
				}
			}

			RepaintList(tag_i);
		}

		if (!IsDiffList()) clear_FileList(TmpBufList[tag_i]);
		//ディレクトリ比較の場合、選択マスク解除時の復帰に利用するためクリアしない
	}

	ClearKeyBuff();
}

//---------------------------------------------------------------------------
//コマンド名をクリップボードにコピー
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::CopyCmdNameActionExecute(TObject *Sender)
{
	InpCmdsDlg->toCopy = true;
	if (InpCmdsDlg->ShowModal()==mrOk) copy_to_Clipboard(InpCmdsDlg->CmdsComboBox->Text);
}

//---------------------------------------------------------------------------
//コマンドの入力
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::InputCommandsActionExecute(TObject *Sender)
{
	try {
		if (InpCmdsDlg->ShowModal()==mrOk) {
			UnicodeString cmds = InpCmdsDlg->CmdsComboBox->Text;
			if (TEST_ActParam("EL")) ActionOptStr = ActionParam;
			if (!ExeAliasOrCommands(cmds)) GlobalAbort();
			//履歴に追加
			TStringList *h_lst = (ScrMode==SCMD_TVIEW)? InputCmdsHistoryV :
								 (ScrMode==SCMD_IVIEW)? InputCmdsHistoryI : InputCmdsHistory;
			int idx = h_lst->IndexOf(cmds);
			if (idx!=0) {
				if (idx>0) h_lst->Delete(idx);
				h_lst->Insert(0, cmds);
			}
		}
	}
	catch (EAbort &e) {
		SetActionAbort(e.Message);
	}
}

//---------------------------------------------------------------------------
//入力したディレクトリに変更
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::InputDirActionExecute(TObject *Sender)
{
	if (CurStt->is_FTP) { SetActionAbort(USTR_OpeNotSuported);  return; }

	UnicodeString tit = "ディレクトリを開く - " + get_LRUD_str();

	//ディレクトリ情報部分で入力
	if		(TEST_ActParam("ND")) 	ShowInpDirPanel();
	else if (TEST_ActParam("ND2"))	ShowInpDirPanel(true);
	//フォルダの参照ダイアログ
	else if (TEST_ActParam("SD")) {
		ShowInpDirPanel();
		UnicodeString dnam = CurPath[CurListTag];
		if (UserModule->SelectDirEx(tit.c_str(), dnam)) {
			InpDirComboBox->Text = dnam;
			ApplyInpDir();
		}
		else HideInpDirPanel();
	}
	//入力ボックス
	else {
		UnicodeString dnam = inputbox_dir(tit.c_str(), _T("InputDir"));
		if (!dnam.IsEmpty()) {
			dnam = to_absolute_name(cv_env_str(dnam), CurPath[CurListTag]);

			if (StartsStr("\\\\", dnam)) {
				UnicodeString rnam;
				int p, cnt;
				for (p=1,cnt=0; p<=dnam.Length(); p++) {
					if (dnam[p]=='\\') {
						cnt++;
						if (cnt==4) break;
					}
				}
				if (!CheckUncPath(dnam.SubString(1, p))) {
					SetActionAbort(GlobalErrMsg);
					return;
				}
			}

			int atr = file_GetAttr(dnam);
			if (atr==faInvalid) {
				SetActionAbort(SysErrorMessage(ERROR_PATH_NOT_FOUND));
			}
			else {
				UnicodeString fnam;
				if (!(atr & faDirectory)) {
					fnam = dnam;
					dnam = ExtractFilePath(dnam);
				}
				dnam = IncludeTrailingPathDelimiter(dnam);
				UpdateCurPath(dnam, fnam);
				if (!GlobalErrMsg.IsEmpty()) SetActionAbort(GlobalErrMsg);
			}
		}
	}
}

//---------------------------------------------------------------------------
//パスマスクを入力
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::InputPathMaskActionExecute(TObject *Sender)
{
	if (!CurStt->is_Find && !CurStt->is_Work) {
		if (!MaskSelectDlg) MaskSelectDlg = new TMaskSelectDlg(this);	//初回に動的作成
		MaskSelectDlg->CmdName = "InputPathMask";
		if (MaskSelectDlg->ShowModal()==mrOk) {
			UnicodeString fnam = GetCurFileName();
			PathMask[CurListTag] = make_PathMask(MaskSelectDlg->MaskSelComboBox->Text);
			RefreshCurPath(fnam);
		}
	}
	else SetActionAbort(USTR_CantOperate);
}

//---------------------------------------------------------------------------
//セパレータの挿入(ワークリスト)
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::InsSeparatorActionExecute(TObject *Sender)
{
	if (WorkListFiltered) { SetActionAbort(USTR_WorkFiltered); return; }

	file_rec *fp = cre_new_file_rec("-", CurListTag);
	int idx = FileListBox[CurListTag]->ItemIndex;
	if (idx>=0 && idx<WorkList->Count-1)
		WorkList->InsertObject(idx + 1, EmptyStr, (TObject*)fp);
	else
		WorkList->AddObject(EmptyStr, (TObject*)fp);
	ChangeWorkList(CurListTag);
	rqWorkListDirInf = !WorkListChanged;
	WorkListChanged  = true;
}
//---------------------------------------------------------------------------
//項目を一時的に1つ下に移動
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ItemTmpDownActionExecute(TObject *Sender)
{
	if ((CurStt->is_Find && CurStt->find_DUPL) || IsDiffList()) {
		SetActionAbort(USTR_CantOperate); return;
	}

	TStringList *lst = GetCurList(true);
	if (lst->Count>0 && ((file_rec*)lst->Objects[lst->Count - 1])->selected) return;

	TListBox *lp = FileListBox[CurListTag];
	int cur_idx = lp->ItemIndex;
	int itm_idx = cur_idx;
	int sel_cnt = GetSelCount(lst);
	for (int i=lst->Count-2; i>=0; i--) {
		if (((file_rec*)lst->Objects[i])->selected || (sel_cnt==0 && i==cur_idx)) lst->Move(i, i + 1);
	}

	itm_idx++;  if (itm_idx<lp->Count) lp->ItemIndex = itm_idx;

	if (CurStt->is_Work) {
		ChangeWorkList(CurListTag);
		rqWorkListDirInf = !WorkListChanged;
		if (NotSortWorkList || WorkListHasSep) WorkListChanged = true;
	}
	else {
		RepaintList(CurListTag);
	}
}
//---------------------------------------------------------------------------
//項目を一時的に1つ上に移動
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ItemTmpUpActionExecute(TObject *Sender)
{
	if ((CurStt->is_Find && CurStt->find_DUPL) || IsDiffList()) {
		SetActionAbort(USTR_CantOperate); return;
	}

	TStringList *lst = GetCurList(true);
	if (lst->Count>0 && ((file_rec*)lst->Objects[0])->selected) return;

	TListBox *lp = FileListBox[CurListTag];
	int cur_idx = lp->ItemIndex;
	int itm_idx = cur_idx;
	int sel_cnt = GetSelCount(lst);
	for (int i=1; i<lst->Count; i++) {
		if (((file_rec*)lst->Objects[i])->selected || (sel_cnt==0 && i==cur_idx)) lst->Move(i, i - 1);
	}

	itm_idx--;  if (itm_idx>=0) lp->ItemIndex = itm_idx;

	if (CurStt->is_Work) {
		ChangeWorkList(CurListTag);
		rqWorkListDirInf = !WorkListChanged;
		if (NotSortWorkList || WorkListHasSep) WorkListChanged = true;
	}
	else {
		RepaintList(CurListTag);
	}
}
//---------------------------------------------------------------------------
//選択項目を一時的にカーソル位置に移動
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ItemTmpMoveActionExecute(TObject *Sender)
{
	if ((CurStt->is_Find && CurStt->find_DUPL) || IsDiffList()) {
		SetActionAbort(USTR_CantOperate); return;
	}

	TListBox *lp = FileListBox[CurListTag];
	int idx = lp->ItemIndex;
	if (idx==-1) return;

	TStringList *lst = GetCurList(true);
	if (!ListSelected(lst)) return;

	//選択項目を切り取って待避
	std::unique_ptr<TStringList> cbuf(new TStringList());
	int ins_idx = idx;
	int i = 0;
	while (i<lst->Count) {
		file_rec *fp = (file_rec*)lst->Objects[i];
		if (fp->selected) {
			cbuf->AddObject(lst->Strings[i], (TObject*)fp);
			lst->Delete(i);
			if (i<ins_idx) ins_idx--;
		}
		else i++;
	}
	//移動先に挿入
	for (int i=cbuf->Count-1; i>=0; i--) {
		file_rec *fp = (file_rec*)cbuf->Objects[i];
		fp->selected = false;
		lst->InsertObject(ins_idx, cbuf->Strings[i], (TObject*)fp);
	}

	if (CurStt->is_Work) {
		ChangeWorkList(CurListTag);
		rqWorkListDirInf = !WorkListChanged;
		WorkListChanged  = true;
		lp->ItemIndex	 = ins_idx;
	}
	else {
		RepaintList(CurListTag);
	}
}

//---------------------------------------------------------------------------
//結合テンプレートの適用
//---------------------------------------------------------------------------
UnicodeString __fastcall TNyanFiForm::ApplyTemplate(
	UnicodeString tmplt, UnicodeString fnam, TStringList *txtbuf, int idx, int code_page)
{
	UnicodeString rstr;

	bool is_html = test_HtmlExt(get_extension(fnam));
	//HTML→テキスト変換
	UnicodeString htm_txt, htm_tit, htm_dsc, htm_kwd;
	if (is_html && ContainsText(tmplt, "$HTM")) {
		std::unique_ptr<HtmConv> htmcnv(new HtmConv());
		ini_HtmConv_def(htmcnv.get(), fnam);
		htmcnv->HtmBuf->Assign(txtbuf);
		htmcnv->CodePage = code_page;
		htmcnv->Convert();
		htm_txt = htmcnv->TxtBuf->Text;
		htm_tit = htmcnv->Title;
		htm_dsc = htmcnv->Description;
		htm_kwd = htmcnv->Keywords;
	}

	UnicodeString t_buf = tmplt;
	while (!t_buf.IsEmpty()) {
		WideChar c = split_top_wch(t_buf);
		if (c=='$') {
			UnicodeString s;
			if 		(remove_top_s(t_buf, _T("TEXT")))	 s = txtbuf->Text;
			else if (remove_top_s(t_buf, _T("HTM2TXT"))) s = is_html? htm_txt : txtbuf->Text;
			else if (remove_top_s(t_buf, _T("HTM_TIT"))) s = htm_tit;
			else if (remove_top_s(t_buf, _T("HTM_DSC"))) s = htm_dsc;
			else if (remove_top_s(t_buf, _T("HTM_KWD"))) s = htm_kwd;
			else {
				c = split_top_wch(t_buf);

				switch (c) {
				//パス名
				case 'P': s = ExtractFilePath(fnam);	break;
				//パス無ファイル名
				case 'B': s = ExtractFileName(fnam);	break;
				//パス無ファイル名主部
				case 'N': s = get_base_name(fnam);		break;
				//パス付ファイル名
				case 'F': s = fnam;						break;
				//タイムスタンプ
				case 'T': s = FormatDateTime(TimeStampFmt, get_file_age(fnam));	break;
				//タイムスタンプ(書式指定)
				case 'D': s = FormatDateTime(split_in_paren(t_buf), get_file_age(fnam));	break;
				//インデックス番号
				case 'I': s = IntToStr(idx);			break;
				//$そのもの
				case '$': s = "$"; break;
				}
			}
			rstr += s;
		}
		else rstr.cat_sprintf(_T("%c"), c);
	}
	return rstr;
}
//---------------------------------------------------------------------------
//テキストファイルの結合
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::JoinTextActionExecute(TObject *Sender)
{
	try {
		TStringList *lst	  = GetCurList(true);
		UnicodeString src_dir = GetCurPathStr();
		UnicodeString dst_dir = GetCurPathStr(OppListTag);

		if (GetSelCount(lst)==0) UserAbort(USTR_NoObject);
		if (TestCurIncDir())	 UserAbort(USTR_IncludeDir);
		if (CurStt->is_Arc || CurStt->is_ADS || CurStt->is_Work || CurStt->is_FTP) UserAbort(USTR_OpeNotSuported);
		if (OppStt->is_Arc || OppStt->is_ADS || OppStt->is_Work || CurStt->is_FTP) UserAbort(USTR_CantOperate);
		if (TestCurIncFindVirtual()) UserAbort(USTR_OpeNotSuported);

		if (!JoinTextDlg) JoinTextDlg = new TJoinTextDlg(this);	//初回に動的作成
		JoinTextDlg->SrcFileListBox->Clear();
		for (int i=0; i<lst->Count; i++) {
			file_rec *fp = (file_rec*)lst->Objects[i];
			if (!fp->selected || fp->is_dir) continue;
			JoinTextDlg->SrcFileListBox->Items->Add(fp->n_name);
		}

		UnicodeString msg;
		if (JoinTextDlg->ShowModal()==mrOk) {
			CurWorking = true;
			StartLog(msg.sprintf(_T("結合開始  %s\t%s"), src_dir.c_str(), dst_dir.c_str()));
			BeginWorkProgress(_T("テキストファイルの結合"), EmptyStr, FileListBox[CurListTag]);

			std::unique_ptr<TStringList> f_buf(new TStringList());	//読込用バッファ
			std::unique_ptr<TStringList> o_buf(new TStringList());	//出力用バッファ

			//テンプレートの読み込み
			std::unique_ptr<TStringList> tmplt(new TStringList());
			UnicodeString tnam = JoinTextDlg->TemplateEdit->Text;
			if (!tnam.IsEmpty()) {
				tnam = to_absolute_name(tnam);
				if (!file_exists(tnam)) throw EAbort(LoadUsrMsg(USTR_NotFound, tnam));
				AddLog(make_LogHdr(_T("LOAD"), tnam));
				if (load_text_ex(tnam, tmplt.get())==0) UserAbort(USTR_FileNotOpen);
			}

			//出力コード
			int out_code_page = get_CodePageOfName(JoinTextDlg->OutCodeComboBox->Text);
			//BOM
			bool with_bom = true;
			if (out_code_page==0) {
				out_code_page = get_FileCodePage(
									src_dir + JoinTextDlg->SrcFileListBox->Items->Strings[0],
									NULL, &with_bom);
			}
			else {
				with_bom = JoinTextDlg->BomCheckBox->Enabled && JoinTextDlg->BomCheckBox->Checked;
			}

			for (int i=0; i<JoinTextDlg->SrcFileListBox->Count; i++) {
				PosWorkProgress(i, JoinTextDlg->SrcFileListBox->Count);

				UnicodeString fnam = src_dir + JoinTextDlg->SrcFileListBox->Items->Strings[i];
				msg = make_LogHdr(_T("JOIN"), fnam);
				load_text_ex(fnam, f_buf.get());
				if (!GlobalErrMsg.IsEmpty()) {
					set_LogErrMsg(msg, GlobalErrMsg);
					AddLog(msg);
					GlobalAbort();
				}

				//テンプレートによる連結
				if (!tnam.IsEmpty())
					o_buf->Text = o_buf->Text + ApplyTemplate(tmplt->Text, fnam, f_buf.get(), i + 1, out_code_page);
				//単純連結
				else {
					o_buf->AddStrings(f_buf.get());
				}

				AddLog(msg);
			}

			//一旦空のファイルを作っておく
			UnicodeString onam = dst_dir + JoinTextDlg->OutNameEdit->Text;
			if (file_exists(onam)) {
				if (!msgbox_Sure(USTR_OverwriteQ)) Abort();
				delete_File(onam);
			}
			if (!create_EmptyFile(onam)) UserAbort(USTR_FaildProc);

			//コード指定
			std::unique_ptr<TEncoding> enc(TEncoding::GetEncoding(out_code_page));
			//改行指定
			switch (JoinTextDlg->OutLnBrkComboBox->ItemIndex) {
			case 1:  o_buf->LineBreak = "\n"; break;
			case 2:  o_buf->LineBreak = "\r"; break;
			default: o_buf->LineBreak = "\r\n";
			}

			//保存
			o_buf->WriteBOM = with_bom;
			if (!saveto_TextFile(onam, o_buf.get(), enc.get())) throw EAbort(LoadUsrMsg(USTR_FaildSave, _T("出力ファイル")));

			CurWorking = false;
			ClearAllAction->Execute();
			AddLog(make_LogHdr(_T("SAVE"), onam));
			EndLog(_T("結合"), get_res_cnt_str(JoinTextDlg->SrcFileListBox->Count));
			ReloadList(OppListTag);
			if (EqualDirLR()) ReloadList(CurListTag); else RepaintList(CurListTag);
			EndWorkProgress();
		}
	}
	catch (EAbort &e) {
		SetActionAbort(e.Message);
	}
}

//---------------------------------------------------------------------------
//指定したファイル位置へ
//---------------------------------------------------------------------------
bool __fastcall TNyanFiForm::JumpToList(int tag, UnicodeString fnam)
{
	GlobalErrMsg = EmptyStr;
	try {
		UnicodeString mask = ExtractFileName(fnam);
		bool has_wc = mask.Pos('*') || mask.Pos('?');	//ワイルドカード有り

		//アーカイブ内
		if (contains_Slash(fnam)) {
			if (ScrMode!=SCMD_FLIST) SetScrMode();
			UnicodeString anam = split_tkn(fnam, '/');
			if (anam.Length()>=MAX_PATH) SysErrAbort(ERROR_BUFFER_OVERFLOW);
			if (!is_AvailableArc(anam)) UserAbort(USTR_FmtNotSuported);
			if (tag==CurListTag) {
				RecoverFileList(tag);
				UpdateCurPath(ExtractFilePath(anam), anam);
			}
			else {
				UnicodeString dnam = ExtractFilePath(anam);
				if (!SameText(CurPath[OppListTag], dnam)) {
					TListBox *lp = FileListBox[OppListTag];
					set_RedrawOff(lp);
					{
						RecoverFileList(OppListTag);
						CurPath[OppListTag] = dnam;
					}
					set_RedrawOn(lp);
				}
			}

			flist_stt *lst_stt	= &ListStt[tag];
			UnicodeString a_sub = ExtractFilePath(ExcludeTrailingPathDelimiter(fnam));
			UnicodeString a_dsp;  a_dsp.sprintf(_T("%s/%s"), ExtractFileName(anam).c_str(), a_sub.c_str());
			if (!lst_stt->is_Arc || !SameText(lst_stt->arc_Name, anam)
				|| !SameText(lst_stt->arc_SubPath, a_sub) || !SameText(lst_stt->arc_DspPath, a_dsp))
			{
				lst_stt->arc_Name	 = anam;
				lst_stt->arc_SubPath = a_sub;
				lst_stt->arc_DspPath = a_dsp;
				if (UpdateTempArcList(tag).IsEmpty()) UserAbort(USTR_CantMakeTmpDir);
				SelMaskList[tag]->Clear();
				if (!ChangeArcFileListEx(lst_stt->arc_Name, lst_stt->arc_SubPath, tag)) {
					InhReload++;
					UserAbort(USTR_ArcNotOpen);
				}
			}
		}
		//通常
		else {
			if (ScrMode!=SCMD_FLIST) SetScrMode(); else RecoverFileList(tag);
			UnicodeString dnam = exclede_delimiter_if_root(ExtractFilePath(fnam));
			if (has_wc) {
				if (!dir_exists(dnam)) SysErrAbort(ERROR_PATH_NOT_FOUND);
			}
			else {
				if (!file_exists(fnam)) SysErrAbort(ERROR_FILE_NOT_FOUND);
			}

			if (!SameText(CurPath[tag], dnam)) CurPath[tag] = dnam;
		}

		//ワイルドカード有り
		if (has_wc) {
			TStringList *lst = GetFileList(tag);
			TListBox *lp = FileListBox[tag];
			int idx  = lp->ItemIndex;
			int idx0 = -1, idx1 = -1;
			for (int i=0; i<lst->Count && idx1==-1; i++) {
				if (i<=idx && idx0!=-1) continue;
				if (str_match(mask, ExtractFileName(lst->Strings[i]))) {
					if (i<=idx) idx0 = i; else idx1 = i;
				}
			}
			idx = (idx1!=-1)? idx1 : idx0;
			if (idx!=-1) lp->ItemIndex = idx;
		}
		//ワイルドカード無し
		else {
			IndexOfFileList(fnam, tag);
		}

		if (tag==CurListTag) SetFileInf();
		return true;
	}
	catch (EAbort &e) {
		GlobalErrMsg = e.Message;
		return false;
	}
}
//---------------------------------------------------------------------------
//アーカイブ内の指定した相対ファイル位置へ
//---------------------------------------------------------------------------
bool __fastcall TNyanFiForm::JumpToArcR(int tag, UnicodeString fnam)
{
	GlobalErrMsg = EmptyStr;
	try {
		UnicodeString mask = ExtractFileName(fnam);
		bool has_wc = mask.Pos('*') || mask.Pos('?');	//ワイルドカード有り

		//アーカイブ内
		flist_stt *lst_stt	= &ListStt[tag];
		UnicodeString a_sub = ExtractFilePath(ExcludeTrailingPathDelimiter(fnam));
		if (!SameText(lst_stt->arc_SubPath, a_sub)) {
			lst_stt->arc_SubPath = a_sub;
			if (UpdateTempArcList(tag).IsEmpty()) UserAbort(USTR_CantMakeTmpDir);
			SelMaskList[tag]->Clear();
			if (!ChangeArcFileListEx(lst_stt->arc_Name, lst_stt->arc_SubPath, tag)) {
				InhReload++;
				UserAbort(USTR_ArcNotOpen);
			}
		}

		//ワイルドカード有り
		if (has_wc) {
			TStringList *lst = GetFileList(tag);
			TListBox *lp = FileListBox[tag];
			int idx  = lp->ItemIndex;
			int idx0 = -1, idx1 = -1;
			for (int i=0; i<lst->Count && idx1==-1; i++) {
				if (i<=idx && idx0!=-1) continue;
				if (str_match(mask, ExtractFileName(lst->Strings[i]))) {
					if (i<=idx) idx0 = i; else idx1 = i;
				}
			}
			idx = (idx1!=-1)? idx1 : idx0;
			if (idx!=-1) lp->ItemIndex = idx;
		}
		//ワイルドカード無し
		else {
			IndexOfFileList(fnam, tag);
		}

		if (tag==CurListTag) SetFileInf();
		return true;
	}
	catch (EAbort &e) {
		GlobalErrMsg = e.Message;
		return false;
	}
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::JumpToActionExecute(TObject *Sender)
{
	try {
		if (CurStt->is_FTP) UserAbort(USTR_OpeNotSuported);

		UnicodeString fnam = def_if_empty(ActionParam, GetCurFileName());
		if (fnam.IsEmpty()) UserAbort(USTR_NoParameter);

		if (CurStt->is_Arc && ExtractFileDrive(fnam).IsEmpty()) {
			if (!JumpToArcR(CurListTag, fnam)) GlobalAbort();
		}
		else {
			fnam = to_absolute_name(fnam, CurPath[CurListTag]);
			if (!JumpToList(CurListTag, fnam)) GlobalAbort();
		}
	}
	catch (EAbort &e) {
		SetActionAbort(e.Message);
	}
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::JumpToActionUpdate(TObject *Sender)
{
	TAction *ap = (TAction*)Sender;
	ap->Visible = ScrMode==SCMD_FLIST || ScrMode==SCMD_GREP;
	ap->Enabled = ap->Visible;
}

//---------------------------------------------------------------------------
//キー割り当て一覧
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::KeyListActionExecute(TObject *Sender)
{
	int idx = 0;
	if      (TxtViewPanel->Visible) idx = 2;
	else if (ImgViewPanel->Visible) idx = 3;
	else if (LogListBox->Focused()) idx = 4;
	else if (CurStt->is_IncSea)		idx = 1;
	KeyListDlg->KeyTabControl->TabIndex = idx;

	KeyListDlg->ToFilter = TEST_ActParam("FF");
	if (KeyListDlg->ShowModal()==mrOk &&  !StartsText("KeyList", KeyListDlg->CommandStr)) {
		UnicodeString cmd = KeyListDlg->CommandStr;
		switch (KeyListDlg->KeyTabControl->TabIndex) {
		case 0: case 1:
				if (ScrMode==SCMD_FLIST) ExeCommandAction(cmd);	else beep_Warn(); break;
		case 2: if (ScrMode==SCMD_TVIEW) ExeCommandV(cmd);		else beep_Warn(); break;
		case 3: if (ScrMode==SCMD_IVIEW) ExeCommandI(cmd);		else beep_Warn(); break;
		case 4: if (ScrMode==SCMD_FLIST) ExeCommandL(cmd);		else beep_Warn(); break;
		}
		ActionOk = true;
	}
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::KeyListActionUpdate(TObject *Sender)
{
	TAction *ap = (TAction*)Sender;
	ap->Visible = ScrMode!=SCMD_GREP;
	ap->Enabled = ap->Visible && !CurWorking && !FindBusy && !CalcBusy && !ExeCmdsBusy;
}

//---------------------------------------------------------------------------
//ライブラリを選択して開く
//---------------------------------------------------------------------------
bool __fastcall TNyanFiForm::PopSelLibrary(UnicodeString prm, int tag, TControl *cp)
{
	try {
		if (prm.IsEmpty()) Abort();

		UnicodeString l_fnam, l_dnam, l_snam;
		//すべてのライブラリ
		if (USAME_TS(prm, "*")) {
			//メニューの作成
			std::unique_ptr<TStringList> l_lst(new TStringList());
			std::unique_ptr<TStringList> m_buf(new TStringList());
			get_files(LibraryPath, _T("*.library-ms"), l_lst.get());
			for (int i=0; i<l_lst->Count; i++) {
				UnicodeString dnam, rnam, tmp;
				UnicodeString lnam = l_lst->Strings[i];
				std::unique_ptr<TStringList> lib(new TStringList());
				get_LibraryList(lnam, lib.get());
				if (lib->Count==1) {
					dnam = lib->Strings[0];
					//タイトル,パス,ライブラリ(ico),ライブラリ	(4)
					m_buf->Add(tmp.sprintf(_T("&%u: %s\t%s\t%s\t%s"), i + 1,
									get_base_name(lnam).c_str(), dnam.c_str(), lnam.c_str(), lnam.c_str()));
				}
				else if (lib->Count>1) {
					//タイトル,,ライブラリ(ico)	(3)
					m_buf->Add(tmp.sprintf(_T(">&%u: %s\t\t%s"), i + 1, get_base_name(lnam).c_str(), lnam.c_str()));
					for (int j=0; j<lib->Count; j++) {
						dnam = lib->Strings[j];
						rnam = yen_to_delimiter(ExcludeTrailingPathDelimiter(DispRegName? get_RegDirName(dnam) : dnam));
						//タイトル,パス,,ライブラリ,サブ	(5)
						m_buf->Add(tmp.sprintf(_T("&%u: %s\t%s\t\t%s\t%s"),
									j + 1, rnam.c_str(), dnam.c_str(), lnam.c_str(), ExtractFileName(dnam).c_str()));
					}
					m_buf->Add("<");
				}
			}
			//選択
			ExePopMenuList(m_buf.get(), true, cp);
			if (PopMenuIndex!=-1) {
				TStringDynArray itm_buf = split_strings_tab(m_buf->Strings[PopMenuIndex]);
				if (itm_buf.Length>=4) {
					l_dnam = itm_buf[1];
					l_snam = (itm_buf.Length==5)? itm_buf[4] : EmptyStr;
					l_fnam = itm_buf[3];
				}
			}
		}
		//指定ライブラリ
		else {
			l_fnam = ChangeFileExt(prm, ".library-ms");
			if (ExtractFilePath(l_fnam).IsEmpty()) l_fnam.Insert(LibraryPath, 1);
			if (!file_exists(l_fnam)) return false;

			std::unique_ptr<TStringList> lib(new TStringList());
			get_LibraryList(l_fnam, lib.get());
			if (lib->Count==0) Abort();
			if (lib->Count==1) {
				l_dnam = lib->Strings[0];
			}
			else {
				//ポップアップメニューで選択
				ActionOptStr = "ListItemPos";
				std::unique_ptr<TStringList> m_buf(new TStringList());
				for (int i=0; i<lib->Count; i++) {
					UnicodeString lbuf = lib->Strings[i];
					UnicodeString rnam = yen_to_slash(ExcludeTrailingPathDelimiter(DispRegName? get_RegDirName(lbuf) : lbuf));
					//タイトル,パス	(2)
					m_buf->Add(UnicodeString().sprintf(_T("&%u: %s\t%s"), i + 1, rnam.c_str(), lbuf.c_str()));
				}
				ExePopMenuList(m_buf.get(), true, cp);
				if (PopMenuIndex!=-1) {
					l_dnam = get_post_tab(m_buf->Strings[PopMenuIndex]);
					l_snam = ExtractFileName(l_dnam);
				}
			}
		}

		//開く
		if (!l_dnam.IsEmpty()) {
			if (!dir_exists(l_dnam)) Abort();
			flist_stt *lst_stt = &ListStt[tag];
			if (lst_stt->is_Find || lst_stt->is_Work) RecoverFileList();
			lst_stt->LibraryInfo.sprintf(_T("%s\t%s"), l_fnam.c_str(), l_dnam.c_str());
			lst_stt->LibSubPath = l_snam;
			if (tag==CurListTag) UpdateCurPath(l_dnam); else UpdateOppPath(l_dnam);
		}

		return true;
	}
	catch (...) {
		return false;
	}
}

//---------------------------------------------------------------------------
//ライブラリへ
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::LibraryActionExecute(TObject *Sender)
{
	try {
		if (TEST_ActParam("SD")) {
			if (!NetShareDlg) NetShareDlg = new TNetShareDlg(this);	//初回に動的作成
			NetShareDlg->isLibrary = true;
			NetShareDlg->ShowModal();
		}
		else if (!ActionParam.IsEmpty()) {
			if (!PopSelLibrary(ActionParam)) UserAbort(USTR_DirNotFound);
		}
		else {
			UpdateCurPath(LibraryPath);
			if (!GlobalErrMsg.IsEmpty()) GlobalAbort();
		}
	}
	catch (EAbort &e) {
		SetActionAbort(e.Message);
	}
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::LibraryItemClick(TObject *Sender)
{
	ExeCommandAction("Library", "*");
}

//---------------------------------------------------------------------------
//リンク先を反対側に開く
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::LinkToOppActionExecute(TObject *Sender)
{
	try {
		if (CurStt->is_FTP) UserAbort(USTR_CantOperate);
		file_rec *cfp = GetCurFrecPtr(true);
		if (!cfp || cfp->is_virtual || cfp->f_attr==faInvalid) Abort();

		UnicodeString fnam;
		//シンボリックリンク、ジャンクション
		if (cfp->is_sym) {
			fnam = cfp->l_name;
		}
		//ショートカット
		else if (test_LnkExt(cfp->f_ext)) {
			fnam = usr_SH->get_LnkName(cfp->f_name);
		}
		//ハードリンク
		else {
			if (cfp->is_dir || CurStt->is_ADS || StartsStr("\\\\", CurPath[CurListTag])) Abort();
			if (get_HardLinkCount(cfp->f_name)<2) Abort();
			std::unique_ptr<TStringList> hlst(new TStringList());
			if (get_HardLinkList(cfp->f_name, hlst.get())>0) {
				UnicodeString onam = CurPath[OppListTag];
				UnicodeString fnam2;
				for (int i=0; i<hlst->Count; i++) {
					UnicodeString hnam = hlst->Strings[i];
					if (SameText(cfp->f_name, hnam)) continue;
					if (fnam.IsEmpty() && IndexOfFileList(hnam, OppListTag)!=-1)
						fnam  = hnam;
					else if (fnam2.IsEmpty())
						fnam2 = hnam;
					else if (!fnam.IsEmpty() && !fnam2.IsEmpty()) break;
				}
				if (fnam.IsEmpty()) fnam = fnam2;
			}
		}

		if (fnam.IsEmpty()) Abort();
		if (!file_exists(fnam)) UserAbort(USTR_NotFound);

		if (dir_exists(fnam))
			CurPath[OppListTag] = exclede_delimiter_if_root(fnam);
		else {
			CurPath[OppListTag] = exclede_delimiter_if_root(ExtractFilePath(fnam));
			int idx = IndexOfFileList(fnam, OppListTag);
			if (idx!=-1) {
				TListBox *lp  = FileListBox[OppListTag];
				lp->ItemIndex = idx;
				DrawOppCsr++;
				lp->Invalidate();
			}
		}

		//反対側へ
		if (TEST_ActParam("TO")) ToOppositeAction->Execute();
	}
	catch (EAbort &e) {
		SetActionAbort(e.Message);
	}
}

//---------------------------------------------------------------------------
//アーカイブの内容一覧をログに表示
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ListArchiveActionExecute(TObject *Sender)
{
	try {
		if (CurStt->is_FTP) UserAbort(USTR_CantOperate);

		CurWorking = true;
		file_rec *cfp = GetCurFrecPtr();
		if (!cfp || cfp->is_dir) Abort();
		if (cfp->is_virtual && !SetTmpFile(cfp)) UserAbort(USTR_FaildTmpUnpack);

		//一覧を取得
		std::unique_ptr<TStringList> r_lst(new TStringList());
		if (!usr_ARC->GetArcList(cfp->is_virtual? cfp->tmp_name : cfp->f_name, "l", r_lst.get()))
			UserAbort(USTR_FaildProc);

		//一覧をログに表示
		AddLogCr();
		UnicodeString msg = "  LIST ";
		if (!cfp->arc_name.IsEmpty()) msg += CurStt->arc_DspPath;
		msg = yen_to_slash(msg + cfp->n_name);
		AddLog(msg);
		AddLogStrings(r_lst.get());
		AddLogCr();
		//コピー/一覧表示/ファイル出力
		ClipSaveList(r_lst.get(), _T("アーカイブの内容一覧"));
		CurWorking = false;
	}
	catch (EAbort &e) {
		SetActionAbort(e.Message);
	}
}

//---------------------------------------------------------------------------
//ファイル再生時間の一覧
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ListDurationActionExecute(TObject *Sender)
{
	try {
		if (CurStt->is_Arc || CurStt->is_FTP) UserAbort(USTR_CantOperate);

		TStringList *lst = GetCurList(true);
		int sel_cnt = GetSelCount(lst);
		if (sel_cnt==0) UserAbort(USTR_NoObject);
		bool inc_dir = TestCurIncDir();

		CalcBusy = true;
		ShowMessageHint(USTR_CalculatingESC, col_bgHint, false, true);
		StartLog(_T("計算開始"));
		SttWorkMsg(_T("再生時間を計算中..."), CalcTag);

		std::unique_ptr<TStringList> r_lst(new TStringList());
		UnicodeString msg, stt_str;
		int total_time	= 0;	//総再生時間
		int total_f_cnt = 0;	//総ファイル数
		int item_cnt	= 0;
		int er_cnt		= 0;
		for (int i=0; i<lst->Count && !CalcAborted; i++) {
			Application->ProcessMessages();
			file_rec *fp = (file_rec*)lst->Objects[i];
			if (!fp->selected) continue;
			stt_str.sprintf(_T("再生時間を計算中... %u/%u"), ++item_cnt, sel_cnt);
			//ディレクトリ
			if (fp->is_dir) {
				//オーディオ/ビデオファイルを抽出
				stt_str.cat_sprintf(_T(" - [%s]"), fp->b_name.c_str());
				SttWorkMsg(stt_str + " - 対象を検索中", CalcTag);
				std::unique_ptr<TStringList> fbuf(new TStringList());
				get_files(fp->f_name, _T("*.*"), fbuf.get(), true);
				int j = 0;
				while (j<fbuf->Count) {
					if (!is_AudioVideo(fbuf->Strings[j])) fbuf->Delete(j); else j++;
				}

				int sub_t   = 0;
				int sub_cnt = 0;
				int sub_er  = 0;
				for (int j=0; j<fbuf->Count && !CalcAborted; j++) {
					Application->ProcessMessages();
					UnicodeString fnam = fbuf->Strings[j];
					SttWorkMsg(stt_str + msg.sprintf(_T(" %u/%u"), j + 1, fbuf->Count), CalcTag);
					int t = get_duration(fnam);
					if (t>=0) sub_t += t; else sub_er++;
					sub_cnt++;
				}
				total_time += sub_t; er_cnt += sub_er; total_f_cnt += sub_cnt;
				msg.sprintf(_T("[%s]\t %-11s%11u"), fp->b_name.c_str(), mSecToTStr(sub_t, sub_t%1000!=0).c_str(), sub_cnt);
				if (sub_er>0) msg.cat_sprintf(_T("  ERR:%u"), sub_er);
				r_lst->Add(msg);
			}
			//ファイル
			else {
				SttWorkMsg(stt_str, CalcTag);
				int t = get_duration(fp->f_name);
				if (t>=0) {
					total_time += t;
					msg.sprintf(_T("%s\t %-11s"), fp->n_name.c_str(), mSecToTStr(t, t%1000!=0).c_str());
				}
				else {
					msg.sprintf(_T("%s\t ??:??:??.??"), fp->n_name.c_str());
					er_cnt++;
				}
				if (inc_dir) msg += "          1";
				if (t<0) msg += "  E";
				r_lst->Add(msg);
				total_f_cnt++;
			}
			fp->selected = false;
			InvalidateFileList();
		}
		RepaintList(CurListTag);
		CalcBusy = false;
		if (CalcAborted) SttBarWarnUstr(USTR_Canceled);

		//整形
		int max_len = format_res_list(r_lst.get());
		//合計
		UnicodeString hr_str = inc_dir? make_RuledLine(3, max_len, 11, 10) : make_RuledLine(2, max_len, 11);
		r_lst->Add(hr_str);
		if (inc_dir)
			msg.sprintf(_T("%-*s %-11s%11u"), max_len - 2, _T("合計"), mSecToTStr(total_time, total_time%1000>0).c_str(), total_f_cnt);
		else
			msg.sprintf(_T("%-*s%8u  %-11s"), max_len - 11, _T("合計"), total_f_cnt, mSecToTStr(total_time, total_time%1000>0).c_str());
		if (er_cnt>0) msg.cat_sprintf(_T("  ERR:%u"), er_cnt);
		r_lst->Add(msg);
		//ヘッダ
		r_lst->Insert(0, hr_str);
		msg.sprintf(_T("ファイル名%*s長さ"), max_len - 9, _T(" "));
		if (inc_dir) msg += "        ファイル数";
		r_lst->Insert(0, msg);
		r_lst->Insert(0, CurPath[CurListTag]);
		//ログ出力
		AddLogStrings(r_lst.get());
		AddLog(CalcAborted? _T("計算中断") : _T("計算終了"), true);
		AddLogCr();
		//コピー/一覧表示/ファイル出力
		ClipSaveList(r_lst.get(), _T("再生時間の一覧"));
		if (!CalcAborted) SttWorkMsg(EmptyStr, CalcTag);
	}
	catch (EAbort &e) {
		SetActionAbort(e.Message);
	}
}

//---------------------------------------------------------------------------
//DLL のエクスポート関数一覧
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ListExpFuncActionExecute(TObject *Sender)
{
	try {
		if (CurStt->is_FTP) UserAbort(USTR_CantOperate);

		cursor_HourGlass();
		file_rec *cfp = GetCurFrecPtr();
		if (!cfp || cfp->is_dir) Abort();
		if (cfp->is_virtual && !SetTmpFile(cfp)) UserAbort(USTR_FaildTmpUnpack);

		UnicodeString msg = make_LogHdr(_T("LIST"), cfp);
		//一覧を取得
		std::unique_ptr<TStringList> r_lst(new TStringList());
		bool ok = get_DllExpFunc(cfp->is_virtual? cfp->tmp_name : cfp->f_name, r_lst.get());
		if (!ok) set_LogErrMsg(msg);
		AddLogCr(); AddLog(msg);
		if (ok) {
			AddLogStrings(r_lst.get());
			AddLogCr();
			//コピー/一覧表示/ファイル出力
			ClipSaveList(r_lst.get(), _T("エクスポート関数一覧"));
		}
		cursor_Default();
	}
	catch (EAbort &e) {
		SetActionAbort(e.Message);
	}
}

//---------------------------------------------------------------------------
//クリップボードを一覧で表示
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ListClipboardActionExecute(TObject *Sender)
{
	try {
		GeneralInfoDlg->ToFilter = TEST_ActParam("FF");
		if (Clipboard()->AsText.IsEmpty()) Abort();
		std::unique_ptr<TStringList> lst(new TStringList());
		lst->Text = Clipboard()->AsText;
		set_FormTitle(GeneralInfoDlg, _T("クリップボード"));
		GeneralInfoDlg->GenInfoList->Assign(lst.get());
		GeneralInfoDlg->ShowModal();
	}
	catch (EAbort &e) {
		SetActionAbort(e.Message);
	}
}

//---------------------------------------------------------------------------
//ファイル名の一覧
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ListFileNameActionExecute(TObject *Sender)
{
	UnicodeString fmt =
		ActionParam.IsEmpty()? UnicodeString("$F") :
		  TEST_ActParam("FN")? UnicodeString("$B") : ActionParam;

	TStringList *lst = GetCurList();
	std::unique_ptr<TStringList> r_lst(new TStringList());
	GetCopyFileNames(fmt, GetSelCount(lst)==0, NULL, r_lst.get());
	if (r_lst->Count>0) {
		set_FormTitle(GeneralInfoDlg, _T("ファイル名一覧"));
		GeneralInfoDlg->isFileList = true;
		GeneralInfoDlg->GenInfoList->Assign(r_lst.get());
		if (GeneralInfoDlg->ShowModal()==mrOk) {
			//選択状態を反映
			TStringList *sel_lst = GeneralInfoDlg->GenSelList;
			if (sel_lst->Count>0) {
				for (int i=0; i<lst->Count; i++) {
					file_rec *fp = (file_rec*)lst->Objects[i];
					fp->selected = (sel_lst->IndexOf(fp->f_name)!=-1);
				}
				InvalidateFileList();
			}
			//カーソル移動
			IndexOfFileList(GeneralInfoDlg->RetStr);
		}
	}
}

//---------------------------------------------------------------------------
//ログを一覧表示
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ListLogActionExecute(TObject *Sender)
{
	set_FormTitle(GeneralInfoDlg, _T("ログ"));
	GeneralInfoDlg->isLog	 = true;
	GeneralInfoDlg->ToFilter = TEST_DEL_ActParam("FF");
	GeneralInfoDlg->ErrOnly  = TEST_DEL_ActParam("EO");
	GeneralInfoDlg->GenInfoList->Assign(LogBufList);
	GeneralInfoDlg->ShowModal();
}

//---------------------------------------------------------------------------
//NyanFi 情報
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ListNyanFiActionExecute(TObject *Sender)
{
	UnicodeString hr_str = StringOfChar(_T('-'), 62);
	UnicodeString tmp;

	std::unique_ptr<TStringList> lst(new TStringList());
	TStringList *i_lst = lst.get();

	get_FileNamePathInf(Application->ExeName, i_lst);
	if (IsAdmin) i_lst->Add("管理者として実行");
	get_AppInf(Application->ExeName, i_lst);
	add_PropLine(_T("URL"),			 SUPPORT_URL, i_lst);
	add_PropLine(_T("クラス名"),	 ClassName(), i_lst);

	TRect w_rc = get_window_rect(Handle);
	add_PropLine(_T("Windowサイズ"), get_wd_x_hi_str(w_rc.Width(), w_rc.Height()), i_lst);
	i_lst->Add(EmptyStr);

	//アーカイバDLL情報
	int cnt = 0;
	for (int i=0; i<MAX_ARC_DLL; i++) if (usr_ARC->ArcFunc[i].Available) cnt++;
	if (cnt>0) {
		i_lst->Add("[アーカイバDLL] " + hr_str);
		for (int i=0; i<MAX_ARC_DLL; i++) {
			arc_func *fp = &usr_ARC->ArcFunc[i];
			if (fp->hDll) {
				get_FileNamePathInf(fp->FileName, i_lst, true);
				if (fp->Available) {
					//7z.dll版のエラー
					if (fp->use7zdll) {
						if (!FExt7zDll.IsEmpty()) add_PropLine(_T("追加拡張子"), FExt7zDll, i_lst);
						if (fp->err7zdll) add_PropLine(_T("エラー"), "7z.dll not found", i_lst, LBFLG_ERR_FIF);
					}
					else if (usr_ARC->Use7zDll) {
						if ((USAME_TI(fp->Prefix, "Unrar") && test_FileExt(".rar", FExt7zDll)) ||
							(USAME_TI(fp->Prefix, "UnIso") && test_FileExt(".iso", FExt7zDll)))
						{
							add_PropLine(_T("備考"), "使用されません。", i_lst);
						}
					}
				}
				else {
					add_PropLine(_T("エラー"), "利用できません", i_lst, LBFLG_ERR_FIF);
				}
				i_lst->Add(EmptyStr);

				//unrar
				if (USAME_TI(fp->Prefix, "Unrar")) {
					UnicodeString fnam = ExtractFilePath(fp->FileName) + (is_X64()? "unrar64.dll" : "unrar.dll");
					i_lst->Add(ExtractFileName(fnam));
					if (fnam.Pos('\\')) i_lst->Add(ExtractFilePath(fnam));
					if (file_exists(fnam)) {
						i_lst->Add(get_FileInfStr(fnam));
						get_AppInf(fnam, i_lst, false);
						if (usr_ARC->Use7zDll && test_FileExt(".rar", FExt7zDll)) {
							add_PropLine(_T("備考"), "使用されません。", i_lst);
						}
					}
					else {
						add_PropLine(_T("エラー"), LoadUsrMsg(USTR_NotFound), i_lst, LBFLG_ERR_FIF);
					}
					i_lst->Add(EmptyStr);
				}
			}
		}
	}

	//Susieプラグイン情報
	if (SPI->PlgList->Count>0) {
		i_lst->Add("[Susie Plug-in] " + hr_str);
		for (int i=0; i<SPI->PlgList->Count; i++) {
			spi_info *sp = SPI->PlgList->Items[i];
			get_FileNamePathInf(sp->FileName, i_lst);
			add_PropLine(_T("API Ver."),		sp->VerType,	i_lst);
			add_PropLine(_T("Plug-in情報"),		sp->FileInfo,	i_lst);
			add_PropLine(_T("対応拡張子"),		sp->FileExt,	i_lst);
			add_PropLine(_T("ファイル形式名"),	sp->FileType,	i_lst);
			get_AppInf(sp->FileName, i_lst);
			i_lst->Add(EmptyStr);
		}
	}

	//Migemo
	if (usr_Migemo->DictReady) {
		i_lst->Add("[C/Migemo] -----" + hr_str);
		get_FileNamePathInf(usr_Migemo->FileName, i_lst, true);
		i_lst->Add(EmptyStr);
	}

	//xdoc2txt
	if (xd2tx_Available) {
		i_lst->Add("[xdoc2txt] -----" + hr_str);
		get_FileNamePathInf(xd2tx_FileName, i_lst, true);
		i_lst->Add(EmptyStr);
	}

	int i = 0;
	while (i<i_lst->Count) {
		if (ContainsStr(i_lst->Strings[i], "元のファイル名:")) i_lst->Delete(i); else i++;
	}

	//WIC
	i_lst->Add("[WIC] ----------" + hr_str);
	add_PropLine(_T("拡張子(標準)"), FEXT_WICSTD, i_lst);
	add_PropLine(_T("拡張子(拡張)"), WicFextStr,  i_lst);
	i_lst->Add(EmptyStr);
	i_lst->Add("拡張コーデック");
	if (WIC_get_ex_list(i_lst)==0) i_lst->Add("  無し");

	//Git
	if (GitExists) {
		i_lst->Add("[Git] ----------" + hr_str);
		get_FileNamePathInf(CmdGitExe, i_lst, true);
		i_lst->Add(EmptyStr);
	}

	//情報をログに表示
	AddLogCr();
	AddLogStrings(i_lst);
	AddLogCr();

	//コピー/一覧表示/ファイル出力
	try {
		ClipSaveList(i_lst, _T("NyanFi 情報"));
	}
	catch (EAbort &e) {
		SetActionAbort(e.Message);
	}
}

//---------------------------------------------------------------------------
//テキストファイルを一覧ダイアログで表示
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ListTextCore(bool is_tail)
{
	try {
		bool reverse = false;
		int  tail_ln = 100;

		if (is_tail) {
			GeneralInfoDlg->ToEnd	 = TEST_DEL_ActParam("TE");
			GeneralInfoDlg->ToFilter = TEST_DEL_ActParam("FF");
			reverse = remove_top_text(ActionParam, _T("R"));
			if (!ActionParam.IsEmpty()) {
				UnicodeString s = split_tkn(ActionParam, ';');
				int n = s.ToIntDef(-1);
				if (n>0) tail_ln = n; else ActionParam = s;
			}
		}
		else {
			GeneralInfoDlg->ToFilter = TEST_DEL_ActParam("FF");
			GeneralInfoDlg->ErrOnly  = TEST_DEL_ActParam("EO");
		}

		UnicodeString h_ptn = extract_prm_RegExPtn(ActionParam);	//見出しパターン

		UnicodeString fnam, rnam;
		bool is_ftp = false;
		if (!ActionParam.IsEmpty()) {
			fnam = rnam = to_absolute_name(ActionParam, CurPath[CurListTag]);
		}
		else {
			file_rec *cfp = GetCurFrecPtr(true);
			if (!cfp || cfp->is_dummy || cfp->is_dir) Abort();
			if (cfp->is_virtual && !SetTmpFile(cfp)) UserAbort(USTR_FaildTmpUnpack);
			if (cfp->is_ftp && !file_exists(cfp->tmp_name)) cfp->tmp_name = DownloadFtpCore(cfp);
			fnam   = (cfp->is_virtual || cfp->is_ftp)? cfp->tmp_name : cfp->f_name;
			rnam   = cfp->f_name;
			is_ftp = cfp->is_ftp;
		}

		int code_page;
		UnicodeString line_brk;
		bool has_bom;
		if (!is_TextFile(fnam, &code_page, &line_brk, &has_bom)) UserAbort(USTR_NotText);

		KeepModalScr = true;
		for (;;) {
			std::unique_ptr<TStringList> f_buf(new TStringList());
			cursor_HourGlass();
			if (is_tail) {
				load_text_tail(fnam, f_buf.get(), code_page, tail_ln, reverse);
			}
			else {
				load_text_ex(fnam, f_buf.get(), code_page);
				GeneralInfoDlg->isTree = AddPathToTreeList(f_buf.get());
			}
			cursor_Default();

			GeneralInfoDlg->ErrMsg		 = GlobalErrMsg;
			GeneralInfoDlg->FileName	 = fnam;
			GeneralInfoDlg->CodePage	 = code_page;
			GeneralInfoDlg->LineBreakStr = line_brk;
			GeneralInfoDlg->HasBOM		 = has_bom;
			GeneralInfoDlg->HdrLnStr	 = h_ptn;

			if (is_tail) {
				GeneralInfoDlg->isTail	  = true;
				GeneralInfoDlg->TailLine  = tail_ln;
				GeneralInfoDlg->isReverse = reverse;
			}
			GeneralInfoDlg->isFTP = is_ftp;
			GeneralInfoDlg->GenInfoList->Assign(f_buf.get());
			if (GeneralInfoDlg->ShowModal()!=mrRetry) break;

			//次/前のテキストへ
			TStringList *lst = GetCurList();
			int idx = IndexOfFileList(rnam);
			int cnt = 0;
			do {
				idx = USAME_TI(GeneralInfoDlg->RetStr, "PrevFile")? to_PrevFile(lst, idx) : to_NextFile(lst, idx);
				if (idx==-1) {
					beep_Warn(); break;
				}

				FileListBox[CurListTag]->ItemIndex = idx;
				file_rec *cfp = GetCurFrecPtr(true);	if (!cfp) Abort();
				if (cfp->is_virtual && !SetTmpFile(cfp)) UserAbort(USTR_FaildTmpUnpack);
				fnam = cfp->is_virtual? cfp->tmp_name : cfp->f_name;
				rnam = cfp->f_name;
				cnt++;
			} while (!is_TextFile(fnam, &code_page, &line_brk, &has_bom) && cnt<lst->Count);
			SetFileInf();
		}
		KeepModalScr = false;	ModalScrForm->Visible = false;
	}
	catch (EAbort &e) {
		KeepModalScr = false;	ModalScrForm->Visible = false;
		SetActionAbort(e.Message);
	}
}
//---------------------------------------------------------------------------
//テキストファイルの末尾を一覧で表示
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ListTailActionExecute(TObject *Sender)
{
	ListTextCore(true);
}
//---------------------------------------------------------------------------
//テキストファイルを一覧で表示
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ListTextActionExecute(TObject *Sender)
{
	ListTextCore(false);
}

//---------------------------------------------------------------------------
//ディレクトリのツリー表示
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ListTreeActionExecute(TObject *Sender)
{
	try {
		if (!IsCurFList()) UserAbort(USTR_OpeNotSuported);

		CurWorking = true;
		ShowMessageHint(USTR_WaitForReady, col_bgHint, false, true);

		UnicodeString cnam;
		if (!ActionParam.IsEmpty())
			cnam = to_absolute_name(cv_env_str(ActionParam), CurPath[CurListTag]);
		else
			cnam = CurPath[CurListTag];
		if (!dir_exists(cnam)) SysErrAbort(ERROR_PATH_NOT_FOUND);

		std::unique_ptr<TStringList> r_lst(new TStringList());
		TStringList *lst = GetCurList(true);
		if (ListSelected(lst)) {
			for (int i=0; i<lst->Count; i++) {
				file_rec *fp = (file_rec*)lst->Objects[i];
				if (fp->selected && fp->is_dir) {
					r_lst->Add(IncludeTrailingPathDelimiter(fp->f_name));
					get_SubDirs(fp->f_name, r_lst.get(), NULL, 0, true);
				}
			}
		}
		if (r_lst->Count==0) get_SubDirs(cnam, r_lst.get(), NULL, 0, true);

		MakeTreeList(r_lst.get(), cnam);

		CurWorking = false;

		GeneralInfoDlg->Caption = "ディレクトリのツリー表示";
		GeneralInfoDlg->isTree  = true;
		GeneralInfoDlg->GenInfoList->Assign(r_lst.get());
		GeneralInfoDlg->ShowModal();
	}
	catch (EAbort &e) {
		SetActionAbort(e.Message);
	}
}

//---------------------------------------------------------------------------
//ファイルのハッシュ値を取得
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::GetHashActionExecute(TObject *Sender)
{
	try {
		if (TestCurIncDir()) UserAbort(USTR_IncludeDir);
		if (TestCurIncFindVirtual() || CurStt->is_FTP) UserAbort(USTR_OpeNotSuported);

		UnicodeString idstr = def_if_empty(ActionParam, "MD5");

		CurWorking = true;
		ShowMessageHint(USTR_WaitForReady, col_bgHint, false, true);
		file_rec *cfp = GetCurFrecPtr(true);
		if (!cfp || cfp->is_dir) Abort();
		if (cfp->is_virtual && !SetTmpFile(cfp)) UserAbort(USTR_FaildTmpUnpack);
		UnicodeString fnam = cfp->is_virtual? cfp->tmp_name : cfp->f_name;
		UnicodeString msg  = make_LogHdr(idstr, cfp->f_name);
		UnicodeString hash = get_HashStr(fnam, idstr);
		if (!hash.IsEmpty()) {
			cfp->hash = hash;
			copy_to_Clipboard(hash);
			msg.cat_sprintf(_T("  %s"), hash.c_str());
			ViewFileInf(cfp, true);
		}
		else set_LogErrMsg(msg);
		AddLogCr(); AddLog(msg);
		CurWorking = false;
	}
	catch (EAbort &e) {
		SetActionAbort(e.Message);
	}
}

//---------------------------------------------------------------------------
//背景画像の読み込み
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::LoadBgImageActionExecute(TObject *Sender)
{
	try {
		if (BgImgMode==1 || BgImgMode==2) {
			UnicodeString fnam, msg;
			//指定
			if (!ActionParam.IsEmpty()) {
				fnam = to_absolute_name(ActionParam);
			}
			//カーソル位置
			else {
				if (CurStt->is_Arc) UserAbort(USTR_CantOperate);
				file_rec *cfp = GetCurFrecPtr();
				if (!is_Viewable(cfp))	Abort();
				fnam = cfp->f_name;
			}

			AddLog(make_LogHdr(_T("BGIMG"), fnam));
			BgImgName[(BgImgMode==2)? CurListTag : 0] = to_relative_name(fnam);
			if (!UpdateBgImage(true, true)) UserAbort(USTR_FaildLoad);
		}
	}
	catch (EAbort &e) {
		SetActionAbort(e.Message);
	}
}

//---------------------------------------------------------------------------
//結果リストをファイルから読み込む
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::LoadResultListActionExecute(TObject *Sender)
{
	try {
		UnicodeString fnam;
		if (!ActionParam.IsEmpty()) {
			fnam = to_absolute_name(ActionParam);
		}
		else {
			UserModule->PrepareOpenDlg(_T("結果ストを読み込む"), F_FILTER_TXT, _T("*.txt"), ResultListPath);
			if (!UserModule->OpenDlg->Execute()) SkipAbort();
			fnam = UserModule->OpenDlg->FileName;
		}
	
		if (!file_exists(fnam)) UserAbort(USTR_FileNotOpen);
		ResultListPath = ExtractFilePath(fnam);

		CurWorking = true;
		FindTag    = CurListTag;
		ShowMessageHint(USTR_WaitForReady, col_bgHint, false, true);

		if (OppStt->is_Find) RecoverFileList(OppListTag);
		TStringList *r_lst = ResultList[FindTag];
		clear_FileList(r_lst);

		std::unique_ptr<TStringList> fbuf(new TStringList());
		fbuf->LoadFromFile(fnam);
		if (fbuf->Count==0 || !USAME_TI(fbuf->Strings[0], ";[ResultList]")) UserAbort(USTR_IllegalFormat);

		std::unique_ptr<TStringList> stt_lst(new TStringList());
		for (int i=0; i<fbuf->Count; i++) {
			UnicodeString lbuf = fbuf->Strings[i]; 
			if (lbuf.IsEmpty()) continue;
			//検索情報
			if (remove_top_s(lbuf, ';')) {
				stt_lst->Add(lbuf);
				continue;
			}

			//項目
			UnicodeString fnam = split_pre_tab(lbuf);
			UnicodeString anam = lbuf;
			if (fnam.IsEmpty() && anam.IsEmpty()) continue;

			if (fnam.IsEmpty() && is_separator(anam)) {
				r_lst->AddObject(fnam, (TObject*)cre_new_file_rec("-", FindTag));
			}
			else if (!is_InvalidUnc(ExtractFilePath(fnam))
				&& (ends_PathDlmtr(fnam)? dir_exists(fnam) : file_exists(fnam)))
			{
				r_lst->AddObject(fnam, (TObject*)cre_new_file_rec(fnam, FindTag));
			}
		}

		UnicodeString dnam = def_if_empty(stt_lst->Values["Find_Path"], CurPath[FindTag]);
		UpdateCurPath(dnam);

		//検索情報を復元
		clear_FindStt(CurStt);
		CurStt->is_Find 	  = true;
		CurStt->find_Path	  = dnam;
		CurStt->find_Keywd	  = stt_lst->Values["Find_Keywd"];
		CurStt->find_Mask	  = stt_lst->Values["Find_Mask"];
		CurStt->find_Icons	  = ReplaceStr(stt_lst->Values["Find_Icons"], "/", "\r\n");

		CurStt->find_MARK	  = USAME_TS(stt_lst->Values["Find_MARK"],	"1");
		CurStt->find_TAG	  = USAME_TS(stt_lst->Values["Find_TAG"],	"1");
		CurStt->find_DUPL	  = USAME_TS(stt_lst->Values["Find_DUPL"],	"1");
		CurStt->find_DICON	  = USAME_TS(stt_lst->Values["find_DICON"],	"1");
		CurStt->find_HLINK	  = USAME_TS(stt_lst->Values["Find_HLINK"],	"1");

		CurStt->find_ResLink  = USAME_TS(stt_lst->Values["Find_ResLink"], "1");
		CurStt->find_DirLink  = USAME_TS(stt_lst->Values["Find_DirLink"], "1");
		CurStt->find_PathSort = FindPathColumn;
		CurStt->find_Loaded   = (!CurStt->find_DICON);

		//戻り用
		file_rec *fp = cre_new_up_rec(FindTag);
		fp->f_time = get_file_age(fnam);
		fp->p_name = CurStt->find_Path;
		r_lst->InsertObject(0, fp->f_name, (TObject*)fp);

		//リストボックス初期化(仮想)
		FileListBox[FindTag]->Color = col_bgFind;
		UpdateBgImage();
		SetFlItemWidth(r_lst, FindTag);
		update_FileListBox(r_lst, FindTag, 0);
		ViewCurFileInf();
		SetDirCaption(FindTag);
		SetDriveFileInfo(FindTag);

		CurWorking = false;
	}
	catch (EAbort &e) {
		SetActionAbort(e.Message);
	}
}

//---------------------------------------------------------------------------
//タブグループをファイルから読み込む
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::LoadTabGroupActionExecute(TObject *Sender)
{
	try {
		UnicodeString fnam;
		if (!ActionParam.IsEmpty()) {
			fnam = to_absolute_name(ActionParam);
		}
		else {
			UserModule->PrepareOpenDlg(_T("タブグループを読み込む"), F_FILTER_INI, _T("*.INI"));
			if (UserModule->OpenDlg->Execute()) fnam = UserModule->OpenDlg->FileName;
		}
		if (fnam.IsEmpty()) SkipAbort();

		if (!file_exists(fnam)) SttBarWarnUstr(USTR_FileNotOpen);

		std::unique_ptr<UsrIniFile> tab_file(new UsrIniFile(fnam));
		UnicodeString sct = "General";
		int tab_idx = tab_file->ReadInteger(sct, "CurTabIndex", 0);

		std::unique_ptr<TStringList> tab_lst(new TStringList());
		tab_file->LoadListItems("TabList", tab_lst.get(), 30, false);
		if (tab_lst->Count==0) TextAbort(_T("有効な項目がありません。"));

		for (int i=0; i<TabList->Count; i++) del_tab_info((tab_info*)TabList->Objects[i]);
		TabList->Assign(tab_lst.get());

		for (int i=0; i<TabList->Count; i++) {
			tab_info *tp = new tab_info;
			for (int j=0; j<MAX_FILELIST; j++) {
				tp->sel_list[j]   = new TStringList();
				tp->dir_hist[j]   = new TStringList();
				tp->dir_hist_p[j] = 0;
				tab_file->LoadListItems(sct.sprintf(_T("DirHistory%02u_%u"), i + 1, j), tp->dir_hist[j], 30, false);
			}
			TabList->Objects[i] = (TObject*)tp;
		}

		UpdateTabBar(tab_idx, true);
		TabControl1Change(NULL);
		TabGroupName = fnam;
	}
	catch (EAbort &e) {
		SetActionAbort(e.Message);
	}
}

//---------------------------------------------------------------------------
//ワークリストをファイルから読み込む
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::LoadWorkListActionExecute(TObject *Sender)
{
	try {
		UnicodeString wnam = ActionParam;

		SaveWorkListAction->Execute();

		//パラメータ指定
		if (!wnam.IsEmpty()) {
			if (!SetWorkList(to_absolute_name(wnam))) UserAbort(USTR_WlistCantOpen);
		}
		//通常動作
		else {
			UserModule->PrepareOpenDlg(_T("ワークリストを読み込む"), F_FILTER_NWL, _T("*.nwl"), WorkListPath);
			if (UserModule->OpenDlg->Execute()) {
				if (!SetWorkList(UserModule->OpenDlg->FileName)) UserAbort(USTR_WlistCantOpen);
				WorkListPath = ExtractFilePath(UserModule->OpenDlg->FileName);
			}
		}
		//履歴に追加
		if (WorkToDirHist && CurStt->is_Work) AddDirHistory(WorkListName, CurListTag);
	}
	catch (EAbort &e) {
		SetActionAbort(e.Message);
	}
}

//---------------------------------------------------------------------------
//テキストプレビューをロック
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::LockTextPreviewActionExecute(TObject *Sender)
{
	SetToggleAction(LockTxtPrv);
	LockTxtPanel->Visible = LockTxtPrv;
	if (LockTxtPrv)
		LockTxtPanel->Caption = " LOCK: " + ExtractFileName(TxtPrvFile) + get_FileInfStr(TxtPrvFile, false);
	else
		SetFileInf();
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::LockTextPreviewActionUpdate(TObject *Sender)
{
	TAction *ap = (TAction*)Sender;
	ap->Visible = ScrMode==SCMD_FLIST;
	ap->Enabled = ap->Visible && TxtPrvListPanel->Showing;
	ap->Checked = LockTxtPrv;
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::LockTxtPanelDblClick(TObject *Sender)
{
	LockTxtPrv = false;
	LockTxtPanel->Visible = LockTxtPrv;
}

//---------------------------------------------------------------------------
//ファイル情報をログに出力
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::LogFileInfoCore(file_rec *fp)
{
	UnicodeString msg = "  FLINFO ";
	try {
		if (!fp) Abort();
		if (!fp->is_dir && fp->is_virtual && !SetTmpFile(fp)) UserAbort(USTR_FaildTmpUnpack);
		if (!fp->arc_name.IsEmpty()) msg += CurStt->arc_DspPath;
		msg += yen_to_slash(fp->n_name);
		GetFileInfList(fp, true);
		AddLogCr();
		if (fp->inf_list->Text.IsEmpty()) Abort();
		AddLog(msg);
		AddLogStrings(fp->inf_list);
		if (fp->selected) {
			fp->selected = false;
			InvalidateFileList();
		}
	}
	catch (EAbort &e) {
		set_LogErrMsg(msg, e.Message);
		AddLog(msg);
	}
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::LogFileInfoActionExecute(TObject *Sender)
{
	StartLog(_T("情報出力開始"));
	CurWorking = true;
	TStringList *lst = GetCurList(true);
	//選択あり
	if (GetSelCount(lst)>0) {
		for (int i=0; i<lst->Count; i++) {
			file_rec *fp = (file_rec*)lst->Objects[i];
			if (fp->selected) LogFileInfoCore(fp);
		}
	}
	//カーソル位置
	else {
		LogFileInfoCore(GetCurFrecPtr());
	}
	CurWorking = false;
	AddLogCr();
	EndLog(_T("情報出力"));
}

//---------------------------------------------------------------------------
//マーク/解除
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::MarkActionExecute(TObject *Sender)
{
	if (CurStt->is_ADS || CurStt->is_FTP) {
		SetActionAbort(USTR_CantOperate);  return;
	}

	file_rec *cfp = GetCurFrecPtr();
	if (!cfp || cfp->f_attr==faInvalid) { SetActionAbort(); return; }

	bool rq_down;
	//マーク&メモ(入力)
	if (TEST_ActParam("IM")) {
		UnicodeString memo = IniFile->GetMarkMemo(cfp->r_name);
		if (input_query_ex(ExtractFileName(cfp->r_name).c_str(), _T("メモ"), &memo, 480)) {
			IniFile->FileMark(cfp->r_name, 1, memo);
		}
		CloseIME(Handle);
		rq_down = false;
	}
	//マーク&メモ(指定)
	else if (!TEST_ActParam("ND") && !ActionParam.IsEmpty()) {
		IniFile->FileMark(cfp->r_name, 1, ActionParam);
		rq_down = false;
	}
	//マーク/解除
	else {
		IniFile->FileMark(cfp->r_name);
		rq_down = !TEST_ActParam("ND");
	}

	ViewFileInf(cfp, true);

	switch (ScrMode) {
	case SCMD_FLIST:
		{
			TListBox *lp = FileListBox[CurListTag];
			int idx0 = lp->ItemIndex;
			if (rq_down) CursorDownAction->Execute();
			if (lp->ItemIndex==idx0) InvalidateFileList();
			if (SameText(CurPath[OppListTag], cfp->p_name)) InvalidateFileList(OppListTag);
		}
		break;
	case SCMD_IVIEW:
		if (GetCurIndex()!=-1) {
			if (rq_down) NextFileAction->Execute();
			if (ThumbnailGrid->Visible) ThumbnailGrid->Repaint();
		}
		break;
	}
}

//---------------------------------------------------------------------------
//マーク一覧
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::MarkListActionExecute(TObject *Sender)
{
	if (ScrMode==SCMD_IVIEW) CloseIAction->Execute();

	EditHistoryDlg->isMark	 = true;
	EditHistoryDlg->ToFilter = TEST_ActParam("FF");
	int res = EditHistoryDlg->ShowModal();
	UnicodeString fnam = EditHistoryDlg->EditFileName;
	if (res==mrOk || res==mrClose) {
		if (JumpToList(CurListTag, fnam)) {
			if (!EditHistoryDlg->CmdStr.IsEmpty()) {
				if (ExeCommandAction(EditHistoryDlg->CmdStr, ActionParam)) ActionOk = true;
			}
		}
		else SetActionAbort(GlobalErrMsg);
	}
}

//---------------------------------------------------------------------------
//マーク項目だけを残して他を隠す
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::MarkMaskActionExecute(TObject *Sender)
{
	if (!IsCurFList() && !CurStt->is_Arc) { SetActionAbort(USTR_OpeNotSuported); return; }

	UnicodeString fnam	= GetCurFileName();
	TStringList *lst	= GetCurList(true);
	TStringList *sm_lst = SelMaskList[CurListTag];
	int lst_m_cnt = sm_lst->Count;
	sm_lst->Clear();

	if (!TEST_ActParam("CA")) {
		int m_cnt = 0;
		for (int i=0; i<lst->Count; i++) {
			file_rec *fp = (file_rec*)lst->Objects[i];
			if (IniFile->IsMarked(fp->r_name)) m_cnt++;
		}
		if (m_cnt>0) {
			for (int i=0; i<lst->Count; i++) {
				file_rec *fp = (file_rec*)lst->Objects[i];
				if (IniFile->IsMarked(fp->r_name) || fp->is_up) sm_lst->Add(fp->f_name);
			}
		}
	}

	if (lst_m_cnt != sm_lst->Count) {
		if (CurStt->is_Arc)
			ChangeArcFileListEx(CurStt->arc_Name, CurStt->arc_SubPath, CurListTag, fnam);
		else
			UpdateCurPath(EmptyStr, fnam);
	}
}

//---------------------------------------------------------------------------
//マスクによるファイル/ディレクトリ名検索
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::MaskFindActionExecute(TObject *Sender)
{
	try {
		UnicodeString msk = Trim(ActionParam);
		if (msk.IsEmpty()) UserAbort(USTR_NoParameter);

		if (OppStt->is_Find) RecoverFileList(OppListTag);
		clear_FindStt(CurStt);
		CurStt->find_Dir  = ends_PathDlmtr(msk);
		CurStt->find_Mask = ExcludeTrailingPathDelimiter(msk);
		if (CurStt->find_Mask.IsEmpty()) CurStt->find_Mask = "*";
		CurStt->find_Path = CurPath[CurListTag];
		CurStt->find_SubDir = true;

		CurStt->find_ResLink  = IniFile->ReadBoolGen(_T("FindResLink"));
		CurStt->find_DirLink  = IniFile->ReadBoolGen(_T("FindDirLink"));
		CurStt->find_PathSort = FindPathColumn;

		//選択中ディレクトリをリストアップ
		TStringList *lst = GetCurList(true);
		CurStt->find_SubList->Clear();
		for (int i=0; i<lst->Count; i++) {
			file_rec *fp = (file_rec*)lst->Objects[i];
			if (fp->is_dir && fp->selected) CurStt->find_SubList->Add(fp->f_name);
		}
		//選択していなければカレントを対象に
		if (CurStt->find_SubList->Count==0) CurStt->find_SubList->Add(CurStt->find_Path);

		int res = FindFileCore(CurStt->find_Dir);
		if (res==0)  {
			if (!ExeCmdsBusy) SttBarWarnUstr(USTR_NotFound);
		}
		else if (res==-1) SttBarWarnUstr(USTR_Canceled);
		else {
			play_sound(SoundFindFin);
			//イベント: 検索結果リストが表示された直後
			ExeEventCommand(OnFindOpend);
		}
	}
	catch (EAbort &e) {
		SetActionAbort(e.Message);
	}
}

//---------------------------------------------------------------------------
//マスク選択
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::MaskSelectActionExecute(TObject *Sender)
{
	try {
		if (ScrMode==SCMD_IVIEW && !ThumbnailGrid->Visible) Abort();

		if (!MaskSelectDlg) MaskSelectDlg = new TMaskSelectDlg(this);	//初回に動的作成
		UnicodeString mask;
		if (!ActionParam.IsEmpty()) {
			mask = ActionParam;
		}
		else {
			MaskSelectDlg->CmdName = "MaskSelect";
			if (MaskSelectDlg->ShowModal()==mrOk) mask = MaskSelectDlg->MaskSelComboBox->Text;
		}

		if (!mask.IsEmpty()) {
			add_ComboBox_history(MaskSelectDlg->MaskSelComboBox, mask);
			if (SelectMask(GetCurList(), mask)==0 && !ExeCmdsBusy) UserAbort(USTR_NotFound);
		}
	}
	catch (EAbort &e) {
		SetActionAbort(e.Message);
	}
}
//---------------------------------------------------------------------------
//マッチ選択
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::MatchSelectActionExecute(TObject *Sender)
{
	try {
		if (ScrMode==SCMD_IVIEW && !ThumbnailGrid->Visible) Abort();

		UnicodeString ptn;
		if (!ActionParam.IsEmpty()) {
			ptn = ActionParam;
		}
		else {
			if (!MaskSelectDlg) MaskSelectDlg = new TMaskSelectDlg(this);	//初回に動的作成
			MaskSelectDlg->CmdName = "MatchSelect";
			if (MaskSelectDlg->ShowModal()==mrOk) ptn = MaskSelectDlg->MaskSelComboBox->Text;
		}
		if (ptn.IsEmpty()) SkipAbort();

		if (ptn.Pos("\\N")) {
			file_rec *cfp = GetCurFrecPtr();
			ptn = ReplaceText(ptn, "\\N", (cfp && !cfp->is_up)? cfp->b_name : EmptyStr);
		}

		TStringList *lst = GetCurList(true);
		int s_cnt = 0;
		int s_idx = -1;
		for (int i=0; i<lst->Count; i++) {
			file_rec *fp = (file_rec*)lst->Objects[i];
			if (!is_selectable(fp)) continue;
			fp->selected = false;
			if (!ptn_match_str(ptn, fp->n_name).IsEmpty()) {
				fp->selected = true;  s_cnt++;
				if (s_idx==-1) s_idx = i;
			}
		}
		if (s_cnt==0) Abort();

		switch (ScrMode) {
		case SCMD_FLIST:
			if (s_idx!=-1) FileListBox[CurListTag]->ItemIndex = s_idx;
			RepaintList(CurListTag);
			break;
		case SCMD_IVIEW:
			if (s_idx!=-1) set_GridIndex(ThumbnailGrid, s_idx, lst->Count);
			break;
		}
	}
	catch (EAbort &e) {
		SetActionAbort(e.Message);
	}
}

//---------------------------------------------------------------------------
//メニューバーの表示／非表示
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::MenuBarActionExecute(TObject *Sender)
{
	Menu = SetToggleAction(ShowMainMenu)? MainMenu1 : NULL;

	switch (ScrMode) {
	case SCMD_TVIEW:
		if (TextRulerBox->Visible) TextRulerBox->Repaint();
		break;
	case SCMD_IVIEW:
		FittedSizeAction->Execute();
		break;
	}
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::MenuBarActionUpdate(TObject *Sender)
{
	((TAction*)Sender)->Enabled = !IS_FullScr();
	((TAction*)Sender)->Checked = ShowMainMenu;
}

//---------------------------------------------------------------------------
//ディスプレイの電源を切る
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::MonitorOffActionExecute(TObject *Sender)
{
	ShowMessageHint(_T("ディスプレイの電源を切ります"), col_bgWarn, false, false, true);
	Sleep(1000);
	::SendNotifyMessage(HWND_BROADCAST, WM_SYSCOMMAND, SC_MONITORPOWER, 2);
}

//---------------------------------------------------------------------------
//音量ミュート
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::MuteVolumeActionExecute(TObject *Sender)
{
	if (!mute_Volume(ActionParam)) SetActionAbort(USTR_FaildProc);
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::MuteVolumeActionUpdate(TObject *Sender)
{
	((TAction*)Sender)->Checked = IsMuted;
}

//---------------------------------------------------------------------------
//ファイル名をクリップボードの内容に
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::NameFromClipActionExecute(TObject *Sender)
{
	try {
		if (!IsCurFList()) UserAbort(USTR_OpeNotSuported);
		file_rec *cfp = GetCurFrecPtr();	if (!cfp) Abort();

		UnicodeString clp_name;
		if (Clipboard()->HasFormat(CF_TEXT))
			clp_name = ExtractFileName(get_norm_str(exclude_quot(Clipboard()->AsText)));
		if (ActionParam.IsEmpty() || ContainsText(ActionParam, "\\C")) {
			if (clp_name.IsEmpty()) SysErrAbort(CLIPBRD_E_BAD_DATA);
		}

		UnicodeString new_name;
		if (!ActionParam.IsEmpty()) {
			new_name = ActionParam;
			new_name = ReplaceStr(new_name, "\\A", cfp->b_name);
			new_name = ReplaceStr(new_name, "\\E", get_tkn_r(get_extension_if_file(cfp->f_name), '.'));
			if (ContainsText(new_name, "\\C")) {
				new_name = ReplaceStr(new_name, "\\CA", get_base_name(clp_name));
				new_name = ReplaceStr(new_name, "\\CE", get_tkn_r(get_extension(clp_name), '.'));
			}
		}
		else {
			new_name = clp_name;
		}
		new_name = CurPath[CurListTag] + new_name;

		StartLog("改名開始  " + GetSrcPathStr());
		CurWorking = true;
		UnicodeString msg = make_RenameLog(cfp->f_name, new_name);
		SetDirWatch(false);
		bool ok = rename_File(cfp->f_name, new_name);
		SetDirWatch(true);
		if (ok)
			cfp->f_name = new_name;
		else
			set_LogErrMsg(msg);
		AddLog(msg);
		InvalidateFileList();
		CurWorking = false;
		ReloadList(CurListTag);
		EndLog(_T("改名"));
		if (!ok) UserAbort(USTR_FaildProc);
		IndexOfFileList(new_name);
	}
	catch (EAbort &e) {
		SetActionAbort(e.Message);
	}
}

//---------------------------------------------------------------------------
//ファイル名の大文字/小文字化
//---------------------------------------------------------------------------
bool __fastcall TNyanFiForm::NameToUpLowCore(bool upper)
{
	UnicodeString msg, prestr;
	prestr.sprintf(_T("%s"), upper? _T("大文字化") : _T("小文字化"));
	StartLog(msg.sprintf(_T("%s開始  %s"), prestr.c_str(), GetSrcPathStr().c_str()));

	CurWorking = true;
	TStringList *lst = GetCurList(true);
	int sel_cnt = GetSelCount(lst);
	int cur_idx = FileListBox[CurListTag]->ItemIndex;
	int ok_cnt = 0, er_cnt = 0;
	SetDirWatch(false);

	for (int i=0; i<lst->Count; i++) {
		file_rec *fp = (file_rec*)lst->Objects[i];
		if (fp->selected || (sel_cnt==0 && i==cur_idx)) {
			UnicodeString new_name = upper? fp->f_name.UpperCase() : fp->f_name.LowerCase();
			msg = make_RenameLog(fp->f_name, new_name);
			if (rename_File(fp->f_name, new_name)) {
				fp->f_name	 = new_name;
				fp->selected = false;
				InvalidateFileList();
			}
			else {
				set_LogErrMsg(msg);
			}
			((msg[1]=='E')? er_cnt : ok_cnt)++;
			AddLog(msg);
		}
	}

	SetDirWatch(true);
	CurWorking = false;
	ReloadList(CurListTag);
	EndLog(prestr, get_res_cnt_str(ok_cnt, er_cnt));
	return (er_cnt==0);
}

//---------------------------------------------------------------------------
//ファイル名の小文字化
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::NameToLowerActionExecute(TObject *Sender)
{
	if (!IsCurFList())
		SetActionAbort(USTR_OpeNotSuported);
	else if (!NameToUpLowCore(false))
		SetActionAbort(USTR_FaildProc);
}
//---------------------------------------------------------------------------
//ファイル名の大文字化
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::NameToUpperActionExecute(TObject *Sender)
{
	if (!IsCurFList())
		SetActionAbort(USTR_OpeNotSuported);
	else if (!NameToUpLowCore(true))
		SetActionAbort(USTR_FaildProc);
}
//---------------------------------------------------------------------------
//ネットワークドライブの割り当て
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::NetConnectActionExecute(TObject *Sender)
{
	::WNetConnectionDialog(Handle, RESOURCETYPE_DISK);
}
//---------------------------------------------------------------------------
//ネットワークドライブの切断
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::NetDisconnectActionExecute(TObject *Sender)
{
	::WNetDisconnectDialog(Handle, RESOURCETYPE_DISK);
}

//---------------------------------------------------------------------------
//新規ファイル
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::NewFileActionExecute(TObject *Sender)
{
	try {
		if (CurStt->is_Arc || CurStt->is_Find || CurStt->is_Work || CurStt->is_FTP) UserAbort(USTR_CantOperate);

		if (!NewFileDlg) NewFileDlg = new TNewFileDlg(this);	//初回に動的作成
		if (NewFileDlg->ShowModal()!=mrOk) SkipAbort();
		UnicodeString fnam = NewFileDlg->NewNameEdit->Text;
		if (fnam.IsEmpty()) SkipAbort();

		UnicodeString tnam = to_absolute_name(NewFileDlg->TplComboBox->Text);
		if (!file_exists(tnam)) TextAbort(_T("テンプレートが見つかりません。"));

		fnam = CurStt->is_ADS? CurStt->ads_Name + ":" + fnam : CurPath[CurListTag] + fnam;
		if (file_exists(fnam) && !msgbox_Sure(USTR_OverwriteQ)) SkipAbort();

		StartLog("ファイル作成開始  " + GetSrcPathStr());
		UnicodeString msg = make_LogHdr(_T("CREATE"), fnam);
		if (!copy_File(tnam, fnam) || !set_file_age(fnam, Now())) set_LogErrMsg(msg);
		AddLog(msg);
		if (msg[1]=='E') UserAbort(USTR_FaildProc);
		ReloadList(CurListTag, fnam);
		if (EqualDirLR()) ReloadList(OppListTag);
		EndLog(_T("作成"));
	
		UnicodeString CmdStr = NewFileDlg->NewExeCmdEdit->Text;
		if (!CmdStr.IsEmpty() && !ExeCommandsCore(CmdStr)) GlobalAbort();
	}
	catch (EAbort &e) {
		SetActionAbort(e.Message);
	}
}
//---------------------------------------------------------------------------
//新規テキスト作成
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::NewTextFileActionExecute(TObject *Sender)
{
	try {
		if (CurStt->is_Arc || CurStt->is_Find || CurStt->is_Work || CurStt->is_FTP) UserAbort(USTR_CantOperate);

		UnicodeString fnam = FormatParam(ActionParam);
		if (fnam.IsEmpty()) {
			InputExDlg->IpuntExMode = INPEX_NEW_TEXTFILE;
			InputExDlg->InputComboBox->Text = EmptyStr;
			fnam = (InputExDlg->ShowModal()==mrOk)? InputExDlg->InputComboBox->Text : EmptyStr;
		}
		if (fnam.IsEmpty()) return;

		if (!CurStt->is_ADS && get_extension(fnam).IsEmpty() && !StartsStr('.', fnam))
			fnam = ChangeFileExt(fnam, ".txt");

		fnam = CurStt->is_ADS? CurStt->ads_Name + ":" + fnam : CurPath[CurListTag] + fnam;
		if (file_exists(fnam) && !msgbox_Sure(USTR_OverwriteQ)) SkipAbort();

		StartLog("テキスト作成開始  " + GetSrcPathStr());
		UnicodeString msg = make_LogHdr(_T("CREATE"), fnam);
		std::unique_ptr<TStringList> o_buf(new TStringList());
		if (InputExDlg->ClipCheckBox->Checked) o_buf->Text = Clipboard()->AsText;
		if (!saveto_TextFile(fnam, o_buf.get(), InputExDlg->CodePageComboBox->ItemIndex)) set_LogErrMsg(msg);
		AddLog(msg);
		if (msg[1]=='E') UserAbort(USTR_FaildProc);
		ReloadList(CurListTag, fnam);
		if (EqualDirLR()) ReloadList(OppListTag);
		EndLog(_T("作成"));
		if (EditNewText && !open_by_TextEditor(fnam)) GlobalAbort();
	}
	catch (EAbort &e) {
		SetActionAbort(e.Message);
	}
}
//---------------------------------------------------------------------------
//次のドライブへ
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::NextDriveActionExecute(TObject *Sender)
{
	UnicodeString dstr = get_drive_str(CurPath[CurListTag]);
	std::unique_ptr<TStringList> d_list(new TStringList());
	if (get_available_drive_list(d_list.get())==0) {
		SetActionAbort();
	}
	else {
		int idx = -1;
		for (int i=0; i<d_list->Count && idx==-1; i++)
			if (CompareText(dstr, d_list->Strings[i])<0) idx = i;
		if (idx==-1) idx = 0;
		UpdateCurDrive(d_list->Strings[idx]);
	}
}

//---------------------------------------------------------------------------
//次のマーク項目へ
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::NextMarkActionExecute(TObject *Sender)
{
	int c_idx = GetCurIndex();
	int idx0 = -1, idx1 = -1;
	TStringList *lst = GetCurList();
	for (int i=0; i<lst->Count && idx1==-1; i++) {
		if (i<=c_idx && idx0!=-1) continue;
		if (IniFile->IsMarked(((file_rec*)lst->Objects[i])->r_name)) {
			if (i<=c_idx) idx0 = i; else idx1 = i;
		}
	}
	SetCurIndex((idx1!=-1)? idx1 : idx0);
}

//---------------------------------------------------------------------------
//次の NyanFi
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::NextNyanFiActionExecute(TObject *Sender)
{
	if (activate_NyanFi(1)) return;

	if (TEST_ActParam("DN")) {
		ActionParam = EmptyStr;
		DuplicateAction->Execute();
	}
}

//---------------------------------------------------------------------------
//ファイル名主部が同じ次のファイルへ移動
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::NextSameNameActionExecute(TObject *Sender)
{
	file_rec *cfp = GetCurFrecPtr();
	if (cfp && !cfp->is_dir) {
		int c_idx = GetCurIndex();
		int idx0=-1, idx1=-1;
		TStringList *lst = GetCurList();
		for (int i=0; i<lst->Count && idx1==-1; i++) {
			if (i<=c_idx && idx0!=-1) continue;
			file_rec *fp = (file_rec*)lst->Objects[i];
			if (fp->is_dir || !SameText(cfp->b_name, fp->b_name)) continue;
			((i<=c_idx)? idx0 : idx1) = i;
		}
		int new_idx = (idx1!=-1)? idx1 : idx0;
		if (new_idx==c_idx || !SetCurIndex(new_idx)) SetActionAbort();
	}
}

//---------------------------------------------------------------------------
//代替データストリームを仮想リストとして開く
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::OpenADSActionExecute(TObject *Sender)
{
	try {
		if (CurStt->is_Arc || CurStt->is_ADS || CurStt->is_FTP) UserAbort(USTR_CantOperate);

		file_rec *cfp = GetCurFrecPtr(true);
		if (!cfp || cfp->f_name.IsEmpty() || cfp->is_dummy) Abort();
		if (cfp->is_virtual) UserAbort(USTR_CantOperate);

		if (!ChangeAdsList(cfp->f_name, CurListTag)) Abort();
	}
	catch (EAbort &e) {
		SetActionAbort(e.Message);
	}
}

//---------------------------------------------------------------------------
//独自の関連付けで開く
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::OpenByAppActionExecute(TObject *Sender)
{
	try {
		//パラメータ指定
		if (!ActionParam.IsEmpty()) {
			UnicodeString fnam = to_absolute_name(ActionParam, CurPath[CurListTag]);
			if (!file_exists(fnam)) SysErrAbort(ERROR_FILE_NOT_FOUND);
			UnicodeString app = get_MenuItemStr(get_AssociatedApps(get_extension(fnam)));
			if (app.IsEmpty()) TextAbort(_T("関連付けられていません。"));
			if (USAME_TS(app, "SKIP")) SkipAbort();
			if (starts_AT(app) || remove_top_text(app, _T("ExeCommands_"))) {
				ActionOptStr = "ListItemPos";
				if (!ExeCommandsCore(app)) GlobalAbort();
			}
			else if (starts_Dollar(app)) {
				ExeAlias(app);
				if (!ActionOk && !ActionErrMsg.IsEmpty()) ActionAbort();
			}
			else {
				if (!Execute_ex(app, add_quot_if_spc(fnam), ExtractFilePath(fnam))) UserAbort(USTR_FaildExec);
				AddToRecentFile(fnam);
			}
		}
		//通常動作
		else if (ScrMode!=SCMD_GREP) {
			if (CurStt->is_FTP) UserAbort(USTR_CantOperate);
			TStringList *lst = GetCurList(true);
			std::unique_ptr<TStringList> s_lst(new TStringList());
			int sel_cnt   = (OpenOnlyCurApp || fromOpenStd)? 0 : GetSelCount(lst);
			file_rec *cfp = GetCurFrecPtr(true, true);
			file_rec *rfp = NULL;

			bool opn_cfp = (sel_cnt==0) && cfp && !cfp->is_dummy;
			if (opn_cfp) {
				rfp = cfp;
			}
			else if (sel_cnt>0) {
				for (int i=0; i<lst->Count && !rfp; i++) {
					file_rec *fp = (file_rec*)lst->Objects[i];
					if (fp->selected) rfp = fp;
				}
			}

			if (!rfp || rfp->f_attr==faInvalid) Abort();
			if (rfp->is_ftp) UserAbort(USTR_CantOperate);

			UnicodeString app = get_MenuItemStr(
				get_AssociatedApps(rfp->is_up? UnicodeString("..") : rfp->is_dir? UnicodeString("\\") : rfp->f_ext));
			if (USAME_TS(app, "SKIP")) SkipAbort();

			//関連付け有り
			if (!app.IsEmpty()) {
				//コマンドファイル/コマンド
				if (starts_AT(app) || remove_top_text(app, _T("ExeCommands_"))) {
					ActionOptStr = "ListItemPos";
					if (!ExeCommandsCore(app)) GlobalAbort();
				}
				//エイリアス
				else if (starts_Dollar(app)) {
					ExeAlias(app);
					if (!ActionOk && !ActionErrMsg.IsEmpty()) ActionAbort();
				}
				//アプリケーション
				else {
					UnicodeString fnam =
						opn_cfp ? (rfp->is_up? ExcludeTrailingPathDelimiter(CurPath[CurListTag]) : GetCurFileStr(true))
								: GetSelFileStr(GetCurList(), true, false, s_lst.get());

					if (!Execute_ex(app, fnam, CurPath[CurListTag])) UserAbort(USTR_FaildExec);
					if (s_lst->Count>0) AddToRecentFile(s_lst.get()); else AddToRecentFile(fnam);
				}
			}
			//関連付け無し
			else {
				//ディレクトリを開く
				if (OpenDirByStd && rfp->is_dir) {
					OpenStandardAction->Execute();
				}
				//その他
				else {
					switch (OpenByMode) {
					case 1: OpenByWinAction->Execute();		break;
					case 2: OpenStandardAction->Execute();	break;
					default:
						if (!rfp->is_dir) TextAbort(_T("関連付けられていません。"));
					}
				}
			}

			//選択解除
			if (ActionOk && !fromOpenStd && !DontClrSelApp && sel_cnt>0) ClrSelect(lst);
		}
	}
	catch (EAbort &e) {
		SetActionAbort(e.Message);
	}
}

//---------------------------------------------------------------------------
//エクスプローラで開く
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::OpenByExpActionExecute(TObject *Sender)
{
	try {
		UnicodeString prm;
		//パラメータ指定
		if (!ActionParam.IsEmpty()) {
			if (StartsStr("::{", ActionParam) || StartsStr("shell:", ActionParam) || StartsStr('/', ActionParam)) {
				prm = ActionParam;
			}
			else {
				prm = to_absolute_name(cv_env_str(ActionParam), CurPath[CurListTag]);
				if (!dir_exists(prm)) SysErrAbort(ERROR_PATH_NOT_FOUND);
				prm.Insert("/e,", 1);
			}
		}
		//通常動作
		else {
			if (CurStt->is_ADS || CurStt->is_FTP) UserAbort(USTR_CantOperate);

			file_rec *cfp = GetCurFrecPtr(true, true);
			if (!cfp || cfp->is_dummy || cfp->f_attr==faInvalid) Abort();

			if (test_FileExt(cfp->f_ext, _T("._sf")))
				prm = "/e," + get_PathFrom_SF(cfp);
			else if (cfp->is_dir)
				prm = "/e," + (cfp->is_up? CurPath[CurListTag] : cfp->f_name);
			else
				prm.sprintf(_T("/select,\"%s\""), cfp->f_name.c_str());	//ファイルを選択
		}

		//エクスプローラ起動
		if (::ShellExecute(NULL, _T("open"), _T("explorer"), prm.c_str(), NULL, SW_SHOWNORMAL) <= (HINSTANCE)32)
			UserAbort(USTR_FaildExec);
	}
	catch (EAbort &e) {
		SetActionAbort(e.Message);
	}
}

//---------------------------------------------------------------------------
//Windowsの関連付けで開く
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::OpenByWinActionExecute(TObject *Sender)
{
	try {
		//パラメータ指定
		if (!ActionParam.IsEmpty()) {
			UnicodeString fnam = ActionParam;
			if (!is_match_regex(fnam, _T("^") URL_MATCH_PTN) && !StartsText("mailto:", fnam)) {
				fnam = to_absolute_name(fnam, CurPath[CurListTag]);
				if (!file_exists(fnam)) SysErrAbort(ERROR_FILE_NOT_FOUND);
			}
			Execute_ex(fnam, EmptyStr, ExtractFilePath(fnam));
		}
		//通常動作
		else if (ScrMode!=SCMD_GREP) {
			if (CurStt->is_ADS || CurStt->is_FTP) UserAbort(USTR_CantOperate);

			TStringList *lst = GetCurList(true);
			int  sel_cnt  = (OpenOnlyCurWin || fromOpenStd)? 0 : GetSelCount(lst);
			bool opn_cfp  = (sel_cnt==0 );
			file_rec *cfp = GetCurFrecPtr(true, true);
			if (opn_cfp && (!cfp || cfp->is_dummy || cfp->f_attr==faInvalid)) Abort();

			//ディレクトリ
			if (opn_cfp && cfp->is_dir) {
				Execute_ex(cfp->is_up? CurPath[CurListTag] : cfp->f_name);
			}
			//ファイル
			else {
				CurWorking = true;
				int cur_idx = FileListBox[CurListTag]->ItemIndex;
				for (int i=0; i<lst->Count; i++) {
					file_rec *fp = (file_rec*)lst->Objects[i];
					if (fp->is_dir) continue;
					if ((!opn_cfp && fp->selected) || (opn_cfp && i==cur_idx)) {
						UnicodeString fnam;
						if (fp->is_virtual) {
							if (!SetTmpFile(fp)) UserAbort(USTR_FaildTmpUnpack);
							fnam = fp->tmp_name;
						}
						else {
							fnam = fp->f_name;
						}

						if (::ShellExecute(NULL, _T("open"), fnam.c_str(), NULL,
								ExtractFilePath(fnam).c_str(), SW_SHOWNORMAL) <= (HINSTANCE)32)
									UserAbort(USTR_FaildExec);

						AddToRecentFile(fnam);
					}
				}
				CurWorking = false;
			}

			//選択解除
			if (ActionOk && !DontClrSelWin && sel_cnt>0) ClrSelect(lst);
		}
	}
	catch (EAbort &e) {
		SetActionAbort(e.Message);
	}
}

//---------------------------------------------------------------------------
//リモートリポジトリURLを開く
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::OpenGitURLActionExecute(TObject *Sender)
{
	try {
		if (!GitExists || CurStt->is_Arc || CurStt->is_FTP) UserAbort(USTR_CantOperate);
		file_rec *cfp = GetCurFrecPtr();
		if (!cfp || cfp->is_dummy || cfp->f_attr==faInvalid) Abort();
		UnicodeString url = get_GitUrl(cfp);
		if (url.IsEmpty()) Abort();
		Execute_ex(url);
	}
	catch (EAbort &e) {
		SetActionAbort(e.Message);
	}
}

//---------------------------------------------------------------------------
//標準の Enter キーで開く動作
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::OpenStandardActionExecute(TObject *Sender)
{
	file_rec *cfp = NULL;
	if (!ActionParam.IsEmpty()) {
		if (FindBusy) { SetActionAbort(USTR_CantOperate); return; }

		UnicodeString fnam = to_absolute_name(ActionParam, CurPath[CurListTag]);
		if (file_exists(fnam)) {
			if (dir_exists(fnam)) fnam = IncludeTrailingPathDelimiter(fnam);
			cfp = cre_new_file_rec(fnam, CurListTag);
			RecoverFileList2();
		}
	}
	else {
		cfp = cre_new_file_rec(GetCurFrecPtr(true, true));
	}
	if (!cfp) { SetActionAbort(SysErrorMessage(ERROR_FILE_NOT_FOUND)); return; }

	try {
		GlobalErrMsg = EmptyStr;
		if (cfp->is_dummy || cfp->f_attr==faInvalid) Abort();

		//コマンドへの関連付けをチェック
		TAction *CmdAct = NULL;
		UnicodeString CmdPrm;
		if (!cfp->is_dir) {
			for (int i=0; i<OpenStdCmdList->Count && !CmdAct; i++) {
				if (!test_FileExt(cfp->f_ext, OpenStdCmdList->Names[i])) continue;
				UnicodeString cmd = OpenStdCmdList->ValueFromIndex[i];
				UnicodeString prm = exclude_quot(get_PrmStr(cmd));
				cmd = get_CmdStr(cmd);
				for (int j=0; j<ActionList1->ActionCount; j++) {
					TAction *ap = (TAction*)ActionList1->Actions[j];
					if (!USAME_TI(ap->Category, "Command")) continue;
					if (SameText(cmd, get_tkn(ap->Name, _T("Action")))) {
						CmdAct = ap;  CmdPrm = prm;	break;
					}
				}
			}
		}

		bool is_nbt = (CmdAct==ExeCommandsAction);
		UnicodeString msg;

		//--------------------------
		//検索中の動作
		//--------------------------
		if (FindBusy) {
			if (!CurStt->is_Find || CurStt->is_Arc || CurStt->is_Work || cfp->is_dir) Abort();
			if (CmdAct) {
				if (!contained_wd_i(_T("OpenByApp|OpenByWin|FileEdit|BinaryEdit"), get_tkn(CmdAct->Name, _T("Action")))) Abort();
				fromOpenStd = true;
				if (!ExeCmdAction(CmdAct)) ActionAbort();
			}
			else if (test_MciSndExt(cfp->f_ext)) {
				if (!play_sound_ex(cfp->f_name)) UserAbort(USTR_CantPlay);
			}
			else if (test_FileExt(cfp->f_ext, FEXT_EXECUTE)) {
				if (test_LnkExt(cfp->f_ext)) {
					if (dir_exists(cv_env_str(usr_SH->get_LnkName(cfp->f_name)))) Abort();
				}
				if (msgbox_Sure(msg.sprintf(_T("[%s]を実行しますか?"), cfp->n_name.c_str()), SureExec)) {
					if (!Execute_ex(cfp->f_name, EmptyStr, cfp->p_name)) {
						ExeErrLog(cfp->f_name, LoadUsrMsg(USTR_FaildExec));
						UserAbort(USTR_FaildExec);
					}
				}
			}
			else TextAbort(_T("HANDLED"));

			if (DownAfterOpenStd) CursorDownAction->Execute();	//実行後、下に移動
		}
		//--------------------------
		//結果リスト
		//--------------------------
		else if (CurStt->is_Find && (cfp->is_up || !OpenStdOnResList)) {
			RecoverFileList2();	//結果リストから抜ける

			if (!cfp->is_up) {
				//仮想
				if (cfp->is_virtual) {
					if (!JumpToList(CurListTag, cfp->f_name)) GlobalAbort();
				}
				//通常
				else {
					//ディレクトリ
					if (cfp->is_dir) {
						CurPath[CurListTag] = IncludeTrailingPathDelimiter(cfp->f_name);
				 		FileListBox[CurListTag]->ItemIndex = 0;
					}
					//ファイル
					else {
						CurPath[CurListTag] = cfp->p_name;
						IndexOfFileList(cfp->f_name);
					}
					SetFileInf();
				}
			}
		}
		//--------------------------
		//仮想ディレクトリ
		//--------------------------
		else if (CurStt->is_Arc) {
			//ディレクトリ(仮想)
			if (cfp->is_dir) {
				//一つ上へ
				if (cfp->is_up) {
					ToParentAction->Execute();
				}
				//サブディレクトリへ
				else {
					CurStt->arc_SubPath = IncludeTrailingPathDelimiter(cfp->f_name);
					CurStt->arc_DspPath += IncludeTrailingPathDelimiter(cfp->b_name);
					if (UpdateTempArcList(CurListTag).IsEmpty()) UserAbort(USTR_CantMakeTmpDir);
					SelMaskList[CurListTag]->Clear();
					ChangeArcFileListEx(CurStt->arc_Name, CurStt->arc_SubPath, CurListTag, "..");
				}
			}
			//ファイル(仮想)
			else {
				if (!SetTmpFile(cfp)) UserAbort(USTR_FaildTmpUnpack);
				bool not_down = false;
				//コマンドへの関連付け有り
				if (CmdAct) {
					fromOpenStd = true;
					if (is_nbt) {
						ActionParam  = def_if_empty(CmdPrm, "@" + cfp->tmp_name);
						ActionOptStr = "ListItemPos";
					}
					if (!ExeCmdAction(CmdAct)) ActionAbort();
				}
				//多重アーカイブへ
				else if (test_ArcExt2(cfp->f_ext) && is_AvailableArc(cfp->tmp_name)) {
					CurStt->arc_RetList->Insert(0,
						UnicodeString().sprintf(_T("%s\t%s"), CurStt->arc_Name.c_str(), CurStt->arc_SubPath.c_str()));
					CurStt->arc_Name    = cfp->tmp_name;
					CurStt->arc_SubPath = EmptyStr;
					CurStt->arc_DspPath.cat_sprintf(_T("%s\\"), ExtractFileName(CurStt->arc_Name).c_str());
					if (UpdateTempArcList(CurListTag).IsEmpty()) UserAbort(USTR_CantMakeTmpDir);
					SelMaskList[CurListTag]->Clear();
					if (!ChangeArcFileListEx(CurStt->arc_Name, CurStt->arc_SubPath, CurListTag, "..")) {
						InhReload++;
						UserAbort(USTR_ArcNotOpen);
					}
					not_down = true;
				}
				//サウンド
				else if (test_MciSndExt(cfp->f_ext)) {
					if (!play_sound_ex(cfp->tmp_name)) UserAbort(USTR_CantPlay);
				}
				//イメージビュアー
				else if (is_Viewable(cfp) || test_IcoExt(cfp->f_ext)) {
					if (!ExeCmdAction(ImageViewerAction)) ActionAbort();
				}
				//テキストビュアー
				else if (!ExeCmdAction(TextViewerAction)) {
					ActionAbort();
				}

				if (DownAfterOpenStd && !not_down) CursorDownAction->Execute();	//実行後、下に移動
			}
		}
		//----------------------------------
		//代替データストリーム
		//----------------------------------
		else if (CurStt->is_ADS) {
			if (cfp->is_up) {
				RecoverFileList2();
			}
			else {
				if (!file_exists(cfp->f_name)) SysErrAbort(ERROR_FILE_NOT_FOUND);

				//音を再生
				if (test_MciSndExt(cfp->f_ext)) {
					if (!play_sound_ex(cfp->f_name)) UserAbort(USTR_CantPlay);
				}
				//イメージビュアー
				else if (is_Viewable(cfp) || test_IcoExt(cfp->f_ext)) {
					if (!ExeCmdAction(ImageViewerAction)) ActionAbort();
				}
				//テキストビュアー
				else if (!ExeCmdAction(TextViewerAction)) {
					ActionAbort();
				}
			}
		}
		//----------------------------------
		//FTP
		//----------------------------------
		else if (CurStt->is_FTP) {
			if (!IdFTP1->Connected()) {
				RecoverFileList();  Abort();
			}
			//ディレクトリ
			if (cfp->is_dir) {
				SelMaskList[CurListTag]->Clear();
				//親ディレクトリへ
				if (cfp->is_up) {
					UnicodeString l_pnam = CurFTPPath;
					if (!ChangeFtpFileList(CurListTag, "..", CurFTPPath)) GlobalAbort();
					if (SyncLR && IsOppFList() &&
						SameText(ExtractFileName(ExcludeTrailingPathDelimiter(l_pnam)),
							     ExtractFileName(ExcludeTrailingPathDelimiter(CurPath[OppListTag]))))
					{
						OppToParent();
					}
				}
				//サブディレクトリへ
				else {
					if (!ChangeFtpFileList(CurListTag, cfp->n_name, "..")) GlobalAbort();
					UnicodeString onam = CurPath[OppListTag] + ExtractFileName(ExcludeTrailingPathDelimiter(CurFTPPath));
					if (SyncLR && IsOppFList() && IndexOfFileList(onam, OppListTag)!=-1) {
						FCurPath[OppListTag] = IncludeTrailingPathDelimiter(onam);
						UpdateList(FileList[OppListTag], CurPath[OppListTag], OppListTag);
						SetDirWatch(CurPath[OppListTag], OppListTag);
						assign_FileListBox(FileListBox[OppListTag], FileList[OppListTag], -1, FlScrPanel[OppListTag]);
						RepaintList(OppListTag);
					}
				}
			}
			//ファイル
			else Abort();
		}
		//----------------------------------
		//ファイルリスト/ワークリスト
		//----------------------------------
		else {
			//ディレクトリ
			if (cfp->is_dir) {
				//親ディレクトリへ
				if (cfp->is_up) {
					if (CurStt->is_Find || CurStt->is_Work) RecoverFileList();
					//ライブラリ処理
					UnicodeString lnam = get_LibFile_if_root();
					if (!lnam.IsEmpty()) {
						if (!JumpToList(CurListTag, lnam)) GlobalAbort();
					}
					else {
						UpdateCurPath(get_parent_path(cfp->p_name), ExcludeTrailingPathDelimiter(CurPath[CurListTag]));
					}
				}
				//サブディレクトリへ
				else {
					//ワークリストのUNCパス項目をチェック
					if (CurStt->is_Work && StartsStr("\\\\", cfp->p_name) && NoCheckWorkUnc && !CheckUncPath(cfp->p_name)) {
						cfp->f_attr = faInvalid;
						InvalidateFileList();
						SetFileInf();
						GlobalAbort();
					}

					if (CurStt->is_Find || CurStt->is_Work) RecoverFileList();
					CurPath[CurListTag] = IncludeTrailingPathDelimiter(cfp->f_name);
					SetFileInf();
				}
			}
			//ファイル
			else {
				//結果リストのアーカイブ内
				if (CurStt->is_Find && cfp->is_virtual) {
					if (!JumpToList(CurListTag, cfp->f_name)) GlobalAbort();
					SetFileInf();
					TextAbort(_T("HANDLED"));
				}

				if (!file_exists(cfp->f_name)) SysErrAbort(ERROR_FILE_NOT_FOUND);

				bool not_down = false;
				//コマンドへの関連付け有り
				if (CmdAct) {
					fromOpenStd = true;
					if (is_nbt) {
						ActionParam  = def_if_empty(CmdPrm, "@" + cfp->f_name);
						ActionOptStr = "ListItemPos";
					}
					if (!ExeCmdAction(CmdAct)) ActionAbort();
				}
				//仮想ディレクトリへ
				else if (test_ArcExt2(cfp->f_ext) && is_AvailableArc(cfp->f_name)) {
					if (cfp->f_name.Length()>=MAX_PATH) SysErrAbort(ERROR_BUFFER_OVERFLOW);
					if (CurStt->is_Find || CurStt->is_Work) RecoverFileList();	//結果リスト/ワークリストから抜ける
					CurStt->arc_Name	= cfp->f_name;
					CurStt->arc_SubPath = EmptyStr;
					CurStt->arc_DspPath = IncludeTrailingPathDelimiter(cfp->n_name);
					if (UpdateTempArcList(CurListTag).IsEmpty()) UserAbort(USTR_CantMakeTmpDir);
					SelMaskList[CurListTag]->Clear();
					if (!ChangeArcFileListEx(CurStt->arc_Name, CurStt->arc_SubPath, CurListTag)) {
						InhReload++;
						UserAbort(USTR_ArcNotOpen);
					}
					//イベント: 仮想ディレクトリを開いた直後
					ExeEventCommand(OnArcOpend);
					not_down = true;
				}
				//ライブラリ
				else if (test_LibExt(cfp->f_ext)) {
					if (!PopSelLibrary(cfp->f_name)) UserAbort(USTR_DirNotFound);
				}
				//ワークリスト
				else if (test_NwlExt(cfp->f_ext)) {
					SaveWorkListAction->Execute();
					if (!SetWorkList(cfp->f_name)) UserAbort(USTR_WlistCantOpen);
					//履歴に追加
					if (WorkToDirHist) AddDirHistory(cfp->f_name, CurListTag);
					not_down = true;
				}
				//音を再生
				else if (test_MciSndExt(cfp->f_ext)) {
					if (!play_sound_ex(cfp->f_name)) UserAbort(USTR_CantPlay);
				}
				//イメージビュアー
				else if (is_Viewable(cfp) || test_IcoExt(cfp->f_ext)) {
					if (!ExeCmdAction(ImageViewerAction)) ActionAbort();
				}
				//ショートカット
				else if (test_LnkExt(cfp->f_ext)) {
					UnicodeString lnam, prm, fld;
					int shw;
					usr_SH->get_LnkInf(cfp->f_name, NULL, &lnam, &prm, &fld, &shw);
					//ディレクトリへのショートカットの場合、リンク先に移動
					if (dir_exists(lnam)) {
						if (CurStt->is_Work) RecoverFileList();
						CurPath[CurListTag] = exclede_delimiter_if_root(lnam);
						SetFileInf();
					}
					//リンク先ファイルを開く
					else if (!lnam.IsEmpty()) {
						UnicodeString fext = get_extension(lnam);
						bool sure = (test_FileExt(fext, FEXT_EXECUTE _T(".nbt")) && SureExec);
						if (msgbox_Sure(msg.sprintf(_T("[%s]を実行しますか?"), ExtractFileName(lnam).c_str()), sure)) {
							//コマンドファイル
							if (test_NbtExt(fext)) {
								if (!ExeCommandsCore("@" + lnam)) GlobalAbort();
							}
							//特殊(GUID)
							else if (StartsStr("::{", lnam)) {
								lnam.Insert("shell:", 1);
								if (::ShellExecute(NULL, _T("open"), _T("explorer"), lnam.c_str(), NULL, SW_SHOWNORMAL) <= (HINSTANCE)32)
									UserAbort(USTR_FaildExec);
							}
							//一般 (※ 〜.lnk を直接起動すると失敗する場合がある)
							else if (::ShellExecute(NULL, _T("open"),
								lnam.c_str(), prm.c_str(), fld.c_str(), shw) <= (HINSTANCE)32)
							{
								UserAbort(USTR_FaildExec);
							}
						}
					}
					//リンク先が取得できなかったら直接開く
					else {
						if (::ShellExecute(NULL, _T("open"), cfp->f_name.c_str(), NULL, NULL, shw) <= (HINSTANCE)32)
							UserAbort(USTR_FaildExec);
					}
				}
				//実行
				else if (test_FileExt(cfp->f_ext, FEXT_EXECUTE)) {
					if (msgbox_Sure(msg.sprintf(_T("[%s]を実行しますか?"), cfp->n_name.c_str()), SureExec)) {
						if (!Execute_ex(cfp->f_name, EmptyStr, cfp->p_name)) {
							ExeErrLog(cfp->f_name, LoadUsrMsg(USTR_FaildExec));
							UserAbort(USTR_FaildExec);
						}
					}
				}
				//タブグループ
				else if (OpenStdTabGroup && SameText(get_IniTypeStr(cfp), "タブグループ")) {
					ExeCommandAction("LoadTabGroup", cfp->f_name);
				}
				//メニューファイル
				else if (OpenStdMenuFile && is_MenuFile(cfp)) {
					ExeCommandAction("ExeMenuFile", cfp->f_name);
				}
				//結果リスト
				else if (OpenStdResultList && is_ResultList(cfp)) {
					ExeCommandAction("LoadResultList", cfp->f_name);
				}
				//テキストビュアー
				else if (!ExeCmdAction(TextViewerAction)) {
					ActionAbort();
				}

				if (DownAfterOpenStd && !not_down) CursorDownAction->Execute();	//実行後、下に移動
			}
		}

		if (!GlobalErrMsg.IsEmpty()) GlobalAbort();
	}
	catch (EAbort &e) {
		SetActionAbort(e.Message);
	}
	catch (...) {
		SetInternalException();
	}

	fromOpenStd = false;
	del_file_rec(cfp);
}

//---------------------------------------------------------------------------
//ごみ箱を開く
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::OpenTrashActionExecute(TObject *Sender)
{
	if (::ShellExecute(NULL, _T("open"), _T("explorer"), _T("/root,::{645FF040-5081-101B-9F08-00AA002F954E}"), 
		NULL, SW_SHOWNORMAL) <= (HINSTANCE)32)
			SetActionAbort(USTR_FaildExec);
}

//---------------------------------------------------------------------------
//オプション設定
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::OptionDlgActionExecute(TObject *Sender)
{
	if (!OptionDlg) OptionDlg = new TOptionDlg(this);	//初回に動的作成
	OptionDlg->SetSheet(ActionParam);

	//安全のためビュアーを閉じる
	if		(ScrMode==SCMD_IVIEW) CloseIAction->Execute();
	else if (ScrMode==SCMD_TVIEW) ExeCommandV(_T("Close"));

	//通常のファイルリストに戻す
	if (ScrMode==SCMD_FLIST) RecoverFileList2(-1);
	Application->ProcessMessages();	

	if (OptionDlg->ShowModal()==mrOk) {
		if (OptionDlg->WinSizeChanged && IniWinMode==1) {
			WindowState = wsNormal;
			SetBounds(IniWinLeft, IniWinTop, IniWinWidth, IniWinHeight);
		}

		//デザイン、フォント、配色
		Perform(WM_NYANFI_APPEAR, (OptionDlg->LayoutChanged? 1 : 0), (NativeInt)0);

		//ツールボタン
		if (OptionDlg->TlBarColChanged) {
			UpdateToolBtn(SCMD_FLIST);
			UpdateToolBtn(SCMD_TVIEW);
			UpdateToolBtn(SCMD_IVIEW);
		}
		else if ((!ToolBarISide && ToolBarI->ButtonCount==0) || (ToolBarISide && ToolBarI2->ButtonCount==0)) {
			UpdateToolBtn(SCMD_IVIEW);
		}

		UpdLogTimer->Enabled	= false;
		UpdLogTimer->Interval	= LogInterval;
		UpdLogTimer->Enabled	= true;

		WatchDirTimer->Enabled	= false;
		WatchDirTimer->Interval = WatchInterval;
		WatchDirTimer->Enabled	= true;
		if (WatchDirTimer->Interval==0) {
			SetDirWatch(EmptyStr, 0);
			SetDirWatch(EmptyStr, 1);
		}

		if (IsPrimary) {
			SaveOptions();
			UpdateIniFile(IniFile);
			TrayIcon1->Visible = StoreTaskTray;
		}
	}
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::OptionDlgActionUpdate(TObject *Sender)
{
	((TAction*)Sender)->Enabled =
		IsPrimary && !CurWorking && !FindBusy && !CalcBusy && !CurStt->is_IncSea && !CurStt->is_Filter;
}

//---------------------------------------------------------------------------
//アーカイブの作成
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::PackActionExecute(TObject *Sender)
{
	file_rec *cfp = cre_new_file_rec(GetCurFrecPtr(true));

	bool to_cur  = USAME_TI(ActionOptStr, "ToCurrent");
	ActionOptStr = EmptyStr;

	try {
		if (!IsCurFList() || (!to_cur && !IsOppFList())) UserAbort(USTR_CantOperate);

		UnicodeString dst_dir = CurPath[to_cur? CurListTag : OppListTag];
		TStringList *lst = GetCurList(true);
		int sel_cnt 	 = GetSelCount(lst);
		if (sel_cnt==0 && (cfp->f_name.IsEmpty() || cfp->is_dummy)) Abort();

		UnicodeString arc_file, pasaword, arc_fext;
		int  arc_t;
		bool pack_per_dir = false;
		bool inc_top_dir  = false;

		//パラメータ指定
		if (!ActionParam.IsEmpty() && !ContainsStr(ActionParam, "?")) {
			UnicodeString anam = FormatParam(ActionParam);
			arc_t = usr_ARC->GetArcType(anam);
			if (arc_t==0) 					  UserAbort(USTR_IllegalParam);
			if (!usr_ARC->IsAvailable(arc_t)) throw EAbort(usr_ARC->ErrMsg);

			if (arc_t>0) arc_file = dst_dir + anam;
			//圧縮形式(レベル)
			usr_ARC->ZipPrm_x	= IniFile->ReadIntGen(_T("ZipPrm_x"),	5);
			usr_ARC->ZipPrm_sfx = IniFile->ReadBoolGen(_T("ZipPrm_sfx"));
			usr_ARC->TarPrm_z	= IniFile->ReadIntGen(_T("TarPrm_z"),	6);
			usr_ARC->CabPrm_z	= IniFile->ReadIntGen(_T("CabPrm_z"),	0);
			//追加スイッチ
			usr_ARC->ExSw_Zip	= IniFile->ReadStrGen(_T("ExSw_Zip"));
			usr_ARC->ExSw_7z	= IniFile->ReadStrGen(_T("ExSw_7z"));
			usr_ARC->ExSw_Lha 	= IniFile->ReadStrGen(_T("ExSw_Lha"));
			usr_ARC->ExSw_Cab 	= IniFile->ReadStrGen(_T("ExSw_Cab"));
			usr_ARC->ExSw_Tar 	= IniFile->ReadStrGen(_T("ExSw_Tar"));
		}
		//ダイアログ指定
		else {
			bool dir_only = false;
			if (sel_cnt>0) {
				int d_cnt = 0;
				for (int i=0; i<lst->Count; i++) {
					file_rec *fp = (file_rec*)lst->Objects[i];
					if (!fp->selected) continue;
					if (fp->is_dir) d_cnt++; else { d_cnt = 0; break; }
				}
				dir_only = (d_cnt>0);
			}

			//デフォルトのアーカイブ名を設定
			UnicodeString arc_name;
			if (ContainsStr(ActionParam, "?")) {
				arc_name = FormatParam(ReplaceStr(ActionParam, "?", ""));
				if (!get_extension(arc_name).IsEmpty()) {
					arc_t = usr_ARC->GetArcType(arc_name);
					int idx = (arc_t==UARCTYP_ZIP)? 0 : (arc_t==UARCTYP_7Z) ? 1 :
							  (arc_t==UARCTYP_LHA)? 2 : (arc_t==UARCTYP_CAB)? 3 :
							  (arc_t==UARCTYP_TAR)? 4 : -1;
					if (idx!=-1) {
						IniFile->WriteIntGen(_T("ArcFormat"), idx);
						arc_name = ChangeFileExt(arc_name, EmptyStr);
					}
				}
			}
			if (arc_name.IsEmpty()) {
				arc_name = (cfp && !cfp->is_dummy)? cfp->b_name : EmptyStr;
				for (int i=0; i<lst->Count && arc_name.IsEmpty(); i++) {
					file_rec *fp = (file_rec*)lst->Objects[i];
					if (fp->selected) arc_name = fp->b_name;
				}
			}

			//ダイアログを表示
			if (!PackArcDlg) PackArcDlg = new TPackArcDlg(this);	//初回に動的作成
			PackArcDlg->ArcNameEdit->Text = arc_name;
			PackArcDlg->PerDirCheckBox->Enabled = dir_only;
			arc_t = 0;
			if (PackArcDlg->ShowModal()==mrOk) {
				arc_name = PackArcDlg->ArcNameEdit->Text;
				pasaword = PackArcDlg->PasswordEdit->Text;
				arc_fext = PackArcDlg->FextLabel->Caption;
				pack_per_dir = PackArcDlg->PerDirCheckBox->Checked;
				inc_top_dir  = PackArcDlg->IncDirCheckBox->Checked;
				if (!pack_per_dir) {
					if (arc_name.IsEmpty()) Abort();
					arc_file = dst_dir + arc_name + arc_fext;
				}

				switch (PackArcDlg->FormatRadioGroup->ItemIndex) {
				case 1:  arc_t = UARCTYP_7Z;  break;
				case 2:  arc_t = UARCTYP_LHA; break;
				case 3:  arc_t = UARCTYP_CAB; break;
				case 4:  arc_t = UARCTYP_TAR; break;
				default: arc_t = UARCTYP_ZIP;
				}
			}
		}

		if (arc_t>0) {
			bool sure_same = IniFile->ReadBoolGen(_T("SureSameArc"), true);
			int  same_mode = IniFile->ReadIntGen(_T("SameArcMode"));

			UnicodeString src_dir = GetCurPathStr();
			UnicodeString msg, tmp;

			//ディレクトリ毎に個別圧縮
			if (pack_per_dir) {
				StartLog(msg.sprintf(_T("圧縮開始  %s\t%s"), src_dir.c_str(), CurPath[OppListTag].c_str()));
				CurWorking = true;
				for (int i=0; i<lst->Count; i++) {
					file_rec *fp = (file_rec*)lst->Objects[i];
					if (!fp->selected) continue;

					UnicodeString src_dir2 = inc_top_dir? src_dir : IncludeTrailingPathDelimiter(src_dir + fp->b_name);

					std::unique_ptr<TStringList> s_lst(new TStringList());
					UnicodeString src_files, res_file;
					if (inc_top_dir || arc_t==UARCTYP_CAB) {
						add_PackItem(fp, arc_t, src_dir2, s_lst.get());
						res_file = make_ResponseFile(s_lst.get(), arc_t, &src_files, true);
						if (res_file==RESPONSE_ERR) UserAbort(USTR_FaildListFile);
						if (src_files.IsEmpty() && res_file.IsEmpty()) UserAbort(USTR_NoObject);
						if (!res_file.IsEmpty()) src_files = add_quot_if_spc("@" + res_file);
					}
					else {
						src_files = "*";
					}

					arc_file = dst_dir + fp->b_name + arc_fext;
					msg = make_LogHdr(_T("PACK"), arc_file);

					if (file_exists(arc_file)) {
						if (sure_same) {
							tmp.sprintf(_T("同名アーカイブ[%s]があります。\r\n"), ExtractFileName(arc_file).c_str());
							tmp.cat_sprintf(_T("%sしますか?"), (same_mode==0)? _T("既存内容に追加") : _T("削除して新規作成"));
							if (msgbox_Y_N_C(tmp)!=IDYES) {
								msg[1] = 'C';  UserAbort(USTR_Canceled);
							}
						}

						if (same_mode==1 && !delete_File(arc_file)) {
							set_LogErrMsg(msg);
							msg[1] = 'E'; AddLog(msg);
							UserAbort(USTR_FaildProc);
						}
					}

					if (!usr_ARC->Pack(arc_t, arc_file, src_dir2, src_files, pasaword)) set_LogErrMsg(msg, usr_ARC->ErrMsg);
					delete_FileIf(res_file);
					AddLog(msg);

					if (msg[1]=='E') UserAbort(USTR_FaildProc);
					fp->selected = false;
					InvalidateFileList();
					if (!to_cur) {
						ReloadList(OppListTag);
						IndexOfFileList(arc_file, OppListTag);
					}
					if (to_cur || EqualDirLR()) ReloadList(CurListTag);
					SetDriveInfo();
				}
				CurWorking = false;
				EndLog(_T("圧縮"));
			}
			//通常圧縮
			else {
				//対象リストを作成
				std::unique_ptr<TStringList> s_lst(new TStringList());
				if (sel_cnt>0) {
					for (int i=0; i<lst->Count; i++) {
						file_rec *fp = (file_rec*)lst->Objects[i];
						if (fp->selected) add_PackItem(fp, arc_t, src_dir, s_lst.get());
					}
				}
				else {
					add_PackItem(cfp, arc_t, src_dir, s_lst.get());
				}

				UnicodeString src_files;
				UnicodeString res_file = make_ResponseFile(s_lst.get(), arc_t, &src_files, true);
				if (res_file==RESPONSE_ERR) UserAbort(USTR_FaildListFile);
				if (src_files.IsEmpty() && res_file.IsEmpty()) UserAbort(USTR_NoObject);
				if (!res_file.IsEmpty()) src_files = add_quot_if_spc("@" + res_file);

				msg = make_LogHdr(_T("PACK"), arc_file);

				if (file_exists(arc_file)) {
					if (sure_same) {
						tmp.sprintf(_T("同名アーカイブ[%s]があります。\r\n"), ExtractFileName(arc_file).c_str());
						tmp.cat_sprintf(_T("%sしますか?"), (same_mode==0)? _T("既存内容に追加") : _T("削除して新規作成"));
						if (msgbox_Y_N_C(tmp)!=IDYES) {
							msg[1] = 'C';  UserAbort(USTR_Canceled);
						}
					}

					if (same_mode==1 && !delete_File(arc_file)) {
						set_LogErrMsg(msg);
						msg[1] = 'E'; AddLog(msg);
						UserAbort(USTR_FaildProc);
					}
				}

				CurWorking = true;
				StartLog(tmp.sprintf(_T("圧縮開始  %s\t%s"), src_dir.c_str(), dst_dir.c_str()));
				if (!usr_ARC->Pack(arc_t, arc_file, src_dir, src_files, pasaword)) set_LogErrMsg(msg, usr_ARC->ErrMsg);
				delete_FileIf(res_file);
				CurWorking = false;
				AddLog(msg);
				if (msg[1]=='E') UserAbort(USTR_FaildProc);
				ClrSelect();
				InvalidateFileList();
				if (!to_cur) {
					ReloadList(OppListTag);
					IndexOfFileList(arc_file, OppListTag);
				}
				if (to_cur || EqualDirLR()) ReloadList(CurListTag);
				SetDriveInfo();
				EndLog(_T("圧縮"));
			}
		}
	}
	catch (EAbort &e) {
		SetActionAbort(e.Message);
	}

	del_file_rec(cfp);
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::PackToCurrActionExecute(TObject *Sender)
{
	ActionOptStr = "ToCurrent";
	PackAction->Execute();
}

//---------------------------------------------------------------------------
//1ページ下に移動
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::PageDownActionExecute(TObject *Sender)
{
	TListBox *lp = FileListBox[CurListTag];	if (lp->Count<2 || lp->ItemIndex==lp->Count-1) return;
	ListBoxPageDown(lp);
	lp->Invalidate();
	SetDriveFileInfo(CurListTag, false, false);
}
//---------------------------------------------------------------------------
//選択しながら1ページ下に移動
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::PageDownSelActionExecute(TObject *Sender)
{
	TListBox *lp = FileListBox[CurListTag];	if (lp->ItemIndex==lp->Count-1) return;
	int idx0 = lp->ItemIndex;
	ListBoxPageDown(lp);
	int idx1 = lp->ItemIndex;
	TStringList *lst = GetCurList();
	for (int i=idx0; i<=idx1; i++) set_select((file_rec*)lst->Objects[i]);
	RepaintList(CurListTag);
	SetFileInf();
}

//---------------------------------------------------------------------------
//1ページ上に移動
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::PageUpActionExecute(TObject *Sender)
{
	TListBox *lp = FileListBox[CurListTag];	if (lp->Count<2 || lp->ItemIndex==0) return;
	ListBoxPageUp(lp);
	lp->Invalidate();
	SetDriveFileInfo(CurListTag, false, false);
}
//---------------------------------------------------------------------------
//選択しながら1ページ上に移動
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::PageUpSelActionExecute(TObject *Sender)
{
	TListBox *lp = FileListBox[CurListTag];	if (lp->ItemIndex==0) return;
	int idx1 = lp->ItemIndex;
	ListBoxPageUp(lp);
	int idx0 = lp->ItemIndex;
	TStringList *lst = GetCurList();
	for (int i=idx0; i<=idx1; i++) set_select((file_rec*)lst->Objects[i]);
	RepaintList(CurListTag);
	SetFileInf();
}

//---------------------------------------------------------------------------
//パスマスク
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::PathMaskDlgActionExecute(TObject *Sender)
{
	if (!CurStt->is_Find && !CurStt->is_Work) {
		if (TEST_ActParam("ND")) {
			PopupRegDirMenu(_T("PathMask"));
		}
		else {
			if (!PathMaskDlg) PathMaskDlg = new TPathMaskDlg(this);	//初回に動的作成
			PathMaskDlg->ShowModal();
		}
	}
	else SetActionAbort(USTR_CantOperate);
}

//---------------------------------------------------------------------------
//全てのタスクを一旦停止
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::PauseAllTaskActionExecute(TObject *Sender)
{
	bool paused = false;
	for (int i=0; i<MAX_TASK_THREAD && !paused; i++) {
		TTaskThread *tp = TaskThread[i];
		if (tp && tp->TaskPause) paused = true;
	}

	SetToggleAction(paused);
	for (int i=0; i<MAX_TASK_THREAD; i++) {
		TTaskThread *tp = TaskThread[i];
		if (tp) tp->TaskPause = paused;
	}
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::PauseAllTaskActionUpdate(TObject *Sender)
{
	int task_cnt = 0, pause_cnt = 0;
	for (int i=0; i<MAX_TASK_THREAD; i++) {
		TTaskThread *tp = TaskThread[i];
		if (tp) {
			task_cnt++;
			if (tp->TaskPause) pause_cnt++;
		}
	}

	TAction *ap = (TAction*)Sender;
	ap->Enabled = (task_cnt>0);
	ap->Caption = (pause_cnt>0)? "すべて再開" : "すべて一旦停止";
}

//---------------------------------------------------------------------------
//プレイリストを作って再生
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::PlayListActionExecute(TObject *Sender)
{
	//次
	if (TEST_ActParam("NX")) {
		cursor_HourGlass();
		play_PlayList();
		if (GeneralInfoDlg->Visible)
			::PostMessage(GeneralInfoDlg->Handle, WM_NYANFI_PLAYLIST, ListShuffled? 1 : 0, 0);
		ListShuffled = false;
		cursor_Default();
		return;
	}
	//前
	if (TEST_ActParam("PR")) {
		cursor_HourGlass();
		play_PlayList(true);
		if (GeneralInfoDlg->Visible)
			::PostMessage(GeneralInfoDlg->Handle, WM_NYANFI_PLAYLIST, 0, 0);
		cursor_Default();
		return;
	}
	//一時停止
	if (TEST_ActParam("PS")) {
		if (!PlayFile.IsEmpty()) mciSendString(_T("pause  PLYLIST"), NULL, 0, NULL);
		return;
	}
	//再開
	if (TEST_ActParam("RS")) {
		if (!PlayFile.IsEmpty()) mciSendString(_T("resume  PLYLIST"), NULL, 0, NULL);
		return;
	}
	//ファイル情報
	if (TEST_ActParam("FI")) {
		if (!PlayFile.IsEmpty()) FileInfoDlg->ShowModalEx(PlayFile);
		return;
	}
	//プレイリスト一覧
	if (TEST_ActParam("LS")) {
		if (PlayList->Count>0) {
			UnicodeString tit = "プレイリスト";
			if (!PlayListFile.IsEmpty()) tit.cat_sprintf(_T(" - %s"), PlayListFile.c_str());
			GeneralInfoDlg->Caption	   = tit;
			GeneralInfoDlg->isPlayList = true;
			GeneralInfoDlg->FileName   = PlayListFile;
			GeneralInfoDlg->ShowModal();
		}
		return;
	}

	try {
		cursor_HourGlass();
		::mciSendString(_T("close PLYLIST"), NULL, 0, NULL);
		PlayList->Clear();
		PlayStbIdx = -1;
		PlayRepeat = PlayShuffle = false;
		if		(TEST_DEL_ActParam("RP")) PlayRepeat  = true;
		else if (TEST_DEL_ActParam("SF")) PlayShuffle = true;
		else if (TEST_DEL_ActParam("SR")) PlayShuffle = PlayRepeat = true;
		ActionParam = exclude_quot(ActionParam);
		//対象指定
		if (!ActionParam.IsEmpty()) {
			if (!add_PlayList(to_absolute_name(ActionParam)))
				throw EAbort(LoadUsrMsg(USTR_NotFound, _T("対象")));
		}
		//選択指定
		else {
			TStringList *lst = GetCurList(true);
			if (GetSelCount(lst)>0) {
				for (int i=0; i<lst->Count; i++) {
					file_rec *fp = (file_rec*)lst->Objects[i];
					if (fp->selected) add_PlayList(fp->f_name);
				}
				ClearAllAction->Execute();
			}
		}
		//再生開始
		if (PlayList->Count>0) {
			PlayStbIdx = 0;
			play_PlayList();
		}
		cursor_Default();
	}
	catch (EAbort &e) {
		SetActionAbort(e.Message);
	}
}

//---------------------------------------------------------------------------
//ディレクトリをポップ
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::PopDirActionExecute(TObject *Sender)
{
	bool ok = false;
	while (DirStack->Count>0 && !ok) {
		TStringDynArray itm_buf = get_csv_array(DirStack->Strings[0], 2, true);
		DirStack->Delete(0);
		if (dir_exists(itm_buf[0])) {
			if (TEST_ActParam("OP"))
				UpdateOppPath(itm_buf[0], itm_buf[1].ToIntDef(0));
			else
				UpdateCurPath(itm_buf[0], itm_buf[1].ToIntDef(0));
			SetCurTab(true);
			ok = true;
		}
	}
	if (!ok) SetActionAbort(_T("スタックが空です。"));
}


//---------------------------------------------------------------------------
//メインメニューをポップアップ表示
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::AssignToMenuItem(TMenuItem *m_item, TMenuItem *src_m)
{
	TMenuItem *mp = new TMenuItem(m_item);
	mp->Caption 	= src_m->Caption;
	mp->Tag 		= src_m->Tag;
	mp->Visible		= src_m->Visible;
	mp->Enabled		= src_m->Visible;
	mp->Checked		= src_m->Checked;
	mp->ImageIndex	= src_m->ImageIndex;
	mp->AutoHotkeys = src_m->AutoHotkeys;

	if (src_m->Action)
		mp->Action  = src_m->Action;
	else if (src_m->OnClick && src_m->OnClick!=ExtMenuClick)
		mp->OnClick = src_m->OnClick;

	m_item->Add(mp);

	if (src_m->Count>0) {
		for (int i=0; i<src_m->Count; i++) AssignToMenuItem(mp, src_m->Items[i]);
	}
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::PopupMainMenuActionExecute(TObject *Sender)
{
	int idx = !ActionParam.IsEmpty()? pos_i(ActionParam[1], "FESVLTOH") - 1 : -1;

	FileMenuClick(FileMenu);

	IconImgListP->Clear();
	SetExtMenuItem(EditMenu, ExtMenuList, EXTMENU_BASE);
	SetExtMenuItem(ToolMenu, ExtToolList, EXTTOOL_BASE);

	IV_SidebarPosAction->Execute();
	IV_ThumbPosAction->Execute();

	ExPopupMenu->Items->Clear();
	if (idx!=-1) {
		TMenuItem *src_m = MainMenu1->Items->Items[idx];
		for (int i=0; i<src_m->Count; i++) AssignToMenuItem(ExPopupMenu->Items, src_m->Items[i]);
	}
	else {
		for (int i=0; i<MainMenu1->Items->Count; i++) {
			if (idx==-1 || i==idx) AssignToMenuItem(ExPopupMenu->Items, MainMenu1->Items->Items[i]);
		}
	}
	reduction_MenuLine(ExPopupMenu->Items);

	//表示
	int yp = (ScrMode==SCMD_FLIST && ToolBarF->Visible)? yp = ToolBarF->Height :
			 (ScrMode==SCMD_TVIEW && ToolBarV->Visible)? yp = ToolBarV->Height :
			 (ScrMode==SCMD_IVIEW && ToolBarI->Visible)? yp = ToolBarI->Height : 0;
	TPoint p = ActionOptIsMousePos()? Mouse->CursorPos :
			  ActionOptIsButtonPos()? ButtonPos : this->ClientToScreen(Point(0, yp));
	ActionOptStr = EmptyStr;
	ShowExPopupMenu(p);
}

//---------------------------------------------------------------------------
//前のドライブへ
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::PrevDriveActionExecute(TObject *Sender)
{
	UnicodeString dstr = get_drive_str(CurPath[CurListTag]);
	std::unique_ptr<TStringList> d_list(new TStringList());
	if (get_available_drive_list(d_list.get())==0) {
		SetActionAbort();
	}
	else {
		int idx = -1;
		for (int i=d_list->Count-1; i>=0 && idx==-1; i--)
			if (CompareText(dstr, d_list->Strings[i])>0) idx = i;
		if (idx==-1) idx = d_list->Count - 1;
		UpdateCurDrive(d_list->Strings[idx]);
	}
}

//---------------------------------------------------------------------------
//前のマーク項目へ
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::PrevMarkActionExecute(TObject *Sender)
{
	int c_idx = GetCurIndex();
	int idx0 = -1, idx1 = -1;
	TStringList *lst = GetCurList();
	for (int i=lst->Count-1; i>=0 && idx1==-1; i--) {
		if (i>=c_idx && idx0!=-1) continue;
		if (IniFile->IsMarked(((file_rec*)lst->Objects[i])->r_name)) {
			if (i>=c_idx) idx0 = i; else idx1 = i;
		}
	}
	SetCurIndex((idx1!=-1)? idx1 : idx0);
}

//---------------------------------------------------------------------------
//前の NyanFi
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::PrevNyanFiActionExecute(TObject *Sender)
{
	activate_NyanFi(-1);
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ChgNyanFiActionUpdate(TObject *Sender)
{
	((TAction*)Sender)->Enabled = MultiInstance;
}

//---------------------------------------------------------------------------
//ユーザ定義メニューを表示
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ExePopMenuList(
	TStringList *lst,	//定義リスト
	bool is_execmd,		//ExeCommandsCore PopupMenu を実行 (default = false)
	TControl *cp)		//表示の基準コントロール
{
	ExPopupMenu->Items->Clear();
	IconImgListP->Clear();
	PopMenuList->Assign(lst);
	PopMenuIndex = -1;

	TMenuItem *pp = ExPopupMenu->Items;
	for (int i=0; i<PopMenuList->Count; i++) {
		UnicodeString lbuf = Trim(PopMenuList->Strings[i]);
		if (lbuf.IsEmpty() || StartsStr(';', lbuf)) continue;
		TStringDynArray m_buf = split_strings_tab(lbuf);
		if (m_buf.Length==0 || m_buf[0].IsEmpty()) continue;
		UnicodeString tit = m_buf[0];

		//サブメニュー
		if (remove_top_s(tit, '>')) {
			TMenuItem *mp = new TMenuItem(ExPopupMenu);
			mp->Caption    = tit;
			mp->ImageIndex = (m_buf.Length>=3)? add_IconImage(m_buf[2], IconImgListP) : -1;
			pp->Add(mp);
			pp = mp;
		}
		else if (remove_top_s(tit, '<')) {
			if (pp!=ExPopupMenu->Items) pp = pp->Parent;
		}
		//メニュー項目
		else {
			TMenuItem *mp = new TMenuItem(ExPopupMenu);
			mp->Tag = i;
			if (is_execmd) {
				mp->OnClick = ExeCmdsMenuClick;
			}
			else {
				//単独でパラメータ無コマンドだったらアクションへバインド
				if (m_buf.Length>1 && is_OneNrmCmd(m_buf[1], true)) {
					for (int j=0; j<ActionList1->ActionCount; j++) {
						TAction *ap = (TAction*)ActionList1->Actions[j];
						if (StartsText("Command", ap->Category) && SameText(m_buf[1], get_tkn(ap->Name, _T("Action")))) {
							mp->Action = ap;
							break;
						}
					}
				}
				if (!mp->Action && m_buf.Length>1) mp->OnClick = MenuFileItemClick;
			}

			mp->Caption    = Trim(m_buf[0]);
			mp->Enabled    = !is_match_regex_i(tit, _T("^\\[.+\\]\\s不明なエイリアス"));
			mp->ImageIndex = (m_buf.Length>=3)? add_IconImage(m_buf[2], IconImgListP) : -1;
			pp->Add(mp);
		}
	}

	//メニュー表示
	TPoint mp = (cp==L_StatPanel || cp==R_StatPanel)?
					Point(get_CharWidth_Font(DrvInfFont, 10), 0) : Point(16, 16);

	TPoint p  = cp ? cp->ClientToScreen(mp) :
		 ActionOptIsMousePos()? Mouse->CursorPos :
		ActionOptIsButtonPos()? ButtonPos :
		(USAME_TI(ActionOptStr, "ListItemPos") || (fromFileList && !is_execmd))? CurListItemPos() :
		 TxtViewPanel->Visible? TextPaintBox->ClientToScreen(mp) :
		 ImgViewPanel->Visible? ImgScrollPanel->ClientToScreen(mp) :
			GrepPanel->Visible? ResultListBox->ClientToScreen(mp) :
								FileListBox[CurListTag]->ClientToScreen(mp);

	if (!fromMenuFile) ActionOptStr = EmptyStr;

	ShowExPopupMenu(p);

	if (is_execmd) Application->ProcessMessages();
}
//---------------------------------------------------------------------------
UnicodeString __fastcall TNyanFiForm::get_MenuItemStr(TStringDynArray menu_lst)
{
	UnicodeString ret_str;

	if (menu_lst.Length>0) {
		if (menu_lst.Length>1) {
			std::unique_ptr<TStringList> m_buf(new TStringList());
			make_AssoMenuList(menu_lst, m_buf.get());
			ActionOptStr = "ListItemPos";
			ExePopMenuList(m_buf.get(), true);
			Application->ProcessMessages();
			if (PopMenuIndex==-1) ret_str = "SKIP"; else ret_str = menu_lst[PopMenuIndex];
		}
		else {
			ret_str = menu_lst[0];
			if (is_separator(ret_str)) ret_str = "SKIP";
		}
		split_dsc(ret_str);
	}

	return ret_str;
}

//---------------------------------------------------------------------------
//ユーザ定義メニューの項目を実行
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::MenuFileItemClick(TObject *Sender)
{
	int idx = ((TMenuItem*)Sender)->Tag;
	if (idx>=0 && idx<PopMenuList->Count) {
		TStringDynArray m_buf = split_strings_tab(PopMenuList->Strings[idx]);
		if (m_buf.Length>1) {
			if (!ExeCommandsCore(m_buf[1])) SetActionAbort(GlobalErrMsg);
		}
	}
}

//---------------------------------------------------------------------------
//メニューファイルを実行
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ExeMenuFileActionExecute(TObject *Sender)
{
	std::unique_ptr<TStringList> fbuf(new TStringList());
	if (load_MenuFile(ActionParam, fbuf.get())) {
		fromMenuFile = true;
		if (!ActionOptIsMousePos() && !ActionOptIsButtonPos()) ActionOptStr = "ListItemPos";
		ExePopMenuList(fbuf.get());
		fromMenuFile = false;
	}
	else {
		SetActionAbort(USTR_FileNotOpen);
	}
}

//---------------------------------------------------------------------------
//シャットダウン
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::PowerOffActionExecute(TObject *Sender)
{
	ReqClose	= true;
	ReqPowerOff = true;
}

//---------------------------------------------------------------------------
//PowerShell
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::PowerShellActionExecute(TObject *Sender)
{
	ExeCommandAction("FileRun", "powershell");
}

//---------------------------------------------------------------------------
//プロパティを表示
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::PropertyDlgActionExecute(TObject *Sender)
{
	if (!IsCurFList()) {
		SetActionAbort(USTR_CantOperate); return;
	}

	UnicodeString fnam;
	if (!ActionParam.IsEmpty()) {
		fnam = ActionParam;
	}
	else {
		file_rec *fp = GetCurFrecPtr(false, true);
		if (fp && !fp->is_virtual)
			fnam = fp->is_up? ExcludeTrailingPathDelimiter(fp->p_name) : fp->f_name;
	}
	if (!fnam.IsEmpty()) {
		Mouse->CursorPos = CurListItemPos();
		ShowPropertyDialog(fnam);
	}
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::PropertyDlgActionUpdate(TObject *Sender)
{
	TAction *ap = (TAction*)Sender;
	ap->Visible = ScrMode==SCMD_FLIST || ScrMode==SCMD_TVIEW || ScrMode==SCMD_IVIEW;
	ap->Enabled = ap->Visible && GetCurFrecPtr(false, true) && !CurStt->is_Arc;
}

//---------------------------------------------------------------------------
//ディレクトリをプッシュ
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::PushDirActionExecute(TObject *Sender)
{
	UnicodeString tmp;
	if (TEST_ActParam("OP")) {
		if (IsOppFList())
			DirStack->Insert(0,
				tmp.sprintf(_T("\"%s\",%d"), CurPath[OppListTag].c_str(), FileListBox[OppListTag]->ItemIndex));
		else
			SetActionAbort();
	}
	else if (IsCurFList())
		DirStack->Insert(0,
			tmp.sprintf(_T("\"%s\",%d"), CurPath[CurListTag].c_str(), FileListBox[CurListTag]->ItemIndex));
	else
		SetActionAbort();
}

//---------------------------------------------------------------------------
//再起動
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::RebootActionExecute(TObject *Sender)
{
	ReqClose  = true;
	ReqReboot = true;
}

//---------------------------------------------------------------------------
//最近使ったファイル一覧
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::RecentListActionExecute(TObject *Sender)
{
	if (TEST_ActParam("AC")) {
		if (msgbox_Sure(LoadUsrMsg(USTR_DeleteQ, _T("すべての項目")), !(ExeCmdsBusy && XCMD_MsgOff)))
			SHAddToRecentDocs(SHARD_PATHA, NULL);
		return;
	}

	if (TEST_ActParam("BC")) {
		EditHistoryDlg->ClrBrkRecentAction->Execute();
		return;
	}

	EditHistoryDlg->isRecent = true;
	int res = EditHistoryDlg->ShowModal();
	UnicodeString fnam = EditHistoryDlg->EditFileName;
	UnicodeString cmd  = EditHistoryDlg->CmdStr;
	if (res==mrOk || res==mrClose) {
		if (JumpToList(CurListTag, fnam))
			ExeCommandAction(EditHistoryDlg->CmdStr, ActionParam);
		else
			SetActionAbort(GlobalErrMsg);
	}
}

//---------------------------------------------------------------------------
//登録ディレクトリ
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::RegDirDlgActionExecute(TObject *Sender)
{
	if (TEST_ActParam("ND")) {
		PopupRegDirMenu(_T("RegDir"));
	}
	else {
		if (!RegDirDlg) RegDirDlg = new TRegDirDlg(this);	//初回に動的作成
		RegDirDlg->IsAddMode = TEST_ActParam("AD");
		if (RegDirDlg->ShowModal()==mrOk && !RegDirDlg->CmdStr.IsEmpty()) {
			ExeCommandAction(RegDirDlg->CmdStr);
		}
	}
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::RegDirPopupActionExecute(TObject *Sender)
{
	PopupRegDirMenu(TEST_ActParam("OP")? _T("OppDir") : _T("RegDir"));
}

//---------------------------------------------------------------------------
//正規表現チェッカー
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::RegExCheckerActionExecute(TObject *Sender)
{
	if (!RegExChecker) RegExChecker = new TRegExChecker(this);	//初回に動的作成
	if (!RegExChecker->Visible) {
		RegExChecker->PatternStr = ActionParam;
		RegExChecker->ShowModal();
	}
}

//---------------------------------------------------------------------------
//ファイルリストを最新の情報に
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ReloadListActionExecute(TObject *Sender)
{
	if (!Initialized || UnInitializing) return;
	if (CurStt->is_Find && CurStt->find_Loaded) return;

	if (TEST_ActParam("OFF")) {
		DisReload = true;
	}
	else {
		DisReload = false;
		bool cur_only = TEST_ActParam("CO");
		ClrSelect(GetCurList());
		if (!cur_only) ClrSelect(GetOppList());

		WatchDirTimer->Enabled = false;
		ChkHardLink = TEST_ActParam("HL");
		ReloadList(cur_only? CurListTag : -1);
		ChkHardLink = false;
		WatchDirTimer->Enabled = true;
	}
}

//---------------------------------------------------------------------------
//名前等の変更
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::RenameDlgActionExecute(TObject *Sender)
{
	if (CurStt->is_Work) {
		SetAliasAction->Execute();
		return;
	}

	try {
		if (CurStt->is_ADS || IsDiffList()) UserAbort(USTR_CantOperate);

		//アーカイブ内の改名
		if (CurStt->is_Arc) {
			if (!usr_ARC->HasRename(CurStt->arc_Name)) UserAbort(USTR_OpeNotSuported);

			file_rec *cfp = GetCurFrecPtr();
			if (!cfp || cfp->is_dummy) Abort();
			UnicodeString new_name = cfp->n_name;
			if (!input_query_ex(USTR_Rename, _T("名前"), &new_name)) SkipAbort();
			if (!CurStt->arc_SubPath.IsEmpty())
				new_name = IncludeTrailingPathDelimiter(CurStt->arc_SubPath) + new_name;
			StartLog("改名開始  " + CurStt->arc_Name);
			UnicodeString msg = make_RenameLog(cfp->f_name, new_name);
			CurWorking = true;
			SetDirWatch(false);
			if (!usr_ARC->RenFile(CurStt->arc_Name, cfp->f_name, new_name)) set_LogErrMsg(msg, usr_ARC->ErrMsg);
			AddLog(msg);
			SetDirWatch(true);
			CurWorking = false;
			EndLog(_T("改名"));

			TStringList *sm_lst = SelMaskList[CurListTag];
			if (sm_lst->Count>0) {
				int idx = sm_lst->IndexOf(cfp->f_name);
				if (idx!=-1) sm_lst->Strings[idx] = new_name;
			}

			ChangeArcFileListEx(CurStt->arc_Name, CurStt->arc_SubPath, CurListTag);
			return;
		}

		//FTPでの改名
		if (CurStt->is_FTP) {
			if (!IdFTP1->Connected()) {
				RecoverFileList();  Abort();
			}

			file_rec *cfp = GetCurFrecPtr();  if (!cfp) Abort();
			UnicodeString old_name = cfp->n_name;
			UnicodeString new_name = old_name;
			if (!input_query_ex(USTR_Rename, _T("名前"), &new_name)) SkipAbort();
			StartLog("改名開始  " + CurFTPPath);
			UnicodeString msg = make_RenameLog(yen_to_slash(cfp->f_name), new_name);
			CurWorking = true;
			try {
				IdFTP1->Rename(old_name, new_name);
			}
			catch (...) {
				msg[1] = 'E';
			}
			add_FTPLogMsg(msg);
			if (!ChangeFtpFileList()) GlobalAbort();
			CurWorking	   = false;
			EndLog(_T("改名"));
			return;
		}

		//対象一覧を取得
		std::unique_ptr<TStringList> o_lst(new TStringList());
		TStringList *lst = GetCurList();
		for (int i=0; i<lst->Count; i++) {
			file_rec *fp = (file_rec*)lst->Objects[i];
			if (!fp->selected) continue;
			UnicodeString fnam = fp->f_name;
			if (fp->is_dir) fnam = IncludeTrailingPathDelimiter(fnam);
			o_lst->Add(fnam);
		}

		if (o_lst->Count==0) {
			file_rec *cfp = GetCurFrecPtr(true);
			if (cfp) {
				UnicodeString fnam = cfp->f_name;
				if (cfp->is_dir) fnam = IncludeTrailingPathDelimiter(fnam);
				o_lst->Add(fnam);
			}
		}
		if (o_lst->Count==0) Abort();

		//ダイアログ準備
		if (!RenameDlg) RenameDlg = new TRenameDlg(this);	//初回に動的作成
		RenameDlg->ItemList->Assign(o_lst.get());

		//カレントの一覧を取得
		RenameDlg->CurNameList->Clear();
		for (int i=0; i<lst->Count; i++) {
			file_rec *fp = (file_rec*)lst->Objects[i];
			if (is_selectable(fp)) RenameDlg->CurNameList->Add(fp->f_name);
		}

		//リスト編集による改名
		if (TEST_ActParam("ED")) {
			std::unique_ptr<TStringList> fbuf(new TStringList());
			int w = std::max(UnicodeString(o_lst->Count).Length(), 3);
			for (int i=0; i<o_lst->Count; i++) {
				UnicodeString fnam = ExtractFileName(ExcludeTrailingPathDelimiter(o_lst->Strings[i]));
				fbuf->Add(UnicodeString().sprintf(_T("%0*u\t%s"), w, i + 1, fnam.c_str()));
			}
			fbuf->Add(EmptyStr);
			fbuf->Add("\"項目番号 [TAB] ファイル名\" という書式にしたがって改名を行います。");
			fbuf->Add("ファイル名部分を自由に変更し、このリストを保存してください。");
			fbuf->Add("不要な項目は削除してもかまいませんが、順番は入れ替えないでください。");
			fbuf->Add("NyanFi の確認メッセージで「はい」を選ぶとリストが読み込まれ、改名を行えます。");
			fbuf->Add("なおこの説明を含め、空行以降の内容は無視されます。");

			UnicodeString ren_list = TempPathA + RENLIST_FILE;
			if (!saveto_TextUTF8(ren_list, fbuf.get())) throw EAbort(LoadUsrMsg(USTR_FaildSave, _T("リストファイル")));
			RenameDlg->EditedList  = true;
			RenameDlg->RenListFile = ren_list;
		}

		SetDirWatch(false);
		RenameDlg->OppPath = IsOppFList()? CurPath[OppListTag] : EmptyStr;
		if (RenameDlg->ShowModal()==mrOk) {
			TStringList *sm_lst = SelMaskList[CurListTag];
			if (sm_lst->Count>0) {
				TStringList *n_lst = RenameDlg->ItemList;
				for (int i=0; i<o_lst->Count; i++) {
					int idx = sm_lst->IndexOf(o_lst->Strings[i]);
					if (idx!=-1) sm_lst->Strings[idx] = n_lst->Strings[i];
				}
			}

			RenameOptCmdFile();
			FlushLog();
			ClrSelect();
			ReloadList(CurListTag);
			if (!RenameDlg->IsMulti) IndexOfFileList(RenameDlg->ItemList->Strings[0]);
			SetFileInf();
			SetDirWatch(true);

			//必要なら反対パスへ反映
			bool ret_opp = false;
			UnicodeString ret_nam;
			if (OppStt->is_Arc) {
				for (int i=0; i<RenArcFileList->Count && !ret_opp; i++) {
					UnicodeString lbuf	  = RenArcFileList->Strings[i];
					UnicodeString org_nam = split_pre_tab(lbuf);
					ret_opp = SameText(org_nam, OppStt->arc_Name);
					if (ret_opp) ret_nam = lbuf;
				}
			}
			RenArcFileList->Clear();

			if (ret_opp) {
				RecoverFileList(OppListTag);
				IndexOfFileList(ret_nam, OppListTag);
			}
			else {
				if (IsOppFList()) {
					if (!SameText(RenameDlg->OppPath, CurPath[OppListTag]))
						CurPath[OppListTag] = IncludeTrailingPathDelimiter(RenameDlg->OppPath);
					else if (EqualDirLR() || CurStt->is_Find)
						ReloadList(OppListTag);
				}
			}
		}
		else SetDirWatch(true);
	}
	catch (EAbort &e) {
		SetActionAbort(e.Message);
	}
	catch (...) {
		SetInternalException();
	}
}

//---------------------------------------------------------------------------
//リポジトリ一覧
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::RepositoryListActionExecute(TObject *Sender)
{
	EditHistoryDlg->isRepo	 = true;
	EditHistoryDlg->ToFilter = TEST_ActParam("FF");
	int res = EditHistoryDlg->ShowModal();
	if (res==mrOk || res==mrClose) {
		UpdateCurPath(IncludeTrailingPathDelimiter(EditHistoryDlg->EditFileName));
		ExeCommandAction(EditHistoryDlg->CmdStr);
	}
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::RepositoryListActionUpdate(TObject *Sender)
{
	TAction *ap = (TAction*)Sender;
	ap->Visible = ScrMode==SCMD_FLIST && GitExists;
	ap->Enabled = ap->Visible;
}

//---------------------------------------------------------------------------
//再起動
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::RestartActionExecute(TObject *Sender)
{
	try {
		if (TEST_DEL_ActParam("DM")) {
			TEST_DEL_ActParam("RA");
			if (IsAdmin) {
				//降格して再起動
				NotSaveINI	= TEST_ActParam("NS");
				ReqKeepDupl = false;
				//再起動用バッチファイルを作成
				UnicodeString cmd = "\'" + Application->ExeName + "\'";
				if (!ActionParam.IsEmpty()) cmd.cat_sprintf(_T(" \'-I%s\'"), ActionParam.c_str());

				std::unique_ptr<TStringList> fbuf(new TStringList());
				fbuf->Text =
					"TIMEOUT 1 /nobreak\r\n"
					"schtasks /create /tn \"Domate_NyanFi\" /tr \"" + cmd + "\" /sc once /st 23:59\r\n"
					"schtasks /run /tn \"Domate_NyanFi\"\r\n"
					"schtasks /delete /f /tn \"Domate_NyanFi\"\r\n"
					"EXIT\r\n";

				UnicodeString bat_nam = ExePath + "demote.bat";
				if (!saveto_TextFile(bat_nam, fbuf.get()))
					throw EAbort(LoadUsrMsg(USTR_FaildSave, _T("バッチファイル")));
				RstBatName = bat_nam;

				Close();
				return;
			}
		}

		UnicodeString prmstr = TEST_DEL_ActParam("NS")? "-q" : "-Q";
		UnicodeString optstr = TEST_DEL_ActParam("RA")? "A" : "";
		if (!ActionParam.IsEmpty()) prmstr.cat_sprintf(_T(" -I\"%s\""), exclude_quot(ActionParam).c_str());
		if (!Execute_ex(Application->ExeName, prmstr, ExePath, optstr)) SetActionAbort(USTR_FaildExec);

	}
	catch (EAbort &e) {
		SetActionAbort(e.Message);
	}
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::RestartActionUpdate(TObject *Sender)
{
	TAction *ap = (TAction*)Sender;
	ap->Visible = ScrMode==SCMD_FLIST;
	ap->Enabled = ap->Visible && IsPrimary && !CurWorking && !FindBusy && !CalcBusy && !ExeCmdsBusy;
}

//---------------------------------------------------------------------------
//ファイルリスト表示に戻る
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ReturnListActionExecute(TObject *Sender)
{
	if (ScrMode!=SCMD_FLIST)
		SetScrMode();
	else
		RecoverFileList2();
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ReturnListActionUpdate(TObject *Sender)
{
	((TAction*)Sender)->Visible = ScrMode!=SCMD_FLIST;
	((TAction*)Sender)->Enabled = !FindBusy;
}

//---------------------------------------------------------------------------
//結果リストに名前を付けて保存
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::SaveAsResultListActionExecute(TObject *Sender)
{
	UserModule->PrepareSaveDlg(LoadUsrMsg(USTR_SaveAs, _T("結果リスト")).c_str(), F_FILTER_TXT, NULL, ResultListPath);
	if (UserModule->SaveDlg->Execute()) {
		UnicodeString fnam = UserModule->SaveDlg->FileName;
		//検索情報
		UnicodeString stt = ";[ResultList]\n";
		stt.cat_sprintf(_T(";Find_Path=%s\n"),	CurStt->find_Path.c_str());
		stt.cat_sprintf(_T(";Find_Mask=%s\n"),	CurStt->find_Mask.c_str());
		stt.cat_sprintf(_T(";Find_Keywd=%s\n"),	CurStt->find_Keywd.c_str());

		if (CurStt->find_DICON) {
			stt.cat_sprintf(_T(";Find_Icons=%s\n"),	ReplaceStr(CurStt->find_Icons, "\r\n", "/").c_str());
			stt += ";find_DICON=1\n";
		}

		if (CurStt->find_MARK)		stt += ";Find_MARK=1\n";
		if (CurStt->find_TAG)		stt += ";Find_TAG=1\n";
		if (CurStt->find_DUPL)		stt += ";Find_DUPL=1\n";
		if (CurStt->find_HLINK)		stt += ";Find_HLINK=1\n";
		if (CurStt->find_ResLink)	stt += ";Find_ResLink=1\n";
		if (CurStt->find_DirLink)	stt += ";Find_DirLink=1\n";

		std::unique_ptr<TStringList> fbuf(new TStringList());
		fbuf->Text = stt;

		//項目
		TStringList *lst = GetCurList(true);
		for (int i=0; i<lst->Count; i++) {
			file_rec *fp = (file_rec*)lst->Objects[i];
			if (fp->is_up || (fp->is_dummy && fp->alias.IsEmpty())) continue;
			UnicodeString lbuf = (fp->is_dir)? IncludeTrailingPathDelimiter(fp->f_name) : fp->f_name;
			lbuf.cat_sprintf(_T("\t%s"), fp->alias.c_str());
			fbuf->Add(lbuf);
		}

		if (saveto_TextUTF8(fnam, fbuf.get())) {
			ResultListPath = ExtractFilePath(fnam);
			ShowHintAndStatus(UnicodeString().sprintf(_T("結果リスト[%s]を保存しました。"), ExtractFileName(fnam).c_str()));
		}
		else SttBarWarnUstr(USTR_FaildSave);
	}
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::SaveAsResultListActionUpdate(TObject *Sender)
{
	TAction *ap = (TAction*)Sender;
	ap->Visible = ScrMode==SCMD_FLIST;
	ap->Enabled = ap->Visible && CurStt->is_Find && !IsDiffList();
}

//---------------------------------------------------------------------------
//タブグループに名前を付けて保存
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::SaveAsTabGroupActionExecute(TObject *Sender)
{
	try {
		UnicodeString fnam;
		if (!ActionParam.IsEmpty()) {
			fnam = to_absolute_name(ActionParam);
		}
		else {
			UserModule->PrepareSaveDlg(_T("タブグループの保存"), F_FILTER_INI);
			if (!UserModule->SaveDlg->Execute()) SkipAbort();
			fnam = UserModule->SaveDlg->FileName;
		}

		if (fnam.IsEmpty()) SkipAbort();
		if (!save_TagGroup(fnam)) UserAbort(USTR_FaildSave);
		TabGroupName = fnam;
	}
	catch (EAbort &e) {
		SetActionAbort(e.Message);
	}
}
//---------------------------------------------------------------------------
//タブグループを上書き保存
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::SaveTabGroupActionExecute(TObject *Sender)
{
	if (TabGroupName.IsEmpty()) {
		SaveAsTabGroupAction->Execute();
	}
	else {
		UnicodeString msg;
		msg.sprintf(_T("タブグループ[%s]"), ExtractFileName(TabGroupName).c_str());
		if (save_TagGroup(TabGroupName))
			ShowHintAndStatus(msg + "を保存しました。");
		else
			SttBarWarn(msg + "の保存に失敗。");
	}
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::TabGroupActionUpdate(TObject *Sender)
{
	TAction *ap = (TAction*)Sender;
	ap->Visible = (ScrMode==SCMD_FLIST && TabPanel->Visible);
	ap->Enabled = ap->Visible;
}

//---------------------------------------------------------------------------
//ワークリストに名前を付けて保存
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::SaveAsWorkListActionExecute(TObject *Sender)
{
	bool is_fl = TEST_ActParam("FL");
	if (is_fl && CurStt->is_Arc) { SetActionAbort(); return; }

	UnicodeString fnam = is_fl? EmptyStr : ExtractFileName(WorkListName);
	UserModule->PrepareSaveDlg(LoadUsrMsg(USTR_SaveAs, _T("ワークリスト")).c_str(), F_FILTER_NWL, fnam.c_str(), WorkListPath);
	if (UserModule->SaveDlg->Execute()) {
		if (save_WorkList(UserModule->SaveDlg->FileName, is_fl? GetCurList() : WorkList)) {
			WorkListName = UserModule->SaveDlg->FileName;
			WorkListPath = ExtractFilePath(WorkListName);
			WorkListTime = get_file_age(WorkListName);
			rqWorkListDirInf = true;
		}
		else {
			SttBarWarn(LoadUsrMsg(USTR_FaildSave, ExtractFileName(UserModule->SaveDlg->FileName)));
		}
	}
}
//---------------------------------------------------------------------------
//ワークリストを上書き保存
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::SaveWorkListActionExecute(TObject *Sender)
{
	if (get_file_age(WorkListName)!=WorkListTime) {
		if (!msgbox_Sure(_T("ワークリストが更新されています\r\n保存せずに変更内容を破棄しますか?"), true, true)) return;
	}

	//無名の場合、名前を付けて保存
	if (WorkListName.IsEmpty()) {
		SaveAsWorkListAction->Execute();
	}
	//上書き保存
	else {
		for (;;) {
			UnicodeString msg;
			if (save_WorkList(WorkListName)) {
				WorkListTime = get_file_age(WorkListName);
				ShowHintAndStatus(
					msg.sprintf(_T("ワークリスト[%s]を保存しました。"), get_base_name(WorkListName).c_str()));
				break;
			}
			//保存に失敗した場合、再試行 or 別名保存
			else {
				msg.sprintf(_T("ワークリスト[%s]の保存に失敗。"), ExtractFileName(WorkListName).c_str());
				if (Application->MessageBox(msg.c_str(), _T("エラー"), MB_RETRYCANCEL|MB_ICONERROR)==IDRETRY) continue;

				if (save_WorkList(WorkListName + ".$$$")) {
					msg.cat_sprintf(_T("\r\n[%s.$$$]の名前で一時保存しました。"), ExtractFileName(WorkListName).c_str());
					msgbox_WARN(msg);
				}
				break;
			}
		}
	}
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::SaveWorkListActionUpdate(TObject *Sender)
{
	((TAction*)Sender)->Visible = ScrMode==SCMD_FLIST || ScrMode==SCMD_IVIEW;
	((TAction*)Sender)->Enabled = WorkListChanged && !WorkListFiltered;
}

//---------------------------------------------------------------------------
//新規ワークリストの作成
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::NewWorkListActionExecute(TObject *Sender)
{
	try {
		SaveWorkListAction->Execute();

		WorkListName = EmptyStr;
		clear_FileList(WorkList);

		switch (ScrMode) {
		case SCMD_FLIST:
			if (OppStt->is_Work) RecoverFileList(OppListTag);
			ChangeWorkList(CurListTag);
			rqWorkListDirInf = !WorkListChanged;
			WorkListChanged  = true;
			break;
		case SCMD_IVIEW:
			SetViewFileList(true, true);
			break;
		}
	}
	catch (EAbort &e) {
		SetActionAbort(e.Message);
	}
}

//---------------------------------------------------------------------------
//ファイルリストのスクロール
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ScrollDownActionExecute(TObject *Sender)
{
	TListBox *lp = FileListBox[CurListTag];
	if (ActionParam.IsEmpty())
		ListBoxScrollDown(lp, ListWheelScrLn);
	else
		ListBoxScrollDown(lp, ActionParam);

	if (FlCursorVisible && ListBoxCsrToVisible(lp)) SetFileInf();
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ScrollUpActionExecute(TObject *Sender)
{
	TListBox *lp = FileListBox[CurListTag];
	if (ActionParam.IsEmpty())
		ListBoxScrollUp(lp, ListWheelScrLn);
	else
		ListBoxScrollUp(lp, ActionParam);

	if (FlCursorVisible && ListBoxCsrToVisible(lp)) SetFileInf();
}

//---------------------------------------------------------------------------
//ログのスクロール
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ScrollDownLogActionExecute(TObject *Sender)
{
	if (ActionParam.IsEmpty())
		ListBoxScrollDown(LogListBox, ListWheelScrLn);
	else
		ListBoxScrollDown(LogListBox, ActionParam);

	if (FlCursorVisible) ListBoxCsrToVisible(LogListBox);
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ScrollUpLogActionExecute(TObject *Sender)
{
	if (ActionParam.IsEmpty())
		ListBoxScrollUp(LogListBox, ListWheelScrLn);
	else
		ListBoxScrollUp(LogListBox, ActionParam);

	if (FlCursorVisible) ListBoxCsrToVisible(LogListBox);
}
//---------------------------------------------------------------------------
//テキストプレビューのスクロール
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ScrollDownTextActionExecute(TObject *Sender)
{
	if (PreviewPanel->Visible) {
		if (ActionParam.IsEmpty())
			ListBoxScrollDown(TxtPrvListBox, ListWheelScrLn);
		else
			ListBoxScrollDown(TxtPrvListBox, ActionParam);

		if (FlCursorVisible) ListBoxCsrToVisible(TxtPrvListBox);
	}
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ScrollUpTextActionExecute(TObject *Sender)
{
	if (PreviewPanel->Visible) {
		if (ActionParam.IsEmpty())
			ListBoxScrollUp(TxtPrvListBox, ListWheelScrLn);
		else
			ListBoxScrollUp(TxtPrvListBox, ActionParam);

		if (FlCursorVisible) ListBoxCsrToVisible(TxtPrvListBox);
	}
}

//---------------------------------------------------------------------------
//すべてのファイルを選択/解除
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::SelAllFileActionExecute(TObject *Sender)
{
	if (ScrMode==SCMD_IVIEW && !ThumbnailGrid->Visible) {
		SetActionAbort();
	}
	else {
		TStringList *lst = GetCurList();
		bool not_sel = (GetSelCount(lst)==0);

		for (int i=0; i<lst->Count; i++) {
			file_rec *fp = (file_rec*)lst->Objects[i];
			set_select(fp, !fp->is_dir? not_sel : false);
		}

		switch (ScrMode) {
		case SCMD_FLIST: RepaintList(CurListTag);	break;
		case SCMD_IVIEW: ThumbnailGrid->Repaint();	break;
		}
	}
}
//---------------------------------------------------------------------------
//すべての項目を選択/解除
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::SelAllItemActionExecute(TObject *Sender)
{
	TStringList *lst = GetCurList();
	bool not_sel = (GetSelCount(lst)==0);
	for (int i=0; i<lst->Count; i++) set_select((file_rec*)lst->Objects[i], not_sel);
	RepaintList(CurListTag);
}

//---------------------------------------------------------------------------
//リストによって項目を選択
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::SelByListActionExecute(TObject *Sender)
{
	try {
		bool is_lr = TEST_DEL_ActParam("LR");
		bool is_sm = TEST_DEL_ActParam("SM");
		bool is_cp = TEST_DEL_ActParam("CP");
		bool is_op = TEST_DEL_ActParam("OP");

		UnicodeString lnam = (is_cp || is_op)? GetCurFileName()
											 : to_absolute_name(cv_env_str(exclude_quot(ActionParam)), CurPath[CurListTag]);
		if (lnam.IsEmpty()) UserAbort(USTR_NoParameter);
		if (!file_exists(lnam)) throw EAbort(LoadUsrMsg(USTR_NotFound, _T("ファイル")));

		std::unique_ptr<TStringList> f_lst(new TStringList());
		load_text_ex(lnam, f_lst.get());

		CurWorking = true;
		for (int i=0; i<MAX_FILELIST; i++) {
			int s_tag = is_lr? ((i==0)? CurListTag : OppListTag) :
					    is_op? ((i==0)? OppListTag : -1) : ((i==0)? CurListTag : -1);
			if (s_tag==-1) continue;

			TStringList *lst  = GetFileList(s_tag);
			ClrSelect(lst);

			TStringList *sm_lst = SelMaskList[s_tag];
			if (is_sm) sm_lst->Clear();

			UnicodeString top_fnam;
			for (int j=0; j<f_lst->Count; j++) {
				UnicodeString lbuf = f_lst->Strings[j];
				if (lbuf.IsEmpty() || StartsStr(';', lbuf)) continue;
				UnicodeString fnam = ExcludeTrailingPathDelimiter(split_pre_tab(lbuf));
				//パス付き
				if (!ExtractFilePath(fnam).IsEmpty()) {
					int idx = lst->IndexOf(fnam);
					if (idx!=-1) {
						file_rec *fp = (file_rec*)lst->Objects[idx];
						if (is_sm) sm_lst->Add(fp->f_name); else fp->selected = true;
						if (top_fnam.IsEmpty()) top_fnam = fp->f_name;
					}
				}
				//パス無し
				else {
					bool is_ptn = fnam.Pos('*') || fnam.Pos('?');
					for (int k=0; k<lst->Count; k++) {
						file_rec *fp = (file_rec*)lst->Objects[k];
						if ((is_ptn && str_match(fnam, fp->n_name)) || SameText(fnam, fp->n_name)) {
							if (is_sm) sm_lst->Add(fp->f_name); else fp->selected = true;
							if (top_fnam.IsEmpty()) top_fnam = fp->f_name;
						}
					}
				}
			}

			if (is_sm) {
				ApplySelMask(lst, s_tag);
				AssignFileList(lst, s_tag, top_fnam);
			}
			else {
				RepaintList(s_tag);
				IndexOfFileList(top_fnam, s_tag);
			}
		}
		CurWorking = false;
	}
	catch (EAbort &e) {
		SetActionAbort(e.Message);
	}
}
//---------------------------------------------------------------------------
//選択/解除
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::SelectActionExecute(TObject *Sender)
{
	switch (ScrMode) {
	case SCMD_FLIST:
		{
			TListBox *lp = FileListBox[CurListTag];
			int idx0 = lp->ItemIndex;
			int n = 1;
			//繰り返し回数入力
			if (TEST_ActParam("IN"))
				n = inputbox_ex_n(_T("Select"), _T("繰り返し回数"));
			//繰り返し回数指定
			else if (!ActionParam.IsEmpty() && !TEST_ActParam("ND"))
				n = ActionParam.ToIntDef(1);
			//繰り返しあり
			if (n>1) {
				ListBoxCursorDown(lp, n);
				int idx1 = lp->ItemIndex;
				TStringList *lst = GetCurList();
				for (int i=idx0,cnt=0; i<=idx1 && cnt<n; i++,cnt++) set_select_r((file_rec*)lst->Objects[i]);
				InvalidateFileList();
			}
			//繰り返しなし
			else if (n==1) {
				set_select_r(GetFrecPtr(FileListBox[CurListTag], GetCurList(true)));
				if (!TEST_ActParam("ND")) CursorDownAction->Execute();
				if (lp->ItemIndex==idx0) InvalidateFileList();
			}
			else SetActionAbort(_T("SKIP"));
			//情報表示を更新
			SetDriveInfo();
			SetSttBarInf();
		}
		break;

	case SCMD_IVIEW:
		if (!isViewClip) {
			int idx = GetCurIndex();
			if (idx!=-1) {
				file_rec *vfp = (file_rec*)ViewFileList->Objects[idx];
				vfp->selected = !vfp->selected;
				if (!TEST_ActParam("ND")) NextFileAction->Execute();
				if (ThumbnailGrid->Visible) ThumbnailGrid->Repaint();
			}
			else SetActionAbort();
		}
		break;
	}
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::SelectUpActionExecute(TObject *Sender)
{
	if (ScrMode!=SCMD_FLIST) return;

	set_select_r(GetFrecPtr(FileListBox[CurListTag], GetCurList(true)));
	CursorUpAction->Execute();
	RepaintList(CurListTag);
}

//---------------------------------------------------------------------------
//空のディレクトリを選択
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::SelEmptyDirActionExecute(TObject *Sender)
{
	if (CurStt->is_Arc || CurStt->is_ADS || CurStt->is_FTP) { SetActionAbort(USTR_OpeNotSuported); return; }

	bool no_file = TEST_ActParam("NF");
	TStringList *lst = GetCurList(true);
	for (int i=0; i<lst->Count; i++) {
		file_rec *fp = (file_rec*)lst->Objects[i];
		fp->selected = fp->is_dir? is_EmptyDir(fp->f_name, no_file) : false;
	}
	RepaintList(CurListTag);
	if (GetSelCount(lst)==0) SttBarWarnUstr(USTR_NotFound);
}

//---------------------------------------------------------------------------
//リポジトリ内の変更ファイルを選択
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::SelGitChangedActionExecute(TObject *Sender)
{
	try {
		if (!IsCurFList()) UserAbort(USTR_CantOperate);
		if (get_GitTopPath(CurPath[CurListTag]).IsEmpty()) UserAbort(USTR_NotRepository);

		std::unique_ptr<TStringList> glst(new TStringList());
		SetDirWatch(false);
		int cnt = get_GitChangedList(CurPath[CurListTag], glst.get());
		SetDirWatch(true);
		if (cnt==-1) UserAbort(USTR_FaildProc);
		if (cnt==0)  Abort();

		TStringList *lst = GetCurList(true);
		int top_idx = -1;
		for (int i=0; i<lst->Count; i++) {
			file_rec *fp = (file_rec*)lst->Objects[i];
			fp->selected = (glst->IndexOf(fp->f_name)!=-1);
			if (fp->selected && top_idx==-1) top_idx = i;
		}
		FileListBox[CurListTag]->ItemIndex = top_idx;
		RepaintList(CurListTag);
	}
	catch (EAbort &e) {
		SetActionAbort(e.Message);
	}
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::SelGitChangedActionUpdate(TObject *Sender)
{
	TAction *ap = (TAction*)Sender;
	ap->Visible = ScrMode==SCMD_FLIST && GitExists;
	ap->Enabled = ap->Visible;
}

//---------------------------------------------------------------------------
//マーク項目を選択
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::SelMarkActionExecute(TObject *Sender)
{
	TStringList *lst = GetCurList();
	int top_idx = -1;
	for (int i=0; i<lst->Count; i++) {
		file_rec *fp = (file_rec*)lst->Objects[i];
		fp->selected = IniFile->IsMarked(fp->r_name);
		if (fp->selected && top_idx==-1) top_idx = i;
	}

	if (top_idx!=-1) {
		switch (ScrMode) {
		case SCMD_FLIST:
			FileListBox[CurListTag]->ItemIndex = top_idx;
			RepaintList(CurListTag);
			if (EqualDirLR()) InvalidateFileList(OppListTag);
			break;
		case SCMD_IVIEW:
			set_GridIndex(ThumbnailGrid, top_idx, lst->Count);
			break;
		}
	}
}

//---------------------------------------------------------------------------
//選択マスク
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::SelMaskActionExecute(TObject *Sender)
{
	try {
		if (CurStt->is_ADS) UserAbort(USTR_CantOperate);

		UnicodeString fnam	= GetCurFileName();
		TStringList *lst	= GetCurList(true);
		TStringList *sm_lst = SelMaskList[CurListTag];
		sm_lst->Clear();

		if (!TEST_ActParam("CA") && GetSelCount(lst)>0) {
			for (int i=0; i<lst->Count; i++) {
				file_rec *fp = (file_rec*)lst->Objects[i];
				if (fp->selected) {
					if (!fp->is_dummy) sm_lst->Add(fp->f_name);
					fp->selected = false;
				}
			}
		}

		if (CurStt->is_Work) {
			if (sm_lst->Count==0) {
				if (!SetWorkList()) UserAbort(USTR_WlistCantOpen);
			}
			else {
				WorkListFiltered = true;
				ChangeWorkList(CurListTag);
			}
		}
		else if (CurStt->is_Arc) {
			ChangeArcFileListEx(CurStt->arc_Name, CurStt->arc_SubPath, CurListTag, fnam);
		}
		else if (CurStt->is_Find) {
			if (IsDiffList()) {
				if (TEST_ActParam("CA")) {
					ResetIncSeaFilter(CurListTag, true);
					ResetIncSeaFilter(OppListTag, true);
				}
				else {
					ApplySelMask(lst, CurListTag);
					AssignFileList(lst, CurListTag);
					CurToOppDiffList();
				}
			}
			else {
				CurStt->find_DICON? FindFolderIconCore(CurListTag) :
				CurStt->find_HLINK? FindHardLinkCore(CurStt->find_Name, CurListTag) :
				CurStt->find_MARK ? FindMarkCore(CurListTag) :
				CurStt->find_TAG  ? FindTagCore(CurListTag)
								  : FindFileCore(CurStt->find_Dir, CurListTag);
			}
		}
		else if (CurStt->is_FTP)
			ChangeFtpFileList(CurListTag);
		else
			UpdateCurPath(EmptyStr, fnam);

		//反対側にも適用 (OP : CompareDlg のための隠しパラメータ)
		if (TEST_ActParam("OP") && (IsOppFList() || OppStt->is_Arc)) {
			sm_lst = SelMaskList[OppListTag];
			sm_lst->Clear();

			lst = GetOppList();
			if (GetSelCount(lst)>0) {
				for (int i=0; i<lst->Count; i++) {
					file_rec *fp = (file_rec*)lst->Objects[i];
					if (fp->selected) {
						sm_lst->Add(fp->f_name);
						fp->selected = false;
					}
				}

				if (OppStt->is_Arc)
					ChangeArcFileListEx(OppStt->arc_Name, OppStt->arc_SubPath, OppListTag);
				else
					CurPath[OppListTag] = exclede_delimiter_if_root(CurPath[OppListTag]);
			}
		}
	}
	catch (EAbort &e) {
		SetActionAbort(e.Message);
	}
}

//---------------------------------------------------------------------------
//カレント側だけにあるファイルを選択
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::SelOnlyCurActionExecute(TObject *Sender)
{
	TStringList *c_lst = GetCurList(true);
	TStringList *o_lst = GetOppList();

	int top_s_idx = -1;
	for (int c_i=0; c_i<c_lst->Count; c_i++) {
		file_rec *cfp = (file_rec*)c_lst->Objects[c_i];
		cfp->selected = false;
		if (cfp->is_dir) continue;
		cfp->selected = true;
		for (int o_i=0; o_i<o_lst->Count; o_i++) {
			file_rec *ofp = (file_rec*)o_lst->Objects[o_i];
			if (ofp->is_dir) continue;
			if (SameText(ofp->n_name, cfp->n_name)) {
				cfp->selected = false;  break;
			}
		}
		if (cfp->selected && top_s_idx==-1) top_s_idx = c_i;
	}

	RepaintList(CurListTag);
	if (top_s_idx!=-1) FileListBox[CurListTag]->ItemIndex = top_s_idx;
}

//---------------------------------------------------------------------------
//選択状態を反転
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::SelReverseActionExecute(TObject *Sender)
{
	if (ScrMode==SCMD_IVIEW && !ThumbnailGrid->Visible) {
		SetActionAbort(); return;
	}

	TStringList *lst = GetCurList();
	int sel_d_cnt = 0, sel_f_cnt = 0;
	for (int i=0; i<lst->Count; i++) {
		file_rec *fp = (file_rec*)lst->Objects[i];
		if (fp->selected) (fp->is_dir? sel_d_cnt : sel_f_cnt)++;
	}

	//ディレクトリのみ選択の場合、ディレクトリの選択状態を反転
	if (sel_d_cnt>0 && sel_f_cnt==0) {
		for (int i=0; i<lst->Count; i++) {
			file_rec *fp = (file_rec*)lst->Objects[i];
			if (is_selectable(fp) && fp->is_dir) fp->selected = !fp->selected;
		}
	}
	//ファイルの選択状態を反転
	else {
		for (int i=0; i<lst->Count; i++) {
			file_rec *fp = (file_rec*)lst->Objects[i];
			if (is_selectable(fp)) fp->selected = !fp->is_dir? !fp->selected : false;
		}
	}

	switch (ScrMode) {
	case SCMD_FLIST: RepaintList(CurListTag); 	break;
	case SCMD_IVIEW: ThumbnailGrid->Repaint();	break;
	}
}
//---------------------------------------------------------------------------
//すべての項目の選択状態を反転
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::SelReverseAllActionExecute(TObject *Sender)
{
	TStringList *lst = GetCurList();
	for (int i=0; i<lst->Count; i++) set_select_r((file_rec*)lst->Objects[i]);
	RepaintList(CurListTag);
}

//---------------------------------------------------------------------------
//拡張子が同じファイルを選択
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::SelSameExtActionExecute(TObject *Sender)
{
	try {
		if (ScrMode==SCMD_IVIEW && !ThumbnailGrid->Visible) Abort();
		file_rec *cfp = GetCurFrecPtr();
		if (!cfp || cfp->is_dir) Abort();

		int s_cnt = 0;
		int s_idx = -1;
		TStringList *lst = GetCurList();
		for (int i=0; i<lst->Count; i++) {
			file_rec *fp = (file_rec*)lst->Objects[i];
			if (!is_selectable(fp) || fp->is_dir) continue;
			fp->selected = SameText(fp->f_ext, cfp->f_ext);
			if (fp->selected) {
				s_cnt++;
				if (s_idx==-1) s_idx = i;
			}
		}
		if (ScrMode==SCMD_IVIEW) ThumbnailGrid->Repaint();

		switch (ScrMode) {
		case SCMD_FLIST:
			if (s_idx!=-1) FileListBox[CurListTag]->ItemIndex = s_idx;
			RepaintList(CurListTag);
			break;
		case SCMD_IVIEW:
			if (s_idx!=-1) set_GridIndex(ThumbnailGrid, s_idx, lst->Count);
			break;
		}

		if (s_cnt==1) Abort();
	}
	catch (EAbort &e) {
		SetActionAbort(e.Message);
	}
}
//---------------------------------------------------------------------------
//ファイル名主部が同じファイルを選択
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::SelSameNameActionExecute(TObject *Sender)
{
	try {
		if (ScrMode==SCMD_IVIEW && !ThumbnailGrid->Visible) Abort();
		file_rec *cfp = GetCurFrecPtr();
		if (!cfp || cfp->is_dir) Abort();
		int s_cnt = SelectMask(GetCurList(), UnicodeString().sprintf(_T("%s.*;%s"), cfp->b_name.c_str(), cfp->b_name.c_str()));
		if (ScrMode==SCMD_IVIEW) ThumbnailGrid->Repaint();
		if (s_cnt==1) Abort();
	}
	catch (EAbort &e) {
		SetActionAbort(e.Message);
	}
}

//---------------------------------------------------------------------------
//ワークリストの登録項目を選択
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::SelWorkItemActionExecute(TObject *Sender)
{
	if (ScrMode==SCMD_IVIEW && !ThumbnailGrid->Visible) { SetActionAbort(); return; }

	int s_idx = -1;
	TStringList *lst = GetCurList();
	for (int i=0; i<lst->Count; i++) {
		file_rec *fp = (file_rec*)lst->Objects[i];
		if (!is_selectable(fp)) continue;
		fp->selected = (WorkList->IndexOf(fp->f_name)!=-1);
		if (fp->selected && s_idx==-1) s_idx = i;
	}
	if (ScrMode==SCMD_IVIEW) ThumbnailGrid->Repaint();

	if (s_idx!=-1) {
		switch (ScrMode) {
		case SCMD_FLIST:
			FileListBox[CurListTag]->ItemIndex = s_idx;
			RepaintList(CurListTag);
			break;
		case SCMD_IVIEW:
			set_GridIndex(ThumbnailGrid, s_idx, lst->Count);
			break;
		}
	}
	else SetActionAbort();
}

//---------------------------------------------------------------------------
//ワークリストの項目にエイリアスを設定
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::SetAliasActionExecute(TObject *Sender)
{
	if (CurStt->is_Work && WorkListFiltered) { SetActionAbort(USTR_WorkFiltered); return; }

	file_rec *cfp = GetCurFrecPtr();
	if (cfp && !cfp->is_dummy) {
		UnicodeString anam = def_if_empty(cfp->alias, cfp->b_name);
		if (input_query_ex((cfp->n_name + " のエイリアスを設定").c_str(), _T("名前"), &anam)) cfp->alias = anam;
		RepaintList(CurListTag);
		rqWorkListDirInf = !WorkListChanged;
		WorkListChanged  = true;
	}
	else SetActionAbort();
}
//---------------------------------------------------------------------------
//アーカイブのタイムスタンプを設定
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::SetArcTimeActionExecute(TObject *Sender)
{
	file_rec *cfp = cre_new_file_rec(GetCurFrecPtr(true));

	try {
		if (CurStt->is_Arc || CurStt->is_ADS || CurStt->is_FTP) UserAbort(USTR_CantOperate);

		StartLog("設定開始  " + GetSrcPathStr());
		CurWorking = true;
		ShowMessageHint(USTR_WaitForReady, col_bgHint, false, true);
		TStringList *lst = GetCurList(true);
		//選択あり
		UnicodeString msg;
		int ok_cnt = 0, er_cnt = 0;
		if (GetSelCount(lst)>0) {
			for (int i=0; i<lst->Count; i++) {
				file_rec *fp = (file_rec*)lst->Objects[i];  if (!fp->selected) continue;
				msg = make_LogHdr(_T("TIME"), fp);
				if (usr_ARC->SetArcTime(fp->f_name, ForceDel)) {
					ok_cnt++;
				}
				else {
					set_LogErrMsg(msg, usr_ARC->ErrMsg);
					er_cnt++;
				}
				AddLog(msg);
				fp->selected = false;
				Application->ProcessMessages();
			}
		}
		//カーソル位置
		else {
			if (cfp->f_name.IsEmpty() || cfp->is_dummy)  Abort();
			if (!test_ArcExt(cfp->f_ext)) UserAbort(USTR_FmtNotSuported);
			msg = make_LogHdr(_T("TIME"), cfp);
			if (usr_ARC->SetArcTime(cfp->f_name, ForceDel)) {
				ok_cnt++;
			}
			else {
				set_LogErrMsg(msg, usr_ARC->ErrMsg);
				er_cnt++;
			}
			AddLog(msg);
		}
		CurWorking = false;
		EndLog(_T("設定"), get_res_cnt_str(ok_cnt, er_cnt));
		ReloadList(CurListTag);
	}
	catch (EAbort &e) {
		SetActionAbort(e.Message);
	}

	MsgHint->ReleaseHandle();

	del_file_rec(cfp);
}

//---------------------------------------------------------------------------
//ディレクトリのタイムスタンプを設定
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::SetDirTimeActionExecute(TObject *Sender)
{
	file_rec *cfp = cre_new_file_rec(GetCurFrecPtr(true));

	try {
		if (CurStt->is_Arc || CurStt->is_ADS || CurStt->is_FTP) UserAbort(USTR_CantOperate);

		std::unique_ptr<TStringList> tsk_lst(new TStringList());
		UnicodeString cmd = "DTIME";
		if (!ActionParam.IsEmpty()) {
			UnicodeString dnam = to_absolute_name(ActionParam, CurPath[CurListTag]);
			if (!dir_exists(dnam)) SysErrAbort(ERROR_PATH_NOT_FOUND);
			tsk_lst->Add(cmd + "\t" + ExcludeTrailingPathDelimiter(dnam));
		}
		else {
			TStringList *lst = GetCurList(true);
			//選択あり
			if (GetSelCount(lst)>0) {
				for (int i=0; i<lst->Count; i++) {
					file_rec *fp = (file_rec*)lst->Objects[i]; 
					if (!fp->is_dir || !fp->selected) continue;
					tsk_lst->Add(cmd + "\t" + fp->f_name);
					fp->selected = false;
				}
				RepaintList(CurListTag);
			}
			//カーソル位置
			else {
				if (cfp->f_name.IsEmpty() || cfp->is_dummy || !cfp->is_dir)  Abort();
				tsk_lst->Add(cmd + "\t" + cfp->f_name);
			}
		}

		//タスク開始
		if (tsk_lst->Count>0) {
			TaskConfig  *cp = NULL;
			TTaskThread *tp = CreTaskThread(&cp);	if (cp==NULL) Abort();
			cp->TaskList->Assign(tsk_lst.get());
			cp->CmdStr	 = TaskCmdList->Values[cmd];
			cp->DistPath = GetCurPathStr();
			cp->InfStr	 = cp->DistPath;
			ActivateTask(tp, cp);
		}
	}
	catch (EAbort &e) {
		SetActionAbort(e.Message);
	}

	del_file_rec(cfp);
}

//---------------------------------------------------------------------------
//ファイルのタイムスタンプを Exif 撮影日時に
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::SetExifTimeActionExecute(TObject *Sender)
{
	try {
		if (CurStt->is_Arc || CurStt->is_ADS || CurStt->is_FTP) UserAbort(USTR_CantOperate);

		TStringList *lst = GetCurList(true);
		bool lst_sel = ListSelected(lst);
		if (!lst_sel && !GetCurFrecPtr()) Abort();

		UnicodeString msg;
		StartLog(msg.sprintf(_T("Exif撮影日時に設定  %s"), GetSrcPathStr().c_str()));
		BeginWorkProgress(_T("タイムスタンプをExif撮影日時に設定"), EmptyStr, FileListBox[CurListTag]);

		CurWorking = true;
		int ok_cnt = 0;
		int cur_idx = FileListBox[CurListTag]->ItemIndex;
		for (int i=0; i<lst->Count; i++) {
			PosWorkProgress(i, lst->Count);
			file_rec *fp = (file_rec*)lst->Objects[i];
			if (fp->selected || (!lst_sel && i==cur_idx)) {
				if (fp->is_dir || !test_ExifExt(fp->f_ext)) continue;
				msg = make_LogHdr(_T("TIME"), fp);
				if (EXIF_SetExifTime(fp->f_name)) {
					fp->selected = false;
					InvalidateFileList();
					ok_cnt++;
				}
				else {
					msg[1] = 'E';
				}
				AddLog(msg);
			}
		}

		CurWorking = false;
		ReloadList(CurListTag);
		if (EqualDirLR()) ReloadList(OppListTag); else RepaintList(CurListTag);
		AddLog(get_res_cnt_str(ok_cnt));
		EndWorkProgress();
	}
	catch (EAbort &e) {
		SetActionAbort(e.Message);
	}
}

//---------------------------------------------------------------------------
//フォルダーアイコンの設定
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::SetFolderIconActionExecute(TObject *Sender)
{
	try {
		if (TEST_ActParam("ND")) {
			std::unique_ptr<TStringList> lst(new TStringList());
			get_FolderIconList(lst.get());
			std::unique_ptr<TStringList> m_buf(new TStringList());
			UnicodeString tmp;
			for (int i=0; i<lst->Count; i++) {
				if (i<10) {
					m_buf->Add(tmp.sprintf(_T("&%u: %s\t\t%s"),
							(i + 1)%10, get_base_name(lst->Strings[i]).c_str(), lst->Strings[i].c_str()));
				}
				else {
					m_buf->Add(tmp.sprintf(_T("%s\t\t%s"),
							get_base_name(lst->Strings[i]).c_str(), lst->Strings[i].c_str()));
				}
			}
			m_buf->Add("-");
			m_buf->Add("(&S) アイコンファイルを選択");
			m_buf->Add(tmp.sprintf(_T("(&R) デフォルトアイコンに戻す\t\t%s"), DefFldIcoName.c_str()));
			m_buf->Add("-");
			m_buf->Add("(&D) デフォルトアイコンを選択");
			m_buf->Add("(&Z) デフォルトアイコンを標準に戻す");
			ExePopMenuList(m_buf.get(), true);
			Application->ProcessMessages();
			int idx = PopMenuIndex;	if (idx==-1) SkipAbort();
			if		(idx<lst->Count) 			ActionParam = lst->Strings[idx];
			else if (idx==(m_buf->Count - 1))	ActionParam = "RD";
			else if (idx==(m_buf->Count - 2))	ActionParam = "SD";
			else if (idx==(m_buf->Count - 4))	ActionParam = "RS";
			else if (idx==(m_buf->Count - 5))	ActionParam = EmptyStr;
			else SkipAbort();
		}

		if (TEST_ActParam("RD")) {
			DefFldIcoName = EmptyStr;
		}
		else if (TEST_ActParam("SD")) {
			UserModule->PrepareOpenDlg(_T("デフォルトのフォルダアイコンを選択"), F_FILTER_ICO, NULL, IconFilePath);
			if (!UserModule->OpenDlg->Execute()) SkipAbort();
			UnicodeString inam = UserModule->OpenDlg->FileName;
			IconFilePath = ExtractFilePath(inam);
			inam = to_relative_name(inam);
			DefFldIcoName = inam;
		}
		else {
			if (CurStt->is_Arc || CurStt->is_ADS || CurStt->is_FTP) UserAbort(USTR_CantOperate);
			if (!TestCurIncDir()) UserAbort(USTR_NoObject);

			TStringList *lst = GetCurList(true);
			int sel_cnt = GetSelCount(lst);
			int cur_idx = FileListBox[CurListTag]->ItemIndex;
			//デフォルトに戻す
			if (TEST_ActParam("RS")) {
				for (int i=0; i<lst->Count; i++) {
					file_rec *fp = (file_rec*)lst->Objects[i];
					if (fp->is_up || !fp->is_dir) continue;
					if (fp->selected || (sel_cnt==0 && i==cur_idx)) {
						set_FolderIcon(fp->f_name);
						fp->selected = false;
					}
				}
			}
			//アイコンを設定
			else {
				UnicodeString inam;
				if (!ActionParam.IsEmpty()) {
					inam = to_absolute_name(get_actual_name(ActionParam));
					if (!file_exists(inam)) throw EAbort(LoadUsrMsg(USTR_NotFound, _T("アイコンファイル")));
				}
				else {
					UserModule->PrepareOpenDlg(_T("フォルダアイコンの指定"), F_FILTER_ICO, NULL, IconFilePath);
					if (!UserModule->OpenDlg->Execute()) SkipAbort();
					inam = UserModule->OpenDlg->FileName;
					IconFilePath = ExtractFilePath(inam);
				}

				if (inam.IsEmpty()) SkipAbort();

				for (int i=0; i<lst->Count; i++) {
					file_rec *fp = (file_rec*)lst->Objects[i];
					if (fp->is_up || !fp->is_dir) continue;
					if (fp->selected || (sel_cnt==0 && i==cur_idx)) {
						set_FolderIcon(fp->f_name, inam);
						fp->selected = false;
					}
				}
			}

			if (DirSortMode[CurListTag]!=5) ReloadList(CurListTag, GetCurFileName());
		}

		::PostMessage(Handle, WM_NYANFI_FLICON, (WPARAM)0, (LPARAM)0);
	}
	catch (EAbort &e) {
		SetActionAbort(e.Message);
	}
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::SetFolderIconActionUpdate(TObject *Sender)
{
	TAction *ap = (TAction*)Sender;
	ap->Visible = ScrMode==SCMD_FLIST;
	ap->Enabled = ap->Visible && IsPrimary;
}

//---------------------------------------------------------------------------
//フォントサイズを変更
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::SetFontSizeActionExecute(TObject *Sender)
{
	bool x_sw = remove_top_s(ActionParam, '^');
	if (!ActionParam.IsEmpty())
		SetFileListFontSize(ActionParam.ToIntDef(ListFont->Size), false, x_sw);
}

//---------------------------------------------------------------------------
//パスマスクを設定
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::SetPathMaskActionExecute(TObject *Sender)
{
	UnicodeString mask = ActionParam;
	UnicodeString fnam = GetCurFileName();
	if (USAME_TI(mask, "EX")) mask = "*" + get_extension(fnam);
	UnicodeString desc = ActionDesc;
	if (desc.IsEmpty()) desc = mask;

	TListBox *lp = FileListBox[CurListTag];
	set_RedrawOff(lp);
	{
		PathMask[CurListTag] = make_PathMask(mask, desc);
		RefreshCurPath(fnam);
	}
	set_RedrawOn(lp);
}

//---------------------------------------------------------------------------
//ステータスバーの書式を設定
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::SetSttBarFmtActionExecute(TObject *Sender)
{
	SttBarFmt = ActionParam;
	SetSttBarInf();
}

//---------------------------------------------------------------------------
//サブウィンドウのサイズを設定
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::SetSubSizeActionExecute(TObject *Sender)
{
	int size = ActionParam.ToIntDef(0);	if (size==0) return;
	bool rel = (StartsStr('+', ActionParam) || StartsStr('-', ActionParam));
	//サブパネルが下
	if (LayoutMode==0) {
		int hi = SubPanel->Height;
		if (rel) hi += size; else hi = size;
		if ((MainPanel->ClientHeight - hi)<ListPanel->Constraints->MinHeight) return;
		SubPanel->Height = hi;
	}
	//サブパネルがサイド
	else {
		int wd = SubPanel->Width;
		if (rel) wd += size; else wd = size;
		if ((MainPanel->ClientWidth - wd)<ListPanel->Constraints->MinWidth) return;
		SubPanel->Width = wd;
	}
}

//---------------------------------------------------------------------------
//リスト項目にタグを設定/追加
//！失敗した場合 Abort 例外
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::SetTags(
	UnicodeString tags,		//タグ
	bool sw_add)			//true = 追加	(default = false)
{
	TStringList *lst = GetCurList();
	bool lst_sel = ListSelected(lst);

	CurWorking = true;
	tags = usr_TAG->NormTags(tags);
	std::unique_ptr<TStringList> flst(new TStringList());
	int cur_idx = (ScrMode==SCMD_IVIEW)? ViewFileList->IndexOf(ViewFileName) : FileListBox[CurListTag]->ItemIndex;
	for (int i=0; i<lst->Count; i++) {
		file_rec *fp = (file_rec*)lst->Objects[i]; 
		if (fp->selected || (!lst_sel && i==cur_idx)) {
			if (fp->is_up || fp->is_dummy || fp->f_attr==faInvalid) continue;

			if 		(sw_add)		 usr_TAG->AddTags(fp->f_name, tags);
			else if (tags.IsEmpty()) usr_TAG->DelItem(fp->f_name);
			else 					 usr_TAG->SetTags(fp->f_name, tags);

			fp->tags = usr_TAG->GetTags(fp->f_name);
			fp->inf_list->Clear();
			fp->selected = false;
		}
	}
	CurWorking = false;

	if (ScrMode==SCMD_IVIEW) {
		if (ImgSidePanel->Visible) {
			int idx = ViewFileList->IndexOf(ViewFileName);
			if (idx!=-1) SetImgInfListBox((file_rec*)ViewFileList->Objects[idx]);
		}
		if (ThumbnailGrid->Visible) ThumbnailGrid->Repaint();
	}
	else {
		if (!sw_add && CurStt->is_Find && CurStt->find_TAG) {
			ReloadList(CurListTag);
		}
		else {
			RepaintList(CurListTag);
			SetFileInf();
		}

		if (OppStt->is_Find && OppStt->find_TAG) ReloadList(OppListTag);
	}

	if (!usr_TAG->UpdateFile()) UserAbort(USTR_FaildSave);
}
//---------------------------------------------------------------------------
//タグの設定
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::SetTagActionExecute(TObject *Sender)
{
	try {
		if (CurStt->is_Arc || CurStt->is_ADS || CurStt->is_FTP) UserAbort(USTR_CantOperate);

		TStringList *lst = GetCurList();
		bool lst_sel = ListSelected(lst);
		if (!lst_sel && !GetCurFrecPtr()) Abort();

		usr_TAG->Recycle();

		//共通のタグを取得
		int cur_idx = (ScrMode==SCMD_IVIEW)? ViewFileList->IndexOf(ViewFileName) : FileListBox[CurListTag]->ItemIndex;
		UnicodeString def_tag;
		for (int i=0; i<lst->Count; i++) {
			file_rec *fp = (file_rec*)lst->Objects[i]; 
			if (fp->selected || (!lst_sel && i==cur_idx)) {
				if (fp->is_up || fp->is_dummy || fp->f_attr==faInvalid) continue;
				if (fp->tags.IsEmpty()) fp->tags = usr_TAG->GetTags(fp->f_name);
				if (def_tag.IsEmpty()) {
					def_tag = fp->tags;
				}
				else if (!SameText(def_tag, fp->tags)) {
					def_tag = EmptyStr; break;
				}
			}
		}

		UnicodeString tags;
		if (!ActionParam.IsEmpty()) {
			tags = ActionParam;
			if (USAME_TS(tags, ";")) {
				InputExDlg->IpuntExMode = INPEX_SET_TAG;
				InputExDlg->InputComboBox->Text = def_tag;
				if (InputExDlg->ShowModal()!=mrOk) SkipAbort();;
				tags = InputExDlg->InputComboBox->Text;
			}
		}
		else {
			if (!TagManDlg) TagManDlg = new TTagManDlg(this);	//初回に動的作成
			TagManDlg->CmdStr = "SetTag";
			TagManDlg->TagEdit->Text = def_tag;
			if (TagManDlg->ShowModal()!=mrOk) SkipAbort();
			tags = TagManDlg->TagEdit->Text;
		}

		SetTags(tags);
		SetFileInf();
		SetSttBarInf();
	}
	catch (EAbort &e) {
		SetActionAbort(e.Message);
	}
}

//---------------------------------------------------------------------------
//共有フォルダ一覧
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ShareListActionExecute(TObject *Sender)
{
	try {
		UnicodeString cnam;
		if (StartsStr("\\\\", CurPath[CurListTag])) {
			cnam = get_root_name(CurPath[CurListTag]);
		}
		else {
			UnicodeString dstr = get_drive_str(CurPath[CurListTag]);
			if (get_drive_type(dstr) == DRIVE_REMOTE) {
				DWORD InfoSize = 1000;
				std::unique_ptr<BYTE[]> inf(new BYTE[InfoSize]);
				LPUNIVERSAL_NAME_INFO pInf = (LPUNIVERSAL_NAME_INFO)inf.get();
				if (WNetGetUniversalName(dstr.c_str(), UNIVERSAL_NAME_INFO_LEVEL, pInf, &InfoSize)!=NO_ERROR) 
					UserAbort(USTR_FaildProc);
				cnam = get_root_name(pInf->lpUniversalName);
			}
			else {
				TCHAR szComName[256];
				DWORD dwSize = sizeof(szComName);
				if (!::GetComputerName(szComName, &dwSize)) UserAbort(USTR_FaildProc);
				cnam = szComName;
			}
		}

		if (!NetShareDlg) NetShareDlg = new TNetShareDlg(this);	//初回に動的作成
		NetShareDlg->ComputerName = cnam;
		NetShareDlg->isShare = true;
		NetShareDlg->ShowModal();
	}
	catch (EAbort &e) {
		SetActionAbort(e.Message);
	}
}
//---------------------------------------------------------------------------
//ファイルサイズをバイト単位で表示
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ShowByteSizeActionExecute(TObject *Sender)
{
	SetToggleAction(ShowByteSize);

	for (int i=0; i<MAX_FILELIST; i++) {
		SetFlItemWidth(GetFileList(i), i);
		InvalidateFileList(i);
	}
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ShowByteSizeActionUpdate(TObject *Sender)
{
	((TAction*)Sender)->Checked = ShowByteSize;
}

//---------------------------------------------------------------------------
//ファイル情報を表示
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ShowFileInfoActionExecute(TObject *Sender)
{
	file_rec *cfp = GetCurFrecPtr(false, true);
	if (!cfp || cfp->is_dummy || cfp->f_attr==faInvalid) {
		SetActionAbort();  return;
	}

	//ディレクトリの容量計算
	if (ScrMode==SCMD_FLIST && cfp->is_dir && !cfp->is_up && !cfp->is_ftp) {
		CalcBusy = true;
		ShowMessageHint(USTR_CalculatingESC, col_bgHint, false, true);
		CalcDirSizeCore(cfp);
		InvalidateFileList(CalcTag);
		SetDriveFileInfo(CalcTag);
		CalcBusy = false;
		if (CalcAborted) SttBarWarnUstr(USTR_Canceled);
	}

	if (TEST_ActParam("SD")
		|| (ScrMode==SCMD_FLIST && !(SubPanel->Visible && InfListPanel->Visible))
		|| (ScrMode==SCMD_TVIEW)
		|| (ScrMode==SCMD_IVIEW && !ImgSidePanel->Visible))
	{
		if (cfp->is_ftp && !cfp->is_dir && !file_exists(cfp->tmp_name))
			cfp->tmp_name = DownloadFtpCore(cfp);

		KeepModalScr = true;
		while (FileInfoDlg->ShowModal()==mrRetry && (ScrMode!=SCMD_TVIEW)) {
			bool is_prv = USAME_TI(FileInfoDlg->CmdStr, "PrevFile");
			if (ScrMode==SCMD_IVIEW) {
				if (is_prv) PrevFileAction->Execute(); else NextFileAction->Execute();
			}
			else {
				if (is_prv) CursorUpAction->Execute(); else CursorDownAction->Execute();
			}
		}
		KeepModalScr = false;	ModalScrForm->Visible = false;
		if (ScrMode!=SCMD_TVIEW) SetFileInf();
	}
	else {
		ViewFileInf(cfp, true);
	}
}

//---------------------------------------------------------------------------
//ファンクションキーバーの表示
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ShowFKeyBarActionExecute(TObject *Sender)
{
	FKeyBar->Visible = SetToggleAction(ShowFKeyBar);
	UpdateFKeyBtn();
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ShowFKeyBarActionUpdate(TObject *Sender)
{
	((TAction*)Sender)->Enabled = !IS_FullScr();
	((TAction*)Sender)->Checked = ShowFKeyBar;
}

//---------------------------------------------------------------------------
//隠しファイルを表示
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ShowHideAtrActionExecute(TObject *Sender)
{
	SetToggleAction(ShowHideAtr);
	ReloadList();
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ShowHideAtrActionUpdate(TObject *Sender)
{
	((TAction*)Sender)->Checked = ShowHideAtr;
}

//---------------------------------------------------------------------------
//アイコンの表示
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ShowIconActionExecute(TObject *Sender)
{
	if (TEST_ActParam("FD")) {
		IconMode = (IconMode==0)? 1 : (IconMode==1)? 2 : 1;
	}
	else {
		bool sw = (IconMode>0);
		SetToggleAction(sw);
		IconMode = sw? 1 : 0;
	}

	for (int i=0; i<MAX_FILELIST; i++) {
		SetFlItemWidth(GetFileList(i), i);
		InvalidateFileList(i);
	}
}

//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ShowIconActionUpdate(TObject *Sender)
{
	((TAction*)Sender)->Visible = ScrMode==SCMD_FLIST;
	((TAction*)Sender)->Checked = (IconMode>0);
}

//---------------------------------------------------------------------------
//ログウィンドウの表示
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ShowLogWinActionExecute(TObject *Sender)
{
	LogPanel->Visible = SetToggleAction(ShowLogWin);
	SetSubLayout();
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ShowLogWinActionUpdate(TObject *Sender)
{
	((TAction*)Sender)->Visible = ScrMode==SCMD_FLIST;
	((TAction*)Sender)->Checked = ShowLogWin;
}
//---------------------------------------------------------------------------
//イメージプレビューの表示
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ShowPreviewActionExecute(TObject *Sender)
{
	if (PreviewPanel->Visible && InfListPanel->Visible) {
		if (PreviewPanel->Align==alTop)  PreviewHeight = PreviewPanel->Height;
		if (PreviewPanel->Align==alLeft) PreviewWidth  = PreviewPanel->Width;
	}

	PreviewPanel->Visible = SetToggleAction(ShowImgPreview);
	SetSubLayout();

	if (ShowProperty) ViewFileInf(GetCurFrecPtr(true, true));
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ShowPreviewActionUpdate(TObject *Sender)
{
	((TAction*)Sender)->Visible = ScrMode==SCMD_FLIST;
	((TAction*)Sender)->Checked = ShowImgPreview;
}
//---------------------------------------------------------------------------
//ファイル情報を表示
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ShowPropertyActionExecute(TObject *Sender)
{
	if (PreviewPanel->Visible && InfListPanel->Visible) {
		if (PreviewPanel->Align==alTop)  PreviewHeight = PreviewPanel->Height;
		if (PreviewPanel->Align==alLeft) PreviewWidth  = PreviewPanel->Width;
	}

	InfListPanel->Visible = SetToggleAction(ShowProperty);
	SetSubLayout();

	if (ShowProperty) ViewFileInf(GetCurFrecPtr(true, true));
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ShowPropertyActionUpdate(TObject *Sender)
{
	((TAction*)Sender)->Visible = ScrMode==SCMD_FLIST;
	((TAction*)Sender)->Checked = ShowProperty;
}

//---------------------------------------------------------------------------
//ステータスバーの表示
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ShowStatusBarActionExecute(TObject *Sender)
{
	StatusBar1->Visible = SetToggleAction(ShowSttBar);
	ClockBar->Visible	= !ShowSttBar && (LayoutMode!=0) && !SttClockFmt.IsEmpty();
	ClockBarI->Visible	= !ShowSttBar && !SttClockFmt.IsEmpty();;
	if (StatusBar1->Visible) SetFileInf();
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ShowStatusBarActionUpdate(TObject *Sender)
{
	((TAction*)Sender)->Enabled = !IS_FullScr();
	((TAction*)Sender)->Checked = ShowSttBar;
}

//---------------------------------------------------------------------------
//システムファイルを表示
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ShowSystemAtrActionExecute(TObject *Sender)
{
	SetToggleAction(ShowSystemAtr);
	ReloadList();
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ShowSystemAtrActionUpdate(TObject *Sender)
{
	((TAction*)Sender)->Checked = ShowSystemAtr;
}

//---------------------------------------------------------------------------
//ファイルを開くプログラムの選択
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ShowOpenAsRunActionExecute(TObject *Sender)
{
	file_rec *fp = GetCurFrecPtr();
	if (fp) Execute_ex("rundll32.exe", "shell32.dll,OpenAs_RunDLL " + fp->n_name);
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ShowOpenAsRunActionUpdate(TObject *Sender)
{
	((TAction*)Sender)->Visible = ScrMode==SCMD_FLIST;
	file_rec *fp = GetCurFrecPtr();
	((TAction*)Sender)->Enabled = fp? !fp->is_dir : false;
}

//---------------------------------------------------------------------------
//ツールバーの表示
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ShowToolBarActionExecute(TObject *Sender)
{
	switch (ScrMode) {
	case SCMD_FLIST:
		SetToggleAction(ShowToolBar);
		ToolBarF->Visible = ShowToolBar;
		break;
	case SCMD_TVIEW:
		SetToggleAction(ShowToolBarV);
		ToolBarV->Visible = ShowToolBarV;
		break;
	case SCMD_IVIEW:
		SetToggleAction(ShowToolBarI);
		ToolBarI2->Visible	= ShowToolBarI && ShowImgSidebar && ToolBarISide;
		ToolBarI->Visible	= ShowToolBarI && !ToolBarI2->Visible;
		break;
	}
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ShowToolBarActionUpdate(TObject *Sender)
{
	TAction *ap = (TAction*)Sender;
	switch (ScrMode) {
	case SCMD_FLIST: ap->Visible = true;  ap->Enabled = true;  ap->Checked = ShowToolBar;	break;
	case SCMD_TVIEW: ap->Visible = true;  ap->Enabled = true;  ap->Checked = ShowToolBarV;	break;
	case SCMD_IVIEW: ap->Visible = true;  ap->Enabled = true;  ap->Checked = ShowToolBarI;	break;
	default:	     ap->Visible = false; ap->Enabled = false;
	}
}

//---------------------------------------------------------------------------
//項目名の類似性ソート
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::SimilarSortActionExecute(TObject *Sender)
{
	try {
		if ((CurStt->is_Work && (NotSortWorkList || WorkListHasSep))
			|| (CurStt->is_Find && CurStt->find_DUPL) || IsDiffList())
				UserAbort(USTR_CantOperate);

		bool ig_a = TEST_ActParam("IA");
		bool ig_x = ig_a || TEST_ActParam("IX");
		bool ig_c = ig_a || TEST_ActParam("IC");
		bool ig_n = ig_a || TEST_ActParam("IN");
		bool ig_f = ig_a || TEST_ActParam("IF");

		file_rec *cfp = GetCurFrecPtr();
		if (!cfp || cfp->is_dummy) Abort();
		UnicodeString rnam = ig_x? cfp->b_name : ExtractFileName(cfp->f_name);

		CurWorking = true;
		TStringList *lst = GetCurList(true);
		int idx = FileListBox[CurListTag]->ItemIndex;
		for (int i=0; i<lst->Count; i++) {
			file_rec *fp = (file_rec*)lst->Objects[i];
			if (i==idx) {
				fp->distance = -1;
			}
			else if (fp->is_up || fp->is_dummy) {
				fp->distance = 1000;
			}
			else {
				UnicodeString fnam = ig_x? fp->b_name : ExtractFileName(fp->f_name);
		 		fp->distance = get_NrmLevenshteinDistance(rnam, fnam, ig_c, ig_n, ig_f);
			}
		}

		lst->CustomSort(SortComp_Distance);
		update_FileListBox(lst, CurListTag, (cfp? lst->IndexOfObject((TObject*)cfp) : 0));
		CurWorking = false;
	}
	catch (EAbort &e) {
		SetActionAbort(e.Message);
	}
}

//---------------------------------------------------------------------------
//ソートダイアログ
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::SortDlgActionExecute(TObject *Sender)
{
	if ((CurStt->is_Work && NotSortWorkList)
		|| (CurStt->is_Find && CurStt->find_DUPL)
		|| IsDiffList())
	{
		SetActionAbort();  return;
	}

	bool is_path_sort = CurStt->is_Find && FindPathColumn && CurStt->find_PathSort;
	bool chg_cur = false, chg_opp = false;

	//パラメータにより即変更
	if (!ActionParam.IsEmpty()) {
		//現在のソートモードを逆順に
		if (TEST_ActParam("IV")) {
			if (is_path_sort) {
				FlOdrDscPath[CurListTag] = !FlOdrDscPath[CurListTag];
				chg_cur = true;
			}
			else {
				switch (SortMode[CurListTag]) {
				case 2:  FlOdrOld[CurListTag]	  = !FlOdrOld[CurListTag];		break;
				case 3:  FlOdrSmall[CurListTag]   = !FlOdrSmall[CurListTag];	break;
				case 4:  FlOdrDscAttr[CurListTag] = !FlOdrDscAttr[CurListTag];	break;
				default: FlOdrDscName[CurListTag] = !FlOdrDscName[CurListTag];
				}
				chg_cur = true;
				//反対側
				if (SortBoth) {
					switch (SortMode[OppListTag]) {
					case 2:  FlOdrOld[OppListTag]	  = !FlOdrOld[OppListTag];		break;
					case 3:  FlOdrSmall[OppListTag]   = !FlOdrSmall[OppListTag];	break;
					case 4:  FlOdrDscAttr[OppListTag] = !FlOdrDscAttr[OppListTag];	break;
					default: FlOdrDscName[OppListTag] = !FlOdrDscName[OppListTag];
					}
					if (SortMode[OppListTag]==SortMode[CurListTag]) chg_opp = true;
				}
			}
		}
		//すべてのソートモードを逆順に
		else if (TEST_ActParam("IA")) {
			FlOdrOld[CurListTag]	 = !FlOdrOld[CurListTag];
			FlOdrSmall[CurListTag]	 = !FlOdrSmall[CurListTag];
			FlOdrDscAttr[CurListTag] = !FlOdrDscAttr[CurListTag];
			FlOdrDscName[CurListTag] = !FlOdrDscName[CurListTag];
			if (CurStt->is_Find && FindPathColumn) FlOdrDscPath[CurListTag] = !FlOdrDscPath[CurListTag];
			chg_cur = true;
			//反対側
			if (SortBoth) {
				FlOdrOld[OppListTag]	 = !FlOdrOld[OppListTag];
				FlOdrSmall[OppListTag]	 = !FlOdrSmall[OppListTag];
				FlOdrDscAttr[OppListTag] = !FlOdrDscAttr[OppListTag];
				FlOdrDscName[OppListTag] = !FlOdrDscName[OppListTag];
				FlOdrDscPath[OppListTag] = !FlOdrDscPath[OppListTag];
				if (OppStt->is_Find && FindPathColumn) FlOdrDscPath[OppListTag] = !FlOdrDscPath[OppListTag];
				chg_opp = true;
			}
		}
		//ソートモードを変更
		else {
			if (TEST_ActParam("XNX") || TEST_ActParam("XNI")) {
				int idx = (DirSortMode[CurListTag]==0)? (TEST_ActParam("XNX")? 5 : 6) : 0;
				DirSortMode[CurListTag] = idx;
				chg_cur = true;
				if (SortBoth && DirSortMode[OppListTag]!=idx) {
					DirSortMode[OppListTag] = idx;
					chg_opp = true;
				}
			}
			else if (ActionParam.Length()==2) {
				//ディレクトリのソート方法
				if (StartsText("X", ActionParam)) {
					int idx = UnicodeString("NFDSAXI").Pos(ActionParam[2]);
					if (idx>0) {
						idx--;
						if (DirSortMode[CurListTag]!=idx) {
							DirSortMode[CurListTag] = idx;
							chg_cur = true;
						}
						if (SortBoth && DirSortMode[OppListTag]!=idx) {
							DirSortMode[OppListTag] = idx;
							chg_opp = true;
						}
					}
				}
				//トグル切り替え
				else {
					int idx1 = SortIdStr.Pos(ActionParam[1]);
					int idx2 = SortIdStr.Pos(ActionParam[2]);
					if (idx1>0 && idx2>0) {
						if (is_path_sort) {
							CurStt->find_PathSort = false;
							chg_cur = true;
						}
						else {
							idx1--; idx2--;
							int idx = (SortMode[CurListTag]==idx1)? idx2 : idx1;
							if (SortMode[CurListTag]!=idx) {
								SortMode[CurListTag] = idx;
								chg_cur = true;
							}
							if (SortBoth && SortMode[OppListTag]!=idx) {
								SortMode[OppListTag] = idx;
								chg_opp = true;
							}
						}
					}
				}
			}
			//通常切り替え
			else {
				CurStt->find_PathSort = false;
				if (ActionParam[1]=='L') {
					if (CurStt->is_Find && FindPathColumn) {
						CurStt->find_PathSort = true;
						chg_cur = true;
					}
				}
				else {
					int idx = SortIdStr.Pos(ActionParam[1]);
					if (idx>0) {
						idx--;
						if (SortMode[CurListTag]!=idx) {
							SortMode[CurListTag] = idx;
							chg_cur = true;
						}
						if (SortBoth && SortMode[OppListTag]!=idx) {
							SortMode[OppListTag] = idx;
							chg_opp = true;
						}
					}
				}
			}
		}
	}
	//ダイアログ
	else {
		if (!SortModeDlg) SortModeDlg = new TSortModeDlg(this);	//初回に動的作成
		if (SortModeDlg->ShowModal()==mrOk) {
			chg_cur = true;
			if (SortBoth) chg_opp = true;
		}
	}

	if (chg_cur) {
		UnicodeString fnam = GetCurFileName();
		if (!CurStt->is_Find && SortMode[CurListTag]==5)
			ReloadList(CurListTag, fnam);
		else
			RepaintList(CurListTag, fnam, true);
	}

	if (chg_opp) {
		if (!OppStt->is_Find && SortMode[OppListTag]==5)
			ReloadList(OppListTag);
		else
			RepaintList(OppListTag, EmptyStr, true);
	}

	SetFileInf();
}

//---------------------------------------------------------------------------
//特殊フォルダ一覧
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::SpecialDirListActionExecute(TObject *Sender)
{
	if (!RegDirDlg) RegDirDlg = new TRegDirDlg(this);	//初回に動的作成
	RegDirDlg->ToFilter  = TEST_ActParam("FF");
	RegDirDlg->IsSpecial = true;
	if (RegDirDlg->ShowModal()==mrOk && !RegDirDlg->CmdStr.IsEmpty()) ExeCommandAction(RegDirDlg->CmdStr);
}

//---------------------------------------------------------------------------
//サブディレクトリ一覧
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::SubDirListActionExecute(TObject *Sender)
{
	try {
		bool is_nd = TEST_DEL_ActParam("ND");

		if (ActionParam.IsEmpty()) ActionParam = ".";

		UnicodeString pnam = slash_to_yen(ActionParam);
		if (USAME_TS(pnam, "\\")) {
			pnam = GetCurFileName();
			if (!dir_exists(pnam)) pnam = CurPath[CurListTag];
		}

		pnam = to_path_name(pnam);
		if (is_root_dir(CurPath[CurListTag]) && StartsStr("..", pnam)) SkipAbort();
		pnam = to_absolute_name(pnam, CurPath[CurListTag]);
		if (pnam.IsEmpty()) SkipAbort();

		if (is_computer_name(pnam)) {
			ShareListAction->Execute();
			SkipAbort();
		}

		if (!dir_exists(pnam)) SysErrAbort(ERROR_PATH_NOT_FOUND);

		//ポップアップ表示
		if (is_nd) {
			std::unique_ptr<TStringList> mbuf(new TStringList());
			TSearchRec sr;
			if (FindFirst(cv_ex_filename(pnam + "*"), faAnyFile, sr)==0) {
				do {
					if ((sr.Attr & faDirectory)==0) continue;
					if (!ShowHideAtr   && (sr.Attr & faHidden))  continue;
					if (!ShowSystemAtr && (sr.Attr & faSysFile)) continue;
					if (ContainsStr("..", sr.Name)) continue;
					int idx = mbuf->Count;
					UnicodeString lbuf;
					if		(idx<10) lbuf.sprintf(_T("&%u: "), (idx + 1)%10);
					else if (idx<36) lbuf.sprintf(_T("&%c: "), (char)('A' + (idx - 10)));
					else lbuf = "　 ";
					lbuf.cat_sprintf(_T("%s\tChangeDir_\"%s\""), sr.Name.c_str(), (pnam + sr.Name).c_str());
					mbuf->Add(lbuf);
				} while(FindNext(sr)==0);
				FindClose(sr);
			}
			ExePopMenuList(mbuf.get());
		}
		//ダイアログ表示
		else {
			if (!NetShareDlg) NetShareDlg = new TNetShareDlg(this);	//初回に動的作成
			NetShareDlg->PathName = pnam;
			NetShareDlg->isSelDir = true;
			NetShareDlg->isSelSub = true;
			NetShareDlg->ShowModal();
		}
	}
	catch (EAbort &e) {
		SetActionAbort(e.Message);
	}
}

//---------------------------------------------------------------------------
//予約項目の保留
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::SuspendActionExecute(TObject *Sender)
{
	SetToggleAction(RsvSuspended);
	if (!RsvSuspended) StartReserve();
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::SuspendActionUpdate(TObject *Sender)
{
	TAction *ap = (TAction*)Sender;
	ap->Caption = RsvSuspended? "解除" : "保留";
}

//---------------------------------------------------------------------------
//左右のリストを入れ替える
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::SwapLRActionExecute(TObject *Sender)
{
	TListBox *lp0 = FileListBox[CurListTag];
	TListBox *lp1 = FileListBox[OppListTag];
	int idx = lp0->ItemIndex;

	std::swap(FCurPath[0], FCurPath[1]);

	WatchDirTimer->Enabled = false;
	std::swap(hWatchDir[0], hWatchDir[1]);
	std::swap(WatchPath[0], WatchPath[1]);
	WatchDirTimer->Enabled = true;

	swap_FileList(FileList[0],	  FileList[1]);
	swap_FileList(ArcFileList[0], ArcFileList[1]);
	swap_FileList(AdsFileList[0], AdsFileList[1]);
	swap_FileList(ResultList[0],  ResultList[1]);
	swap_FileList(SelMaskList[0], SelMaskList[1], false);

	std::swap(ListStt[0],  ListStt[1]);
	std::swap(SortMode[0], SortMode[1]);
	std::swap(PathMask[0], PathMask[1]);

	SetFlItemWidth(GetFileList(0), 0);
	SetFlItemWidth(GetFileList(1), 1);

	//ファイルリストはバーチャルなので Count を交換
	int cnt0 = lp0->Count;
	int cnt1 = lp1->Count;
	std::swap(cnt0, cnt1);
	lp0->Count = cnt0;
	lp1->Count = cnt1;

	RepaintList();

	if (TEST_ActParam("TO")) {
		lp1->ItemIndex = idx;	lp1->SetFocus();
	}
	else {
		lp0->ItemIndex = 0;		lp0->SetFocus();
	}

	SetFileInf();
}

//---------------------------------------------------------------------------
//名前の入れ替え
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::SwapNameActionExecute(TObject *Sender)
{
	try {
		CurWorking = true;

		SetDirWatch(false);
		bool is_lr = TEST_ActParam("LR");
		TStringList *lst0 = GetCurList(true);
		TStringList *lst1 = GetOppList();
		UnicodeString itm_name[2], org_name[2], new_name[2], fext[2], tmp_name[2];
		std::unique_ptr<TStringList> r_lst(new TStringList());

		//左右
		if (is_lr) {
			if (!IsCurFList() || !IsOppFList()) UserAbort(USTR_OpeNotSuported);

			std::unique_ptr<TStringList> s_lst0(new TStringList());
			std::unique_ptr<TStringList> s_lst1(new TStringList());
			GetSelList(lst0, s_lst0.get(), true, true);
			GetSelList(lst1, s_lst1.get(), true, true);
			if (s_lst0->Count!=1 || s_lst1->Count!=1) UserAbort(USTR_IllegalParam);

			file_rec *fp0 = (file_rec*)s_lst0->Objects[0];
			file_rec *fp1 = (file_rec*)s_lst1->Objects[0];

			if (SameText(fp0->f_name, fp1->f_name)) UserAbort(USTR_IllegalParam);

			//左右が親子関係の場合、ややこしいことになるので非対応
			if (StartsStr(fp0->f_name, fp1->f_name) || StartsStr(fp1->f_name, fp0->f_name))
				UserAbort(USTR_OpeNotSuported);

			itm_name[0] = org_name[0] = fp0->f_name;	fext[0] = fp0->f_ext;
			itm_name[1] = org_name[1] = fp1->f_name;	fext[1] = fp1->f_ext;
			new_name[0] = ExtractFilePath(org_name[0]) + ChangeFileExt(ExtractFileName(org_name[1]), fext[0]);
			new_name[1] = ExtractFilePath(org_name[1]) + ChangeFileExt(ExtractFileName(org_name[0]), fext[1]);
			if (file_exists(new_name[0]) || file_exists(new_name[1])) TextAbort(_T("名前が重複します。"));
		}
		//カレント内
		else {
			if (CurStt->is_Arc || CurStt->is_ADS || CurStt->is_FTP || IsDiffList()) UserAbort(USTR_OpeNotSuported);
			std::unique_ptr<TStringList> s_lst0(new TStringList());
			GetSelList(lst0, s_lst0.get(), true, true);
			if (s_lst0->Count!=2) UserAbort(USTR_IllegalParam);
			for (int i=0; i<2; i++) {
				file_rec *fp = (file_rec*)s_lst0->Objects[i];
				itm_name[i] = org_name[i] = fp->f_name;
				fext[i] = fp->f_ext;
			}
			new_name[0] = ChangeFileExt(org_name[1], fext[0]);
			new_name[1] = ChangeFileExt(org_name[0], fext[1]);
		}

		StartLog("改名開始  " + GetSrcPathStr());

		//中間改名
		int ok_cnt = 0;
		for (int i=0; i<2; i++) {
			tmp_name[i] = ExtractFilePath(itm_name[i]);
			tmp_name[i].cat_sprintf(_T("$~NF%04u.~TMP"), i);
			if (move_FileT(itm_name[i], tmp_name[i])) {
				itm_name[i] = tmp_name[i];
				ok_cnt++;
			}
		}
		//失敗したら元に戻して中断
		if (ok_cnt<2) {
			for (int i=0; i<2; i++)
				if (FileExists(tmp_name[i])) move_FileT(tmp_name[i], org_name[i]);
			UserAbort(USTR_FaildProc);
		}

		//改名処理
		UnicodeString opp_path = IsOppFList()? CurPath[OppListTag] : EmptyStr;
		for (int i=0; i<2; i++) {
			UnicodeString msg = make_RenameLog(org_name[i], new_name[i]);
			if (move_FileT(itm_name[i], new_name[i])) {
				r_lst->Add(org_name[i] + "\t" + new_name[i]);
				//反対パスに反映されるかをチェック
				if (!is_lr) {
					UnicodeString org_pnam = IncludeTrailingPathDelimiter(org_name[i]);
					if (file_GetAttr(new_name[i]) & faDirectory) {
						if (StartsText(org_pnam, opp_path))
							opp_path = IncludeTrailingPathDelimiter(new_name[i]) + opp_path.Delete(1, org_pnam.Length());
					}
				}
			}
			else set_LogErrMsg(msg, get_LogErrMsg(EmptyStr, false));
			AddLog(msg);
		}

		CurWorking = false;
		ClrSelect();
		ReloadList(CurListTag);
		if (is_lr) {
			ClrSelect(lst1);
			ReloadList(OppListTag);
		}
		SetFileInf();
		SetDirWatch(true);

		//必要なら反対パスへ反映
		if (!is_lr && IsOppFList()) {
			if (!opp_path.IsEmpty() && !SameText(opp_path, CurPath[OppListTag]))
				CurPath[OppListTag] = IncludeTrailingPathDelimiter(opp_path);
			else if (EqualDirLR() || CurStt->is_Find)
				ReloadList(OppListTag);
		}

		//改名ログの作成
		if (!IniFile->ReadBoolGen(_T("RenameDlgNoRenLog")) && !saveto_TextUTF8(ExePath + RENLOG_FILE, r_lst.get()))
			throw EAbort(LoadUsrMsg(USTR_FaildSave, _T("改名ログ")));

		AddLog(_T("改名終了  OK"), true);
		FlushLog();
	}
	catch (EAbort &e) {
		SetDirWatch(true);
		SetActionAbort(e.Message);
	}
}

//---------------------------------------------------------------------------
//左右のディレクトリ変更を同期
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::SyncLRActionExecute(TObject *Sender)
{
	SetToggleAction(SyncLR);
	SetDirRelation();
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::SyncLRActionUpdate(TObject *Sender)
{
	TAction *ap = (TAction*)Sender;
	ap->Visible = ScrMode==SCMD_FLIST;
	ap->Enabled = ap->Visible;
	((TAction*)Sender)->Checked = SyncLR;
}

//---------------------------------------------------------------------------
//タグ選択
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::TagSelectActionExecute(TObject *Sender)
{
	try {
		if (CurStt->is_Arc || CurStt->is_ADS || CurStt->is_FTP) UserAbort(USTR_CantOperate);

		usr_TAG->Recycle();
		UnicodeString tags;
		bool and_sw, sel_msk;
		if (!ActionParam.IsEmpty()) {
			tags = ActionParam;
			if (USAME_TS(tags, ";")) {
				InputExDlg->IpuntExMode = INPEX_TAG_SELECT;
				InputExDlg->InputComboBox->Text = EmptyStr;
				tags = (InputExDlg->ShowModal()==mrOk)? InputExDlg->InputComboBox->Text : EmptyStr;
			}
			and_sw	= (tags.Pos('|')==0);
			tags	= ReplaceStr(tags, "|", ";");
			sel_msk = (ScrMode==SCMD_FLIST) && IniFile->ReadBoolGen(_T("TagSelSelMask"));
		}
		else {
			if (!TagManDlg) TagManDlg = new TTagManDlg(this);	//初回に動的作成
			TagManDlg->CmdStr = "TagSelect";
			TagManDlg->TagEdit->Text = EmptyStr;
			if (TagManDlg->ShowModal()!=mrOk) SkipAbort();
			tags	= TagManDlg->TagEdit->Text;
			and_sw	= TagManDlg->AndCheckBox->Checked;
			sel_msk = (ScrMode==SCMD_FLIST) && TagManDlg->SelMaskCheckBox->Checked;
		}

		tags = usr_TAG->NormTags(tags, false);
		if (tags.IsEmpty()) SkipAbort();
		bool all_match = USAME_TI(tags, "*");

		TStringList *lst = GetCurList();
		int s_cnt = 0;
		int s_idx = -1;
		for (int i=0; i<lst->Count; i++) {
			file_rec *fp = (file_rec*)lst->Objects[i];
			if (!is_selectable(fp)) continue;
			fp->selected = false;
			if (all_match? usr_TAG->HasTag(fp->f_name) : usr_TAG->Match(fp->f_name, tags, and_sw)) {
				fp->selected = true;  s_cnt++;
				if (s_idx==-1) s_idx = i;
			}
		}
		if (s_cnt==0) Abort();

		switch (ScrMode) {
		case SCMD_FLIST:
			//選択項目だけを残す(選択マスク)
			if (sel_msk) {
				ExeCommandAction("SelMask");
			}
			else {
				if (s_idx!=-1) FileListBox[CurListTag]->ItemIndex = s_idx;
				RepaintList(CurListTag);
			}
			SetFileInf();
			break;
		case SCMD_IVIEW:
			if (s_idx!=-1) set_GridIndex(ThumbnailGrid, s_idx, lst->Count);
			break;
		}
	}
	catch (EAbort &e) {
		SetActionAbort(e.Message);
	}
}

//---------------------------------------------------------------------------
//タスクマネージャ
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::TaskManActionExecute(TObject *Sender)
{
	if (!TaskManDlg) TaskManDlg = new TTaskManDlg(this);	//初回に動的作成
	TaskManDlg->ShowModal();
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::TaskManActionUpdate(TObject *Sender)
{
	((TAction*)Sender)->Enabled = (!NotShowNoTask || get_BusyTaskCount()>0);
}

//---------------------------------------------------------------------------
//アーカイブの正当性を検査してログに表示
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::TestArchiveActionExecute(TObject *Sender)
{
	try {
		CurWorking = true;
		file_rec *cfp = GetCurFrecPtr();
		if (!cfp || cfp->is_dummy || cfp->is_dir || cfp->f_attr==faInvalid) Abort();
		if (cfp->is_ftp) UserAbort(USTR_CantOperate);
		if (cfp->is_virtual && !SetTmpFile(cfp)) UserAbort(USTR_FaildTmpUnpack);

		//正当性を検査
		std::unique_ptr<TStringList> r_lst(new TStringList());
		if (!usr_ARC->GetArcList(cfp->is_virtual? cfp->tmp_name : cfp->f_name, "t", r_lst.get()))
			UserAbort(USTR_FaildProc);

		//結果をログに表示
		AddLogCr();
		UnicodeString msg = "  TEST ";
		if (!cfp->arc_name.IsEmpty()) msg += CurStt->arc_DspPath;
		msg += yen_to_slash(cfp->n_name);
		AddLog(msg);
		AddLogStrings(r_lst.get());
		AddLogCr();
		CurWorking = false;
	}
	catch (EAbort &e) {
		SetActionAbort(e.Message);
	}
}

//---------------------------------------------------------------------------
//テキストビュアー
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::TextViewerActionExecute(TObject *Sender)
{
	try {
		//別ウィンドウで開く
		if (TEST_DEL_ActParam("XW")) {
			TExTxtViewer *xtv;
			//クリップボード
			if (TEST_ActParam("CB")) {
				xtv = new TExTxtViewer(this);
				xtv->FileName = xtv->OrgName = EmptyStr;
				xtv->isClip = true;
			}
			//指定ファイル
			else if (!ActionParam.IsEmpty()) {
				UnicodeString fnam = exclude_quot(ActionParam);
				//URL
				if (is_match_regex(fnam, _T("^") URL_MATCH_PTN)) {
					UnicodeString url = fnam;  if (EndsStr('/', url)) url += "index.html";
					fnam = TempPathA + ExtractFileName(slash_to_yen(url));
					if (!test_TxtExt(get_extension(fnam))) UserAbort(USTR_NotText);
					if (DownloadWorkProgress(url, fnam)!=mrOk) Abort();
					xtv = new TExTxtViewer(this);
					xtv->FileName = xtv->OrgName = fnam;
				}
				//ファイル
				else {
					fnam = to_absolute_name(cv_env_str(fnam), CurPath[CurListTag]);
					xtv = new TExTxtViewer(this);
					xtv->FileName = xtv->OrgName = fnam;
				}
			}
			//通常
			else {
				file_rec *cfp = GetCurFrecPtr();
				if (!cfp || cfp->is_dummy || cfp->is_dir || cfp->f_attr==faInvalid) Abort();

				if ((CurStt->is_Arc || contains_Slash(cfp->f_name)) && !SetTmpFile(cfp))
					UserAbort(USTR_FaildTmpUnpack);
				else if (CurStt->is_FTP && !file_exists(cfp->tmp_name))
					cfp->tmp_name = DownloadFtpCore(cfp);

				xtv = new TExTxtViewer(this);
				xtv->OrgName  = cfp->f_name;
				xtv->FileName = (cfp->is_virtual || cfp->is_ftp)? cfp->tmp_name : cfp->f_name;
			}

			if (xtv) {
				//イベント: テキストビュアーを開く直前
				if (xtv->isClip)
					ExeEventCommand(OnTvOpen, "ViewClip");
				else
					ExeEventCommand(OnTvOpen, EmptyStr, xtv->FileName);
				xtv->Show();
			}
			SkipAbort();
		}

		//次の NyanFi で開く
		if (TEST_DEL_ActParam("NN")) {
			if (CurStt->is_Arc || CurStt->is_FTP) UserAbort(USTR_CantOperate);
			file_rec *cfp = GetCurFrecPtr();
			if (!cfp || cfp->is_dummy || cfp->is_dir || cfp->f_attr==faInvalid) Abort();

			HWND hNextWnd = get_NyanFiWnd(1);
			if (hNextWnd) {
				UnicodeString fnam = cfp->f_name;
				COPYDATASTRUCT cd;
				cd.dwData = CPYDTID_TXTVIEW;
				cd.cbData = sizeof(_TCHAR) * (fnam.Length() + 1);
				cd.lpData = fnam.c_str();
				::SendMessage(hNextWnd, WM_COPYDATA, 0, (LPARAM)&cd);
				SkipAbort();
			}
			else ActionParam = EmptyStr;
		}

		//メイン画面で開く
		//クリップボード
		if (TEST_ActParam("CB")) {
			if (!ViewClipText()) Abort();
		}
		//指定ファイル
		else if (!ActionParam.IsEmpty()) {
			UnicodeString fnam = ActionParam;
			//URL
			if (is_match_regex(fnam, _T("^") URL_MATCH_PTN)) {
				UnicodeString url = fnam;  if (EndsStr('/', url)) url += "index.html";
				fnam = TempPathA + ExtractFileName(slash_to_yen(url));
				if (!test_TxtExt(get_extension(fnam))) UserAbort(USTR_NotText);
				if (DownloadWorkProgress(url, fnam)!=mrOk) Abort();
				if (!SetAndOpenTxtViewer(fnam, 1, true)) UserAbort(USTR_FileNotOpen);
			}
			//ファイル
			else {
				fnam = to_absolute_name(cv_env_str(fnam), CurPath[CurListTag]);
				if (!SetAndOpenTxtViewer(fnam)) UserAbort(USTR_FileNotOpen);
			}
		}
		//通常
		else {
			file_rec *cfp = GetCurFrecPtr();
			if (!cfp || cfp->is_dummy || cfp->is_dir || cfp->f_attr==faInvalid) Abort();

			if ((CurStt->is_Arc || contains_Slash(cfp->f_name)) && !SetTmpFile(cfp))
				UserAbort(USTR_FaildTmpUnpack);
			else if (cfp->is_ftp && !file_exists(cfp->tmp_name))
				cfp->tmp_name = DownloadFtpCore(cfp);

			if (!OpenTxtViewer(cfp)) UserAbort(USTR_FileNotOpen);
		}
	}
	catch (EAbort &e) {
		SetActionAbort(e.Message);
	}
}

//---------------------------------------------------------------------------
//別ウィンドウのテキストビュアーへ
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ToExViewerActionExecute(TObject *Sender)
{
	std::unique_ptr<TStringList> lst(new TStringList());
	get_ExViewerList(lst.get());

	int idx = -1;
	if (lst->Count==1) {
		idx = 0;
	}
	else if (lst->Count>1) {
		//ポップアップメニューで選択
		std::unique_ptr<TStringList> m_buf(new TStringList());
		for (int i=0; i<lst->Count; i++) {
			m_buf->Add(UnicodeString().sprintf(_T("&%u: %s"),
				i + 1, get_tkn(((TForm *)lst->Objects[i])->Caption, " - テキストビュアー").c_str()));
		}
		ExePopMenuList(m_buf.get(), true);
		Application->ProcessMessages();
		idx = PopMenuIndex;
	}

	if (idx!=-1) ((TForm *)lst->Objects[idx])->SetFocus();
}

//---------------------------------------------------------------------------
//左側へ
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ToLeftActionExecute(TObject *Sender)
{
	InvalidateFileList(1);
	FileListBox[0]->SetFocus();
	if (GetSelCount(GetCurList())>0) InvalidateFileList(0);
	ListBoxSetIndex(FileListBox[0], FileListBox[0]->ItemIndex);
}

//---------------------------------------------------------------------------
//ログウィンドウへ
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ToLogActionExecute(TObject *Sender)
{
	if (SubPanel->Visible && LogPanel->Visible) LogListBox->SetFocus();
}

//---------------------------------------------------------------------------
//反対側のファイルリストへ
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ToOppositeActionExecute(TObject *Sender)
{
	((CurListTag==0)? ToRightAction : ToLeftAction)->Execute();
}

//---------------------------------------------------------------------------
//カーソル位置に対応する反対側項目へ
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ToOppItemCore(const _TCHAR *mode_str)
{
	try {
		bool no_opp = TEST_DEL_ActParam("NO");

		if (USAME_TI(mode_str, "HASH")) {
			if (CurStt->is_Arc || CurStt->is_FTP || IsDiffList()
				|| OppStt->is_Arc || OppStt->is_FTP || OppStt->is_Find || OppStt->is_Work)
					UserAbort(USTR_OpeNotSuported);
		}

		UnicodeString idstr = def_if_empty(ActionParam, "MD5");

		//カーソル位置を取得
		TStringList *lst = GetCurList(true);
		TListBox *lp = FileListBox[CurListTag];
		int idx_c = lp->ItemIndex;
		int itm_p = idx_c - lp->TopIndex;
		if (idx_c==-1 || idx_c>=lst->Count) Abort();
		file_rec *cfp = (file_rec*)lst->Objects[idx_c];
		if (cfp->is_dummy) Abort();

		int idx_o = -1;
		if (USAME_TI(mode_str, "NAME")) {
			UnicodeString fnam = cfp->n_name;
			//反対側で検索
			lst = GetOppList();
			for (int i=0; i<lst->Count && idx_o==-1; i++) {
				if (SameText(ExtractFileName(lst->Strings[i]), fnam)) idx_o = i;
			}
		}
		else if (USAME_TI(mode_str, "HASH")) {
			if (cfp->is_dir || cfp->f_size==0) Abort();

			CurWorking = true;
			//カーソル位置のハッシュ値取得
			cfp->hash = get_HashStr(cfp->f_name, idstr);
			if (cfp->hash.IsEmpty()) UserAbort(USTR_FaildProc);
			ViewFileInf(cfp, true);

			//反対側で検索
			lst = GetOppList();
			for (int i=0; i<lst->Count && idx_o==-1; i++) {
				file_rec *fp = (file_rec*)lst->Objects[i];
				if (fp->is_dummy || fp->is_dir) continue;
				if (fp->f_size==cfp->f_size) {
					fp->hash = get_HashStr(fp->f_name, idstr);
					if (SameText(fp->hash, cfp->hash)) idx_o = i;
				}
			}
			CurWorking = false;
		}

		//見つかった
		if (idx_o!=-1) {
			//反対側に点線カーソル表示
			if (no_opp) {
				lp = FileListBox[OppListTag];
				lp->ItemIndex = idx_o;
				lp->TopIndex  = std::max(idx_o - itm_p, 0);
				DrawOppCsr++;
				lp->Invalidate();
			}
			//反対側へ移動
			else {
				lp = FileListBox[CurListTag];
				lp->Invalidate();
				lp = FileListBox[OppListTag];
				lp->ItemIndex = idx_o;
				lp->TopIndex  = std::max(idx_o - itm_p, 0);
				lp->SetFocus();
				SetFileInf();
			}
		}
		//見つからなかった
		else {
			if (no_opp) {
				DrawOppCsr = 0;
				InvalidateFileList(OppListTag);
			}
			UserAbort(USTR_NotFound);
		}
	}
	catch (EAbort &e) {
		SetActionAbort(e.Message);
	}
}

//---------------------------------------------------------------------------
//カーソル位置と同ハッシュ値の反対側項目へ
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ToOppSameHashActionExecute(TObject *Sender)
{
	ToOppItemCore(_T("HASH"));
}
//---------------------------------------------------------------------------
//カーソル位置と同名の反対側項目へ
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ToOppSameItemActionExecute(TObject *Sender)
{
	ToOppItemCore(_T("NAME"));
}

//---------------------------------------------------------------------------
//親ディレクトリへ
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ToParentActionExecute(TObject *Sender)
{
	try {
		//代替データストリーム/結果リスト
		if (CurStt->is_ADS || CurStt->is_Find) {
			RecoverFileList2();	//ファイルリストに戻る
		}
		//仮想ディレクトリ
		else if (CurStt->is_Arc) {
			bool end_flag = false;
			UnicodeString last_dir;
			if (CurStt->arc_SubPath.IsEmpty()) {
				if (CurStt->arc_RetList->Count>0) {
					//多重アーカイブから抜ける
					ClearTempArc(ExtractFilePath(CurStt->arc_Name));
					UnicodeString lbuf = CurStt->arc_RetList->Strings[0];
					CurStt->arc_RetList->Delete(0);
					CurStt->arc_Name	= get_pre_tab(lbuf);
					CurStt->arc_SubPath = get_post_tab(lbuf);
					last_dir = CurStt->arc_SubPath + ExtractFileName(ExcludeTrailingPathDelimiter(CurStt->arc_DspPath));
					CurStt->arc_DspPath = get_parent_path(CurStt->arc_DspPath);
				}
				else end_flag = true;
			}
			else {
				last_dir = CurStt->arc_SubPath;
				CurStt->arc_SubPath = get_parent_path(CurStt->arc_SubPath);
				CurStt->arc_DspPath = get_parent_path(CurStt->arc_DspPath);
			}
			if (!end_flag) {
				if (UpdateTempArcList(CurListTag).IsEmpty()) UserAbort(USTR_CantMakeTmpDir);
				SelMaskList[CurListTag]->Clear();
				ChangeArcFileListEx(CurStt->arc_Name, CurStt->arc_SubPath, CurListTag, last_dir);
			}
			else {
				RecoverFileList();	//仮想ディレクトリから抜ける
			}
		}
		//FTP
		else if (CurStt->is_FTP) {
			if (!IdFTP1->Connected()) {
				RecoverFileList();  Abort();
			}
			UnicodeString l_pnam = CurFTPPath;
			if (!ChangeFtpFileList(CurListTag, "..", CurFTPPath)) GlobalAbort();
			if (SyncLR && IsOppFList() &&
				SameText(ExtractFileName(ExcludeTrailingPathDelimiter(l_pnam)),
						 ExtractFileName(ExcludeTrailingPathDelimiter(CurPath[OppListTag]))))
			{
				OppToParent();
			}
		}
		//ワークリスト
		else if (CurStt->is_Work) {
			if (!WorkListName.IsEmpty() && !JumpToList(CurListTag, WorkListName)) GlobalAbort();
		}
		//ファイルリスト
		else {
			//ライブラリ処理
			UnicodeString lnam = get_LibFile_if_root();
			if (!lnam.IsEmpty()) {
				if (!JumpToList(CurListTag, lnam)) GlobalAbort();
			}
			else {
				UnicodeString pnam = CurPath[CurListTag];
				if (is_root_dir(pnam)) {
					if (TEST_ActParam("DL")) {
						if (StartsStr("\\\\", pnam))
							ShareListAction->Execute();
						else {
							if (!SelDriveDlg) SelDriveDlg = new TSelDriveDlg(this);	//初回に動的作成
							SelDriveDlg->ShowModal();
						}
					}
					else if (TEST_ActParam("DP"))
						PopupDriveMenu();
				}
				else {
					UpdateCurPath(get_parent_path(pnam), ExcludeTrailingPathDelimiter(pnam));
				}
			}
		}
	}
	catch (EAbort &e) {
		SetActionAbort(e.Message);
	}
	catch (...) {
		SetInternalException();
	}
}

//---------------------------------------------------------------------------
//左ファイルリストで親ディレクトリへ
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ToParentOnLeftActionExecute(TObject *Sender)
{
	((CurListTag==0)? ToParentAction : ToLeftAction)->Execute();
}
//---------------------------------------------------------------------------
//右ファイルリストで親ディレクトリへ
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ToParentOnRightActionExecute(TObject *Sender)
{
	((CurListTag==1)? ToParentAction : ToRightAction)->Execute();
}

//---------------------------------------------------------------------------
//左ファイルリストで次のNyanFiへ
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ToPrevOnLeftActionExecute(TObject *Sender)
{
	if (CurListTag==0) activate_NyanFi(-1); else ToLeftAction->Execute();
}
//---------------------------------------------------------------------------
//右ファイルリストで前のNyanFiへ
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ToNextOnRightActionExecute(TObject *Sender)
{
	if (CurListTag==1) activate_NyanFi(1); else ToRightAction->Execute();
}

//---------------------------------------------------------------------------
//右側へ
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ToRightActionExecute(TObject *Sender)
{
	InvalidateFileList(0);
	FileListBox[1]->SetFocus();
	if (GetSelCount(GetCurList())>0) InvalidateFileList(1);
	ListBoxSetIndex(FileListBox[1], FileListBox[1]->ItemIndex);
}

//---------------------------------------------------------------------------
//ルートディレクトリへ
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ToRootActionExecute(TObject *Sender)
{
	if (CurStt->is_FTP) {
		if (!ChangeFtpFileList(CurListTag, TopFTPPath, "..")) SetActionAbort(GlobalErrMsg);
	}
	else {
		RecoverFileList2();
		if (!is_root_dir(CurPath[CurListTag])) {
			CurPath[CurListTag] = ExtractFileDrive(CurPath[CurListTag]);
			SetFileInf();
		}
	}
}

//---------------------------------------------------------------------------
//テキストプレビューへ
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ToTextActionExecute(TObject *Sender)
{
	if (PreviewPanel->Visible && TxtPrvListPanel->Visible) TxtPrvListBox->SetFocus();
}

//---------------------------------------------------------------------------
//タグデータの整理
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::TrimTagDataActionExecute(TObject *Sender)
{
	if (msgbox_Sure(LoadUsrMsg(USTR_DeleteQ, _T("存在しない項目のデータ")), SureDelete, true)) {
		CurWorking = true;
		usr_TAG->Recycle();
		int cnt = usr_TAG->TrimData();
		CurWorking = false;

		UnicodeString msg;
		if (cnt>0)
			msg.sprintf(_T("%u 個のデータを削除しました。"), cnt);
		else
			msg = "存在しない項目のデータはありませんでした。";
		msgbox_OK(msg);
	}
}

//---------------------------------------------------------------------------
//直前の改名を元に戻す
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::UndoRenameActionExecute(TObject *Sender)
{
	try {
		if (CurStt->is_FTP || IsDiffList()) UserAbort(USTR_CantOperate);

		//改名ログを取得
		UnicodeString ren_log = ExePath + RENLOG_FILE;
		if (!file_exists(ren_log)) throw EAbort(LoadUsrMsg(USTR_NotFound, _T("直前の改名ログ")));
		std::unique_ptr<TStringList> ren_lst(new TStringList());
		load_text_ex(ren_log, ren_lst.get());
		if (!GlobalErrMsg.IsEmpty()) GlobalAbort();
		if (ren_lst->Count==0) Abort();

		UnicodeString pnam = ExtractFilePath(get_pre_tab(ren_lst->Strings[0]));
		UnicodeString msg; msg.sprintf(_T("[%s]での %u 件の改名を元に戻しますか?"), pnam.c_str(), ren_lst->Count);
		if (!msgbox_Sure(msg, true, true)) SkipAbort();

		CurWorking = true;
		StartLog("アンドゥ開始  " + pnam);
		BeginWorkProgress(_T("直前の改名のアンドゥ"), "準備中...", ListPanel);
		//新/旧名リスト作成
		std::unique_ptr<TStringList> org_lst(new TStringList());
		std::unique_ptr<TStringList> new_lst(new TStringList());
		std::unique_ptr<TStringList> tmp_lst(new TStringList());
		for (int i=0; i<ren_lst->Count; i++) {
			UnicodeString lbuf	   = ren_lst->Strings[i];
			org_lst->Add(split_pre_tab(lbuf));
			new_lst->Add(lbuf);
		}
		//改名中の重複チェック
		bool duplicated = false;
		if (ren_lst->Count>1) {
			for (int i=0; !duplicated && i<new_lst->Count; i++) {
				for (int j=0; !duplicated && j<org_lst->Count; j++) {
					if (i==j) continue;
					if (SameText(org_lst->Strings[j], new_lst->Strings[i])) duplicated = true;
				}
			}
		}
		//重複回避のための中間改名
		if (duplicated) {
			//一時ファイルが残っていないかチェック
			std::unique_ptr<TStringList> t_lst(new TStringList());
			get_files(ExtractFilePath(ren_lst->Strings[0]), _T("$~NF*.~TMP"), t_lst.get());
			if (t_lst->Count>0 &&
				msgbox_Sure(_T("一時ファイル($~NF*.~TMP)が残っていますが、削除してもよいですか?")))
					for (int i=0; i<t_lst->Count; i++) DeleteFile(t_lst->Strings[i]);
			//中間改名
			ProgressSubLabel->Caption = "中間改名中...";
			for (int i=0; i<new_lst->Count; i++) {
				PosWorkProgress(i, new_lst->Count);
				UnicodeString new_name = new_lst->Strings[i];
				UnicodeString tmp_name = ExtractFilePath(new_name);
				tmp_name.cat_sprintf(_T("$~NF%04u.~TMP"), i);
				if (!move_FileT(new_name, tmp_name)) TextAbort(_T("中間処理に失敗、中断しました。"));
				tmp_lst->Add(tmp_name);
			}
			Sleep(500);
		}

		//改名
		ProgressSubLabel->Caption = "改名中...";
		WorkProgressBar->Position = 0;
		int ok_cnt = 0, er_cnt = 0;
		for (int i=0; i<new_lst->Count; i++) {
			PosWorkProgress(i, new_lst->Count);
			msg = make_LogHdr(_T("UNDO"),
				new_lst->Strings[i]).cat_sprintf(_T(" ---> %s"), ExtractFileName(org_lst->Strings[i]).c_str());
			if (move_FileT(duplicated? tmp_lst->Strings[i] : new_lst->Strings[i], org_lst->Strings[i])) {
				ok_cnt++;
			}
			else {
				set_LogErrMsg(msg, get_LogErrMsg(EmptyStr, false));
				er_cnt++;
			}
			AddLog(msg);
		}

		AddLog("アンドゥ終了" + get_res_cnt_str(ok_cnt, er_cnt), true);
		if (er_cnt>0) throw EAbort(msg.sprintf(_T("%u個のファイルでアンドゥに失敗しました。"), er_cnt));
		delete_File(ren_log);
		CurWorking = false;
		EndWorkProgress();
	}
	catch (EAbort &e) {
		SetActionAbort(e.Message);
	}
}

//---------------------------------------------------------------------------
//アーカイブの解凍
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::UnPackActionExecute(TObject *Sender)
{
	file_rec *cfp = cre_new_file_rec(GetCurFrecPtr(true));

	bool to_cur  = USAME_TI(ActionOptStr, "ToCurrent");
	ActionOptStr = EmptyStr;

	try {
		if (CurStt->is_Arc || CurStt->is_FTP)	UserAbort(USTR_CantOperate);
		if (!to_cur && !IsOppFList())			UserAbort(USTR_CantOperate);

		UnicodeString dst_dir = CurPath[to_cur? CurListTag : OppListTag];
		UnicodeString msg;
		bool sure_unpack = (ExeCmdsBusy && XCMD_MsgOff)? false : SureUnPack;

		bool is_cd	= TEST_ActParam("CD");
		bool is_cd2 = TEST_ActParam("CD2");
		bool is_ow	= TEST_ActParam("OW");

		TStringList *lst = GetCurList(true);
		int sel_cnt = GetSelCount(lst);
		//選択あり
		if (sel_cnt>0) {
			UnicodeString anam;
			for (int i=0; i<lst->Count; i++) {
				file_rec *fp = (file_rec*)lst->Objects[i];
				if (!fp->selected) continue;
				if (fp->is_dir || !test_ArcExt(fp->f_ext)) UserAbort(USTR_FmtNotSuported);
				if (anam.IsEmpty()) anam = fp->f_name;
			}

			if (sel_cnt==1)
				msg.sprintf(_T("%s を解凍しますか?"), ExtractFileName(anam).c_str());
			else
				msg = "複数のアーカイブが選択されていますが解凍しますか?";

			if (msgbox_Sure(msg, sure_unpack)) {
				StartLog(msg.sprintf(_T("解凍開始  %s\t%s"), GetSrcPathStr().c_str(), dst_dir.c_str()));
				CurWorking = true;
				UnicodeString opp_dnam;
				for (int i=0; i<lst->Count; i++) {
					file_rec *fp = (file_rec*)lst->Objects[i];  if (!fp->selected) continue;
					UnicodeString dnam = dst_dir;
					//ディレクトリ作成
					if (is_cd || (is_cd2 && usr_ARC->GetRootCount(fp->f_name)>1)) {
						dnam.cat_sprintf(_T("%s\\"), fp->b_name.c_str());
						SetLastError(NO_ERROR);
						if (!dir_exists(dnam) && !create_Dir(dnam)) {
							AddLog(msg.sprintf(_T("E CREATE [%s]%s"), fp->b_name.c_str(), get_LogErrMsg().c_str()));
							throw EAbort(LoadUsrMsg(USTR_CantCreDir, fp->b_name));
						}
						opp_dnam = ExcludeTrailingPathDelimiter(dnam);
					}
					msg = make_LogHdr(_T("UNPACK"), fp);
					SetDirWatch(false);
					if (!usr_ARC->UnPack(fp->f_name, dnam, EmptyStr, true, false, is_ow))
						set_LogErrMsg(msg, usr_ARC->ErrMsg);
					SetDirWatch(true);
					AddLog(msg);
					if (msg[1]=='E') UserAbort(USTR_FaildProc);
					fp->selected = false;
					InvalidateFileList();
				}
				CurWorking = false;

				if (!to_cur) {
					ReloadList(OppListTag);
					IndexOfFileList(opp_dnam, OppListTag);
				}

				if (to_cur || EqualDirLR()) ReloadList(CurListTag); else RepaintList(CurListTag);

				EndLog(_T("解凍"));
			}
		}
		//カーソル位置
		else {
			if (cfp->f_name.IsEmpty() || cfp->is_dummy)  Abort();
			if (!test_ArcExt(cfp->f_ext)) UserAbort(USTR_FmtNotSuported);

			if (msgbox_Sure(msg.sprintf(_T("%s を解凍しますか?"), cfp->n_name.c_str()), sure_unpack)) {
				StartLog(msg.sprintf(_T("解凍開始  %s\t%s"), GetSrcPathStr().c_str(), CurPath[OppListTag].c_str()));
				UnicodeString dnam = dst_dir;
				UnicodeString opp_dnam;
				//ディレクトリ作成
				if (is_cd || (is_cd2 && usr_ARC->GetRootCount(cfp->f_name)>1)) {
					dnam.cat_sprintf(_T("%s\\"), cfp->b_name.c_str());
					SetLastError(NO_ERROR);
					if (!dir_exists(dnam) && !create_Dir(dnam)) {
						AddLog(msg.sprintf(_T("E CREATE [%s]%s"), cfp->b_name.c_str(), get_LogErrMsg().c_str()));
						throw EAbort(LoadUsrMsg(USTR_CantCreDir, cfp->b_name));
					}
					opp_dnam = ExcludeTrailingPathDelimiter(dnam);
				}
				UnicodeString msg = make_LogHdr(_T("UNPACK"), cfp);
				CurWorking = true;
				SetDirWatch(false);
				if (!usr_ARC->UnPack(cfp->f_name, dnam, EmptyStr, true, false, is_ow))
					set_LogErrMsg(msg, usr_ARC->ErrMsg);

				SetDirWatch(true);
				CurWorking = false;
				AddLog(msg);

				if (!to_cur) {
					ReloadList(OppListTag);
					IndexOfFileList(opp_dnam, OppListTag);
				}

				if (to_cur || EqualDirLR()) ReloadList(CurListTag); else RepaintList(CurListTag);

				if (msg[1]=='E') UserAbort(USTR_FaildProc);
				EndLog(_T("解凍"));
			}
		}
	}
	catch (EAbort &e) {
		SetActionAbort(e.Message);
	}

	del_file_rec(cfp);
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::UnPackToCurrActionExecute(TObject *Sender)
{
	ActionOptStr = "ToCurrent";
	UnPackAction->Execute();
}
//---------------------------------------------------------------------------
//削除にごみ箱を使う/使わない
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::UseTrashActionExecute(TObject *Sender)
{
	SetToggleAction(DelUseTrash);
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::UseTrashActionUpdate(TObject *Sender)
{
	((TAction*)Sender)->Checked = DelUseTrash;
}

//---------------------------------------------------------------------------
//最近閲覧したファイル一覧
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ViewHistoryActionExecute(TObject *Sender)
{
	EditHistoryActionExecute(Sender);
}

//---------------------------------------------------------------------------
//ログを閲覧
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ViewLogActionExecute(TObject *Sender)
{
	//別ウィンドウで開く
	if (TEST_ActParam("XW")) {
		//イベント: テキストビュアーを開く直前
		ExeEventCommand(OnTvOpen, "ViewLog");

		TExTxtViewer *xtv = new TExTxtViewer(this);
		xtv->FileName = xtv->OrgName = EmptyStr;
		xtv->Show();
	}
	//メイン画面で開く
	else {
		TxtMainPanel->Visible	= false;
		TxtScrollPanel->Visible = false;

		//イベント: テキストビュアーを開く直前
		ExeEventCommand(OnTvOpen, "ViewLog");

		SetScrMode(SCMD_TVIEW);
		TxtViewer->FileName  = EmptyStr;
		TxtViewer->AssignText(LogBufList);
		TxtViewer->SttHdrInf = "タスクログ  行数:" + get_size_str_B(TxtViewer->MaxLine, 0);
		SetSttBarInf();

		TxtScrollPanel->Visible = true;
		TxtMainPanel->Visible	= true;

		//イベント: テキストビュアーを開いた直後
		ExeEventCommand(OnTvOpened, "ViewLog");
	}
}

//---------------------------------------------------------------------------
//テキストの末尾を指定行分ビュアーで表示
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ViewTailActionExecute(TObject *Sender)
{
	try {
		file_rec *cfp = GetCurFrecPtr(true);
		if (!cfp) Abort();
		if ((CurStt->is_Arc || contains_Slash(cfp->f_name)) && !SetTmpFile(cfp)) UserAbort(USTR_FaildTmpUnpack);

		bool reverse = remove_top_text(ActionParam, _T("R"));
		int limit_ln = ActionParam.ToIntDef(100);
		if (!OpenTxtViewerTail(cfp, limit_ln, reverse)) GlobalAbort();
	}
	catch (EAbort &e) {
		SetActionAbort(e.Message);
	}
}

//---------------------------------------------------------------------------
//カレントリストの幅を広げる
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::WidenCurListActionExecute(TObject *Sender)
{
	int tag = USAME_TI(ActionOptStr, "Left")? 0 : (USAME_TI(ActionOptStr, "Right")? 1: CurListTag);
	ActionOptStr = EmptyStr;

	float r = 0.75;
	bool x_sw = false;
	if (!ActionParam.IsEmpty()) {
		x_sw = remove_top_s(ActionParam, '^');
		int p = ActionParam.ToIntDef(0);
		if (p>0 && p<100) r = p/100.0;
	}

	if (DivFileListUD) {
		if (x_sw && abs(L_Panel->Height - R_Panel->Height)>4) {
			EqualListWidthAction->Execute();
		}
		else {
			int h = L_Panel->Height + R_Panel->Height;
			L_Panel->Height = h * ((tag==0)? r : 1.0 - r);
		}
	}
	else {
		if (x_sw && abs(L_Panel->Width - R_Panel->Width)>4) {
			EqualListWidthAction->Execute();
		}
		else {
			L_Panel->Width = (ListPanel->ClientWidth - LRSplitter->Width) * ((tag==0)? r : 1.0 - r);
			L_TopPanel->Width = L_Panel->Width - (RelPanel->Width - LRSplitter->Width)/2;
		}
	}
}

//---------------------------------------------------------------------------
//ウィンドウの最大化
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::WinMaximizeActionExecute(TObject *Sender)
{
	WindowState = wsMaximized;
}
//---------------------------------------------------------------------------
//ウィンドウの最小化
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::WinMinimizeActionExecute(TObject *Sender)
{
	Application->Minimize();
}
//---------------------------------------------------------------------------
//ウィンドウを元のサイズに戻す
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::WinNormalActionExecute(TObject *Sender)
{
	WindowState = wsNormal;
}

//---------------------------------------------------------------------------
//ウィンドウの四辺を設定
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::WinPosActionExecute(TObject *Sender)
{
	InhUpdBgImg++;

	//四辺を設定
	if (!ActionParam.IsEmpty()) {
		try {
			TStringDynArray prm_lst = split_strings_semicolon(ActionParam);
			int l = BoundsRect.Left;
			int t = BoundsRect.Top;
			int r = BoundsRect.Right;
			int b = BoundsRect.Bottom;

			for (int i=0; i<prm_lst.Length; i++) {
				UnicodeString lbuf = prm_lst[i].UpperCase();
				if (!starts_tchs(_T("LTRB"), lbuf)) UserAbort(USTR_IllegalParam);
				WideChar c = split_top_wch(lbuf);

				bool is_rel = starts_tchs(_T("+-"), lbuf);	//相対指定か?
				int rel_sig = 0;
				if (is_rel) {
					rel_sig = (lbuf[1]=='-')? -1 : 1;
					lbuf.Delete(1, 1);
				}
				if (lbuf.IsEmpty()) UserAbort(USTR_IllegalParam);
				int v = lbuf.ToIntDef(-1); if (v==-1) UserAbort(USTR_IllegalParam);

				switch (c) {
				case 'L': if (is_rel) l += rel_sig * v; else l = v;	break;
				case 'T': if (is_rel) t += rel_sig * v; else t = v;	break;
				case 'R': if (is_rel) r += rel_sig * v; else r = v;	break;
				case 'B': if (is_rel) b += rel_sig * v; else b = v;	break;
				}
			}

			if (l>=r || t>=b) UserAbort(USTR_IllegalParam);
			WindowState = wsNormal;
			SetBounds(l, t, (r - l), (b - t));
		}
		catch (EAbort &e) {
			SetActionAbort(e.Message);
		}
	}
	//起動時の設定に戻す
	else {
		if (IsPrimary) {
			if (IniWinMode==1) {
				WindowState = wsNormal;
				SetBounds(IniWinLeft, IniWinTop, IniWinWidth, IniWinHeight);
			}
			else IniFile->LoadFormPos(this, 800,600);
		}
		else IniFile->LoadFormPos(this, 800,600, "Win2");
	}

	InhUpdBgImg--;
	Application->ProcessMessages();
	UpdateBgImage(true);
}

//---------------------------------------------------------------------------
//ワークリスト
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::WorkListActionExecute(TObject *Sender)
{
	try {
		if (IsDiffList()) UserAbort(USTR_CantOperate);

		if (TEST_ActParam("OP")) {
			if (OppStt->is_Work) {
				RecoverFileList(OppListTag);
			}
			else {
				if (CurStt->is_Work) RecoverFileList();
				CheckChangeWorkList(OppListTag);
				//履歴に追加
				if (WorkToDirHist && !WorkListName.IsEmpty()) AddDirHistory(WorkListName, OppListTag);
			}
		}
		else if (TEST_ActParam("DI")) {
			if (CurStt->is_Work) {
				if (WorkListFiltered) UserAbort(USTR_WorkFiltered);

				int cnt = 0;
				for (int i=0; i<WorkList->Count; i++)
					if (((file_rec*)WorkList->Objects[i])->f_attr==faInvalid) cnt++;

				if (cnt>0) {
					bool sure_del = (ExeCmdsBusy && XCMD_MsgOff)? false : SureDelete;
					if (!msgbox_Sure(_T("存在しない項目をワークリストから外しますか?"), sure_del)) SkipAbort();
					int i = 0;
					while (i<WorkList->Count) {
						if (((file_rec*)WorkList->Objects[i])->f_attr==faInvalid) del_FileListItem(WorkList, i); else i++;
					}

					//結果反映
					ChangeWorkList(CurListTag);
					SetFileInf();
					rqWorkListDirInf = !WorkListChanged;
					WorkListChanged  = true;
				}
			}
		}
		else {
			if (CurStt->is_Work) {
				if (TEST_ActParam("RL")) {
					if (WorkListFiltered) SelMaskList[CurListTag]->Clear();
					if (!SetWorkList()) UserAbort(USTR_WlistCantOpen);
				}
				else {
					RecoverFileList();
				}
			}
			else {
				if (OppStt->is_Work) RecoverFileList(OppListTag);
				if (TEST_ActParam("RL")) {
					if (!SetWorkList()) UserAbort(USTR_WlistCantOpen);
				}
				else {
					CheckChangeWorkList(CurListTag);
				}
				//履歴に追加
				if (WorkToDirHist && !WorkListName.IsEmpty()) AddDirHistory(WorkListName, CurListTag);
			}
		}

		SetCurTab(true);
	}
	catch (EAbort &e) {
		SetActionAbort(e.Message);
	}
}

//---------------------------------------------------------------------------
//ワークリストの項目を1つ下に移動
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::WorkItemDownActionExecute(TObject *Sender)
{
	if (WorkListFiltered) { SetActionAbort(USTR_WorkFiltered); return; }

	ItemTmpDownAction->Execute();
}
//---------------------------------------------------------------------------
//ワークリストの項目を1つ上に移動
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::WorkItemUpActionExecute(TObject *Sender)
{
	if (WorkListFiltered) { SetActionAbort(USTR_WorkFiltered); return; }

	ItemTmpUpAction->Execute();
}
//---------------------------------------------------------------------------
//選択ワークリスト項目をカーソル位置に移動
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::WorkItemMoveActionExecute(TObject *Sender)
{
	if (WorkListFiltered) { SetActionAbort(USTR_WorkFiltered); return; }

	ItemTmpMoveAction->Execute();
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::WorkItemActionUpdate(TObject *Sender)
{
	TAction *ap = (TAction*)Sender;
	ap->Visible = ScrMode==SCMD_FLIST && CurStt->is_Work;
	ap->Enabled = ap->Visible;
}

//---------------------------------------------------------------------------
//XMLビュアー
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::XmlViewerActionExecute(TObject *Sender)
{
	try {
		file_rec *cfp = GetCurFrecPtr(true);
		if (!cfp || cfp->is_dummy || cfp->is_dir || cfp->f_attr==faInvalid) Abort();
		if (cfp->is_virtual && !SetTmpFile(cfp)) UserAbort(USTR_FaildTmpUnpack);
		UnicodeString fnam = (cfp->is_virtual || cfp->is_ftp)? cfp->tmp_name : cfp->f_name;
		if (!is_TextFile(fnam)) UserAbort(USTR_NotText);

		if (!XmlViewer) XmlViewer = new TXmlViewer(this);	//初回に動的作成
		XmlViewer->FileName = fnam;
		XmlViewer->ShowModal();
	}
	catch (EAbort &e) {
		SetActionAbort(e.Message);
	}
}

//---------------------------------------------------------------------------
//ズームイン
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ZoomInActionExecute(TObject *Sender)
{
	SetFileListFontSize(ActionParam.ToIntDef(1), true);
}
//---------------------------------------------------------------------------
//ズームアウト
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ZoomOutActionExecute(TObject *Sender)
{
	SetFileListFontSize(-ActionParam.ToIntDef(1), true);
}
//---------------------------------------------------------------------------
//ズーム解除
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ZoomResetActionExecute(TObject *Sender)
{
	SetFileListFontSize();
}

//---------------------------------------------------------------------------
//コピー/移動先の指定
//！存在しない場合 Abort 例外/ キャンセル時は SkipAbort
//---------------------------------------------------------------------------
UnicodeString __fastcall TNyanFiForm::GetDistDir(bool is_move, bool *to_flag)
{
	UnicodeString dst_dir;
	UnicodeString tit = is_move? "移動先" : "コピー先";
	//入力(TOパラメータ)
	if (TEST_DEL_ActParam("TO")) {
		UnicodeString dnam = inputbox_dir(tit.c_str(), (is_move? _T("Move") : _T("Copy")));
		if (dnam.IsEmpty()) SkipAbort();
		dnam = to_absolute_name(dnam, CurPath[CurListTag]);
		int atr = file_GetAttr(dnam);
		if (atr!=faInvalid && !(atr & faDirectory)) dnam = ExtractFilePath(dnam);
		if (!dir_exists(dnam)) {
			UnicodeString msg = SysErrorMessage(ERROR_PATH_NOT_FOUND) + "\r\n新規に作成しますか?";
			if (!msgbox_Sure(msg)) SkipAbort();
			//新規作成
			StartLog(_T("作成開始"));
			msg = make_CreateLog(dnam);
			SetLastError(NO_ERROR);
			if (!create_ForceDirs(dnam)) set_LogErrMsg(msg);
			AddLog(msg);
			EndLog(_T("作成"));
			if (msg[1]=='E') throw EAbort(LoadUsrMsg(USTR_CantCreDir, dnam));
		}
		dst_dir = IncludeTrailingPathDelimiter(dnam);
		if (EndsStr("\\.\\", dst_dir)) dst_dir.Delete(dst_dir.Length()-1, 2);
		*to_flag = true;
	}
	//ディレクトリの選択(SDパラメータ)
	else if (TEST_DEL_ActParam("SD")) {
		UnicodeString dnam = CurPath[CurListTag];
		bool res = UserModule->SelectDirEx(tit.c_str(), dnam);
		//※こうしないとフォーカスが戻らない(謎)
		InpDirPanel->Visible = true; InpDirComboBox->SetFocus(); InpDirPanel->Visible = false;
		FileListBox[CurListTag]->SetFocus();
		if (res) {
			dst_dir  = dnam;
			*to_flag = true;
		}
		else SkipAbort();
	}
	//サブディレクトリの選択(SSパラメータ)
	else if (TEST_DEL_ActParam("SS")) {
		if (!NetShareDlg) NetShareDlg = new TNetShareDlg(this);	//初回に動的作成
		NetShareDlg->Caption   = tit;
		NetShareDlg->PathName  = CurPath[CurListTag];
		NetShareDlg->isSelDir  = true;
		NetShareDlg->rqRetPath = true;
		if (NetShareDlg->ShowModal()!=mrOk) SkipAbort();
		dst_dir  = NetShareDlg->PathName;
		*to_flag = true;
	}
	//CopyTo/MoveTo から
	else if (!ActionDstDir.IsEmpty()) {
		dst_dir = IncludeTrailingPathDelimiter(ActionDstDir);
		ActionDstDir = EmptyStr;
		*to_flag = true;
		if (!dir_exists(dst_dir)) SysErrAbort(ERROR_PATH_NOT_FOUND);
	}
	else {
		dst_dir  = GetCurPathStr(OppListTag);
		*to_flag = false;
	}

	return dst_dir;
}

//---------------------------------------------------------------------------
//代替データストリーム対応のファイルコピー
//---------------------------------------------------------------------------
bool __fastcall TNyanFiForm::CopyAdsCore(
	UnicodeString src_nam,	//コピー元
	UnicodeString dst_nam,	//コピー先
	bool &ow_all,			//すべて上書き
	bool &sk_all)			//すべてスキップ
{
	UnicodeString msg = make_LogHdr(_T("COPY"), src_nam);

	//同名処理
	if (file_exists(dst_nam)) {
		if (!ow_all && !sk_all) {
			bool all_checked = false;
			int res = msgbox_SureAll(
						UnicodeString().sprintf(_T("同名ファイル [%s] があります。\n上書きしますか?"),
						ExtractFileName(dst_nam).c_str()),
						all_checked);

			if (res==mrCancel) {
				msg[1] = 'C';  CancelWork = true;
			}
			else if (res==mrYes) {
				msg[1] = 'O';  ow_all = all_checked;
			}
			else {
				msg[1] = 'S';  sk_all = all_checked;
			}
		}
		else if (ow_all) msg[1] = 'O';
		else if (sk_all) msg[1] = 'S';
	}

	try {
		bool copied = false;
		if (msg[1]!='S' && msg[1]!='C') {
			std::unique_ptr<TFileStream> s_fs(new TFileStream(src_nam, fmOpenRead | fmShareDenyNone));
			std::unique_ptr<TFileStream> d_fs(new TFileStream(dst_nam, fmCreate));
			std::unique_ptr<BYTE[]> fbuf(new BYTE[1048576ul]);	//***

			ProgressSubLabel->Caption = ExtractFileName(src_nam);
			__int64 cpy_sz = 0;
			while (!CancelWork) {
				int sz = s_fs->Read(fbuf.get(), 1048576ul);  if (sz==0) break;
				d_fs->Write(fbuf.get(), sz);
				cpy_sz += sz;
				PosWorkProgress(cpy_sz, s_fs->Size);
				Application->ProcessMessages();
			}
			copied = !CancelWork;
		}

		if (copied) {
			//ADSでなければタイムスタンプと属性をコピー
			int p = dst_nam.Length() - ExtractFileName(dst_nam).Length();
			if (p<=2 || dst_nam[p]!=':') {
				if (!set_file_age(dst_nam, get_file_age(src_nam))) Abort();
				if (!file_SetAttr(dst_nam, file_GetAttr(src_nam))) Abort();
			}
		}
	}
	catch (...) {
		set_LogErrMsg(msg);
	}

	AddLog(msg);

	return (msg[1]!='E' && msg[1]!='C');
}
//---------------------------------------------------------------------------
//コピー
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::CopyActionExecute(TObject *Sender)
{
	file_rec *cfp = cre_new_file_rec(GetCurFrecPtr(true));

	try {
		TStringList *lst = GetCurList(true);
		int sel_cnt = GetSelCount(lst);
		int cur_idx = FileListBox[CurListTag]->ItemIndex;
		if (TEST_DEL_ActParam("SO") && sel_cnt==0) SkipAbort();
		if (sel_cnt==0 && (cfp->f_name.IsEmpty() || cfp->is_dummy)) Abort();

		int op_mode = TEST_DEL_ActParam("OP")? 1 : TEST_DEL_ActParam("OP2")? 2 : 0;

		bool is_to = false;
		UnicodeString src_dir = GetCurPathStr();
		UnicodeString dst_dir = GetDistDir(false, &is_to);
		UnicodeString ftp_dir = yen_to_slash(CurFTPPath);

		if (!is_to) {
			if (OppStt->is_Find) {
				if (!IsDiffList() && (!OppStt->find_TAG || !IsCurFList())) UserAbort(USTR_CantOperate);
			}
			if (CurStt->is_Arc && OppStt->is_Arc) UserAbort(USTR_OpeNotSuported);
			if ((CurStt->is_Arc || CurStt->is_ADS || CurStt->is_FTP) && OppStt->is_Work) UserAbort(USTR_CantOperate);
		}
		if (is_drive_protected(dst_dir)) SysErrAbort(ERROR_WRITE_PROTECT);
		if (TestCurIncFindVirtual()) UserAbort(USTR_OpeNotSuported);

		if (!OppStt->is_Arc && !OppStt->is_Work && !OppStt->is_FTP && (CurStt->is_Find || CurStt->is_Work)) {
			int sel_cnt0 = sel_cnt;
			for (int i=0; i<lst->Count; i++) {
				file_rec *fp = (file_rec*)lst->Objects[i];
				if (fp->selected || (sel_cnt==0 && i==cur_idx)) {
					if (fp->is_dummy) {
						fp->selected = false;
						sel_cnt--;
						continue;
					}
					if (SameText(fp->p_name, dst_dir)) UserAbort(USTR_SameCopyDest);
				}
			}
			if (sel_cnt0>0 && sel_cnt==0) {
				RepaintList(CurListTag);
				UserAbort(USTR_NoObject);
			}
		}

		bool sure_copy = (ExeCmdsBusy && XCMD_MsgOff)? false : SureCopy;
		const _TCHAR *cpy_fmt = _T("コピー開始  %s\t%s");
		UnicodeString dst_nam, msg, tmp;

		//アーカイブ内からコピー
		if (CurStt->is_Arc) {
			UnicodeString src_pnam = CurStt->arc_Name;
			if (!CurStt->arc_SubPath.IsEmpty()) src_pnam += "/" + CurStt->arc_SubPath;
			tmp = (sel_cnt>0)? LoadUsrMsg(USTR_SelectedItem) : get_DispName(cfp);
			if (!msgbox_Sure(LoadUsrMsg(USTR_CopyQ, tmp), sure_copy)) SkipAbort();
			StartLog(msg.sprintf(cpy_fmt, src_pnam.c_str(), dst_dir.c_str()));

			CurWorking = true;
			gCopyAll   = false;

			std::unique_ptr<TStringList> f_lst(new TStringList());
			std::unique_ptr<TStringList> d_lst(new TStringList());
			for (int i=0; i<lst->Count; i++) {
				file_rec *fp = (file_rec*)lst->Objects[i];
				if (fp->selected || (sel_cnt==0 && i==cur_idx)) {
					if (dst_nam.IsEmpty()) dst_nam = get_dir_name(fp->f_name);
					if (fp->is_dir) {
						std::unique_ptr<TStringList> a_lst(new TStringList());
						get_ArcList(CurStt->arc_Name, fp->f_name, a_lst.get(), d_lst.get());
						f_lst->AddStrings(a_lst.get());
					}
					else {
						f_lst->Add(fp->f_name);
					}
					fp->selected = false;
					Application->ProcessMessages();
				}
			}
			if (sel_cnt>0) RepaintList(CurListTag);

			UnicodeString src_files;
			UnicodeString res_file = make_ResponseFile(f_lst.get(), usr_ARC->GetArcType(CurStt->arc_Name), &src_files);
			if (res_file==RESPONSE_ERR) UserAbort(USTR_FaildListFile);
			if (src_files.IsEmpty() && res_file.IsEmpty()) UserAbort(USTR_NoObject);

			if (!UnpackCopyCore(CurStt->arc_Name, CurStt->arc_SubPath, src_files, res_file, dst_dir, f_lst.get(), d_lst.get()))
				GlobalAbort();
			delete_FileIf(res_file);

			CurWorking = false;

			if (!is_to) CurPath[OppListTag] = dst_dir;
			if (op_mode>0 && !dst_nam.IsEmpty()) IndexOfFileList(dst_dir + dst_nam, OppListTag);
		}
		//アーカイブ内へコピー
		else if (!is_to && OppStt->is_Arc) {
			if (OppStt->arc_SubPath!=EmptyStr || OppStt->arc_RetList->Count>0 || TestCurIncDir()) UserAbort(USTR_OpeNotSuported);
			if (!usr_ARC->IsAvailable(OppStt->arc_Name)) UserAbort(USTR_CantOperate);
			tmp = (sel_cnt>0)? LoadUsrMsg(USTR_SelectedItem) : get_DispName(cfp);
			if (!msgbox_Sure(LoadUsrMsg(USTR_CopyQ, tmp), sure_copy)) SkipAbort();

			StartLog(msg.sprintf(cpy_fmt, src_dir.c_str(), OppStt->arc_Name.c_str()));
			CurWorking = true;

			for (int i=0; i<lst->Count; i++) {
				file_rec *fp = (file_rec*)lst->Objects[i];
				if (fp->selected || (sel_cnt==0 && i==cur_idx)) {
					if (dst_nam.IsEmpty()) dst_nam = fp->n_name;
					msg = make_LogHdr(_T("COPY"), fp);
					if (!usr_ARC->AddFile(OppStt->arc_Name, fp->f_name)) set_LogErrMsg(msg, usr_ARC->ErrMsg);
					AddLog(msg);
					if (msg[1]=='E') UserAbort(USTR_FaildCopy);
					fp->selected = false;
					InvalidateFileList();
				}
			}
			if (sel_cnt>0) RepaintList(CurListTag);

			CurWorking = false;
			EndLog(_T("コピー"));

			ChangeArcFileListEx(OppStt->arc_Name, OppStt->arc_SubPath, OppListTag);
			if (op_mode>0 && !dst_nam.IsEmpty()) IndexOfFileList(dst_nam, OppListTag);
		}
		//代替データストリームへコピー
		else if (!is_to && OppStt->is_ADS) {
			if (TestCurIncDir()) UserAbort(USTR_CantOperate);
			tmp = (sel_cnt>0)? LoadUsrMsg(USTR_SelectedItem) : get_DispName(cfp);
			if (!msgbox_Sure(LoadUsrMsg(USTR_CopyQ, tmp), sure_copy)) SkipAbort();

			StartLog(msg.sprintf(cpy_fmt, src_dir.c_str(), OppStt->ads_Name.c_str()));
			CurWorking = true;
			CancelWork = false;
			BeginWorkProgress(_T("代替データストリームへコピー"), EmptyStr, FileListBox[CurListTag], true);
			bool ow_all = false, sk_all = false;
			for (int i=0; i<lst->Count && !CancelWork; i++) {
				file_rec *fp = (file_rec*)lst->Objects[i];
				if (fp->selected || (sel_cnt==0 && i==cur_idx)) {
					UnicodeString dst_nam = OppStt->ads_Name + ":" + ExtractFileName(fp->f_name);
					if (CopyAdsCore(fp->f_name, dst_nam, ow_all, sk_all)) fp->selected = false;
					InvalidateFileList();
				}
			}
			ChangeAdsList(OppStt->ads_Name, OppListTag);
			CurWorking = false;

			if (CancelWork) {
				EndWorkProgress(EmptyStr, LoadUsrMsg(USTR_Canceled));
				AddLog(_T("コピー中断"));
			}
			else {
				EndWorkProgress();
				EndLog(_T("コピー"));
			}
		}
		//代替データストリームからコピー
		else if (CurStt->is_ADS) {
			if (!IsOppFList()) UserAbort(USTR_CantOperate);
			tmp = (sel_cnt>0)? LoadUsrMsg(USTR_SelectedItem) : get_DispName(cfp);
			if (!msgbox_Sure(LoadUsrMsg(USTR_CopyQ, tmp), sure_copy)) SkipAbort();

			StartLog(msg.sprintf(cpy_fmt, CurStt->ads_Name.c_str(), dst_dir.c_str()));
			CurWorking = true;
			CancelWork = false;
			BeginWorkProgress(_T("代替データストリームからコピー"), EmptyStr, FileListBox[CurListTag], true);
			bool ow_all = false, sk_all = false;
			for (int i=0; i<lst->Count && !CancelWork; i++) {
				file_rec *fp = (file_rec*)lst->Objects[i];
				if (fp->selected || (sel_cnt==0 && i==cur_idx)) {
					UnicodeString dst_nam = dst_dir + ExtractFileName(fp->f_name);
					if (CopyAdsCore(fp->f_name, dst_nam, ow_all, sk_all)) fp->selected = false;
					InvalidateFileList();
				}
			}
			CurWorking = false;

			if (CancelWork) {
				EndWorkProgress(EmptyStr, LoadUsrMsg(USTR_Canceled));
				AddLog(_T("コピー中断"));
			}
			else {
				EndWorkProgress();
				EndLog(_T("コピー"));
			}
		}
		//FTPからコピー(ダウンロード)
		else if (CurStt->is_FTP) {
			if (!IdFTP1->Connected()) { RecoverFileList();  Abort(); }
			if (TestCurIncDir()) UserAbort(USTR_IncludeDir);
			tmp = (sel_cnt>0)? LoadUsrMsg(USTR_SelectedItem) : get_DispName(cfp);
			if (!msgbox_Sure(LoadUsrMsg(USTR_DownloadQ, tmp), sure_copy)) SkipAbort();

			StartLog(msg.sprintf(_T("ダウンロード開始  %s\t%s"), ftp_dir.c_str(), dst_dir.c_str()));
			BeginWorkProgress(LoadUsrMsg(USTR_Download), EmptyStr, FileListBox[CurListTag], true);
			CurWorking	= true;
			CancelWork	= false;
			gCopyAll	= gCopyCancel = false;
			int dl_cnt = 0;
			for (int i=0; i<lst->Count; i++) {
				file_rec *fp = (file_rec*)lst->Objects[i];
				if (fp->selected || (sel_cnt==0 && i==cur_idx)) {
					if (sel_cnt>1) ProgressLabel->Caption = tmp.sprintf(_T("ダウンロード %u/%u"), dl_cnt + 1, sel_cnt);
					DownloadFtpCore(fp, dst_dir);
					if (gCopyCancel || CancelWork) break;
					fp->selected = false;
					dl_cnt++;
					InvalidateFileList();
					SetDriveInfo();
					ReloadList(OppListTag);
				}
			}
			if (sel_cnt>0) RepaintList(CurListTag);
			RepaintList(OppListTag);
			CurWorking = false;

			if (gCopyCancel || CancelWork) {
				EndWorkProgress(EmptyStr, LoadUsrMsg(USTR_Canceled));
				AddLog(_T("ダウンロード中断"), true);
			}
			else {
				EndWorkProgress();
				EndLog(USTR_Download);
				play_sound(FTPSndTransfer);
			}
		}
		//FTPへコピー(アップロード)
		else if (OppStt->is_FTP) {
			if (TestCurIncDir()) UserAbort(USTR_IncludeDir);
			tmp = (sel_cnt>0)? LoadUsrMsg(USTR_SelectedItem) : get_DispName(cfp);
			if (!msgbox_Sure(LoadUsrMsg(USTR_UploadQ, tmp), sure_copy)) SkipAbort();

			StartLog(msg.sprintf(_T("アップロード開始  %s\t%s"), src_dir.c_str(), ftp_dir.c_str()));
			BeginWorkProgress(LoadUsrMsg(USTR_Upload), EmptyStr, FileListBox[OppListTag], true);
			CurWorking = true;
			CancelWork = false;
			gCopyAll   = gCopyCancel = false;
			int up_cnt = 0;
			for (int i=0; i<lst->Count && !gCopyCancel; i++) {
				file_rec *fp = (file_rec*)lst->Objects[i];
				if (fp->selected || (sel_cnt==0 && i==cur_idx)) {
					if (sel_cnt>1) ProgressLabel->Caption = tmp.sprintf(_T("アップロード %u/%u"), up_cnt + 1, sel_cnt);
					UploadFtpCore(fp);
					if (gCopyCancel || CancelWork) break;
					fp->selected = false;
					up_cnt++;
					InvalidateFileList();
					SetDriveInfo();
				}
			}
			if (sel_cnt>0) RepaintList(CurListTag);
			CurWorking = false;

			if (gCopyCancel || CancelWork) {
				EndWorkProgress(EmptyStr, LoadUsrMsg(USTR_Canceled));
				AddLog(_T("アップロード中断"), true);
				if (CancelWork) FTPDisconnectAction->Execute();
			}
			else {
				EndWorkProgress();
				EndLog(USTR_Upload);
				int rm_tag = OppStt->is_FTP? OppListTag : CurStt->is_FTP? CurListTag : -1;
				if (rm_tag!=-1 && !ChangeFtpFileList(rm_tag)) GlobalAbort();
				play_sound(FTPSndTransfer);
			}
		}
		//ワークリストへ
		else if (!is_to && OppStt->is_Work) {
			if (WorkListFiltered) UserAbort(USTR_WorkFiltered);

			//選択項目
			if (sel_cnt>0) {
				if (!msgbox_Sure(_T("選択項目を登録しますか?"), sure_copy)) SkipAbort();
			}
			//カーソル位置
			else {
				if (WorkList->IndexOf(cfp->f_name)!=-1) UserAbort(USTR_Registered);
				if (!msgbox_Sure(msg.sprintf(_T("%s を登録しますか?"), get_DispName(cfp).c_str()), sure_copy)) SkipAbort();
			}

			int ins_idx = (RegWorkCsrPos && (NotSortWorkList || WorkListHasSep) && is_selectable(GetOppFrecPtr()))?
								FileListBox[OppListTag]->ItemIndex : -1;

			for (int i=0; i<lst->Count; i++) {
				file_rec *fp = (file_rec*)lst->Objects[i];
				if (fp->selected || (sel_cnt==0 && i==cur_idx)) {
					if (dst_nam.IsEmpty()) dst_nam = fp->f_name;
					if (WorkList->IndexOf(fp->f_name)!=-1) continue;
					fp->selected = false;
					file_rec *lfp = cre_new_file_rec(fp);
					if (ins_idx==-1) {
						WorkList->AddObject(lfp->f_name, (TObject*)lfp);
					}
					else {
						WorkList->InsertObject(ins_idx, lfp->f_name, (TObject*)lfp);
						ins_idx++;
					}
					InvalidateFileList();
				}
			}
			if (sel_cnt>0) RepaintList(CurListTag);

			ChangeWorkList(OppListTag);
			rqWorkListDirInf = !WorkListChanged;
			WorkListChanged  = true;
			if (op_mode>0 && !dst_nam.IsEmpty()) IndexOfFileList(dst_nam, OppListTag);
		}
		//タグ検索結果リストへ(タグ追加)
		else if (OppStt->is_Find && OppStt->find_TAG) {
			UnicodeString tags = OppStt->find_Keywd;
			//選択項目
			if (sel_cnt>0) {
				msg.sprintf(_T("選択項目にタグ[%s]を追加しますか?"), tags.c_str());
				if (!msgbox_Sure(msg, sure_copy)) SkipAbort();
			}
			//カーソル位置
			else {
				msg.sprintf(_T("%s にタグ[%s]を追加しますか?"), get_DispName(cfp).c_str(), tags.c_str());
				if (!msgbox_Sure(msg, sure_copy)) SkipAbort();
			}

			SetTags(tags, true);
			RepaintList(CurListTag);
			ReloadList(OppListTag);
		}
		//ファイルリスト/ワークリストから/ディレクトリ比較結果リスト間
		else {
			std::unique_ptr<TStringList> tsk_lst(new TStringList());
			std::unique_ptr<TStringList> dst_lst(new TStringList());
			UnicodeString syn_opt = get_SyncDstList(dst_dir, dst_lst.get(), false, src_dir);
			UnicodeString cmd = "CPY";
			UnicodeString tprm;
			//選択項目
			if (sel_cnt>0) {
				msg = LoadUsrMsg(USTR_CopyQ, USTR_SelectedItem);
				if (dst_lst->Count>1) msg += "\r\n(同期コピー先あり)";
				if (!msgbox_Sure(msg, sure_copy)) SkipAbort();
				for (int i=0; i<lst->Count; i++) {
					file_rec *fp = (file_rec*)lst->Objects[i];
					if (!fp->selected) continue;
					if (fp->f_attr!=faInvalid) {
						tsk_lst->Add(tprm.sprintf(_T("%s\t%s\t"),
							cmd.c_str(), (fp->is_dir? IncludeTrailingPathDelimiter(fp->f_name) : fp->f_name).c_str()));
						fp->selected = false;
					}
				}
				RepaintList(CurListTag);
			}
			//カーソル位置
			else {
				msg = LoadUsrMsg(USTR_CopyQ, get_DispName(cfp));
				if (dst_lst->Count>1) msg += "\r\n(同期コピー先あり)";
				if (!msgbox_Sure(msg, sure_copy)) SkipAbort();
				if (cfp->f_attr!=faInvalid) {
					tsk_lst->Add(tprm.sprintf(_T("%s\t%s\t"),
						cmd.c_str(), (cfp->is_dir? IncludeTrailingPathDelimiter(cfp->f_name) : cfp->f_name).c_str()));
				}
			}

			//タスク開始
			if (tsk_lst->Count>0) {
				TDateTime flt_dt;
				int flt_cnd = get_DateCond(ActionParam, flt_dt);
				if (flt_cnd==-1) UserAbort(USTR_IllegalDtCond);

				//コピー先を設定
				for (int i=0; i<dst_lst->Count; i++) {
					//コピー先を設定
					UnicodeString dnam = dst_lst->Strings[i];
					std::unique_ptr<TStringList> t_buf(new TStringList());
					t_buf->Assign(tsk_lst.get());
					for (int j=0; j<t_buf->Count; j++) {
						UnicodeString dst_nam = dnam;
						if (!is_to && i==0 && IsDiffList()) {
							dst_nam = ExtractFilePath(Trim(get_post_tab(t_buf->Strings[j])));
							dst_nam = dnam + get_tkn_r(dst_nam, CurPath[CurListTag]);
						}
						t_buf->Strings[j] = t_buf->Strings[j] + dst_nam;
					}

					//タスク設定
					TaskConfig  *cp = NULL;
					TTaskThread *tp = CreTaskThread(&cp);	if (!cp) Abort();
					cp->TaskList->Assign(t_buf.get());
					if (i==0) {
						cp->CopyMode = (xCopyMode>=0)? xCopyMode : (IsCurFList() && EqualDirLR())? gCopyMode2 : gCopyMode;
						cp->CopyAll  = (xCopyMode>=0);
						xCopyMode	 = -1;
					}
					else if (ContainsText(syn_opt, "O")) {
						cp->CopyMode = CPYMD_OW;
						cp->CopyAll  = true;
					}

					cp->CopyFmt  = AutoRenFmt;
					cp->CmdStr	 = TaskCmdList->Values[cmd];
					cp->DistPath = dnam;
					cp->InfStr	 = msg.sprintf(_T("%s ---> %s"),
									(CurStt->is_Work? ExtractFileName(WorkListName) : src_dir).c_str(), dnam.c_str());
					//日付条件
					if (flt_cnd>0) {
						cp->FilterMode = flt_cnd;
						cp->FilterTime = flt_dt;
						cp->InfStr.cat_sprintf(_T(" (%s%s)"),
							UnicodeString("<=>").SubString(flt_cnd, 1).c_str(), format_Date(flt_dt).c_str());
					}

					cp->DstPosMode = op_mode;
					ActivateTask(tp, cp);
				}
			}
		}
	}
	catch (EAbort &e) {
		SetActionAbort(e.Message);
	}
	catch (...) {
		SetInternalException();
	}

	del_file_rec(cfp);
}
//---------------------------------------------------------------------------
//指定ディレクトリへコピー
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::CopyToActionExecute(TObject *Sender)
{
	ActionDstDir = to_absolute_name(cv_env_str(ActionParam), CurPath[CurListTag]);
	ActionParam  = EmptyStr;
	if (!ActionDstDir.IsEmpty()) CopyAction->Execute(); else SetActionAbort();
	ActionDstDir = EmptyStr;
}

//---------------------------------------------------------------------------
//移動
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::MoveActionExecute(TObject *Sender)
{
	file_rec *cfp = cre_new_file_rec(GetCurFrecPtr(true));

	try {
		if (CurStt->is_Arc || CurStt->is_ADS ||CurStt->is_Work || CurStt->is_FTP || IsDiffList())
			UserAbort(USTR_CantOperate);

		TStringList *lst = GetCurList(true);
		bool lst_sel = ListSelected(lst);
		if (TEST_DEL_ActParam("SO") && !lst_sel) SkipAbort();
		if (!lst_sel && (cfp->f_name.IsEmpty() || cfp->is_dummy)) Abort();

		bool is_to = false;
		UnicodeString src_dir = GetCurPathStr();
		UnicodeString dst_dir = GetDistDir(true, &is_to);
		if (!is_to && !IsOppFList()) UserAbort(USTR_CantOperate);
		if (get_drive_type(src_dir)==DRIVE_CDROM) UserAbort(USTR_CantOperate);
		if (is_drive_protected(src_dir) || is_drive_protected(dst_dir)) SysErrAbort(ERROR_WRITE_PROTECT);
		if (TestCurIncFindVirtual()) UserAbort(USTR_CantOperate);

		if (CurStt->is_Find) {
			if (lst_sel) {
				for (int i=0; i<lst->Count; i++) {
					file_rec *fp = (file_rec*)lst->Objects[i];
					if (!fp->selected) continue;
					if (SameText(fp->p_name, dst_dir)) UserAbort(USTR_SameMoveDest);
				}
			}
			else if (SameText(cfp->p_name, dst_dir)) UserAbort(USTR_SameMoveDest);
		}
		else if (SameText(src_dir, dst_dir)) UserAbort(USTR_SameMoveDest);

		bool sure_move = (ExeCmdsBusy && XCMD_MsgOff)? false : SureMove;
		std::unique_ptr<TStringList> tsk_lst(new TStringList());
		UnicodeString cmd = "MOV";
		UnicodeString tprm;
		//選択項目
		if (lst_sel) {
			if (!msgbox_Sure(_T("選択項目を移動しますか?"), sure_move)) SkipAbort();
			for (int i=0; i<lst->Count; i++) {
				file_rec *fp = (file_rec*)lst->Objects[i];
				if (!fp->selected) continue;
				tsk_lst->Add(tprm.sprintf(_T("%s\t%s\t%s"),
					cmd.c_str(),
					(fp->is_dir? IncludeTrailingPathDelimiter(fp->f_name) : fp->f_name).c_str(), dst_dir.c_str()));
				fp->selected = false;
			}
			RepaintList(CurListTag);
		}
		//カーソル位置
		else {
			if (!cfp || cfp->is_dummy) Abort();
			UnicodeString msg;
			if (!msgbox_Sure(msg.sprintf(_T("%s を移動しますか?"), get_DispName(cfp).c_str()),  sure_move)) SkipAbort();
			tsk_lst->Add(tprm.sprintf(_T("%s\t%s\t%s"),
				cmd.c_str(),
				(cfp->is_dir? IncludeTrailingPathDelimiter(cfp->f_name) : cfp->f_name).c_str(), dst_dir.c_str()));
		}

		//タスク開始
		if (tsk_lst->Count>0) {
			TaskConfig  *cp = NULL;
			TTaskThread *tp = CreTaskThread(&cp);	if (!cp) Abort();
			cp->TaskList->Assign(tsk_lst.get());
			cp->CopyMode = (xCopyMode>=0)? xCopyMode : EqualDirLR()? gCopyMode2 : gCopyMode;
			cp->CopyAll  = (xCopyMode>=0);
			xCopyMode	 = -1;
			cp->CopyFmt	 = AutoRenFmt;
			cp->CmdStr	 = TaskCmdList->Values[cmd];
			cp->DistPath = dst_dir;
			cp->InfStr.sprintf(_T("%s ---> %s"), src_dir.c_str(), dst_dir.c_str());
			cp->UpdDirList->Add(src_dir);
			cp->DstPosMode = TEST_DEL_ActParam("OP")? 1 : TEST_DEL_ActParam("OP2")? 2 : 0;
			ActivateTask(tp, cp);
		}
	}
	catch (EAbort &e) {
		SetActionAbort(e.Message);
	}

	del_file_rec(cfp);
}
//---------------------------------------------------------------------------
//指定ディレクトリへ移動
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::MoveToActionExecute(TObject *Sender)
{
	ActionDstDir = to_absolute_name(cv_env_str(ActionParam), CurPath[CurListTag]);
	ActionParam  = EmptyStr;
	if (!ActionDstDir.IsEmpty()) MoveAction->Execute(); else SetActionAbort();
	ActionDstDir = EmptyStr;
}

//---------------------------------------------------------------------------
//対象のコピー(エクスプローラー相当)
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::CopyToClipActionExecute(TObject *Sender)
{
	try {
		if (!IsCurFList()) UserAbort(USTR_CantOperate);
		std::unique_ptr<TStringList> flst(new TStringList());
		if (GetCurObjList(flst.get())==0) Abort();
		if (!usr_SH->InvokeMenuCmd(Handle, CurPath[CurListTag], flst.get(), "copy")) UserAbort(USTR_FaildProc);
	}
	catch (EAbort &e) {
		SetActionAbort(e.Message);
	}
}
//---------------------------------------------------------------------------
//対象の切り取り(エクスプローラー相当)
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::CutToClipActionExecute(TObject *Sender)
{
	try {
		if (!IsCurFList()) UserAbort(USTR_CantOperate);
		std::unique_ptr<TStringList> flst(new TStringList());
		if (GetCurObjList(flst.get())==0) Abort();
		if (!usr_SH->InvokeMenuCmd(Handle, CurPath[CurListTag], flst.get(), "cut")) UserAbort(USTR_FaildProc);
	}
	catch (EAbort &e) {
		SetActionAbort(e.Message);
	}
}

//---------------------------------------------------------------------------
//貼り付け
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::PasteActionExecute(TObject *Sender)
{
	try {
		//リンク項目
		if (Clipboard()->HasFormat(::RegisterClipboardFormat(CFSTR_INETURL)) &&
			Clipboard()->HasFormat(::RegisterClipboardFormat(CFSTR_FILEDESCRIPTORW)))
		{
			if (!IsCurFList()) UserAbort(USTR_CantOperate);
			//URL
			UnicodeString url;
			std::unique_ptr<TStringList> sbuf(new TStringList());
			sbuf->Text = (LPTSTR)Clipboard()->GetAsHandle(::RegisterClipboardFormat(CFSTR_INETURL));
			if		(sbuf->Count==2) url = sbuf->Strings[1];
			else if (sbuf->Count==1) url = sbuf->Strings[0];
			//タイトル
			UnicodeString fnam;
			FILEGROUPDESCRIPTOR *fg = (FILEGROUPDESCRIPTOR*)Clipboard()->GetAsHandle(
										::RegisterClipboardFormat(CFSTR_FILEDESCRIPTORW));
			if (fg && fg->cItems>0) fnam = GetCurPathStr() + fg->fgd[0].cFileName;
			if (!make_url_file(fnam, url)) Abort();
		}
		//ファイル
		else if (Clipboard()->HasFormat(CF_HDROP)) {
			if (CurStt->is_Arc || CurStt->is_ADS || CurStt->is_Find || CurStt->is_FTP) UserAbort(USTR_CantOperate);
			bool is_move = false;
			//クリップボードから貼り付け対象を取得
			std::unique_ptr<TStringList> f_lst(new TStringList());
			Clipboard()->Open();
			{
				HDROP dp = (HDROP)Clipboard()->GetAsHandle(CF_HDROP);
				if (dp) {
					UINT f_cnt = ::DragQueryFile(dp, 0xFFFFFFFF, NULL, 0);
					UnicodeString fnam;
					for (UINT i=0; i<f_cnt; i++) {
						fnam.SetLength(MAX_PATH);
						int len = ::DragQueryFile(dp, i, fnam.c_str(),fnam.Length());
						fnam.SetLength(len);
						int atr = file_GetAttr(fnam);
						if (atr==faInvalid) UserAbort(USTR_CantAccessDir);
						if (faDirectory & atr) fnam = IncludeTrailingPathDelimiter(fnam);
						f_lst->Add(fnam);
					}
				}
				//コピー or 切り取り を調べる
				DWORD *ep = (DWORD*)Clipboard()->GetAsHandle(
								::RegisterClipboardFormat(CFSTR_PREFERREDDROPEFFECT));
				if (ep) is_move = (*ep & DROPEFFECT_MOVE);
			}
			Clipboard()->Close();
			if (f_lst->Count==0) Abort();
			f_lst->Sort();

			//ワークリストに登録
			if (CurStt->is_Work) {
				//登録
				int ins_idx = GetCurIndex();
				for (int i=0; i<f_lst->Count; i++) {
					file_rec *fp = cre_new_file_rec(f_lst->Strings[i]);  if (!fp) continue;
					if (WorkList->IndexOf(fp->f_name)!=-1) { del_file_rec(fp); continue; }
					if (ins_idx!=-1)
						WorkList->InsertObject(ins_idx++, fp->f_name, (TObject*)fp);
					else
						WorkList->AddObject(fp->f_name, (TObject*)fp);
				}
				ChangeWorkList(CurListTag);
				FileListBox[CurListTag]->ItemIndex = ins_idx - 1;
				rqWorkListDirInf = !WorkListChanged;
				WorkListChanged  = true;
			}
			//ファイルリスト
			else {
				UnicodeString cmd, tprm;
				cmd.sprintf(_T("%s"), is_move? _T("MOV") : _T("CPY"));
				TaskConfig  *cp = NULL;
				TTaskThread *tp = CreTaskThread(&cp);	if (!cp) Abort();
				UnicodeString dnam = GetCurPathStr();
				//コピーで同名の場合クローン化
				if ((TEST_ActParam("CL") && !is_move)) {
					MakeCloneTaskList(f_lst.get(), dnam, AutoRenFmt, false, cp->TaskList);
					cp->CopyMode = CPYMD_AUT_REN;
					cp->CopyAll  = true;
				}
				//通常動作
				else {
					for (int i=0; i<f_lst->Count; i++)
						cp->TaskList->Add(tprm.sprintf(_T("%s\t%s\t%s"), cmd.c_str(), f_lst->Strings[i].c_str(), dnam.c_str()));
					cp->CopyMode = gCopyMode;
					cp->CopyAll  = false;
				}
				cp->CopyFmt	 = AutoRenFmt;
				cp->CmdStr	 = TaskCmdList->Values[cmd];
				cp->DistPath = dnam;
				cp->InfStr	 = "CLIPBOARD ---> " + dnam;
				ActivateTask(tp, cp);
			}
		}
		else Abort();
	}
	catch (EAbort &e) {
		SetActionAbort(e.Message);
	}
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::PasteActionUpdate(TObject *Sender)
{
	TAction *ap = (TAction*)Sender;
	ap->Visible = ScrMode==SCMD_FLIST;
	ap->Enabled = ap->Visible && !CurWorking && !FindBusy && !CalcBusy
					&& (Clipboard()->HasFormat(CF_HDROP) || Clipboard()->HasFormat(::RegisterClipboardFormat(CFSTR_INETURL)));
}

//---------------------------------------------------------------------------
//クローン用タスクリストの作成
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::MakeCloneTaskList(
	TStringList *src_lst,		//クローン元リスト(ディレクトリは末尾が\)
	UnicodeString dst_path,		//クローン先ディレクトリ
	UnicodeString fmt,			//改名書式
	bool force,					//強制的にディレクトリをクローン化
	TStringList *tsk_lst)		//タスクリスト
{
	UnicodeString tmp;
	for (int i=0; i<src_lst->Count; i++) {
		UnicodeString snam = src_lst->Strings[i];
		//ディレクトリ
		if (ends_PathDlmtr(snam)) {
			UnicodeString src_path = snam;
			UnicodeString src_dir  = ExcludeTrailingPathDelimiter(src_path);
			//コピー
			if (!force &&
				!(SameText(ExtractFilePath(src_dir), dst_path) && file_exists(dst_path + ExtractFileName(src_dir))))
			{
				tsk_lst->Add(tmp.sprintf(_T("CPY\t%s\t%s"), src_path.c_str(), dst_path.c_str()));
			}
			//クローン化
			else {
				UnicodeString cln_path = IncludeTrailingPathDelimiter(
											format_CloneName(fmt, src_path, dst_path, true));
				UnicodeString sea_str = cv_ex_filename(src_path + "*.*");
				TSearchRec sr;
				int cnt = 0;
				if (FindFirst(sea_str, faAnyFile, sr)==0) {
					do {
						UnicodeString fnam = sr.Name;
						if (ContainsStr("..", fnam)) continue;
						fnam = src_path + fnam;
						if (sr.Attr & faDirectory) fnam = IncludeTrailingPathDelimiter(fnam);
						tsk_lst->Add(tmp.sprintf(_T("CPY\t%s\t%s"), fnam.c_str(), cln_path.c_str()));
						cnt++;
					} while(FindNext(sr)==0);
					FindClose(sr);
				}
				if (cnt==0) tsk_lst->Add(tmp.sprintf(_T("CPY\t%s\t%s"), cln_path.c_str(), dst_path.c_str()));
			}
		}
		//ファイル
		else {
			tsk_lst->Add(tmp.sprintf(_T("CPY\t%s\t%s"), snam.c_str(), dst_path.c_str()));
		}
	}
}
//---------------------------------------------------------------------------
//反対パスにクローン作成
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::CloneActionExecute(TObject *Sender)
{
	std::unique_ptr<TStringList> c_lst(new TStringList());

	bool to_cur  = USAME_TI(ActionOptStr, "ToCurrent");
	ActionOptStr = EmptyStr;

	try {
		if (!IsCurFList() || (!to_cur && !IsOppFList())) UserAbort(USTR_CantOperate);
		UnicodeString dst_path = CurPath[to_cur? CurListTag : OppListTag];

		TStringList *lst = GetCurList(true);
		int sel_cnt 	 = GetSelCount(lst);
		bool sure_copy	 = (ExeCmdsBusy && XCMD_MsgOff)? false : SureCopy;

		//書式設定
		UnicodeString fmt;
		bool force_ren = false;
		if (TEST_ActParam("IN")) {
			UnicodeString defstr = "\\N";
			if (sel_cnt<2) {
				file_rec *cfp = GetCurFrecPtr();
				if (cfp && !cfp->is_up) {
					defstr = get_base_name(GetCurFileName());
					force_ren = !cfp->is_dir;
				}
			}

			InputExDlg->IpuntExMode = INPEX_CLONE;
			InputExDlg->InputEdit->EditLabel->Caption = "名前/書式";
			InputExDlg->InputEdit->Text = defstr;
			fmt = (InputExDlg->ShowModal()==mrOk)? InputExDlg->InputEdit->Text : EmptyStr;
			if (fmt.IsEmpty()) SkipAbort();
		}
		else if (!ActionParam.IsEmpty()) {
			fmt = ActionParam;
		}

		if (fmt.IsEmpty()) fmt = FMT_AUTO_REN;

		//選択項目
		if (sel_cnt>0) {
			if (msgbox_Sure(_T("選択項目のクローンを作成しますか?"), sure_copy)) {
				for (int i=0; i<lst->Count; i++) {
					file_rec *fp = (file_rec*)lst->Objects[i];
					if (!fp->selected) continue;
					fp->selected = false;
					c_lst->Add(fp->is_dir? IncludeTrailingPathDelimiter(fp->f_name) : fp->f_name);
				}
				RepaintList(CurListTag);
			}
		}
		//カーソル位置
		else {
			file_rec *cfp = GetCurFrecPtr();	if (!cfp) Abort();
			UnicodeString msg;
			if (msgbox_Sure(msg.sprintf(_T("%s のクローンを作成しますか?"), get_DispName(cfp).c_str()), sure_copy))
				c_lst->Add(cfp->is_dir? IncludeTrailingPathDelimiter(cfp->f_name) : cfp->f_name);
		}
		if (c_lst->Count==0) SkipAbort();

		//タスク登録
		std::unique_ptr<TStringList> tsk_lst(new TStringList());
		MakeCloneTaskList(c_lst.get(), dst_path, fmt, true, tsk_lst.get());

		//タスク開始
		if (tsk_lst->Count>0) {
			TaskConfig  *cp = NULL;
			TTaskThread *tp = CreTaskThread(&cp);	if (!cp) Abort();
			cp->TaskList->Assign(tsk_lst.get());
			cp->CopyMode = force_ren? CPYMD_REN_CLONE : CPYMD_AUT_REN;
			cp->CopyAll  = true;
			cp->CopyFmt  = fmt;
			cp->CmdStr	 = "クローン作成";
			UnicodeString dst_dir = GetCurPathStr(to_cur? CurListTag : OppListTag);
			cp->DistPath = dst_dir;
			cp->InfStr.sprintf(_T("%s ---> %s"), GetCurPathStr().c_str(), dst_dir.c_str());
			ActivateTask(tp, cp);
		}
	}
	catch (EAbort &e) {
		clear_FileList(c_lst.get());
		SetActionAbort(e.Message);
	}
}
//---------------------------------------------------------------------------
//カレントにクローン作成
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::CloneToCurrActionExecute(TObject *Sender)
{
	ActionOptStr = "ToCurrent";
	CloneAction->Execute();
}

//---------------------------------------------------------------------------
//削除
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::DeleteActionExecute(TObject *Sender)
{
	file_rec *cfp = cre_new_file_rec(GetCurFrecPtr(true));

	try {
		TStringList *lst = GetCurList(true);
		int sel_cnt = GetSelCount(lst);
		int cur_idx = FileListBox[CurListTag]->ItemIndex;

		if (is_drive_protected(CurPath[CurListTag])) SysErrAbort(ERROR_WRITE_PROTECT);
		if (TEST_ActParam("SO") && sel_cnt==0) SkipAbort();
		if (TestCurIncFindVirtual()) UserAbort(USTR_OpeNotSuported);

		bool sure_del = (ExeCmdsBusy && XCMD_MsgOff)? false : SureDelete;
		UnicodeString msg, tmp;

		//-----------------------
		//アーカイブ
		//-----------------------
		if (CurStt->is_Arc) {
			if (CurStt->arc_RetList->Count>0) UserAbort(USTR_OpeNotSuported);
			int ok_cnt = 0, er_cnt = 0;
			//選択項目
			if (sel_cnt>0) {
				if (!msgbox_Sure(LoadUsrMsg(USTR_DeleteQ, USTR_SelectedItem), sure_del)) SkipAbort();
			}
			//カーソル位置
			else {
				if (cfp->f_name.IsEmpty() || cfp->is_dummy) Abort();
				if (!msgbox_Sure(LoadUsrMsg(USTR_DeleteQ, get_DispName(cfp) + " "), sure_del)) SkipAbort();
			}

			StartLog(LoadUsrMsg(USTR_BeginDelete, CurStt->arc_Name));
			CurWorking = true;
			UnicodeString cur_fnam = cfp->f_name;
			for (int i=0; i<lst->Count; i++) {
				file_rec *fp = (file_rec*)lst->Objects[i];
				if (fp->selected || (sel_cnt==0 && i==cur_idx)) {
					UnicodeString fnam = fp->f_name;
					if (fp->is_dir) fnam = ExcludeTrailingPathDelimiter(fnam);
					msg = make_LogHdr(_T("DELETE"), fnam);
					UnicodeString res_file = make_ResponseFile(fnam, usr_ARC->GetArcType(CurStt->arc_Name));
					if (res_file==RESPONSE_ERR) {
						set_LogErrMsg(msg, LoadUsrMsg(USTR_FaildListFile));
					}
					else {
						if (!res_file.IsEmpty()) fnam = "@" + res_file;
						if (!usr_ARC->DelFile(CurStt->arc_Name, fnam, true)) set_LogErrMsg(msg, usr_ARC->ErrMsg);
						delete_FileIf(res_file);
					}
					AddLog(msg);
					((msg[1]=='E')? er_cnt : ok_cnt)++;
					InvalidateFileList();
				}
			}
			ChangeArcFileListEx(CurStt->arc_Name, CurStt->arc_SubPath, CurListTag);
			IndexOfFileList(cur_fnam, CurListTag);
			CurWorking = false;
			EndLog(_T("削除"), get_res_cnt_str(ok_cnt, er_cnt));
		}
		//-----------------------
		//FTP
		//-----------------------
		else if (CurStt->is_FTP) {
			if (!IdFTP1->Connected()) { RecoverFileList();  Abort(); }
			UnicodeString ftp_dir = yen_to_slash(CurFTPPath);

			int ok_cnt = 0, er_cnt = 0;
			//選択項目
			if (sel_cnt>0) {
				if (!msgbox_Sure(LoadUsrMsg(USTR_DeleteQ, USTR_SelectedItem), sure_del)) SkipAbort();
			}
			//カーソル位置
			else {
				if (cfp->f_name.IsEmpty() || cfp->is_dummy) Abort();
				if (!msgbox_Sure(LoadUsrMsg(USTR_DeleteQ, get_DispName(cfp) + " "), sure_del)) SkipAbort();
			}

			StartLog(LoadUsrMsg(USTR_BeginDelete, ftp_dir));
			CurWorking = true;
			for (int i=0; i<lst->Count; i++) {
				file_rec *fp = (file_rec*)lst->Objects[i];
				if (fp->selected || (sel_cnt==0 && i==cur_idx)) {
					msg = make_LogHdr(_T("DELETE"), fp);
					try {
						if (fp->is_dir)
							IdFTP1->RemoveDir(fp->n_name);
						else
							IdFTP1->Delete(fp->n_name);
					}
					catch (...) {
						msg[1] = 'E';
					}
					((msg[1]=='E')? er_cnt : ok_cnt)++;
					add_FTPLogMsg(msg);
					InvalidateFileList();
				}
			}
			if (!ChangeFtpFileList()) GlobalAbort();
			CurWorking = false;
			EndLog(_T("削除"), get_res_cnt_str(ok_cnt, er_cnt));
		}
		//-----------------------
		//ワークリスト
		//-----------------------
		else if (CurStt->is_Work) {
			if (WorkListFiltered) UserAbort(USTR_WorkFiltered);

			//選択項目
			if (sel_cnt>0) {
				if (!msgbox_Sure(_T("選択項目をワークリストから外しますか?"), sure_del)) SkipAbort();
				int i = 0;
				while (i<lst->Count) {
					if (((file_rec*)lst->Objects[i])->selected) del_FileListItem(lst, i); else i++;
				}
			}
			//カーソル位置
			else {
				file_rec *cwp = GetCurFrecPtr();	if (!cwp) Abort();
				if (cwp->is_dummy && cwp->alias.IsEmpty()) Abort();
				if (!msgbox_Sure(get_DispName(cwp) + " をワークリストから外しますか?", sure_del)) SkipAbort();
				del_FileListItem(lst, lst->IndexOfObject((TObject*)cwp));
			}
			//結果反映
			ChangeWorkList(CurListTag);
			SetFileInf();
			rqWorkListDirInf = !WorkListChanged;
			WorkListChanged  = true;
		}
		//-----------------------
		//ファイルリスト
		//-----------------------
		else {
			//削除制限項目のチェック
			if (IncProtectItem()) SkipAbort();

			//選択項目
			if (sel_cnt>0) {
				file_rec *sfp = GetCurRepFrecPtr();
				if (sel_cnt==1 && sfp->is_dir) {
					msg = sfp->is_sym?
							LoadUsrMsg(USTR_DeleteQ, tmp.sprintf(_T("リンク %s "), get_DispName(sfp).c_str())) :
							LoadUsrMsg(USTR_DeleteQ, tmp.sprintf(_T("ディレクトリ %s 全体"), get_DispName(sfp).c_str()));
				}
				else if (TestCurIncDir()) {
					msg = LoadUsrMsg(USTR_DeleteQ, _T("ディレクトリを含む選択項目"));
				}
				else {
					msg = LoadUsrMsg(USTR_DeleteQ, USTR_SelectedItem);
				}
				if (has_SyncDir(CurPath[CurListTag], true)) msg += "\r\n(同期先を含む)";
				if (!msgbox_Sure(msg, sure_del)) SkipAbort();

				bool opp_is_sub = false;
				for (int i=0; i<lst->Count && !opp_is_sub; i++) {
					file_rec *fp = (file_rec*)lst->Objects[i];
					if (fp->selected && fp->is_dir &&
						StartsText(IncludeTrailingPathDelimiter(fp->f_name), CurPath[OppListTag]))
							opp_is_sub = true;
				}
				if (opp_is_sub) CurrToOppAction->Execute();
				DeleteSelFiles(lst);
			}
			//カーソル位置
			else {
				if (cfp->f_name.IsEmpty() || cfp->is_dummy) Abort();
				if (cfp->is_dir) {
					msg = cfp->is_sym?
						LoadUsrMsg(USTR_DeleteQ, tmp.sprintf(_T("リンク %s "), get_DispName(cfp).c_str())) :
						LoadUsrMsg(USTR_DeleteQ, tmp.sprintf(_T("ディレクトリ %s 全体"), get_DispName(cfp).c_str()));
				}
				else
					msg = LoadUsrMsg(USTR_DeleteQ, tmp.sprintf(_T("%s "), get_DispName(cfp).c_str()));
				if (has_SyncDir(CurPath[CurListTag], true)) msg += "\r\n(同期先を含む)";
				if (!msgbox_Sure(msg, sure_del)) SkipAbort();

				if (cfp->is_dir &&
					StartsText(IncludeTrailingPathDelimiter(cfp->f_name), CurPath[OppListTag]))
						CurrToOppAction->Execute();
				DeleteFileP(cfp);
			}
		}
	}
	catch (EAbort &e) {
		SetActionAbort(e.Message);
	}
	catch (...) {
		SetInternalException();
	}

	del_file_rec(cfp);
}

//---------------------------------------------------------------------------
//代替データストリームを削除
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::DeleteADSActionExecute(TObject *Sender)
{
	try {
		if (is_drive_protected(CurPath[CurListTag])) SysErrAbort(ERROR_WRITE_PROTECT);
		if (CurStt->is_Arc || CurStt->is_FTP)	UserAbort(USTR_CantOperate);
		if (TestCurIncDir())					UserAbort(USTR_IncludeDir);
		if (TestCurIncFindVirtual())			UserAbort(USTR_CantOperate);

		bool only_zi = TEST_ActParam("ZI");
		if (!msgbox_Sure(
			LoadUsrMsg(USTR_DeleteQ, only_zi? _T("Zone.Identifier") : _T("代替データストリーム")),
			(ExeCmdsBusy && XCMD_MsgOff)? false : SureDelete))
				SkipAbort();

		TStringList *lst = GetCurList(true);
		int sel_cnt = GetSelCount(lst);
		int cur_idx = FileListBox[CurListTag]->ItemIndex;

		SttWorkMsg(_T("代替データストリームを削除中..."), CurListTag);
		StartLog("ADS削除開始  " + CurPath[CurListTag]);
		CurWorking = true;
		int ok_cnt = 0, er_cnt = 0, sk_cnt = 0;
		for (int i=0; i<lst->Count; i++) {
			file_rec *fp = (file_rec*)lst->Objects[i];
			if (fp->selected || (sel_cnt==0 && i==cur_idx)) {
				UnicodeString msg = make_LogHdr(_T("DELADS"), fp);
				std::unique_ptr<TStringList> slst(new TStringList());
				switch (delete_ADS(fp->f_name, ForceDel, only_zi, slst.get())) {
				case 1:		//成功
					ok_cnt++;
					for (int i=0; i<slst->Count; i++) {
						if (i>0) msg += ", ";
						msg.cat_sprintf(_T(":%s"), slst->Strings[i].c_str());
					}
					fp->inf_list->Clear();
					fp->selected = false;
					break;
				case 0:		//失敗
					set_LogErrMsg(msg, get_LogErrMsg(slst->Text, false));
					msg[1] = 'E';  er_cnt++;
					break;
				default:	//無し
					msg[1] = 'S';
					fp->selected = false;
					sk_cnt++;
				}
				AddLog(msg);
				InvalidateFileList();
			}
		}
		CurWorking = false;
		EndLog(_T("削除"), get_res_cnt_str(ok_cnt, er_cnt, sk_cnt));
		SttWorkMsg(EmptyStr, CurListTag);
		SetFileInf();
		if (er_cnt>0) SttBarWarnUstr(USTR_FaildProc);
	}
	catch (EAbort &e) {
		SttWorkMsg(EmptyStr, CurListTag);
		SetActionAbort(e.Message);
	}
}

//---------------------------------------------------------------------------
//完全削除
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::CompleteDeleteActionExecute(TObject *Sender)
{
	try {
		if (CurStt->is_Arc || CurStt->is_Work || CurStt->is_FTP) UserAbort(USTR_CantOperate);
		if (TestCurIncFindVirtual()) UserAbort(USTR_OpeNotSuported);

		TStringList *lst = GetCurList(true);
		int sel_cnt = GetSelCount(lst);
		int cur_idx = FileListBox[CurListTag]->ItemIndex;

		if (TEST_ActParam("SO") && sel_cnt==0) SkipAbort();
		if (is_drive_protected(CurPath[CurListTag])) SysErrAbort(ERROR_WRITE_PROTECT);

		//削除制限項目のチェック
		if (IncProtectItem()) SkipAbort();

		//ファイルリスト
		UnicodeString msg, tmp;
		//選択項目
		if (sel_cnt>0) {
			file_rec *sfp = GetCurRepFrecPtr();
			if (sel_cnt==1 && sfp->is_dir)
				msg = LoadUsrMsg(USTR_CompDeleteQ, tmp.sprintf(_T("ディレクトリ %s 全体"), get_DispName(sfp).c_str()));
			else if (TestCurIncDir())
				msg = LoadUsrMsg(USTR_CompDeleteQ, _T("ディレクトリを含む選択項目"));
			else
				msg = LoadUsrMsg(USTR_CompDeleteQ, USTR_SelectedItem);
		}
		//カーソル位置
		else {
			file_rec *cfp = GetCurFrecPtr(true);
			if (!cfp || cfp->f_name.IsEmpty() || cfp->is_dummy) Abort();
			if (cfp->is_dir)
				msg = LoadUsrMsg(USTR_CompDeleteQ, tmp.sprintf(_T("ディレクトリ %s 全体"), get_DispName(cfp).c_str()));
			else
				msg = LoadUsrMsg(USTR_CompDeleteQ, get_DispName(cfp) + " ");
		}
		if (!msgbox_Sure(msg, true)) SkipAbort();
		if (SureCmpDel && !msgbox_Sure(_T("本当に完全削除してよいですか?"), true)) SkipAbort();

		std::unique_ptr<TStringList> tsk_lst(new TStringList());
		UnicodeString cmd = "CMPDEL", tprm;
		for (int i=0; i<lst->Count; i++) {
			file_rec *fp = (file_rec*)lst->Objects[i];
			if (fp->selected || (sel_cnt==0 && i==cur_idx)) {
				tsk_lst->Add(tprm.sprintf(_T("%s\t%s"),
					cmd.c_str(), (fp->is_dir? IncludeTrailingPathDelimiter(fp->f_name) : fp->f_name).c_str()));
			}
		}

		if (tsk_lst->Count>0) {
			TaskConfig  *cp = NULL;
			TTaskThread *tp = CreTaskThread(&cp);	if (!cp) Abort();
			cp->TaskList->Assign(tsk_lst.get());
			cp->CmdStr	 = TaskCmdList->Values[cmd];
			cp->DistPath = GetCurPathStr();
			cp->InfStr	 = cp->DistPath;
			ActivateTask(tp, cp);
		}
	}
	catch (EAbort &e) {
		SetActionAbort(e.Message);
	}
}

//---------------------------------------------------------------------------
//バックアップ
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::BackupActionExecute(TObject *Sender)
{
	try {
		if (!IsCurFList() || !IsOppFList())	UserAbort(USTR_CantOperate);
		if (EqualDirLR())					UserAbort(USTR_SameCopyDest);

		UnicodeString cur_path = CurPath[CurListTag];
		UnicodeString opp_path = CurPath[OppListTag];

		if (!BackupDlg) BackupDlg = new TBackupDlg(this);	//初回に動的作成
		BackupDlg->SrcDirEdit->Text = cur_path;
		BackupDlg->DstDirEdit->Text = opp_path;
		UnicodeString inf_str;
		inf_str.cat_sprintf(_T("%s ---> %s"), cur_path.c_str(), opp_path.c_str());

		//パラメータ指定で直ちに実行
		if (!ActionParam.IsEmpty()) {
			int idx = -1;
			for (int i=0; i<BakSetupList->Count; i++)
				if (SameText(ActionParam, BakSetupList->Names[i])) { idx = i; break; }
			if (idx==-1) throw EAbort(LoadUsrMsg(USTR_NotFound, _T("バックアップ設定")));
			TStringDynArray set_buf = get_csv_array(BakSetupList->ValueFromIndex[idx], 7, true);

			bool sure_bak = (ExeCmdsBusy && XCMD_MsgOff)? false : IniFile->ReadBoolGen(_T("BackupSureStart"), true);
			if (sure_bak) {
				UnicodeString msg = "バックアップを開始しますか?\r\n\r\n";
				msg.cat_sprintf(_T("バックアップ元: %s\r\n"), cur_path.c_str());
				msg.cat_sprintf(_T("バックアップ先: %s\r\n"), opp_path.c_str());
				msg.cat_sprintf(_T("設定: %s"), ActionParam.c_str());
				if (!msgbox_Sure(msg, true, true)) SkipAbort();
			}

			std::unique_ptr<TStringList> dst_lst(new TStringList());
			if (equal_1(set_buf[5]))
				get_SyncDstList(opp_path, dst_lst.get());
			else
				dst_lst->Add(opp_path);

			TDateTime flt_dt;
			int flt_cnd = get_DateCond(set_buf[6], flt_dt);
			if (flt_cnd==-1) UserAbort(USTR_IllegalDtCond);

			for (int i=0; i<dst_lst->Count; i++) {
				UnicodeString dnam = dst_lst->Strings[i];
				if (i>0 &&SameText(cur_path, dnam)) continue;
				TaskConfig  *cp = NULL;
				TTaskThread *tp = CreTaskThread(&cp);	if (!cp) Abort();
				cp->TaskList->Text = UnicodeString().sprintf(_T("BACKUP\t%s\t%s\r\n"), cur_path.c_str(), dnam.c_str());
				cp->CopyMode = CPYMD_NEW_BACKUP;	//最新ならバックアップ
				cp->CopyAll  = true;
				cp->CopyFmt  = AutoRenFmt;
				cp->CmdStr	 = "バックアップ";
				cp->DistPath = dnam;
				cp->InfStr	 = inf_str.Insert(ActionParam + ": ", 1);

				//日付条件
				if (flt_cnd>0) {
					cp->FilterMode = flt_cnd;
					cp->FilterTime = flt_dt;
					cp->InfStr.cat_sprintf(_T(" (%s%s)"),
								UnicodeString("<=>").SubString(flt_cnd, 1).c_str(), format_Date(flt_dt).c_str());
				}

				cp->Bakup_inc_mask = set_buf[0];
				cp->Bakup_exc_mask = set_buf[1];
				cp->Bakup_skip_dir = set_buf[2];
				cp->Bakup_sub_sw   = equal_1(set_buf[3]);
				cp->Bakup_mirror   = equal_1(set_buf[4]);
				ActivateTask(tp, cp);
			}
		}
		//ダイアログで指定
		else if (BackupDlg->ShowModal()==mrOk) {
			TDateTime flt_dt;
			int flt_cnd = get_DateCond(BackupDlg->BakDateCondEdit->Text, flt_dt);
			if (flt_cnd==-1) UserAbort(USTR_IllegalDtCond);

			std::unique_ptr<TStringList> dst_lst(new TStringList());
			if (BackupDlg->SyncCheckBox->Checked) get_SyncDstList(opp_path, dst_lst.get()); else dst_lst->Add(opp_path);
			for (int i=0; i<dst_lst->Count; i++) {
				UnicodeString dnam = dst_lst->Strings[i];
				if (i>0 &&SameText(cur_path, dnam)) continue;
				TaskConfig  *cp = NULL;
				TTaskThread *tp = CreTaskThread(&cp);	if (!cp) Abort();
				cp->TaskList->Text = UnicodeString().sprintf(_T("BACKUP\t%s\t%s\r\n"), cur_path.c_str(), dnam.c_str());
				cp->CopyMode = CPYMD_NEW_BACKUP;	//最新ならバックアップ
				cp->CopyAll  = true;
				cp->CopyFmt  = AutoRenFmt;
				cp->CmdStr	 = "バックアップ";
				cp->DistPath = dnam;
				cp->InfStr	 = inf_str;

				//日付条件
				if (flt_cnd>0) {
					cp->FilterMode = flt_cnd;
					cp->FilterTime = flt_dt;
					cp->InfStr.cat_sprintf(_T(" (%s%s)"),
								UnicodeString("<=>").SubString(flt_cnd, 1).c_str(), format_Date(flt_dt).c_str());
				}

				cp->Bakup_inc_mask = BackupDlg->BakIncMaskComboBox->Text;
				cp->Bakup_exc_mask = BackupDlg->BakExcMaskComboBox->Text;
				cp->Bakup_skip_dir = BackupDlg->BakSkipDirEdit->Text;
				cp->Bakup_sub_sw   = BackupDlg->SubDirCheckBox->Checked;
				cp->Bakup_mirror   = BackupDlg->MirrorCheckBox->Checked;
				ActivateTask(tp, cp);
			}
		}
	}
	catch (EAbort &e) {
		SetActionAbort(e.Message);
	}
}

//---------------------------------------------------------------------------
//バイナリ文書→テキスト変換
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ConvertDoc2TxtActionExecute(TObject *Sender)
{
	try {
		if (!xd2tx_Available) TextAbort(_T("xdoc2txt が利用できません。"));

		TStringList *lst = GetCurList(true);
		int sel_cnt = GetSelCount(lst);
		if (sel_cnt==0 && !GetCurFrecPtr()) Abort();

		NotConvertAbort();
		if (!msgbox_Sure(_T("バイナリ文書→テキスト変換を開始しますか?"), SureOtherActiv())) SkipAbort();

		CurWorking = true;
		UnicodeString dst_dir = GetCurPathStr(OppListTag);
		UnicodeString msg;
		StartLog(msg.sprintf(_T("変換開始  %s\t%s"), GetSrcPathStr().c_str(), dst_dir.c_str()));
		BeginWorkProgress(_T("バイナリ文書→テキスト変換"), EmptyStr, FileListBox[CurListTag]);

		int code_page = TEST_ActParam("SJ")? 932 :
						TEST_ActParam("IJ")? 50220 :
						TEST_ActParam("EJ")? 20932 :
						TEST_ActParam("U8")? 65001 :
						TEST_ActParam("UL")? 1200 :
						TEST_ActParam("UB")? 1201 : 932;

		int ok_cnt = 0, er_cnt = 0;
		int cur_idx = FileListBox[CurListTag]->ItemIndex;
		for (int i=0; i<lst->Count; i++) {
			PosWorkProgress(i, lst->Count);

			file_rec *fp = (file_rec*)lst->Objects[i];
			if (fp->is_dir) continue;
			if (sel_cnt>0 && !fp->selected) continue;
			if (sel_cnt==0 && cur_idx!=i)   continue;

			try {
				msg = make_LogHdr(_T("DOC2TX"), fp);
				std::unique_ptr<TStringList> f_buf(new TStringList());
				if (!xd2tx_TestExt(fp->f_ext, true))
					TextAbort(_T("対応していないファイル形式です。"));
				if (!xd2tx_Extract(fp->f_name, f_buf.get())) UserAbort(USTR_FaildProc);
				//保存
				std::unique_ptr<TEncoding> enc(TEncoding::GetEncoding(code_page));
				if (!saveto_TextFile(dst_dir + get_base_name(fp->f_name) + ".txt", f_buf.get(), enc.get()))
					UserAbort(USTR_FaildSave);
				fp->selected = false;
				ok_cnt++;
			}
			catch (EAbort &e) {
				set_LogErrMsg(msg, e.Message);
				er_cnt++;
			}
			AddLog(msg);
			InvalidateFileList();
		}

		RepaintList(CurListTag);
		CurWorking = false;
		EndLog(_T("変換"), get_res_cnt_str(ok_cnt, er_cnt));
		EndWorkProgress();
	}
	catch (EAbort &e) {
		SetActionAbort(e.Message);
	}
}

//---------------------------------------------------------------------------
//HTML→テキスト変換
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ConvertHtm2TxtActionExecute(TObject *Sender)
{
	try {
		TStringList *lst = GetCurList(true);
		int sel_cnt = GetSelCount(lst);
		if (sel_cnt==0 && !GetCurFrecPtr()) Abort();

		NotConvertAbort();
		if (!msgbox_Sure(_T("HTML→テキスト変換を開始しますか?"), SureOtherActiv())) SkipAbort();

		CurWorking = true;
		UnicodeString dst_dir = GetCurPathStr(OppListTag);
		UnicodeString msg;
		StartLog(msg.sprintf(_T("変換開始  %s\t%s"), GetSrcPathStr().c_str(), dst_dir.c_str()));
		BeginWorkProgress(_T("HTML→テキスト変換"), EmptyStr, FileListBox[CurListTag]);

		std::unique_ptr<HtmConv> htmcnv(new HtmConv());
		ini_HtmConv_def(htmcnv.get());

		htmcnv->InsHdrInf = TEST_ActParam("HD");
		if		(TEST_ActParam("MD"))	htmcnv->ToMarkdown = true;
		else if (TEST_ActParam("TX"))	htmcnv->ToMarkdown = false;
		else							htmcnv->ToMarkdown = ToMarkdown;

		int ok_cnt = 0, er_cnt = 0;
		int cur_idx = FileListBox[CurListTag]->ItemIndex;
		for (int i=0; i<lst->Count; i++) {
			PosWorkProgress(i, lst->Count);

			file_rec *fp = (file_rec*)lst->Objects[i];
			if (fp->is_dir) continue;
			if (sel_cnt>0 && !fp->selected) continue;
			if (sel_cnt==0 && cur_idx!=i)   continue;

			try {
				msg = make_LogHdr(_T("HTM2TX"), fp);
				if (!test_HtmlExt(fp->f_ext)) TextAbort(_T("HTML文書ではありません。"));
				std::unique_ptr<TStringList> f_buf(new TStringList());
				int code_page = load_text_ex(fp->f_name, f_buf.get());
				if (code_page==0) GlobalAbort();

				htmcnv->FileName = fp->f_name;
				htmcnv->HtmBuf->Assign(f_buf.get());
				htmcnv->CodePage = code_page;
				htmcnv->Convert();

				//保存
				std::unique_ptr<TEncoding> enc(TEncoding::GetEncoding(code_page));
				if (!saveto_TextFile(dst_dir + get_base_name(fp->f_name) + ".txt", htmcnv->TxtBuf, enc.get()))
					UserAbort(USTR_FaildSave);
				fp->selected = false;
				ok_cnt++;
			}
			catch (EAbort &e) {
				set_LogErrMsg(msg, e.Message);
				er_cnt++;
			}
			AddLog(msg);
			InvalidateFileList();
		}

		RepaintList(CurListTag);
		CurWorking = false;
		EndLog(_T("変換"), get_res_cnt_str(ok_cnt, er_cnt));
		EndWorkProgress();
	}
	catch (EAbort &e) {
		SetActionAbort(e.Message);
	}
}

//---------------------------------------------------------------------------
//画像ファイルの変換
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ConvertImageActionExecute(TObject *Sender)
{
	file_rec *cfp = cre_new_file_rec(GetCurFrecPtr(true));

	try {
		bool is_clip = TEST_ActParam("CB");
		if (is_clip && !Clipboard()->HasFormat(CF_BITMAP)) UserAbort(USTR_NoObject);
		NotConvertAbort();

		TStringList *lst = GetCurList(true);
		int sel_cnt 	 = GetSelCount(lst);
		if (!is_clip && sel_cnt==0 && (cfp->f_name.IsEmpty() || cfp->is_dummy)) UserAbort(USTR_NoObject);

		UnicodeString dst_dir = GetCurPathStr(is_clip? CurListTag : OppListTag);

		if (!CvImageDlg) CvImageDlg = new TCvImageDlg(this);	//初回に動的作成
		CvImageDlg->fromClip = is_clip;
		if (CvImageDlg->ShowModal()==mrOk) {
			TaskConfig  *cp = NULL;
			TTaskThread *tp = CreTaskThread(&cp);	if (!cp) Abort();
			TRadioGroup *rp = CvImageDlg->CvFmtRadioGroup;
			UnicodeString fext = (rp->ItemIndex!=-1)? rp->Items->Strings[rp->ItemIndex].LowerCase() : EmptyStr;
			remove_top_s(fext, '&');
			cp->CvImg_f_ext 		= "." + fext;
			cp->CvImg_from_clip		= is_clip;
			cp->CvImg_quality		= CvImageDlg->ImgQTrackBar->Position;
			cp->CvImg_ycrcb 		= CvImageDlg->YCrCbComboBox->ItemIndex;
			cp->CvImg_cmp_mode		= CvImageDlg->CmpModeComboBox->ItemIndex;
			cp->CvImg_scale_mode	= CvImageDlg->ScaleModeComboBox->ItemIndex;
			cp->CvImg_scale_prm1	= EditToInt(CvImageDlg->ScalePrm1Edit, 100);
			cp->CvImg_scale_prm2	= EditToInt(CvImageDlg->ScalePrm2Edit, 100);
			cp->CvImg_scale_opt 	= CvImageDlg->ScaleOptComboBox->ItemIndex;
			cp->CvImg_not_use_prvw	= CvImageDlg->NotUsePrvCheckBox->Checked;
			cp->CvImg_mgn_color 	= CvImageDlg->MgnColPanel->Color;
			cp->CvImg_grayscale 	= CvImageDlg->GrayScaleCheckBox->Checked;
			cp->CvImg_chg_name_mode = CvImageDlg->ChgNameComboBox->ItemIndex;
			cp->CvImg_chg_name_str	= CvImageDlg->ChgNameEdit->Text;
			cp->KeepTime			= CvImageDlg->KeepTimeCheckBox->Checked;

			UnicodeString cmd = "CVIMG";
			UnicodeString tprm;
			//クリップボード
			if (is_clip) {
				cp->CvImg_clip_name = CvImageDlg->ClipNameComboBox->Text;
				cp->CopyMode   = CvImageDlg->ClipOWBtn->Checked? CPYMD_OW : CPYMD_AUT_REN;
				cp->CopyFmt    = AutoRenFmt;
				cp->DstPosMode = 2;
				cp->TaskList->Add(tprm.sprintf(_T("%s\tCLIPBOARD\t%s"), cmd.c_str(), dst_dir.c_str()));
			}
			//選択あり
			else if (sel_cnt>0) {
				for (int i=0; i<lst->Count; i++) {
					file_rec *fp = (file_rec*)lst->Objects[i];
					if (!fp->selected) continue;
					cp->TaskList->Add(tprm.sprintf(_T("%s\t%s\t%s"), cmd.c_str(), fp->f_name.c_str(), dst_dir.c_str()));
					fp->selected = false;
				}
				RepaintList(CurListTag);
			}
			//カーソル位置
			else {
				cp->TaskList->Add(tprm.sprintf(_T("%s\t%s\t%s"), cmd.c_str(), cfp->f_name.c_str(), dst_dir.c_str()));
			}

			cp->CmdStr	 = TaskCmdList->Values[cmd];
			cp->DistPath = dst_dir;
			cp->InfStr	 = (is_clip? UnicodeString("CLIPBOARD") : GetSrcPathStr()) + " ---> " + dst_dir;
			ActivateTask(tp, cp);
		}
	}
	catch (EAbort &e) {
		SetActionAbort(e.Message);
	}

	del_file_rec(cfp);
}

//---------------------------------------------------------------------------
//文字コードの変換
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ConvertTextEncActionExecute(TObject *Sender)
{
	try {
		TStringList *lst = GetCurList(true);
		int sel_cnt = GetSelCount(lst);
		if (sel_cnt==0 && !GetCurFrecPtr()) Abort();

		NotConvertAbort();

		if (!CvTxtEncDlg) CvTxtEncDlg = new TCvTxtEncDlg(this);	//初回に動的作成
		if (CvTxtEncDlg->ShowModal()==mrOk) {
			UnicodeString charset = CvTxtEncDlg->OutCodeComboBox->Text;
			int o_cp = get_CodePageOfName(charset);
			if (o_cp==0) UserAbort(USTR_IllegalParam);
			charset = ReplaceText(charset, "UTF-16(BE)", "UTF-16");

			std::unique_ptr<TEncoding> enc(TEncoding::GetEncoding(o_cp));
			bool with_bom = (CvTxtEncDlg->BomCheckBox->Enabled && CvTxtEncDlg->BomCheckBox->Checked);

			UnicodeString dst_dir = GetCurPathStr(OppListTag);
			UnicodeString msg;
			CurWorking = true;
			StartLog(msg.sprintf(_T("変換開始  %s (%s) %s %s\t%s"),
				CvTxtEncDlg->OutCodeComboBox->Text.c_str(),
				CvTxtEncDlg->OutLnBrkComboBox->Text.c_str(),
				(with_bom? _T("BOM付") : null_TCHAR),
				GetSrcPathStr().c_str(), dst_dir.c_str()));
			BeginWorkProgress(_T("文字コードの変換"), EmptyStr, FileListBox[CurListTag]);
			std::unique_ptr<TStringList> f_buf(new TStringList());
			TRegExOptions opt; opt << roIgnoreCase;

			int cur_idx = FileListBox[CurListTag]->ItemIndex;
			for (int i=0; i<lst->Count; i++) {
				PosWorkProgress(i, lst->Count);

				file_rec *fp = (file_rec*)lst->Objects[i];
				if (fp->is_dir) continue;
				if (sel_cnt>0 && !fp->selected) continue;
				if (sel_cnt==0 && cur_idx!=i)   continue;

				try {
					msg = make_LogHdr(_T("CVENC"), fp);
					int i_cp;
					if (!is_TextFile(fp->f_name, &i_cp)) UserAbort(USTR_NotText);
					load_text_ex(fp->f_name, f_buf.get(), i_cp);
					if (!GlobalErrMsg.IsEmpty()) GlobalAbort();

					//文字コード指定の書き換え
					if (f_buf->Count>0) {
						UnicodeString lbuf = f_buf->Strings[0];
						UnicodeString ptn, tmp;
						//XML
						if (ContainsText(lbuf, "<?xml ")) {
							int p = pos_i(_T("encoding="), lbuf);
							if (p>0) {
								ptn = "encoding=[\"'][^\"'?>]+[\"']";
								tmp.sprintf(_T("encoding=\"%s\""), charset.c_str());
							}
							else {
								ptn = "\\s*\\?>";
								tmp.sprintf(_T(" encoding=\"%s\"?>"), charset.c_str());
							}
							f_buf->Strings[0] = TRegEx::Replace(lbuf, ptn, tmp);
						}
						//HTML
						else if (test_HtmlExt(fp->f_ext)) {
							for (int j = 1; j<f_buf->Count; j++) {
								lbuf = f_buf->Strings[j];
								if (ContainsText(lbuf, "</head>")) break;
								if (ContainsText(lbuf, "<meta ") && ContainsText(lbuf, "charset=")) {
									if (TRegEx::IsMatch(lbuf, "content=\"?text/html;\\s+charset=", opt)) {
										ptn = "charset=[^\"'>]+";
										tmp.sprintf(_T("charset=%s"), charset.c_str());
									}
									else {
										ptn = "charset=[\"'][^\"'>]+[\"']";
										tmp.sprintf(_T("charset=\"%s\""), charset.c_str());
									}
									f_buf->Strings[j] = TRegEx::Replace(lbuf, ptn, tmp);
									break;
								}
							}
						}
					}

					//改行指定
					switch (CvTxtEncDlg->OutLnBrkComboBox->ItemIndex) {
					case 1:  f_buf->LineBreak = "\n"; break;
					case 2:  f_buf->LineBreak = "\r"; break;
					default: f_buf->LineBreak = "\r\n";
					}

					//BOM
					f_buf->WriteBOM = with_bom;

					//保存
					if (!saveto_TextFile(dst_dir + fp->n_name, f_buf.get(), enc.get()))
						UserAbort(USTR_FaildSave);
					fp->selected = false;

					if (SameText(fp->f_name, dst_dir + fp->n_name)) fp->inf_list->Clear();
				}
				catch (EAbort &e) {
					set_LogErrMsg(msg, e.Message);
				}
				AddLog(msg);
				InvalidateFileList();
			}

			RepaintList(CurListTag);
			CurWorking = false;
			EndLog(_T("変換"));
			EndWorkProgress();
		}
	}
	catch (EAbort &e) {
		SetActionAbort(e.Message);
	}
}

//---------------------------------------------------------------------------
//Exif情報の削除
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::DelJpgExifActionExecute(TObject *Sender)
{
	file_rec *cfp = cre_new_file_rec(GetCurFrecPtr(true));

	try {
		TStringList *lst = GetCurList(true);
		int sel_cnt = GetSelCount(lst);
		UnicodeString src_dir = GetCurPathStr();
		UnicodeString dst_dir = GetCurPathStr(OppListTag);

		NotConvertAbort();

		std::unique_ptr<TStringList> tsk_lst(new TStringList());
		UnicodeString cmd = "DLEXIF";
		UnicodeString tprm;
		//選択あり
		if (sel_cnt>0) {
			if (msgbox_Sure(LoadUsrMsg(USTR_DeleteQ, _T("選択ファイルのExif情報")), SureOtherActiv())) {
				for (int i=0; i<lst->Count; i++) {
					file_rec *fp = (file_rec*)lst->Objects[i];
					if (!fp->selected) continue;
					fp->selected = false;
					InvalidateFileList();
					if (!test_JpgExt(fp->f_ext)) continue;
					tsk_lst->Add(tprm.sprintf(_T("%s\t%s\t%s"), cmd.c_str(), fp->f_name.c_str(), dst_dir.c_str()));
				}
				RepaintList(CurListTag);
			}
		}
		//カーソル位置
		else {
			if (cfp->f_name.IsEmpty() || cfp->is_dummy) Abort();
			if (!test_JpgExt(cfp->f_ext)) Abort();
			if (msgbox_Sure(get_DispName(cfp) + " のExif情報を削除しますか", SureOtherActiv()))
				tsk_lst->Add(tprm.sprintf(_T("%s\t%s\t%s"), cmd.c_str(), cfp->f_name.c_str(), dst_dir.c_str()));
		}

		if (tsk_lst->Count>0) {
			TaskConfig  *cp = NULL;
			TTaskThread *tp = CreTaskThread(&cp);	if (!cp) Abort();
			cp->TaskList->Assign(tsk_lst.get());
			cp->KeepTime = TEST_ActParam("KT");
			cp->CmdStr	 = TaskCmdList->Values[cmd];
			cp->DistPath = dst_dir;
			cp->InfStr.sprintf(_T("%s ---> %s"), GetSrcPathStr().c_str(), dst_dir.c_str());
			ActivateTask(tp, cp);
		}
	}
	catch (EAbort &e) {
		SetActionAbort(e.Message);
	}

	del_file_rec(cfp);
}
//---------------------------------------------------------------------------


//■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
// メニュー処理
//■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::MenuFActionUpdate(TObject *Sender)
{
	TAction *ap = (TAction*)Sender;
	ap->Visible = ScrMode==SCMD_FLIST;
	ap->Enabled = ap->Visible;
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::MenuFVActionUpdate(TObject *Sender)
{
	TAction *ap = (TAction*)Sender;
	ap->Visible = ScrMode==SCMD_FLIST || ScrMode==SCMD_TVIEW;
	ap->Enabled = ap->Visible;
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::MenuFIActionUpdate(TObject *Sender)
{
	TAction *ap = (TAction*)Sender;
	ap->Visible = ScrMode==SCMD_FLIST || ScrMode==SCMD_IVIEW;
	ap->Enabled = ap->Visible;
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::MenuFIGActionUpdate(TObject *Sender)
{
	TAction *ap = (TAction*)Sender;
	ap->Visible = ScrMode==SCMD_FLIST || ScrMode==SCMD_IVIEW || ScrMode==SCMD_GREP;
	ap->Enabled = ap->Visible;
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::MenuFVIActionUpdate(TObject *Sender)
{
	TAction *ap = (TAction*)Sender;
	ap->Visible = ScrMode==SCMD_FLIST || ScrMode==SCMD_TVIEW || ScrMode==SCMD_IVIEW;
	ap->Enabled = ap->Visible;
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::MenuVUpdate(TObject *Sender)
{
	TAction *ap = (TAction*)Sender;
	ap->Visible = ScrMode==SCMD_TVIEW;
	ap->Enabled = ap->Visible;
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::MenuIActionUpdate(TObject *Sender)
{
	TAction *ap = (TAction*)Sender;
	ap->Visible = ScrMode==SCMD_IVIEW;
	ap->Enabled = ap->Visible;
}

//---------------------------------------------------------------------------
//メインメニュー
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::MainMenuClick(TObject *Sender)
{
	CancelKeySeq();
	ActionParam = EmptyStr;
	ActionOk	= true;

	reduction_MenuLine((TMenuItem*)Sender);
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::FileMenuClick(TObject *Sender)
{
	CancelKeySeq();
	ActionParam = EmptyStr;
	ActionOk	= true;

	if (ScrMode==SCMD_FLIST || ScrMode==SCMD_IVIEW) {
		//ワークリスト履歴メニュー設定
		TStringList *lp = WorkListHistory;
		for (int i=0; i<WorkListHistoryItem->Count; i++) {
			TMenuItem *mp = WorkListHistoryItem->Items[i];
			mp->Visible = false;
			if (i>=lp->Count || lp->Strings[i].IsEmpty()) continue;
			TStringDynArray itm_buf = get_csv_array(lp->Strings[i], 2);
			if (itm_buf.Length>0) {
				mp->Caption = ((i<10)? UnicodeString().sprintf(_T("&%u: "), (i + 1)%10) : UnicodeString("   ")) + itm_buf[0];
				mp->Visible = true;
			}
		}

		WorkListHistoryItem->Enabled = (lp->Count>0);
		WorkListHistoryItem->Visible = true;
	}
	else {
		WorkListHistoryItem->Visible = false;
	}

	//ライブラリ
	LibraryItem->Visible = (ScrMode==SCMD_FLIST);

	reduction_MenuLine((TMenuItem*)Sender);
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ExtMenuClick(TObject *Sender)
{
	CancelKeySeq();
	ActionParam = EmptyStr;
	ActionOk	= true;

	TMenuItem *mp = (TMenuItem*)Sender;
	IconImgListP->Clear();
	if		(mp==EditMenu) SetExtMenuItem(EditMenu, ExtMenuList, EXTMENU_BASE);
	else if (mp==ToolMenu) SetExtMenuItem(ToolMenu, ExtToolList, EXTTOOL_BASE);

	for (int i=0; i<mp->Count; i++) {
		TMenuItem *ip = mp->Items[i];
		if (ip->Tag>=EXTMENU_BASE) ip->Visible = MainPanel->Visible;
	}

	reduction_MenuLine((TMenuItem*)Sender);
}
//---------------------------------------------------------------------------
//ワークリスト履歴を開く
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::WorkListHstItemClick(TObject *Sender)
{
	try {
		int tag = ((TComponent*)Sender)->Tag;
		if (tag<WorkListHistory->Count) {
			SaveWorkListAction->Execute();
			if (!SetWorkList(get_csv_item(WorkListHistory->Strings[tag], 0))) UserAbort(USTR_WlistCantOpen);
		}
	}
	catch (EAbort &e) {
		SttBarWarn(e.Message);
	}
}

//---------------------------------------------------------------------------
//追加メニューの処理(編集)
//---------------------------------------------------------------------------
bool __fastcall TNyanFiForm::ExeExtMenuItem(int idx)
{
	GlobalErrMsg = EmptyStr;
	try {
		if (idx>=ExtMenuList->Count) UserAbort(USTR_FaildMenu);
		TStringDynArray itm_buf = get_csv_array(ExtMenuList->Strings[idx], 3, true);

		TStringList *lst = FileList[CurListTag];
		int cmd_id = idx_of_word_i(_T("MaskSel|MaskDel|MaskCopy|MaskMove|MaskPack|ExeCommands"), itm_buf[1]);
		UnicodeString prmstr = itm_buf[2];
		ActionParam = EmptyStr;

		switch (cmd_id) {
		case 0:	//マスクに一致するファイルを選択
			SelectMask(GetCurList(), prmstr);
			break;
		case 5:	//指定したコマンドを実行
			if (!ExeCommandsCore(prmstr)) GlobalAbort();
			break;
		default:
			//マスク選択したファイルを〜
			if (SelectMask(lst, prmstr)==0)	Abort();
			switch (cmd_id) {
			case 1:	//削除
				if (CurStt->is_Arc) Abort();
				Sleep(500);
				DeleteSelFiles(lst);
				break;
			case 2:	//コピー
				if (!ExeCmdAction(CopyAction)) ActionAbort();
				break;
			case 3:	//移動
				if (!ExeCmdAction(MoveAction)) ActionAbort();
				break;
			case 4:	//圧縮
				if (CurStt->is_Arc) Abort();
				if (!ExeCmdAction(PackAction)) ActionAbort();
				break;
			}
		}

		return true;
	}
	catch (EAbort &e) {
		if (!ContainsText(e.Message, "Abort")) GlobalErrMsg = e.Message;
		return false;
	}
}

//---------------------------------------------------------------------------
//追加メニューの処理(ツール)
//---------------------------------------------------------------------------
bool __fastcall TNyanFiForm::ExeExtToolItem(int idx)
{
	GlobalErrMsg = EmptyStr;
	try {
		if (idx>=ExtToolList->Count) UserAbort(USTR_FaildMenu);
		TStringDynArray itm_buf = get_csv_array(ExtToolList->Strings[idx], 4, true);
		if (!ExeExtTool(get_actual_path(itm_buf[1]), itm_buf[2], itm_buf[3])) GlobalAbort();
		return true;
	}
	catch (EAbort &e) {
		GlobalErrMsg = e.Message;
		return false;
	}
}

//---------------------------------------------------------------------------
//外部ツール用書式を展開
//！失敗したら EAbort 例外 (GetSelFileStr)
//---------------------------------------------------------------------------
UnicodeString __fastcall TNyanFiForm::FormatExtTool(UnicodeString prm)
{
	TStringList   *lst = GetCurList();
	UnicodeString fnam = (GetSelCount(lst)>0)? GetSelFileStr(lst, true, true) : GetCurFileStr(true);
	UnicodeString cnam = GetCurFileStr(true);
	UnicodeString onam = GetSelFileStr(GetOppList(), true, true);
	UnicodeString bnam, nnam;
	file_rec *bfp = GetCurRepFrecPtr();
	if (bfp) {
		bnam = bfp->n_name;
		nnam = ChangeFileExt(bnam, EmptyStr);
	}

	UnicodeString pnam = ExcludeTrailingPathDelimiter(CurPath[CurListTag]);
	UnicodeString qnam = ExcludeTrailingPathDelimiter(CurPath[OppListTag]);
	UnicodeString xnam = ExcludeTrailingPathDelimiter(ExePath);
	UnicodeString xdrv = ExtractFileDrive(ExePath);

	//パラメータ
	if (!prm.IsEmpty()) {
		UnicodeString s = cv_env_str(prm);	//環境変数を展開;
		prm = EmptyStr;
		while (!s.IsEmpty()) {
			WideChar c = split_top_wch(s);
			if (c=='$') {
				c = split_top_wch(s);
				UnicodeString pstr;
				switch (c) {
				case 'P': case 'Q': case 'X': case 'D':
					//後続文字列の $B、$N を展開
					pstr = split_tkn(s, ' ');
					if (!pstr.IsEmpty()) {
						UnicodeString pbuf;
						while (!pstr.IsEmpty()) {
							WideChar c = split_top_wch(pstr);
							if (c=='$') {
								c = split_top_wch(pstr);
								if		(c=='B') pbuf += bnam;
								else if (c=='N') pbuf += nnam;
								else pbuf.cat_sprintf(_T("$%c"), c);
							}
							else pbuf.cat_sprintf(_T("%c"), c);
						}
						pstr = pbuf;
					}

					if (!s.IsEmpty()) s.Insert(" ", 1);
					switch (c) {
					case 'P': prm += add_quot_if_spc(pnam + pstr);	break;
					case 'Q': prm += add_quot_if_spc(qnam + pstr);	break;
					case 'X': prm += add_quot_if_spc(xnam + pstr);	break;
					case 'D': prm += add_quot_if_spc(xdrv + pstr);	break;
					default:  prm.cat_sprintf(_T("$%c"), c);
					}
					break;

				case 'F': prm += fnam;	break;
				case 'C': prm += cnam;	break;
				case 'O': prm += onam;	break;
				case 'B': prm += bnam;	break;
				case 'N': prm += nnam;	break;
				case '$': prm += "$";	break;

				case 'R':
					{
						UnicodeString rnam;
						//反対側で選択ファイルがあれば $O
						if (!onam.IsEmpty()) {
							rnam = onam;
						}
						//ディレクトリの比較結果リストなら反対のカーソル位置ファイル
						else if (IsDiffList()) {
							rnam = GetOppFileStr();
						}
						//それ以外は $Q\$B
						else {
							//仮想
							if (OppStt->is_Arc) {
								TStringList *o_lst = GetOppList();
								for (int i=0; i<o_lst->Count && rnam.IsEmpty(); i++) {
									file_rec *fp = (file_rec*)o_lst->Objects[i];
									if (fp->is_dir) continue;
									if (SameText(bnam, fp->n_name)) {
										if (SetTmpFile(fp)) rnam = add_quot_if_spc(fp->tmp_name);
									}
								}
							}
							//通常
							else rnam = add_quot_if_spc(qnam + "\\" + bnam);
						}
						prm += rnam;
					}
					break;
				}
			}
			else prm.cat_sprintf(_T("%c"), c);
		}
	}

	return prm;
}

//---------------------------------------------------------------------------
//外部ツールの実行
//---------------------------------------------------------------------------
bool __fastcall TNyanFiForm::ExeExtTool(UnicodeString cmd, UnicodeString prm, UnicodeString wdir)
{
	wdir = !wdir.IsEmpty()? FormatExtTool(wdir) : ExcludeTrailingPathDelimiter(CurPath[CurListTag]);

	if (Execute_ex(cmd, FormatExtTool(prm), wdir)) return true;

	if (GlobalErrMsg.IsEmpty()) GlobalErrMsg = LoadUsrMsg(USTR_FaildExec);
	return false;
}

//---------------------------------------------------------------------------
//メニュー/ツールのエイリアスを実行
//---------------------------------------------------------------------------
bool __fastcall TNyanFiForm::ExeAlias(UnicodeString alias)
{
	ActionOk	 = true;
	ActionErrMsg = EmptyStr;

	remove_top_Dollar(alias);	if (alias.IsEmpty()) return false;

	//追加メニュー
	int idx = indexof_csv_list(ExtMenuList, alias, 3);
	if (idx!=-1) {
		TStringDynArray itm_buf = get_csv_array(ExtMenuList->Strings[idx], 3, true);
		if (StartsStr('>', itm_buf[0])) {
			ExPopupMenu->Items->Clear();
			IconImgListP->Clear();
			SetExtMenuItem(ExPopupMenu->Items, ExtMenuList, EXTMENU_BASE, idx);
			ShowExPopupMenu();
		}
		else {
			if (!ExeExtMenuItem(idx)) SetActionAbort(GlobalErrMsg);
		}
		return true;
	}

	//外部ツール
	idx = indexof_csv_list(ExtToolList, alias, 4);
	if (idx!=-1) {
		TStringDynArray itm_buf = get_csv_array(ExtToolList->Strings[idx], 3, true);
		if (StartsStr('>', itm_buf[0])) {
			ExPopupMenu->Items->Clear();
			IconImgListP->Clear();
			SetExtMenuItem(ExPopupMenu->Items, ExtToolList, EXTTOOL_BASE, idx);
			ShowExPopupMenu();
		}
		else {
			if (!ExeExtToolItem(idx)) SetActionAbort(GlobalErrMsg);
		}
		return true;
	}

	SetActionAbort(UnicodeString().sprintf(_T("不明なエイリアスです [%s]"), alias.c_str()));
	return false;
}

//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ExtMenuItemClick(TObject *Sender)
{
	int tag = ((TMenuItem*)Sender)->Tag;
	if (tag<EXTMENU_BASE) return;

	//編集メニュー
	if (tag<EXTTOOL_BASE) {
		if (!ExeExtMenuItem(tag - EXTMENU_BASE)) SttBarWarn(GlobalErrMsg);
	}
	//ツールメニュー
	else {
		if (!ExeExtToolItem(tag - EXTTOOL_BASE)) SttBarWarn(GlobalErrMsg);
	}
}

//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::TxtViewEditActionUpdate(TObject *Sender)
{
	((TAction*)Sender)->Visible = ScrMode==SCMD_TVIEW;
}

//---------------------------------------------------------------------------
//コードページ変更
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ChgCodePageActionExecute(TObject *Sender)
{
	//ダミー
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ChgCodePageActionUpdate(TObject *Sender)
{
	((TAction*)Sender)->Visible = ScrMode==SCMD_TVIEW && isViewText && !isRichText && !isXDoc2Txt;
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::CP_xxx_ActionUpdate(TObject *Sender)
{
	TAction *ap = (TAction*)Sender;
	ap->Checked = TxtViewer->TxtBufList->Encoding->CodePage==(unsigned int)ap->Tag;
}

//---------------------------------------------------------------------------
//INIファイルの編集
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::EditIniFileActionExecute(TObject *Sender)
{
	UnicodeString cmd;
	cmd.sprintf(_T("FileEdit_\"%s\""), IniFile->FileName.c_str());
	if (!ExeCommandsCore(cmd)) SetActionAbort(GlobalErrMsg);
	if (msgbox_Sure(_T("INIファイルの変更を反映するため NyanFi を再起動しますか?"), true, true)) {
		cmd.sprintf(_T("Restart_NS;\"%s\""), IniFile->FileName.c_str());
		if (!ExeCommandsCore(cmd)) SetActionAbort(GlobalErrMsg);
	}
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::EditIniFileActionUpdate(TObject *Sender)
{
	TAction *ap = (TAction*)Sender;
	ap->Visible = ScrMode==SCMD_FLIST;
	ap->Enabled = ap->Visible && IsPrimary;
}

//---------------------------------------------------------------------------
//INIファイルの閲覧
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ViewIniFileActionExecute(TObject *Sender)
{
	UnicodeString prm = add_quot_if_spc(IniFile->FileName);
	if (TEST_ActParam("XW")) prm += ";XW";
	ExeCommandAction("TextViewer", prm);
}

//---------------------------------------------------------------------------
//アーカイブから更新して再起動
//---------------------------------------------------------------------------
bool __fastcall TNyanFiForm::UpdateFromArc(
	UnicodeString arc_name,
	bool is_dl)		//true = ダウンロードファイルから/ false = 既存アーカイブから
{
	try {
		if (!CloseOtherNyanFi()) TextAbort(_T("他の NyanFi を終了できません。"));

		ShowMessageHint(_T("解凍中..."), col_bgHint, false, true, true);
		ClearTempDir();
		std::unique_ptr<TZipFile> zp(new TZipFile());
		zp->Open(arc_name, zmRead);
		for (int i=0; i<zp->FileCount; i++) {
			UnicodeString fnam = zp->FileName[i];
			if (ContainsText(".exe.chm", get_extension(fnam))) {
				TDateTime dt = FileDateToDateTime(zp->FileInfo[i].ModifiedDateTime);
				zp->Extract(fnam, TempPathA);
				set_file_age(TempPathA + fnam, dt);
			}
		}
		zp->Close();
		if (!move_File(TempPathA + "NyanFi.exe", ExePath + "new_NyanFi.exe")) UserAbort(USTR_FaildProc);
		if (!move_File(TempPathA + "NyanFi.chm", ExePath + "new_NyanFi.chm")) UserAbort(USTR_FaildProc);
		MsgHint->ReleaseHandle();

		//更新用バッチファイルを作成
		UnicodeString msg;
		msg.sprintf(_T("%s"), is_dl? _T("ダウンロードファイル") : _T("既存アーカイブ"));
		msg += "から更新しました。";
		std::unique_ptr<TStringList> fbuf(new TStringList());
		fbuf->Text =
			"IF NOT EXIST new_NyanFi.exe EXIT\r\n"
			"IF NOT EXIST new_NyanFi.chm EXIT\r\n"
			"TIMEOUT 1 /nobreak\r\n"
			":L00\r\n"
			"DEL NyanFi.exe\r\n"
			"IF EXIST NyanFi.exe GOTO L00\r\n"
			":L10\r\n"
			"DEL NyanFi.chm\r\n"
			"IF EXIST NyanFi.chm GOTO L10\r\n"
			"REN new_NyanFi.exe NyanFi.exe\r\n"
			"REN new_NyanFi.chm NyanFi.chm\r\n"
			"START NyanFi.exe -M" + msg + "\r\n"
			"DEL /F \"%~dp0%~nx0\"\r\n"
			"EXIT\r\n";

		UnicodeString bat_nam = ExePath + "update.bat";
		if (!saveto_TextFile(bat_nam, fbuf.get()))
			throw EAbort(LoadUsrMsg(USTR_FaildSave, _T("バッチファイル")));
		RstBatName = bat_nam;

		Close();
		return true;
	}
	catch (EZipException &e) {
		MsgHint->ReleaseHandle();
		GlobalErrMsg = e.Message;
		return false;
	}
	catch (EAbort &e) {
		MsgHint->ReleaseHandle();
		GlobalErrMsg = e.Message;
		return false;
	}
}
//---------------------------------------------------------------------------
//更新の確認
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::CheckUpdateActionExecute(TObject *Sender)
{
	try {
		cursor_HourGlass();
		ClearTempDir();

		//サイトをチェック
		UnicodeString url = DOWNLOAD_URL;
		UnicodeString tmp_name;  tmp_name.sprintf(_T("%snyanfi.htm"), TempPathA.c_str());
		if (get_OnlineFile(url + "nyanfi.htm", tmp_name)<=0) TextAbort(_T("情報が取得できません。"));
		std::unique_ptr<TStringList> fbuf(new TStringList());
		load_text_ex(tmp_name, fbuf.get());

		UnicodeString zip_nam;
		int new_vno = 0;
		bool is_inf = false;
		UnicodeString zip_ptn = is_X64()? "<a href=\"nyanfi64_[0-9]{4}\\.zip\">"
										: "<a href=\"nyanfi[0-9]{4}\\.zip\">";
		UnicodeString inf_str, ver_hdr;
		for (int i=0; i<fbuf->Count; i++) {
			UnicodeString lbuf = fbuf->Strings[i];
			//ファイル名を取得
			if (zip_nam.IsEmpty() && TRegEx::IsMatch(lbuf, zip_ptn)) {
				zip_nam = get_tkn_m(lbuf, _T("<a href=\""), _T("\">"));
				new_vno = extract_int_def(get_tkn_r(zip_nam, is_X64()? "nyanfi64_" : "nyanfi"), 0);
				ver_hdr.sprintf(_T("<p><u><b>V%u.%02u</b></u>"), new_vno/100, new_vno%100);
			}
			//変更点を取得
			else if (new_vno>0) {
				if (!is_inf) {
					if (ContainsText(lbuf, ver_hdr)) is_inf = true;
				}
				else {
					if (ContainsText(lbuf, "p>")) break;
					inf_str += (ReplaceText(lbuf, "<br>", "") + "\r\n");
				}
			}
		}
		if (zip_nam.IsEmpty()) TextAbort(_T("確認に失敗しました。"));

		if (is_inf) {
			//実体参照の解決
			std::unique_ptr<HtmConv> htmcnv(new HtmConv());
			inf_str = htmcnv->RefEntity(inf_str);
		}

		cursor_Default();

		//バージョンチェック
		bool force	 = TEST_ActParam("FD");	//強制ダウンロード(隠しパラメータ)
		bool no_conf = TEST_ActParam("NC");	//保存場所の選択、確認無し
		UnicodeString msg;
		if (new_vno>VersionNo || force) {
			msg.sprintf(_T("新バージョン [%s] があります。ダウンロードしますか?"), zip_nam.c_str());
			if (!inf_str.IsEmpty()) msg.cat_sprintf(_T("\r\n\r\n[変更点]\r\n%s"), inf_str.c_str());
			if (no_conf || msgbox_Sure(msg, true, true)) {
				UnicodeString fnam;
				if (no_conf)
					fnam = DownloadPath + zip_nam;
				else {
					UserModule->PrepareSaveDlg(_T("更新ファイルの保存"),
						_T("アーカイブ (*.zip)|*.zip"), zip_nam.c_str(), DownloadPath);
					if (UserModule->SaveDlg->Execute()) {
						fnam = UserModule->SaveDlg->FileName;
						DownloadPath = ExtractFilePath(fnam);
					}
				}
				if (!fnam.IsEmpty()) {
					//既存アーカイブから更新
					if (no_conf && file_exists(fnam)) {
						if (!UpdateFromArc(fnam)) GlobalAbort();
					}
					//ダウンロードファイルから更新
					else if (DownloadWorkProgress(url + zip_nam, fnam)==mrOk) {
						msg.sprintf(_T("V%.2f → V%.2f\n更新しますか?"), VersionNo/100.0, new_vno/100.0);
						if (no_conf || msgbox_Sure(msg, true, true)) {
							if (!UpdateFromArc(fnam, true)) GlobalAbort();
						}
					}
				}
			}
		}
		else {
			msg.sprintf(_T(" NyanFi %s (%s) : 最新バージョンを使用しています。"),
						VersionStr.c_str(), is_X64()? _T("x64") : _T("x86")),
			msgbox_OK(msg, "更新の確認");
		}
	}
	catch (EAbort &e) {
		cursor_Default();
		msgbox_ERR(e.Message);
	}

	ClearTempDir();
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::CheckUpdateActionUpdate(TObject *Sender)
{
	TAction *ap = (TAction*)Sender;
	ap->Visible = ScrMode==SCMD_FLIST;
	ap->Enabled = ap->Visible && IsPrimary && get_BusyTaskCount()==0 && !CurWorking && !FindBusy && !CalcBusy;
}

//---------------------------------------------------------------------------
//アーカイブから更新
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::UpdateFromArcActionExecute(TObject *Sender)
{
	UnicodeString arc_name;
	//最新のアーカイブを探す
	if (TEST_ActParam("UN")) {
		std::unique_ptr<TStringList> flst(new TStringList());
		get_files(DownloadPath, _T("nyanfi*.zip"), flst.get());
		if (flst->Count>0) {
			flst->CustomSort(comp_NaturalOrder);
			int zip_vno = extract_int_def(ExtractFileName(flst->Strings[flst->Count - 1]), 0);
			if (zip_vno>VersionNo) arc_name = flst->Strings[flst->Count - 1];
		}
		if (arc_name.IsEmpty()) msgbox_OK("新しいアーカイブがありません。", "アーカイブから更新");
	}
	//アーカイブを選択
	else {
		UserModule->PrepareOpenDlg(_T("更新用アーカイブの選択"), _T("アーカイブ (*.zip)|*.zip"), _T("nyanfi*.zip"), DownloadPath);
		if (UserModule->OpenDlg->Execute() && msgbox_Sure(_T("更新しますか?"), true, true))
			arc_name = UserModule->OpenDlg->FileName;
	}

	//更新
	if (!arc_name.IsEmpty()) {
		ClearTempDir();
		if (!UpdateFromArc(arc_name)) msgbox_ERR(GlobalErrMsg);
		ClearTempDir();
	}
}
//---------------------------------------------------------------------------


//■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
// 文字列検索(GREP)
//■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::GrepPageControlChange(TObject *Sender)
{
	SetSttBarGrepOpt();
	GrepResultList->Clear();
	ResultListBox->Clear();
	UpdateActions();
	((GrepPageControl->ActivePage==FindSheet)? GrepFindComboBox : RepFindComboBox)->SetFocus();
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::GrepPageControlChanging(TObject *Sender, bool &AllowChange)
{
	if (FindBusy) AllowChange = false;
}
//---------------------------------------------------------------------------
//Grep用ステータスバーのリサイズ
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::GrepSttSplitterMoved(TObject *Sender)
{
	int stt_wd = GrepSttPanel->ClientWidth - GrepFilterPanel->Width;
	GrepStatusBar->Panels->Items[0]->Width = stt_wd * 0.45;	//***
	GrepStatusBar->Panels->Items[1]->Width = stt_wd * 0.2;	//***
	GrepFilterPanel->Repaint();
	SttPrgBar->ResetPos();
	SetSttBarGrepDir();
}
//---------------------------------------------------------------------------
//Grepパネルのリサイズ
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::GrepT11PanelResize(TObject *Sender)
{
	//※アンカーがずれる(?)現象の対策
	GrepFindComboBox->Width = GrepT11Panel->Width - GrepFindComboBox->Left - 8;
}
//---------------------------------------------------------------------------
//置換パネルのリサイズ
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::RepT1PanelResize(TObject *Sender)
{
	//検索・置換文字列入力欄の調整
	int e_w = (RegExRCheckBox->Left - RepFindLabel->Width - RepStrLabel->Width - RepFindLabel->Left - 30) / 2;
	RepFindComboBox->Width = e_w;
	RepStrComboBox->Width  = e_w;
	RepStrComboBox->Left   = RepFindComboBox->Left + RepFindComboBox->Width + RepStrLabel->Width + 10;
	RepStrLabel->Left	   = RepStrComboBox->Left - RepStrLabel->Width - 4;
}
//---------------------------------------------------------------------------
//文字列検索/置換の準備
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::PrepareGrep()
{
	FindBusy	 = true;
	GrepFiltered = false;

	SttPrgBar->Begin(_T("準備中..."));
	GrepResultList->Clear();
	ResultListBox->Clear();
	GrepFilterEdit->Text  = EmptyStr;
	GrepFilterEdit->Color = col_Invalid;
	UpdateActions();

	//マスクのリストを作成
	TStringDynArray msk_lst = split_strings_semicolon(GrepMaskComboBox->Text);

	bool sub_sw = SubDirCheckBox->Checked;
	int  sub_n  = SubDirNCombo->ItemIndex;

	GrepPathList->Clear();
	GrepFileList->Clear();
	TStringList *lst = GetCurList(true);
	//選択あり
	if (GetSelCount(lst)>0) {
		for (int i=0; i<lst->Count; i++) {
			file_rec *fp = (file_rec*)lst->Objects[i];
			if (!fp->selected) continue;
			(fp->is_dir? GrepPathList : GrepFileList)->Add(fp->f_name);
		}
	}
	//選択なし
	else {
		TStringDynArray skip_dir_lst = split_strings_semicolon(SkipDirEdit->Text);
		for (int i=0; i<lst->Count; i++) {
			file_rec *fp = (file_rec*)lst->Objects[i];
			if (!is_selectable(fp)) continue;
			if (fp->is_dir) {
				if (sub_sw && sub_n>0) {
					bool skip = false;
					for (int j=0; j<skip_dir_lst.Length && !skip; j++)
						skip = str_match(skip_dir_lst[j], fp->n_name);
					if (!skip) GrepPathList->Add(fp->f_name);
				}
			}
			else {
				for (int j=0; j<msk_lst.Length; j++) {
					if (str_match(msk_lst[j], fp->n_name)) {
						GrepFileList->Add(fp->f_name); break;
					}
				}
			}
		}
	}

	//サブディレクトリ
	for (int i=0; i<GrepPathList->Count; i++) {
		for (int j=0; j<msk_lst.Length; j++) {
			get_all_files_ex(GrepPathList->Strings[i], msk_lst[j], GrepFileList,
				sub_sw, sub_n - 1, SkipDirEdit->Text, ShowHideAtr, ShowSystemAtr);
		}
	}

	UnicodeString msg;
	msg.sprintf(_T("%u ファイルを%s中..."),
					GrepFileList->Count, (GrepPageControl->ActivePage==FindSheet)? _T("検索") : _T("置換"));
	SttPrgBar->Begin(msg.c_str());
}

//---------------------------------------------------------------------------
//Grep結果リストでのキー操作
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ResultListBoxKeyDown(TObject *Sender, WORD &Key, TShiftState Shift)
{
	try {
		UnicodeString KeyStr = get_KeyStr(Key, Shift);
		UnicodeString CmdStr = Key_to_CmdF(KeyStr);
		UnicodeString prm	 = get_PrmStr(CmdStr);
		CmdStr = get_CmdStr(CmdStr);

		int cmd_id	= idx_of_word_i(_T("ReturnList|TextViewer|FileEdit|MenuBar|Delete|OpenByApp|OpenByWin"), CmdStr);
		ActionParam = EmptyStr;

		if (FindBusy) {
			GrepFilterEdit->SetFocus();
			UserAbort(USTR_ProcBusy);
		}

		TListBox *lp = (TListBox*)Sender;
		if (lp->ItemIndex==-1) {
			if (cmd_id==0) ReturnListAction->Execute();
		}
		else {
			UnicodeString lbuf = lp->Items->Strings[lp->ItemIndex];
			UnicodeString fnam = split_pre_tab(lbuf);
			int lno = get_pre_tab(lbuf).ToIntDef(0);

			switch (cmd_id) {
			case 0:	//リストに戻る
				ReturnListAction->Execute();
				break;
			case 1:	//閲覧
				fromGrep = true;
				if (test_HtmlExt(get_extension(fnam))) TxtViewer->isHtm2Txt = false;
				//別ウィンドウ
				if (USAME_TI(prm, "XW")) {
					//イベント: テキストビュアーを開く直前
					ExeEventCommand(OnTvOpen, EmptyStr, fnam);

					TExTxtViewer *xtv = new TExTxtViewer(this);
					xtv->FileName = xtv->OrgName = fnam;
					xtv->LineNo   = lno;
					xtv->Show();
				}
				//内部
				else {
					int idx = GrepWorkList? WorkList->IndexOf(fnam) : -1;
					bool ok = (idx!=-1)?
								OpenTxtViewer((file_rec*)WorkList->Objects[idx], false, 0, lno) :
							 	SetAndOpenTxtViewer(fnam, lno);
					if (!ok) UserAbort(USTR_FileNotOpen);
				}
				break;
			case 2:	//編集
				//バイナリ文書
				if (xd2tx_TestExt(get_extension(fnam)))
					ExeCommandAction("FileEdit", fnam);
				//テキスト(タグジャンプ)
				else {
					if (!open_by_TextEditor(fnam, lno)) GlobalAbort();
				}
				break;
			case 3:	//メニューバー
				MenuBarAction->Execute();
				Application->ProcessMessages();
				lp->SetFocus();
				break;

			case 5:	//独自の関連付けで開く
				ExeCommandAction("OpenByApp", fnam);
				break;
			case 6:	//Windowsの関連付けで開く
				ExeCommandAction("OpenByWin", fnam);
				break;

			default:
				if (ExeCmdListBox(lp, CmdStr))
					ResultListBoxClick(lp);
				else if (equal_ENTER(KeyStr)) {
					if (!JumpToList(CurListTag, fnam)) GlobalAbort();
				}
				//一時的に削除
				else if (cmd_id==4 || equal_DEL(KeyStr)) {
					int idx = lp->ItemIndex;
					lp->Items->Delete(idx);
					lp->ItemIndex = std::min(idx, lp->Count - 1);
					SttPrgBar->End(UnicodeString().sprintf(_T("一時削除あり (%u/%u)"), lp->Count, GrepResultList->Count));
					GrepFiltered = true;
				}
				//検索語へ
				else if (USAME_TI(KeyStr, "Ctrl+S")) {
					((GrepPageControl->ActivePage==FindSheet)? GrepFindComboBox : RepFindComboBox)->SetFocus();
				}
				//フィルタへ
				else if (SameText(KeyStr, KeyStr_Filter)) {
					GrepFilterEdit->SetFocus();
				}
				//右クリックメニュー
				else if (contained_wd_i(KeysStr_Popup, KeyStr)) {
					show_PopupMenu(GrepPopupMenu, lp);
				}
			}
		}

		if (!is_DialogKey(Key)) Key = 0;
	}
	catch (EAbort &e) {
		SttBarWarn(e.Message);
	}
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ResultListBoxClick(TObject *Sender)
{
	if (FindBusy) {
		GrepFilterEdit->SetFocus();	return;
	}

	TListBox *lp = ResultListBox;
	if (lp->ItemIndex==-1) return;
	UnicodeString fnam = get_pre_tab(lp->Items->Strings[lp->ItemIndex]);
	SetSttBarGrepDir((GrepShowSubDir && !CurStt->is_Work)? GrepResultPath : ExtractFilePath(fnam));

	if (ShowSttBar)
		StatusBar1->Panels->Items[0]->Text = UnicodeString().sprintf(_T("%s  %s"), fnam.c_str(), get_FileInfStr(fnam).c_str());
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ResultListBoxDblClick(TObject *Sender)
{
	if (FindBusy) {
		GrepFilterEdit->SetFocus();	return;
	}

	perform_Key_RETURN((TControl*)Sender);
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ResultListBoxExit(TObject *Sender)
{
	SetSttBarGrepDir();
}

//---------------------------------------------------------------------------
//検索履歴の入れ換え
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::RegExCheckBoxClick(TObject *Sender)
{
	if (Initialized)
		change_ComboBoxHistory(GrepFindComboBox, _T("GrepFindHistory"), _T("GrepPtnHistory"), RegExCheckBox->Checked);
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::RegExRCheckBoxClick(TObject *Sender)
{
	if (Initialized)
		change_ComboBoxHistory(RepFindComboBox, _T("RepFindHistory"), _T("RepPtrnHisgory"), RegExRCheckBox->Checked);
}

//---------------------------------------------------------------------------
//検索文字列欄でのキー操作
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::GrepFindComboBoxKeyDown(TObject *Sender, WORD &Key, TShiftState Shift)
{
	UnicodeString KeyStr = get_KeyStr(Key, Shift);

	if (contained_wd_i(KeysStr_ToList, KeyStr) && ResultListBox->Count>0)
		ResultListBox->SetFocus();
	else if (SameText(KeyStr, KeyStr_Filter))
		GrepFilterEdit->SetFocus();
	else return;

	Key = 0;
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::GrepFindComboBoxKeyPress(TObject *Sender, System::WideChar &Key)
{
	if (is_KeyPress_CtrlNotCVX(Key)) Key = 0;
}

//---------------------------------------------------------------------------
//フィルタでのキー操作
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::GrepFilterEditKeyDown(TObject *Sender, WORD &Key, TShiftState Shift)
{
	UnicodeString KeyStr = get_KeyStr(Key, Shift);
	//一覧へ
	if (contained_wd_i(KeysStr_ToList, KeyStr))
		ResultListBox->SetFocus();
	//検索語へ
	else if (contained_wd_i(_T("Ctrl+F|Ctrl+S"), KeyStr))
		((GrepPageControl->ActivePage==FindSheet)? GrepFindComboBox : RepFindComboBox)->SetFocus();
	//Migemoモード切替
	else if (SameText(KeyStr, KeyStr_Migemo))
		MigemoCheckBox->Checked = !MigemoCheckBox->Checked;
	else return;

	Key = 0;
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::GrepFilterEditKeyPress(TObject *Sender, System::WideChar &Key)
{
	if (is_KeyPress_CtrlNotCVX(Key)) Key = 0;
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::GrepFilterEditEnter(TObject *Sender)
{
	GrepFilterEdit->Color = scl_Window;
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::GrepFilterEditExit(TObject *Sender)
{
	InvColIfEmpty(GrepFilterEdit);
}

//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::GrepFltOptCheckBoxClick(TObject *Sender)
{
	GrepFilterEditChange(GrepFilterEdit);
}

//---------------------------------------------------------------------------
//Grep 検索結果の描画
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ResultListBoxDrawItem(TWinControl *Control, int Index,
		TRect &Rect, TOwnerDrawState State)
{
	TListBox *lp = (TListBox*)Control;
	UnicodeString itmstr = lp->Items->Strings[Index];
	UnicodeString p_nam  = split_pre_tab(itmstr);
	UnicodeString d_nam  = ExtractFilePath(p_nam);	d_nam.Delete(1, GrepResultPath.Length());
	UnicodeString f_nam  = ExtractFileName(p_nam);
	UnicodeString f_ext  = get_extension(f_nam);
	UnicodeString f_lno  = split_pre_tab(itmstr);
	if (!f_lno.IsEmpty()) {
		if (USAME_TS(f_lno, "-")) f_lno = "   "; else f_lno = UnicodeString().sprintf(_T("(%s)"), f_lno.c_str());
	}
	UnicodeString ln_str = itmstr;
	if (GrepTrimTop) ln_str = TrimLeft(ln_str);

	TRect tmp_rc = Rect;
	OffsetRect(tmp_rc, 0, -tmp_rc.Top);

	int xp_L = tmp_rc.Left + 4;
	int xp_R = tmp_rc.Right;

	//一時ビットマップを作成し、それに一旦描画(ちらつき防止)
	std::unique_ptr<Graphics::TBitmap> tmp_bmp(new Graphics::TBitmap());
	tmp_bmp->SetSize(Rect.Width(), tmp_rc.Height());

	TCanvas *tmp_cv = tmp_bmp->Canvas;
	tmp_cv->Font->Assign(GrepResFont);
	bool is_irreg = IsIrregularFont(tmp_cv->Font);

	tmp_cv->Brush->Color = col_bgList;
	tmp_cv->FillRect(tmp_rc);

	int yp	 = tmp_rc.Top;
	int dx	 = 0;
	int x_mg = Scaled2;

	//項目番号
	if (GrepShowItemNo) {
		int idx = Index + 1;
		if (GrepFileItemNo) {	//ファイル単位で先頭行のみに表示
			idx  = (int)lp->Items->Objects[Index];
			int idx0 = (Index>0)? (int)lp->Items->Objects[Index - 1] : -1;
			if ((int)lp->Items->Objects[Index] == idx0) idx = 0;
		}
		LineNoOut(tmp_cv, tmp_rc, idx);

		tmp_cv->Brush->Color = col_bgList;
		dx = tmp_rc.Left;
	}
	//ディレクトリ名
	if (GrepShowSubDir && !CurStt->is_Work && !d_nam.IsEmpty()) {
		tmp_cv->Font->Color = col_Folder;
		int xp = xp_L + dx;
		PathNameOut(d_nam, tmp_cv, xp, yp);
		dx = xp - xp_L + x_mg;
	}
	//ファイル名
	tmp_cv->Font->Color = f_lno.IsEmpty()? col_Error : get_ExtColor(f_ext);
	tmp_cv->TextOut(xp_L + dx, yp, f_nam);
	dx += (get_TextWidth(tmp_cv, f_nam, is_irreg) + x_mg);

	//行番号
	if (!f_lno.IsEmpty()) {
		tmp_cv->Font->Color = col_LineNo;
		tmp_cv->TextOut(xp_L + dx, yp, f_lno);
		dx += (get_TextWidth(tmp_cv, f_lno, is_irreg) + x_mg);
	}

	int cwd = abs(tmp_cv->Font->Height);
	int wdn = 16;
	for (;;) {
		if (dx<cwd*wdn) { dx = cwd*wdn;  break; }
		wdn += 4;
		if (cwd*wdn > ClientWidth/2) break;
	}

	if (f_lno.IsEmpty()) {
		//エラー表示
		tmp_cv->Font->Color = col_Error;
		tmp_cv->TextOut(xp_L + dx, yp, ln_str);
	}
	else {
		tmp_cv->Font->Color = col_fgList;
		int xp = xp_L + dx;
		if (GrepPageControl->ActivePage == FindSheet) {
			//マッチ語のリストを作成
			std::unique_ptr<TStringList> wlist(new TStringList());
			if (GrepPageControl->ActivePage == FindSheet) {
				//フィルタ
				if (GrepEmFilter && !GrepFilterEdit->Text.IsEmpty()) {
					get_MatchWordList(ln_str, GrepFilterEdit->Text,
						MigemoCheckBox->Checked, false, AndOrCheckBox->Checked, wlist.get());
				}
				//検索語
				else {
					get_MatchWordList(ln_str, GrepKeyword, 
						false, RegExCheckBox->Checked, AndOrCheckBox->Checked, wlist.get());
				}
			}
			else
				wlist->Add(conv_esc_char(RepStrComboBox->Text));

			UnicodeString s0 = get_tkn(ln_str, '\n');
			UnicodeString s1 = get_tkn_r(ln_str, '\n');

			//マッチ語が見えないとき前部分を省略
			if (GrepOmitTop) {
				//最初のマッチ位置
				int p1 = -1, p2 = -1;
				for (int i=0; i<wlist->Count; i++) {
					UnicodeString kwd = wlist->Strings[i];
					int p = GrepCaseSenstive? s0.Pos(kwd) : s0.UpperCase().Pos(kwd.UpperCase());
					if (p>0) {
						p1 = (p1==-1)? p : std::min(p, p1);
						if (p1==p) p2 = p1 + kwd.Length();
					}
				}
				//前部分を省略
				int wd = xp_R - xp;
				if (p2>0 && (get_TextWidth(tmp_cv, s0.SubString(1, p2), is_irreg) > wd)) {
					wd /= 2;
					int w_r = get_TextWidth(tmp_cv, s0.SubString(p1, s0.Length() - p1 + 1), is_irreg);
					if (w_r<wd) wd += (wd - w_r);
					wd -= get_TextWidth(tmp_cv, "… ", is_irreg);
					if (!s1.IsEmpty()) wd -= get_TextWidth(tmp_cv, " ", is_irreg);
					int w = 0;
					for (int i=p1; i>4; i--) {
						w += get_TextWidth(tmp_cv, s0.SubString(i, 1), is_irreg);
						if (w<wd) continue;
						s0.Delete(1, i);
						s0.Insert("…", 1);
						break;
					}
				}
			}

			//マッチ語の強調表示
			EmphasisTextOut(s0, wlist.get(), tmp_cv, xp, yp, GrepCaseSenstive, false);

			//次行表示
			if (!s1.IsEmpty()) TabCrTextOut("\n" + s1, tmp_cv, xp, yp, col_fgList);
		}
		else {
			TabCrTextOut(ln_str, tmp_cv, xp, yp, col_fgList);
		}
	}

	//カーソル線
	if (State.Contains(odFocused)) {
		draw_Line(tmp_cv, xp_L, tmp_rc.Bottom - 2, xp_R, tmp_rc.Bottom - 2,
			CursorWidth, State.Contains(odFocused)? col_Cursor : tmp_cv->Brush->Color);
	}

	//描画
	lp->Canvas->Draw(Rect.Left, Rect.Top, tmp_bmp.get());
	if (State.Contains(odFocused)) lp->Canvas->DrawFocusRect(Rect);
}

//---------------------------------------------------------------------------
//Grep 拡張設定
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::GrepOptionActionExecute(TObject *Sender)
{
	if (!GrepExOptDlg) GrepExOptDlg = new TGrepExOptDlg(this);	//初回に動的作成
	if (GrepExOptDlg->ShowModal()==mrOk) {
		GrepStatusBar->Panels->Items[2]->Text = EmptyStr;
		SetSttBarGrepOpt();
	}

	((GrepPageControl->ActivePage==FindSheet)? GrepFindComboBox : RepFindComboBox)->SetFocus();
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::GrepOptionActionUpdate(TObject *Sender)
{
	TAction *ap = (TAction*)Sender;
	ap->Visible = ScrMode==SCMD_GREP;
	ap->Enabled = ap->Visible && IsPrimary && !FindBusy;
}

//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::SetSttBarGrepDir(UnicodeString dnam)
{
	if (dnam.IsEmpty()) dnam = GrepPath;
	GrepStatusBar->Hint = yen_to_delimiter(dnam);
	GrepStatusBar->Panels->Items[0]->Text
		= get_MiniPathName(dnam, GrepStatusBar->Panels->Items[0]->Width, GrepStatusBar->Font, true);
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::SetSttBarGrepOpt()
{
	UnicodeString msg;
	if (GrepPageControl->ActivePage == FindSheet) {
		if (GrepOutMode!=0) {
			msg = "出力先: ";
			if (GrepOutMode==1)
				msg += ExtractFileName(GrepFileName);
			else
				msg += "クリップボード";
			if (!GrepAppName.IsEmpty()) msg.cat_sprintf(_T("  起動: %s"), ExtractFileName(GrepAppName).c_str());
		}
		else {
			msg = "出力設定: 無し";
		}
	}
	else {
		if (SaveReplaceLog) {
			msg.sprintf(_T("結果ログ: %s"), ExtractFileName(ReplaceLogName).c_str());
			if (ReplaceAppend) msg += " に追加";
		}
	}
	StatusBar1->Panels->Items[0]->Text	  = msg;
	GrepStatusBar->Panels->Items[2]->Text = msg;
}

//---------------------------------------------------------------------------
//出力用のGREP結果行を作成
//---------------------------------------------------------------------------
UnicodeString __fastcall TNyanFiForm::MakeGrepOutLine(
	int  idx,
	bool rep_log)	//置換ログ (default = false);
{
	if (idx<0 || idx>=ResultListBox->Count) return EmptyStr;

	UnicodeString itmstr = ResultListBox->Items->Strings[idx];
	UnicodeString f_nam  = split_pre_tab(itmstr);	//ファイル名
	UnicodeString f_lno  = split_pre_tab(itmstr);	//行番号
	UnicodeString ln_str = itmstr;					//行内容
	if (GrepReplaceTab) ln_str = ReplaceStr(ln_str, "\t", " ");
	if (GrepTrimLeft) {
		TStringDynArray l_lst = SplitString(ln_str, "\n");
		ln_str = EmptyStr;
		for (int j=0; j<l_lst.Length; j++) {
			if (!ln_str.IsEmpty()) ln_str += "\n";
			ln_str += TrimLeft(l_lst[j]);
		}
	}
	ln_str = ReplaceStr(ln_str, "\n", GrepReplaceCr? conv_esc_char(GrepRepCrStr) : UnicodeString("\r\n"));

	//ファイル情報文字列を作成
	UnicodeString f_inf = GrepFileFmt;
	if (f_inf.IsEmpty()) f_inf = "$F $L:";
	f_inf = conv_esc_char(f_inf);
	f_inf = ReplaceStr(f_inf, "$F", add_quot_if_spc(f_nam));
	f_inf = ReplaceStr(f_inf, "$L", f_lno);
	if (f_lno.IsEmpty()) ln_str.Insert("エラー: ", 1);

	//マッチ後の前後に文字列挿入
	if (!rep_log && (!GrepInsStrW.IsEmpty() || !GrepInsStrW2.IsEmpty())) {
		UnicodeString w1 = conv_esc_char(GrepInsStrW);
		UnicodeString w2 = conv_esc_char(GrepInsStrW2);
		if (RegExCheckBox->Checked) {
			TRegExOptions opt;
			if (!GrepCaseSenstive) opt << roIgnoreCase;
			TMatch mt = TRegEx::Match(ln_str, GrepKeyword, opt);
			if (mt.Success) ln_str = ReplaceStr(ln_str, mt.Value, w1 + mt.Value + w2);
		}
		else {
			std::unique_ptr<TStringList> wlist(new TStringList());
			find_mlt_str(GrepKeyword, ln_str, wlist.get(), GrepCaseSenstive);
			for (int i=0; i<wlist->Count; i++) {
				UnicodeString fwd = wlist->Strings[i];
				ln_str = ReplaceStr(ln_str, fwd, w1 + fwd + w2);
			}
		}
	}
	return (f_inf + ln_str);
}

//---------------------------------------------------------------------------
//出力用のGREP結果リストを作成
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::MakeGrepOutList(
	TStringList *lst,	//取得バッファ
	bool rep_log)		//置換ログ (default = false);
{
	lst->Clear();

	for (int i=0; i<ResultListBox->Count; i++) lst->Add(MakeGrepOutLine(i, rep_log));
}

//---------------------------------------------------------------------------
//Grep 検索開始
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::GrepStartActionExecute(TObject *Sender)
{
	int start_cnt = GetTickCount();

	PrepareGrep();
	GrepKeyword 	 = Trim(GrepFindComboBox->Text);
	GrepCaseSenstive = CaseCheckBox->Checked;
	GrepResultPath	 = GrepPath;

	if (GrepFileList->Count==0) {
		FindBusy = false;
		GrepFindComboBox->SetFocus();
		GrepResultMsg = LoadUsrMsg(USTR_NoObject);
		SttPrgBar->End(GrepResultMsg);
		if (ShowMsgHint) ShowMessageHint(GrepResultMsg, col_bgWarn);
		return;
	}

	GrepFindComboBox->Enabled = false;
	std::unique_ptr<TStringList> f_buf(new TStringList());
	std::unique_ptr<TStringList> r_buf(new TStringList());
	UnicodeString tmp;
	int f_cnt = 0, fnd_cnt = 0;
	int idx_tag = 1;
	for (int i=0; !FindAborted && i<GrepFileList->Count; i++) {
		Application->ProcessMessages();
		SttPrgBar->SetPosR(1.0*i/GrepFileList->Count);

		UnicodeString fnam = GrepFileList->Strings[i];	if (!file_exists(fnam)) continue;
		UnicodeString fext = get_extension(fnam);

		if (xd2tx_TestExt(fext)) {
			if (!xd2tx_Extract(fnam, f_buf.get()))  continue;
		}
		else {
			if (load_text_ex(fnam, f_buf.get())==0) continue;
		}

		r_buf->Clear();
		bool f_matched = false;
		bool del_tag   = ExclTagCheckBox->Checked && test_HtmlExt(fext);
		TRegExOptions opt;
		if (!GrepCaseSenstive) opt << roIgnoreCase;
		for (int lp=0; lp<f_buf->Count; lp++) {
			UnicodeString lbuf = f_buf->Strings[lp];
			if (del_tag)  lbuf = replace_regex(lbuf, _T("<[^<>]+>"), null_TCHAR);	//HTML文書のタグ部分を除外

			bool found = RegExCheckBox->Checked ? TRegEx::IsMatch(lbuf, GrepKeyword, opt)
											    : find_mlt(GrepKeyword, lbuf, AndCheckBox->Checked, false, GrepCaseSenstive);
			//発見
			if (found) {
				f_matched = true;
				UnicodeString itmstr;
				itmstr.sprintf(_T("%s\t%u\t%s"), fnam.c_str(), lp + 1, lbuf.c_str());
				//次行表示
				if (NextLineCheckBox->Checked) {
					int p	 = lp + 1;
					int lcnt = 0;
					while (p<f_buf->Count && lcnt<3) {
						tmp = f_buf->Strings[p++];
						if (tmp.IsEmpty()) continue;
						if (lcnt==0) itmstr += "\n";
						itmstr.cat_sprintf(_T("%s\n"), tmp.c_str());
						lcnt++;
					}
				}
				r_buf->AddObject(itmstr, (TObject*)(NativeInt)idx_tag);
				fnd_cnt++;
				if (OneMatchCheckBox->Checked) break;
			}
		}

		if (r_buf->Count>0) {
			ResultListBox->Items->AddStrings(r_buf.get());
			ResultScrPanel->UpdateKnob();
			idx_tag++;
		}

		if (f_matched) {
			f_cnt++;
			GrepStatusBar->Panels->Items[2]->Text =
				tmp.sprintf(_T("%u/%uファイルで %u行発見"), f_cnt, GrepFileList->Count, fnd_cnt);
		}
	}
	GrepFindComboBox->Enabled = true;

	//---------------------------
	//検索終了
	//---------------------------
	float res_cnt = (GetTickCount() - start_cnt)/1000.0;
	FindBusy = false;
	if (UnInitializing) return;

	ResultScrPanel->UpdateKnob();

	if (ResultListBox->Count>0) {
		GrepResultList->Assign(ResultListBox->Items);
		//検索語を履歴に追加
		add_ComboBox_history(GrepFindComboBox, GrepKeyword);
		IniFile->SaveComboBoxItems(GrepFindComboBox, RegExCheckBox->Checked? _T("GrepPtnHistory") : _T("GrepFindHistory"));
		//マスクを履歴に追加
		add_ComboBox_history(GrepMaskComboBox);
		CloseIME(Handle);

		ResultListBox->ItemIndex = 0;
		ResultListBox->SetFocus();
		ResultListBoxClick(ResultListBox);
		GrepResultMsg.sprintf(_T("%u/%uファイルで %u行発見"), f_cnt, GrepFileList->Count, fnd_cnt);
		play_sound(SoundFindFin);

		//結果出力
		if (GrepOutMode!=0) {
			try {
				std::unique_ptr<TStringList> rbuf(new TStringList());
				MakeGrepOutList(rbuf.get());

				UnicodeString fnam = to_absolute_name(GrepFileName);
				int top = 1;
				//ファイル
				if (GrepOutMode==1) {
					if (!fnam.IsEmpty()) {
						std::unique_ptr<TStringList> fbuf(new TStringList());
						if (file_exists(fnam) && GrepAppend) {
							fbuf->LoadFromFile(fnam);	top = fbuf->Count + 1;
						}
						fbuf->AddStrings(rbuf.get());
						if (!saveto_TextUTF8(fnam, fbuf.get())) UserAbort(USTR_FaildSave);
					}
				}
				//クリップボード
				else {
					copy_to_Clipboard(rbuf->Text);
				}

				//アプリ起動
				if (!GrepAppName.IsEmpty()) {
					UnicodeString app_nam = get_actual_path(GrepAppName);
					UnicodeString prmstr  = GrepAppParam;
					if (GrepOutMode==1) {
						prmstr = ReplaceStr(prmstr, "$F", add_quot_if_spc(fnam));
						prmstr = ReplaceStr(prmstr, "$L", IntToStr(top));
					}
					else {
						prmstr = ReplaceStr(prmstr, "$F", EmptyStr);
					}
					if (!Execute_ex(app_nam, prmstr, GrepAppDir)) UserAbort(USTR_FaildExec);
				}
			}
			catch (EAbort &e) {
				SttBarWarn(e.Message);
			}
		}
	}
	else {
		GrepFindComboBox->SetFocus();
		GrepResultMsg.sprintf(_T("%uファイルで見つかりません。"), GrepFileList->Count);
		if (ShowMsgHint) ShowMessageHint(USTR_NotFound, col_bgWarn);
	}

	SttPrgBar->End(GrepResultMsg);
	GrepStatusBar->Panels->Items[1]->Text = tmp.sprintf(_T("%s %5.1f秒"), (FindAborted? _T("中断") : _T("終了")), res_cnt);
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::GrepStartActionUpdate(TObject *Sender)
{
	TAction *ap = (TAction*)Sender;
	if (ScrMode==SCMD_GREP && GrepPageControl->ActivePage==FindSheet) {
		//正規表現パターンのチェック
		UnicodeString kwd = Trim(GrepFindComboBox->Text);
		bool reg_ng = RegExCheckBox->Checked && !kwd.IsEmpty() && !chk_RegExPtn(kwd);
		bool kwd_ok = RegExCheckBox->Checked? (!kwd.IsEmpty() && !reg_ng) : !kwd.IsEmpty();
		GrepFindComboBox->Color = reg_ng? col_Illegal : scl_Window;
		ap->Enabled = !FindBusy && kwd_ok && !(GrepMaskComboBox->Enabled && GrepMaskComboBox->Text.IsEmpty());

		AndCheckBox->Enabled  = !RegExCheckBox->Checked;
		SubDirNCombo->Enabled = SubDirCheckBox->Checked;
		StartBtn->Default	  = !ResultListBox->Focused();
		GrepFindComboBox->Tag
			= CBTAG_HISTORY | (GrepFindComboBox->Focused()? CBTAG_RGEX_V : 0) | (RegExCheckBox->Checked? CBTAG_RGEX_E : 0);
	}
	else ap->Enabled = false;
}

//---------------------------------------------------------------------------
//検索中断
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::GrepAbortActionExecute(TObject *Sender)
{
	if (FindBusy) FindAborted = true;
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::GrepAbortActionUpdate(TObject *Sender)
{
	((TAction*)Sender)->Enabled = FindBusy;
}

//---------------------------------------------------------------------------
//検索結果に名前を付けて保存
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::GrepSaveAsActionExecute(TObject *Sender)
{
	UserModule->SaveTxtDlg->Title		  = LoadUsrMsg(USTR_SaveAs, _T("検索結果"));
	UserModule->SaveTxtDlg->InitialDir    = ExcludeTrailingPathDelimiter(SaveTxtPath);
	UserModule->SaveTxtDlg->EncodingIndex = SaveEncIndex;
	if (UserModule->SaveTxtDlg->Execute()) {
		SaveTxtPath  = ExtractFilePath(UserModule->SaveTxtDlg->FileName);
		SaveEncIndex = UserModule->SaveTxtDlg->EncodingIndex;

		std::unique_ptr<TStringList> fbuf(new TStringList());
		MakeGrepOutList(fbuf.get(), (GrepPageControl->ActivePage == ReplaceSheet));

		if (!saveto_TextFile(UserModule->SaveTxtDlg->FileName, fbuf.get(), SaveEncIndex)) msgbox_ERR(USTR_FaildSave);
	}
}
//---------------------------------------------------------------------------
//検索結果をクリップボードにコピー
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::GrepClipCopyActionExecute(TObject *Sender)
{
	std::unique_ptr<TStringList> rbuf(new TStringList());
	MakeGrepOutList(rbuf.get(), (GrepPageControl->ActivePage == ReplaceSheet));
	copy_to_Clipboard(rbuf->Text);
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::GrepLineCopyActionExecute(TObject *Sender)
{
	copy_to_Clipboard(MakeGrepOutLine(ResultListBox->ItemIndex, (GrepPageControl->ActivePage == ReplaceSheet)));
}

//---------------------------------------------------------------------------
//GREP検索結果の絞り込み
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::GrepExtractCore(
	bool except)	//ture = 除外, false = 抽出
{
	UnicodeString msg;
	msg.sprintf(_T("検索結果の絞り込み : %s"), (except? _T("除外") : _T("抽出")));
	UnicodeString swd = inputbox_ex(msg.c_str(), _T("キーワード"), EmptyStr);
	if (!swd.IsEmpty()) {
		cursor_HourGlass();
		int idx = 0;
		while (idx<ResultListBox->Count) {
			if (find_mlt(swd, ResultListBox->Items->Strings[idx], !except, !except))
				ResultListBox->Items->Delete(idx);
			else idx++;
		}

		set_ListBox_ItemNo(ResultListBox);

		ResultScrPanel->UpdateKnob();
		cursor_Default();

		if (ResultListBox->Count>0) {
			ResultListBox->ItemIndex = 0;
			ResultListBox->SetFocus();
			ResultListBoxClick(ResultListBox);
		}
		else {
			SttBarWarn(_T("絞り込んだ項目がありません。"));
		}

		SttPrgBar->End(msg.sprintf(_T("絞り込み (%u/%u)"), ResultListBox->Count, GrepResultList->Count));
		GrepFiltered = true;
	}
}

//---------------------------------------------------------------------------
//検索結果の絞り込み : 抽出
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::GrepExtractActionExecute(TObject *Sender)
{
	GrepExtractCore(false);
}
//---------------------------------------------------------------------------
//検索結果の絞り込み : 除外
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::GrepExceptActionExecute(TObject *Sender)
{
	GrepExtractCore(true);
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::GrepResultActionUpdate(TObject *Sender)
{
	TAction *ap = (TAction*)Sender;
	ap->Visible = ScrMode==SCMD_GREP;
	ap->Enabled = ap->Visible && !FindBusy && ResultListBox->Count>0;
}

//---------------------------------------------------------------------------
//絞り込みの解除
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::GrepReleaseActionExecute(TObject *Sender)
{
	ResultListBox->Items->Assign(GrepResultList);
	set_ListBox_ItemNo(ResultListBox);

	ResultListBox->ItemIndex = 0;
	ResultScrPanel->UpdateKnob();
	ResultListBox->SetFocus();
	ResultListBoxClick(ResultListBox);
	GrepFiltered = false;
	SttPrgBar->End(GrepResultMsg);
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::GrepReleaseActionUpdate(TObject *Sender)
{
	TAction *ap = (TAction*)Sender;
	ap->Visible = ScrMode==SCMD_GREP;
	ap->Enabled = ap->Visible && GrepFiltered;
}
//---------------------------------------------------------------------------
//絞り込みを確定
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::GrepConfirmActionExecute(TObject *Sender)
{
	GrepResultList->Assign(ResultListBox->Items);
	GrepFiltered = false;
	GrepResultMsg = get_tkn(GrepResultMsg, ' ').cat_sprintf(_T(" %u行発見*"), GrepResultList->Count);
	SttPrgBar->End(GrepResultMsg);
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::GrepConfirmActionUpdate(TObject *Sender)
{
	TAction *ap = (TAction*)Sender;
	ap->Visible = ScrMode==SCMD_GREP;
	ap->Enabled = ap->Visible && GrepFiltered;
}

//---------------------------------------------------------------------------
//検索結果の退避
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::PushResultActionExecute(TObject *Sender)
{
	GrepResultBuff->Assign(ResultListBox->Items);
	GrepResultMsgBuf  = GrepResultMsg;
	GrepResultPathBuf = GrepResultPath;
}
//---------------------------------------------------------------------------
//検索結果の復帰
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::PopResultActionExecute(TObject *Sender)
{
	GrepResultList->Assign(GrepResultBuff);
	GrepResultPath = GrepResultPathBuf;
	GrepResultMsg  = GrepResultMsgBuf;
	ResultListBox->Items->Assign(GrepResultList);
	ResultListBox->Repaint();
	ResultScrPanel->UpdateKnob();
	SttPrgBar->End(GrepResultMsg);
	ResultListBoxClick(ResultListBox);
	GrepResultBuff->Clear();
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::PopResultActionUpdate(TObject *Sender)
{
	TAction *ap = (TAction*)Sender;
	ap->Visible = ScrMode==SCMD_GREP;
	ap->Enabled = ap->Visible && GrepResultBuff->Count>0;
}

//---------------------------------------------------------------------------
//URLを開く
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::GrepOpenUrlActionExecute(TObject *Sender)
{
	Execute_ex(ListBoxGetURL(ResultListBox));
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::GrepOpenUrlActionUpdate(TObject *Sender)
{
	TAction *ap = (TAction*)Sender;
	ap->Visible = ScrMode==SCMD_GREP;
	ap->Enabled  = ap->Visible && !ListBoxGetURL(ResultListBox).IsEmpty();
}

//---------------------------------------------------------------------------
//ヒットしたカレントのファイルを選択
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::GrepSelResActionExecute(TObject *Sender)
{
	TStringList *lst = GetCurList();
	ClrSelect(lst);

	std::unique_ptr<TStringList> flst(new TStringList());
	int cnt = 0;
	for (int i=0; i<ResultListBox->Count; i++) {
		UnicodeString itmstr = ResultListBox->Items->Strings[i];
		UnicodeString p_nam  = split_pre_tab(itmstr);
		if (flst->IndexOf(p_nam)!=-1) continue;
		flst->Add(p_nam);
		int idx = lst->IndexOf(p_nam);
		if (idx!=-1) {
			file_rec *fp = (file_rec*)lst->Objects[idx];
			fp->selected = true;
			cnt++;
		}
	}

	//情報表示を更新
	SetDriveInfo();
	SetSttBarInf();

	if (cnt>0) msgbox_OK(UnicodeString().sprintf(_T("%u 個のファイルを選択しました。"), cnt));

	bool sel_f_only = (cnt>0);
	GrepMaskComboBox->Enabled = !sel_f_only;
	SubDirCheckBox->Enabled   = !sel_f_only;
	SubDirNCombo->Enabled	  = !sel_f_only;
	SkipDirEdit->Enabled	  = !sel_f_only;
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::GrepSelResActionUpdate(TObject *Sender)
{
	TAction *ap = (TAction*)Sender;
	ap->Visible = ScrMode==SCMD_GREP;
	ap->Enabled = ap->Visible && !FindBusy && ResultListBox->Count>0;
}

//---------------------------------------------------------------------------
//GREP結果リストに項目番号を表示
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::GrepShowItemNoActionExecute(TObject *Sender)
{
	GrepShowItemNo = !GrepShowItemNo;
	ResultListBox->Repaint();
	ResultListBoxClick(ResultListBox);
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::GrepShowItemNoActionUpdate(TObject *Sender)
{
	TAction *ap = (TAction*)Sender;
	ap->Visible = ScrMode==SCMD_GREP;
	ap->Enabled = ap->Visible;
	ap->Checked = GrepShowItemNo;
}
//---------------------------------------------------------------------------
//項目番号をファイル単位で表示
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::GrepFileItemNoActionExecute(TObject *Sender)
{
	GrepFileItemNo = !GrepFileItemNo;
	ResultListBox->Repaint();
	ResultListBoxClick(ResultListBox);
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::GrepFileItemNoActionUpdate(TObject *Sender)
{
	TAction *ap = (TAction*)Sender;
	ap->Visible = ScrMode==SCMD_GREP;
	ap->Enabled = ap->Visible;
	ap->Checked = GrepFileItemNo;
}

//---------------------------------------------------------------------------
//GREP結果リストにサブディレクトリ名を表示
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::GrepShowSubDirActionExecute(TObject *Sender)
{
	GrepShowSubDir = !GrepShowSubDir;
	ResultListBox->Repaint();
	ResultListBoxClick(ResultListBox);
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::GrepShowSubDirActionUpdate(TObject *Sender)
{
	TAction *ap = (TAction*)Sender;
	ap->Visible = ScrMode==SCMD_GREP;
	ap->Enabled = ap->Visible;
	ap->Checked = GrepShowSubDir;
}
//---------------------------------------------------------------------------
//行頭の空白・タブを削除
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::GrepTrimTopActionExecute(TObject *Sender)
{
	GrepTrimTop = !GrepTrimTop;
	ResultListBox->Repaint();
	ResultListBoxClick(ResultListBox);
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::GrepTrimTopActionUpdate(TObject *Sender)
{
	TAction *ap = (TAction*)Sender;
	ap->Visible = ScrMode==SCMD_GREP;
	ap->Enabled = ap->Visible;
	ap->Checked = GrepTrimTop;
}
//---------------------------------------------------------------------------
//マッチ語が見えないとき前部分を省略
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::GrepOmitTopActionExecute(TObject *Sender)
{
	GrepOmitTop = !GrepOmitTop;
	ResultListBox->Repaint();
	ResultListBoxClick(ResultListBox);
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::GrepOmitTopActionUpdate(TObject *Sender)
{
	TAction *ap = (TAction*)Sender;
	ap->Visible = ScrMode==SCMD_GREP;
	ap->Enabled = ap->Visible;
	ap->Checked = GrepOmitTop;
}
//---------------------------------------------------------------------------
//フィルタの語を強調表示
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::GrepEmFilterActionExecute(TObject *Sender)
{
	GrepEmFilter = !GrepEmFilter;
	ResultListBox->Repaint();
	ResultListBoxClick(ResultListBox);
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::GrepEmFilterActionUpdate(TObject *Sender)
{
	TAction *ap = (TAction*)Sender;
	ap->Visible = ScrMode==SCMD_GREP;
	ap->Enabled = ap->Visible;
	ap->Checked = GrepEmFilter;
}

//---------------------------------------------------------------------------
//Grep 結果のフィルタ処理
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::GrepFilterEditChange(TObject *Sender)
{
	if (GrepResultList->Count==0) return;

	if (!GrepFilterEdit->Text.IsEmpty()
		&& (!MigemoCheckBox->Checked || (MigemoCheckBox->Checked && GrepFilterEdit->Text.Length()>=IncSeaMigemoMin)))
	{
		std::unique_ptr<TStringList> rbuf(new TStringList());
		filter_List(GrepResultList, rbuf.get(), GrepFilterEdit->Text, MigemoCheckBox->Checked, AndOrCheckBox->Checked);
		ResultListBox->Items->Assign(rbuf.get());
		SttPrgBar->End(UnicodeString().sprintf(_T("%s (%u)"), GrepResultMsg.c_str(), ResultListBox->Count));
		GrepFiltered = true;
	}
	else {
		ResultListBox->Items->Assign(GrepResultList);
		SttPrgBar->End(GrepResultMsg);
		GrepFiltered = false;
	}

	set_ListBox_ItemNo(ResultListBox);
	ResultScrPanel->UpdateKnob();
}

//---------------------------------------------------------------------------
//Grep 文字列置換
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ReplaceStartActionExecute(TObject *Sender)
{
	PrepareGrep();
	GrepResultPath = GrepPath;

	if (GrepFileList->Count==0) {
		FindBusy = false;
		RepFindComboBox->SetFocus();
		GrepResultMsg = LoadUsrMsg(USTR_NoObject);
		SttPrgBar->End(GrepResultMsg);
		if (ShowMsgHint) ShowMessageHint(GrepResultMsg, col_bgWarn);
		return;
	}

	int f_cnt = 0, rep_cnt = 0, fnd_cnt = 0, err_cnt = 0;
	int idx_tag = 1;
	UnicodeString swd = RepFindComboBox->Text;	if (!RegExRCheckBox->Checked) swd = conv_esc_char(swd);
	UnicodeString rwd = conv_esc_char(RepStrComboBox->Text);
	UnicodeString tmp;

	std::unique_ptr<TStringList> f_buf(new TStringList());	//読込バッファ
	std::unique_ptr<TStringList> o_buf(new TStringList());	//出力バッファ
	bool ask_rep = AskRepCheckBox->Checked;
	for (int i=0; !FindAborted && i<GrepFileList->Count; i++) {
		Application->ProcessMessages();
		SttPrgBar->SetPosR(1.0*i/GrepFileList->Count);

		UnicodeString fnam = GrepFileList->Strings[i];	if (!file_exists(fnam)) continue;
		bool with_bom = true;
		if (load_text_ex(fnam, f_buf.get(), 0, 0, false, NULL, &with_bom)==0) continue;

		o_buf->Clear();
		bool changed   = false;
		int  f_rep_cnt = 0;
		for (int lp=0; !FindAborted && lp<f_buf->Count; lp++) {
			UnicodeString lbuf = f_buf->Strings[lp];
			int start_p = 1;	//検索開始位置
			do {
				UnicodeString tmp_buf = lbuf.SubString(start_p, lbuf.Length() - start_p + 1);
				int match_p, match_len;
				if (RegExRCheckBox->Checked) {
					TMatch mt = TRegEx::Match(tmp_buf, swd);	//大小文字を区別
					if (mt.Success) {
						match_p   = mt.Index;
						match_len = mt.Length;
					}
					else match_p = 0;
				}
				else {
					match_p = CaseRCheckBox->Checked? tmp_buf.Pos(swd) : pos_i(swd, tmp_buf);
					match_len = swd.Length();
				}
				if (match_p==0) break;

				//マッチ
			  	fnd_cnt++;
				int org_p = start_p + match_p - 1;	//元文字列での位置
				bool ok = true;
				if (ask_rep) {
					if (!AskRepDlg) AskRepDlg = new TAskRepDlg(this);	//初回に動的作成
					AskRepDlg->FileName  = fnam;
					AskRepDlg->FileCount = GrepFileList->Count;
					AskRepDlg->FileIndex = i;
					AskRepDlg->KeyWord	 = tmp_buf.SubString(match_p, match_len);
					AskRepDlg->FoundLine = lp + 1;
					AskRepDlg->FoundPos  = org_p;
					AskRepDlg->CurIndex  = 3;

					//前後行表示を設定
					TListBox *rp = AskRepDlg->RepListBox;	rp->Clear();
					//前
					for (int j=3; j>0; j--) {
						int idx = lp - j;
						rp->Items->Add((idx>=0 && idx<o_buf->Count)? o_buf->Strings[idx] : EmptyStr);
					}
					//マッチ行
					rp->Items->Add(lbuf);
					//後
					for (int j=1; j<=8; j++) {
						int idx = lp + j;
						rp->Items->Add((idx<f_buf->Count)? f_buf->Strings[idx] : EmptyStr);
					}
					//確認
					TModalResult res = AskRepDlg->ShowModal();
					ok = (res==mrYes || res==mrAll);
					if (res==mrAbort || res==mrCancel) {
						FindAborted = true;
						changed = false;	f_rep_cnt = 0;
					}
					else if (res==mrAll) ask_rep = false;
				}

				//置換
				if (ok) {
					int rep_len;
					if (RegExRCheckBox->Checked) {
						UnicodeString orgstr = tmp_buf.SubString(match_p, match_len);
						UnicodeString repstr = TRegEx::Replace(orgstr, swd, rwd);
						lbuf.Delete(org_p, match_len);	lbuf.Insert(repstr, org_p);
						rep_len = repstr.Length();
					}
					else {
						lbuf.Delete(org_p, match_len);	lbuf.Insert(rwd, org_p);
						rep_len = rwd.Length();
					}
					changed = true;
					f_rep_cnt++;
					start_p = org_p + rep_len;		//検索位置を更新
					tmp.sprintf(_T("%s\t%u\t"), fnam.c_str(), lp + 1);
					ResultListBox->Items->AddObject(tmp + lbuf, (TObject*)(NativeInt)idx_tag);
					ResultListBox->Repaint();
				}
				else {
					start_p = org_p + match_len;	//検索位置を更新
				}
			} while (!FindAborted);

			//出力バッファを設定
			o_buf->Add(lbuf);
		}

		rep_cnt += f_rep_cnt;

		//ファイル保存
		if (changed) {
			idx_tag++;
			f_cnt++;
			GrepStatusBar->Panels->Items[2]->Text =
				tmp.sprintf(_T(" %u/%uファイルで %u箇所置換"), f_cnt, GrepFileList->Count, rep_cnt);

			if (BackupReplace) {
				//バックアップ作成
				try {
					UnicodeString bext = def_if_empty(FExtRepBackup, _T(".bak"));
					if (bext[1]!='.') bext.Insert(".", 1);
					UnicodeString bak_nam = ChangeFileExt(fnam, bext);
					if (!RepBackupDir.IsEmpty()) {
						UnicodeString pnam = ExcludeTrailingPathDelimiter(to_absolute_name(RepBackupDir, ExtractFilePath(fnam)));
						if (chk_cre_dir(pnam).IsEmpty()) Abort();
						bak_nam = IncludeTrailingPathDelimiter(pnam) + ExtractFileName(bak_nam);
					}
					delete_FileIf(bak_nam);

					if (get_HardLinkCount(fnam)>1) {
						if (!copy_File(fnam, bak_nam)) Abort();
					}
					else {
						if (!move_File(fnam, bak_nam)) Abort();
					}
				}
				catch (EAbort &e) {
					err_cnt++;
					ResultListBox->Items->Add(tmp.sprintf(_T("%s\t\tバックアップの作成に失敗しました。"), fnam.c_str()));
					ResultListBox->Repaint();
				}
			}

			//置換したファイルを保存
			try {
				o_buf->WriteBOM = with_bom;
				o_buf->SaveToFile(fnam, f_buf->Encoding);
			}
			catch (...) {
				err_cnt++;
				ResultListBox->Items->Add(LoadUsrMsg(USTR_FaildSave, fnam + "\t\t"));
				ResultListBox->Repaint();
			}
		}
	}

	GrepResultMsg.sprintf(_T("%s"), FindAborted? _T("中断") : _T("終了"));
	FindBusy = false;

	GrepResultList->Assign(ResultListBox->Items);

	if (rep_cnt>0) {
		//検索、置換文字列を履歴に追加
		add_ComboBox_history(RepFindComboBox);
		IniFile->SaveComboBoxItems(RepFindComboBox,  RegExRCheckBox->Checked? _T("RepFindRxHisgory") : _T("RepFindHistory"));
		add_ComboBox_history(RepStrComboBox);

		//結果表示
		ResultListBox->ItemIndex = 0;
		ResultListBox->SetFocus();
		GrepResultMsg.cat_sprintf(_T(" %u/%uファイルで %u箇所置換"), f_cnt, GrepFileList->Count, rep_cnt);
		if (err_cnt>0) GrepResultMsg.cat_sprintf(_T("  エラー:%u"), err_cnt);
		play_sound(SoundFindFin);

		//ログ出力
		if (SaveReplaceLog && !ReplaceLogName.IsEmpty()) {
			UnicodeString fnam = ReplaceLogName;
			if (ExtractFilePath(fnam).IsEmpty()) fnam.Insert(ExePath, 1);
			//既存に追加の場合は一旦読み込む
			std::unique_ptr<TStringList> fbuf(new TStringList());
			int top = 1;
			if (file_exists(fnam) && ReplaceAppend) {
				fbuf->LoadFromFile(fnam);	top = fbuf->Count + 1;
			}
			//結果を変換
			std::unique_ptr<TStringList> rbuf(new TStringList());
			MakeGrepOutList(rbuf.get(), true);
			//ヘッダを挿入
			int lp = 0;
			if (top>1) { rbuf->Insert(lp++, EmptyStr); top++; }
			rbuf->Insert(lp++, tmp.sprintf(_T("文字列置換 >>%s"), format_DateTime(Now()).c_str()));
			rbuf->Insert(lp++, tmp.sprintf(_T("検索文字列 [%s] → 置換文字列 [%s]"), swd.c_str(), rwd.c_str()));
			rbuf->Insert(lp++,
				tmp.sprintf(_T(" %uファイル中 %uファイルで %u箇所置換"), GrepFileList->Count, f_cnt, rep_cnt));
			rbuf->Insert(lp++, EmptyStr);
			//保存
			fbuf->AddStrings(rbuf.get());
			if (saveto_TextUTF8(fnam, fbuf.get())) {
				if (OpenReplaceLog && !open_by_TextEditor(fnam, top)) SttBarWarn(GlobalErrMsg);
			}
			else SttBarWarnUstr(USTR_FaildSave);
		}
	}
	else if (fnd_cnt==0) {
		GrepResultMsg = LoadUsrMsg(USTR_NotFound);
		if (ShowMsgHint) ShowMessageHint(GrepResultMsg, col_bgWarn);
	}

	SttPrgBar->End(GrepResultMsg);
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ReplaceStartActionUpdate(TObject *Sender)
{
	TAction *ap = (TAction*)Sender;
	if (GrepPageControl->ActivePage == ReplaceSheet) {
		//正規表現パターンのチェック
		UnicodeString kwd = RepFindComboBox->Text;
		bool reg_ng = RegExRCheckBox->Checked && !kwd.IsEmpty() && !chk_RegExPtn(kwd);
		bool kwd_ok = RegExRCheckBox->Checked? (!kwd.IsEmpty() && !reg_ng) : !kwd.IsEmpty();
		RepFindComboBox->Color = reg_ng? col_Illegal : scl_Window;
		ap->Enabled = !FindBusy && kwd_ok;

		CaseRCheckBox->Enabled = !RegExRCheckBox->Checked;
		StartRBtn->Default	   = !ResultListBox->Focused();
		RepFindComboBox->Tag
			= CBTAG_HISTORY | (RepFindComboBox->Focused()? CBTAG_RGEX_V : 0) | (RegExRCheckBox->Checked? CBTAG_RGEX_E : 0);
		RepStrComboBox->Tag = CBTAG_HISTORY;
	}
	else {
		ap->Enabled = false;
	}
}

//---------------------------------------------------------------------------
//Grep 閉じる (検索中なら中断)
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::GrepCanBtnClick(TObject *Sender)
{
	if (FindBusy) FindAborted = true; else SetScrMode();
}
//---------------------------------------------------------------------------


//■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
// テキストビュアー
//■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

//---------------------------------------------------------------------------
//テキストビュアーを開く
//---------------------------------------------------------------------------
bool __fastcall TNyanFiForm::OpenTxtViewer(
	file_rec *fp,
	bool bin_mode,		//バイナリ (default = false)
	int code_page,		//コードページ (default = 0 : 判定)
	int lno,			//行番号 (default = 0 : 履歴を参照)
	bool force_txt)		//強制的にテキストとして開く(bin_mode=false の場合 default = false)
{
	GlobalErrMsg = EmptyStr;
	file_rec *cfp = NULL;

	try {
		if (fp) cfp = cre_new_file_rec(fp);

		TxtViewer->Clear();
		if (!cfp || is_Processing(cfp)) Abort();

		UnicodeString fnam = (cfp->is_virtual || cfp->is_ftp)? cfp->tmp_name : cfp->f_name;
		if (!file_exists(fnam)) SttBarWarnUstr(USTR_FileNotOpen);

		//外部ビュアーで開く
		if (!ExtTxViewer.IsEmpty() && isViewText) {
			if (lno==0) lno = 1;
			if (!open_by_ExtTextViewer(fnam, lno)) GlobalAbort();
			return true;
		}

		//イベント: テキストビュアーを開く直前
		ExeEventCommand(OnTvOpen, EmptyStr, fnam);

		int cpag = 0;
		isXDoc2Txt = bin_mode? false : ((UseXd2tx || fromGrep) && xd2tx_TestExt(cfp->f_ext));
		isRichText = bin_mode? false : test_FileExt(cfp->f_ext, _T(".rtf.wri"));
		isViewText = bin_mode? false : (force_txt? true : is_TextFile(fnam, &cpag, NULL, &TxtViewer->HasBOM));
		if (cfp->is_ftp || cfp->inf_list->Count==0) GetFileInfList(cfp, true);

		FuncListDlg->ClearList();

		TxtMainPanel->Visible	= false;
		TxtScrollPanel->Visible = false;

		//ここからテキストビュアー・モード
		cursor_HourGlass();
		SetScrMode(SCMD_TVIEW);

		TxtViewer->FileName   = fnam;
		TxtViewer->OrgName	  = cfp->f_name;
		TxtViewer->isSelected = cfp->selected;
		TxtViewer->FileRec	  = cre_new_file_rec(cfp);	//TxtViewer->Clear で破棄されるのでコピーを作成
		TxtViewPanel->Font->Color = col_Teal;
		TxtViewPanel->Caption = "読込中...";	TxtViewPanel->Repaint();

		UnicodeString inf_str;
		inf_str.sprintf(_T("%s  %s"), warn_filename_RLO(fnam).c_str(), Trim(get_FileInfStr(cfp)).c_str());

		//------------------------------
		//xdoc2txt
		//------------------------------
		if (isXDoc2Txt) {
			std::unique_ptr<TStringList> vbuf(new TStringList());
			if (!xd2tx_Extract(fnam, vbuf.get())) SttBarWarnUstr(USTR_FaildLoad);
			TxtViewer->AssignText(vbuf.get(), lno);
			TxtViewer->LineBreakStr = EmptyStr;
		}
		//------------------------------
		//リッチテキスト
		//------------------------------
		else if (isRichText) {
			TempRichEdit->Lines->LoadFromFile(fnam);
			TxtViewer->AssignText(TempRichEdit->Lines, lno);
		}
		//------------------------------
		//テキスト表示
		//------------------------------
		else if (isViewText) {
			//コード判定して読込(サイズ制限)
			std::unique_ptr<TStringList> vbuf(new TStringList());
			if (code_page==0) code_page = cpag;
			load_text_ex(fnam, vbuf.get(), code_page, ViewTxtLimitSize, force_txt, &TxtViewer->LineBreakStr);
			if (!GlobalErrMsg.IsEmpty()) SttBarWarn(GlobalErrMsg);
			TxtViewer->AssignText(vbuf.get(), lno);
			//行数
			inf_str.cat_sprintf(_T("  %s:%s"),
 				(test_HtmlExt(cfp->f_ext)? _T("ソース行数") : _T("行数")), get_size_str_B(vbuf->Count, 0).c_str());
			if (TxtViewer->isLimited) inf_str += "(部分)";
		}
		//------------------------------
		//バイナリ・ダンプ表示
		//------------------------------
		else {
			if (!TxtViewer->AssignBin()) Abort();
			if (TxtViewer->isLimited) inf_str += "    (部分)";
		}

		TxtSttHeader->Hint		= TxtViewer->FileName;
		TxtViewPanel->Caption	= EmptyStr;
		TxtScrollPanel->Visible = true;
		TxtMainPanel->Visible	= true;
		TxtViewer->SttHdrInf	= inf_str;
		TxtViewer->SetSttInf();
		SetSttBarInf(cfp);
		del_file_rec(cfp);

		cursor_Default();

		//イベント: テキストビュアーを開いた直後
		ExeEventCommand(OnTvOpened);
		return true;
	}
	catch (...) {
		if (GlobalErrMsg.IsEmpty()) GlobalErrMsg = LoadUsrMsg(USTR_FileNotOpen);

		del_file_rec(cfp);
		cursor_Default();

		//テキストビュアー・モードになってからの予期せぬ例外に対処
		//  ファイラーに戻す
		if (ScrMode==SCMD_TVIEW) {
			TxtViewer->CloseAuxForm();
			TxtViewer->Clear();
			SetScrMode(SCMD_FLIST, CurListTag);
		}

		return false;
	}
}
//---------------------------------------------------------------------------
bool __fastcall TNyanFiForm::SetAndOpenTxtViewer(
	UnicodeString fnam,
	int lno,		//行番号 (default = 0)
	bool pop_dir)	//開いた後、元の位置に復帰 (default = false)
{
	if (!FileExists(fnam)) return false;

	RecoverFileList();

	UnicodeString cnam = CurPath[CurListTag];
	int cidx = FileListBox[CurListTag]->ItemIndex;

	UnicodeString pnam = extract_file_path(fnam);
	if (!SameText(CurPath[CurListTag], pnam)) {
		SetScrMode();
		CurPath[CurListTag] = exclede_delimiter_if_root(pnam);
	}
	if (pop_dir) ReloadList(CurListTag, fnam);

	int p = fnam.Length() - ExtractFileName(fnam).Length();
	if (p>2 && fnam[p]==':') {
		if (IndexOfFileList(fnam.SubString(1, p - 1))==-1) return false;
		file_rec *cfp = cre_new_file_rec(fnam, CurListTag);
		bool res = OpenTxtViewer(cfp, false, 0, lno);
		del_file_rec(cfp);
		if (!res) return false;
	}
	else {
		if (IndexOfFileList(fnam)==-1) return false;
		if (!OpenTxtViewer(GetCurFrecPtr(true), false, 0, lno)) return false;
	}

	if (pop_dir) UpdateCurPath(cnam, cidx);

	return true;
}

//---------------------------------------------------------------------------
//テキストの末尾を指定行分テキストビュアーを表示
//---------------------------------------------------------------------------
bool __fastcall TNyanFiForm::OpenTxtViewerTail(file_rec *fp, int limit_ln, bool reverse)
{
	if (!fp) return false;

	bool res = false;
	file_rec *cfp = cre_new_file_rec(fp);

	try {
		TxtViewer->Clear();
		if (!cfp || is_Processing(cfp)) Abort();

		UnicodeString fnam = (cfp->is_virtual || cfp->is_ftp)? cfp->tmp_name : cfp->f_name;
		if (!file_exists(fnam)) SttBarWarnUstr(USTR_FileNotOpen);

		int cpag;
		if (!is_TextFile(fnam, &cpag)) UserAbort(USTR_NotText);

		//イベント: テキストビュアーを開く直前
		ExeEventCommand(OnTvOpen, EmptyStr, fnam);

		if (cfp->inf_list->Count==0) GetFileInfList(cfp, true);

		FuncListDlg->ClearList();

		TxtMainPanel->Visible	= false;
		TxtScrollPanel->Visible = false;

		//ここからテキストビュアー・モード
		cursor_HourGlass();
		SetScrMode(SCMD_TVIEW);

		TxtViewer->FileName   = fnam;
		TxtViewer->OrgName	  = cfp->f_name;
		TxtViewer->isSelected = cfp->selected;
		TxtViewer->FileRec	  = cre_new_file_rec(cfp);	//TxtViewer->Clear で破棄されるのでコピーを作成
		TxtViewer->isTail	  = true;
		TxtViewer->isReverse  = reverse;
		TxtViewer->TailLine   = limit_ln;
		TxtViewPanel->Font->Color = col_Teal;
		TxtViewPanel->Caption = "読込中...";	TxtViewPanel->Repaint();

		//コード判定して読込(行数制限)
		std::unique_ptr<TStringList> vbuf(new TStringList());
		if (load_text_tail(fnam, vbuf.get(), cpag, limit_ln, reverse)==0) SttBarWarnUstr(USTR_FileNotOpen);
		TxtViewer->AssignText(vbuf.get(), reverse? 1 : vbuf->Count);

		UnicodeString inf_str;
		inf_str.sprintf(_T("%s  %s  行数:%s"),
			ExtractFileName(fnam).c_str(), Trim(get_FileInfStr(cfp)).c_str(), get_size_str_B(vbuf->Count, 0).c_str());
		UnicodeString opt_str;
		if (vbuf->Count==limit_ln)	opt_str += "末尾";
		if (reverse)				opt_str += ":逆順";
		if (!opt_str.IsEmpty()) inf_str.cat_sprintf(_T(" (%s)"), opt_str.c_str());
		TxtViewer->SttHdrInf	= inf_str;
		TxtSttHeader->Hint		= TxtViewer->FileName;
		TxtViewPanel->Caption	= EmptyStr;
		TxtScrollPanel->Visible = true;
		TxtMainPanel->Visible	= true;
		SetSttBarInf(cfp);
		cursor_Default();

		//イベント: テキストビュアーを開いた直後
		ExeEventCommand(OnTvOpened);
		res = true;
	}
	catch (EAbort &e) {
		GlobalErrMsg = e.Message;
	}

	del_file_rec(cfp);

	return res;
}
//---------------------------------------------------------------------------
bool __fastcall TNyanFiForm::OpenTxtViewerTail(UnicodeString fnam, int limit_ln, bool reverse)
{
	file_rec *fp = cre_new_file_rec(fnam);	if (!fp) return false;

	bool res = OpenTxtViewerTail(fp, limit_ln, reverse);
	del_file_rec(fp);
	return res;
}

//---------------------------------------------------------------------------
//クリップボードをテキストビュアーを開く
//---------------------------------------------------------------------------
bool __fastcall TNyanFiForm::ViewClipText()
{
	if (!Clipboard()->HasFormat(CF_TEXT)) return false;

	ExeEventCommand(OnTvOpen, "ViewClip");

	SetScrMode(SCMD_TVIEW);
	TxtViewer->FileName = EmptyStr;
	std::unique_ptr<TStringList> vbuf(new TStringList());
	vbuf->Text = Clipboard()->AsText;
	TxtViewer->isClip = true;
	TxtViewer->AssignText(vbuf.get());
	TxtViewer->SttHdrInf = UnicodeString().sprintf(_T("クリップボード  行数:%u"), TxtViewer->MaxLine);
	TxtViewer->SetSttInf();
	SetSttBarInf();
	TxtScrollPanel->Visible = true;

	//イベント: テキストビュアーを開いた直後
	ExeEventCommand(OnTvOpened, "ViewClip");

	return true;
}

//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::TextPaintBoxPaint(TObject *Sender)
{
	TxtViewer->Repaint();
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::TextMarginBoxPaint(TObject *Sender)
{
	TCanvas *cv = TextMarginBox->Canvas;
	cv->Brush->Color = TxtViewer->color_Margin;
	cv->FillRect(TextMarginBox->ClientRect);
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::TextScrollBarChange(TObject *Sender)
{
	TxtViewer->ScrollAdjust();
	TxtViewScrPanel->Repaint();
}

//---------------------------------------------------------------------------
//テキストビュアーでのマウス操作
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::TextPaintBoxMouseDown(TObject *Sender, TMouseButton Button, TShiftState Shift, int X, int Y)
{
	CancelKeySeq();

	if (Button==mbLeft) TxtViewer->onMouseDown(X, Y);
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::TextPaintBoxMouseMove(TObject *Sender, TShiftState Shift, int X, int Y)
{
	if (Shift.Contains(ssLeft)) TxtViewer->onMouseMove(X, Y);
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::TextPaintBoxMouseUp(TObject *Sender, TMouseButton Button, TShiftState Shift, int X, int Y)
{
	TxtViewer->onMouseUp();
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::TextPaintBoxDblClick(TObject *Sender)
{
	if (TxtViewer->ExtClicked) ExeCommandV(_T("Close")); else TxtViewer->onDblClick();
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::TextScrollBoxDblClick(TObject *Sender)
{
	ExeCommandV(_T("Close"));
}

//---------------------------------------------------------------------------
//コードページ変更
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::CodePageActionExecute(TObject *Sender)
{
	OpenTxtViewer(GetCurFrecPtr(), false, ((TAction*)Sender)->Tag, 0, true);
}

//---------------------------------------------------------------------------
//テキストビュアーでの文字列検索
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::PopFindItemClick(TObject *Sender)
{
	FindTextAction->Execute();
}

//---------------------------------------------------------------------------
//テキストビュアーでのコマンド処理
//---------------------------------------------------------------------------
bool __fastcall TNyanFiForm::ExeCommandV(UnicodeString cmd, UnicodeString prm)
{
	if (cmd.IsEmpty()) return false;

	if (prm.IsEmpty()) {
		prm = exclude_quot(get_PrmStr(cmd));
		cmd = get_CmdStr(cmd);
	}

	ActionParam = extract_ExeParam(prm, &ActionDesc);
	ActionOk	= true;

	Application->ProcessMessages();

	try {
		bool handled = TxtViewer->ExeCommand(cmd.c_str(), ActionParam);
		if (handled && !GlobalErrMsg.IsEmpty()) GlobalAbort();
		if (handled) TextAbort(_T("HANDLED"));

		TListBox *lp = FileListBox[CurListTag];
		bool req_close = false;
		bool req_bEdit = false;
		handled = true;

		//クリップボードにコピー
		if (USAME_TI(cmd, "ClipCopy")) {
			TxtViewer->ClipCopy(TEST_ActParam("AD"));
		}
		//ファイルの選択
		else if (USAME_TI(cmd, "SelectFile")) {
			TStringList *lst = GetCurList(true);
			int idx = lst->IndexOf(TxtViewer->OrgName);
			if (idx!=-1) {
				TxtViewer->isSelected = set_select_r((file_rec*)lst->Objects[idx]);
				TxtSttHeader->Repaint();
				//次のファイル
				if (!fromGrep && TEST_ActParam("NX")) {
					TxtViewer->add_ViewHistory();
					TStringList *lst = GetCurList();
					int idx = IndexOfFileList(TxtViewer->OrgName);
					idx = to_NextFile(lst, idx);
					if (idx!=-1) {
						file_rec *fp = (file_rec*)lst->Objects[idx];
						if ((CurStt->is_Arc || contains_Slash(fp->f_name)) && !SetTmpFile(fp)) UserAbort(USTR_FaildTmpUnpack);
						if (!OpenTxtViewer(fp)) GlobalAbort();
						lp->ItemIndex = idx;
						TxtViewer->reqCurPos = true;
					}
				}
			}
		}
		//ファイルの削除
		else if (USAME_TI(cmd, "Delete")) {
			DeleteVAction->Execute();
			TxtViewer->reqCurPos = true;
		}
		//前/次のファイルを表示
		else if (!CurStt->is_FTP && contained_wd_i(_T("PrevFile|NextFile"), cmd)) {
			bool is_prev = USAME_TI(cmd, "PrevFile");
			//Grep検索結果リスト
			if (fromGrep) {
				if (ResultListBox->Count==0) Abort();
				int idx = is_prev? ResultListBox->ItemIndex - 1 : ResultListBox->ItemIndex + 1;
				if (idx<0) idx = ResultListBox->Count - 1; else if (idx>=ResultListBox->Count) idx = 0;
				ResultListBox->ItemIndex = idx;
				UnicodeString lbuf = ResultListBox->Items->Strings[idx];
				UnicodeString fnam = split_pre_tab(lbuf);
				int			   lno = get_pre_tab(lbuf).ToIntDef(0);
				//同ファイル内移動
				if (TxtScrollPanel->Visible && SameText(fnam, TxtViewer->FileName)) {
					TxtViewer->ToLine(lno);
				}
				//別ファイル
				else {
					TxtViewer->add_ViewHistory();
					if (!SetAndOpenTxtViewer(fnam, lno)) UserAbort(USTR_FileNotOpen);
				}
			}
			//ファイルリスト
			else {
				TxtViewer->add_ViewHistory();
				TStringList *lst = GetCurList();
				int idx = IndexOfFileList(TxtViewer->OrgName);
				idx = is_prev? to_PrevFile(lst, idx) : to_NextFile(lst, idx);
				if (idx==-1) Abort();
				file_rec *fp = (file_rec*)lst->Objects[idx];
				if ((CurStt->is_Arc || contains_Slash(fp->f_name)) && !SetTmpFile(fp)) UserAbort(USTR_FaildTmpUnpack);
				if (!OpenTxtViewer(fp)) GlobalAbort();
				lp->ItemIndex = idx;
				TxtViewer->reqCurPos = true;
			}
		}
		//ファイルの再読み込み
		else if (USAME_TI(cmd, "ReloadFile")) {
			if (TxtViewer->FileName.IsEmpty()) UserAbort(USTR_InvalidCmd);
			bool ok;
			if (TxtViewer->isTail) {
				set_RedrawOff(TxtViewPanel);	//ちらつき防止
				ok = OpenTxtViewerTail(TxtViewer->FileName, TxtViewer->TailLine, TxtViewer->isReverse);
				set_RedrawOn(TxtViewPanel);
				TxtViewer->Repaint(true);
			}
			else {
				ok = SetAndOpenTxtViewer(TxtViewer->FileName, TxtViewer->get_CurLineNo());
			}
			if (!ok) UserAbort(USTR_FileNotOpen);
		}
		//テキスト/バイナリ表示の切り換え
		else if (USAME_TI(cmd, "ChangeViewMode")) {
			TxtViewer->CloseAuxForm();
			//バイナリ表示
			if (isXDoc2Txt || isRichText || isViewText) {
				if (!OpenTxtViewer(GetCurFrecPtr(), true)) GlobalAbort();
			}
			//テキスト表示(強制)
			else {
				if (!OpenTxtViewer(GetCurFrecPtr(), false, 0, 0, true)) GlobalAbort();
			}
		}
		//文字コード変更
		else if (USAME_TI(cmd, "ChangeCodePage")) {
			if (TxtViewer->isXDoc2Txt || TxtViewer->isBinary) UserAbort(USTR_InvalidCmd);
			int code_page = TxtViewer->change_CodePage(ActionParam);
			if (code_page==0) UserAbort(USTR_IllegalParam);
			if (!OpenTxtViewer(GetCurFrecPtr(), false, code_page, 0, true)) GlobalAbort();
		}
		//編集
		else if (USAME_TI(cmd, "FileEdit")) {
			if (isXDoc2Txt) ActionParam = TxtViewer->FileName;
			//テキスト編集
			if (ActionParam.IsEmpty()) {
				UnicodeString fnam;
				if (TxtViewer->isClip) {
					//クリップボードを一時ファイルに保存
					fnam.sprintf(_T("%sCLIPBOARD.TXT"), TempPathA.c_str());
					TxtViewer->TxtBufList->SaveToFile(fnam);
				}
				else
					fnam = TxtViewer->FileName;
				if (!open_by_TextEditor(fnam, TxtViewer->get_CurLineNo())) GlobalAbort();
				req_close = true;
			}
			//ファイル名を指定して編集
			else ExeCommandAction(cmd, ActionParam);
		}
		//バイナリ編集
		else if (USAME_TI(cmd, "BinaryEdit")) {
			if (!file_exists(get_actual_path(BinaryEditor))) UserAbort(USTR_AppNotFound);
			req_bEdit = true;
			req_close = true;
		}
		//先頭アドレス
		else if (USAME_TI(cmd, "SetTopAddr"))	SetTopAddrAction->Execute();
		//折り返し幅
		else if (USAME_TI(cmd, "SetWidth"))		SetWidthAction->Execute();
		//左側余白
		else if (USAME_TI(cmd, "SetMargin"))	SetMarginAction->Execute();
		//ダンプリストをファイルに保存
		else if (USAME_TI(cmd, "SaveDump"))		SaveDumpAction->Execute();
		//CSV/TSVエクスポート
		else if (USAME_TI(cmd, "ExportCsv"))	ExportCsvAction->Execute();
		//タグジャンプ
		else if (contained_wd_i(_T("TagJump|TagView"), cmd)) {
			if (TxtViewer->isBinary) UserAbort(USTR_InvalidCmd);

			int lno = 1, pos = 0;
			UnicodeString fnam = TxtViewer->get_SelText();
			if (fnam.IsEmpty()) {
				fnam = TxtViewer->get_CurLine(true);
				pos  = TxtViewer->CurPos.x;
			}

			bool is_edit = ContainsText(cmd, "Jump");
			if (divide_FileName_LineNo(fnam, lno, TxtViewer->FileName, pos)) {
				if (is_edit) {
					if (!open_by_TextEditor(fnam, lno)) GlobalAbort();
				}
				else {
					TxtViewer->add_ViewHistory();
					if (test_HtmlExt(get_extension(fnam)) && lno>1) TxtViewer->isHtm2Txt = false;
					if (!SetAndOpenTxtViewer(fnam, lno)) UserAbort(USTR_FileNotOpen);
				}
			}
			else if (TEST_ActParam("DJ")) {
				DirectTagJumpCore(is_edit);	//見つからなければダイレクトタグジャンプ
			}
			else GlobalAbort();
		}
		//ダイレクトタグジャンプ
		else if (contained_wd_i(_T("TagJumpDirect|TagViewDirect"), cmd)) {
			if (TxtViewer->isBinary) UserAbort(USTR_InvalidCmd);
			DirectTagJumpCore(ContainsText(cmd, "Jump"), ActionParam);
		}
		//ビュアーの履歴を戻る
		else if (USAME_TI(cmd, "BackViewHist")) {
			if (TextViewHistory->Count==0) Abort();
			TStringDynArray itm_buf = get_csv_array(TextViewHistory->Strings[0], 2, true);
			TextViewHistory->Delete(0);
			if (!SetAndOpenTxtViewer(itm_buf[0], itm_buf[1].ToIntDef(0))) UserAbort(USTR_FileNotOpen);
		}
		//ファイル名主部が同じ次のファイルに切り替え
		else if (USAME_TI(cmd, "SwitchSameName")) {
			TStringList *lst = GetCurList(true);
			int idx = lst->IndexOf(TxtViewer->OrgName);
			if (idx!=-1) {
				UnicodeString fnam = get_NextSameName(lst, idx, true);
				if (fnam.IsEmpty()) SysErrAbort(ERROR_FILE_NOT_FOUND);
				TxtViewer->add_ViewHistory();
				IndexOfFileList(fnam);
				if (!OpenTxtViewer(GetCurFrecPtr(true))) GlobalAbort();
			}
		}
		//ソース／ヘッダの切り換え
		else if (USAME_TI(cmd, "SwitchSrcHdr")) {
			UnicodeString fnam = get_SrcHdrName(TxtViewer->FileName);
			if (fnam.IsEmpty()) SysErrAbort(ERROR_FILE_NOT_FOUND);
			TxtViewer->add_ViewHistory();
			IndexOfFileList(fnam);
			if (!OpenTxtViewer(GetCurFrecPtr(true))) GlobalAbort();
		}
		//文字列検索
		else if (USAME_TI(cmd, "FindText")) {
			FindTextAction->Execute();
		}
		//インクリメンタルサーチへ
		else if (USAME_TI(cmd, "IncSearch")) {
			if (TEST_ActParam("MM") && usr_Migemo->DictReady)
				TxtViewer->isIncMigemo = true;
			else if (TEST_ActParam("NM"))
				TxtViewer->isIncMigemo = false;
			TxtViewer->IncSeaWord = EmptyStr;
			TxtViewer->isIncSea   = true;
			TxtViewer->SetSttInf();
		}
		//GREP
		else if (USAME_TI(cmd, "Grep")) {
			fromGrep = false;
			GrepAction->Execute();
		}
		//関数一覧/ ユーザ定義文字列一覧/ マーク行一覧
		else if (contained_wd_i(_T("FunctionList|UserDefList|MarkList"), cmd)) {
			if (TxtViewer->isBinary) UserAbort(USTR_InvalidCmd);
			if		(USAME_TI(cmd, "FunctionList"))	FunctionListAction->Execute();
			else if (USAME_TI(cmd, "UserDefList"))	UserDefListAction->Execute();
			else									MarkListVAction->Execute();
		}
		//テキストビュアーを閉じる
		else if (USAME_TI(cmd, "Close")) {
			req_close = true;
			if (TEST_ActParam("AL")) close_all_ExViewer(this);
		}
		//ファイラーと共通のコマンド
		else if (ExeCommandAction(cmd, ActionParam)) ActionOk = true;
		else handled = false;

		//------------------
		//閉じる
		//------------------
		if (req_close) {
			UnicodeString fnam = TxtViewer->FileName;
			//イベント: テキストビュアーを閉じる直前
			ExeEventCommand(OnTvClose);

			TxtViewer->CloseAuxForm();
			TxtViewer->add_ViewHistory();
			TxtViewer->Clear();

			if (fromGrep) {
				fromGrep = false;
				ActionOptStr = "ToResList";
				GrepAction->Execute();
			}
			else {
				SetScrMode(SCMD_FLIST, CurListTag);

				//必要ならカーソル位置を設定
				if (TxtViewer->reqCurPos) {
					TxtViewer->reqCurPos = false;
					TStringList *lst = GetCurList(true);
					if (lp->Count!=lst->Count) lp->Count = lst->Count;
					int idx = lst->IndexOf(TxtViewer->OrgName);
					if (idx!=-1) ListBoxSetIndex(lp, idx);
					FlScrPanel[CurListTag]->UpdateKnob();
					SetFileInf();
				}

				//イベント: テキストビュアーを閉じた直後
				ExeEventCommand(OnTvClosed);
			}

			//バイナリ編集
			//メモリマップドファイルの場合共有違反となるため閉じてから
			if (req_bEdit) Execute_ex(get_actual_path(BinaryEditor), add_quot_if_spc(fnam));
		}
		return handled;
	}
	catch (EAbort &e) {
		SetActionAbort(e.Message);
		return true;
	}
	catch (...) {
		SetInternalException(cmd, ActionParam);
		return true;
	}
}
//---------------------------------------------------------------------------
bool __fastcall TNyanFiForm::ExeCommandV(const _TCHAR *cmd)
{
	return ExeCommandV(UnicodeString(cmd));
}

//---------------------------------------------------------------------------
//ダイレクトタグジャンプ
//！失敗したら EAbort 例外
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::DirectTagJumpCore(
	bool is_edit,			//true = 編集/ false = 閲覧	(default = false) 
	UnicodeString prm,		//単語指定					(default = EmptyStr)
	UnicodeString dnam,		//tags 基準ディレクトリ		(default = EmptyStr)
	UnicodeString onam)		//対象ファイル				(default = EmptyStr)
{
	UnicodeString tnam, rnam;
	std::unique_ptr<TStringList> j_lst(new TStringList());
	if (TRegEx::IsMatch(prm, "^.+\\t.+\\.\\w+\\t(\\d+|/.+/)")) {
		j_lst->Add(prm);
	}
	else {
		tnam = prm.IsEmpty()? ((ScrMode==SCMD_TVIEW)? TxtViewer->GetCurWord() : EmptyStr) : prm;
		rnam = ExtractFilePath(dnam.IsEmpty()? ((ScrMode==SCMD_TVIEW)? TxtViewer->FileName : CurPath[CurListTag]) : dnam);
		if (get_FileNameByTag(tnam, rnam, j_lst.get(), onam)==0) GlobalAbort();
	}

	UnicodeString fnam;
	if (j_lst->Count==1) {
		fnam = j_lst->Strings[0];
	}
	else {
		EditHistoryDlg->isTags  = true;
		EditHistoryDlg->isView  = !is_edit;
		EditHistoryDlg->TagJumpList->Assign(j_lst.get());
		EditHistoryDlg->TagName = tnam;
		EditHistoryDlg->TagPath = rnam;
		int res = EditHistoryDlg->ShowModal();
		if (res!=mrOk && res!=mrClose) SkipAbort();
		fnam = EditHistoryDlg->TagJumpInf;
	}

	if (!fnam.IsEmpty()) {
		int lno = 1;
		if (!divide_FileName_LineNo(fnam, lno, rnam)) throw EAbort(GlobalErrMsg);
		//編集
		if (is_edit) {
			if (!open_by_TextEditor(fnam, lno)) GlobalAbort();
		}
		//閲覧
		else {
			//閲覧中ファイル内
			if (ScrMode==SCMD_TVIEW && SameText(TxtViewer->FileName, fnam))
				TxtViewer->ToLine(lno);
			//その他のファイル
			else {
				if (ScrMode==SCMD_TVIEW) TxtViewer->add_ViewHistory();
				if (!SetAndOpenTxtViewer(fnam, lno)) UserAbort(USTR_FileNotOpen);
			}
		}
	}
}

//---------------------------------------------------------------------------
//テキストビュアーの右クリックメニュー
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ViewPopupMenuPopup(TObject *Sender)
{
	SortItem->Visible = ScrMode==SCMD_TVIEW && TxtViewer->isText;
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::TV_EditCopyActionExecute(TObject *Sender)
{
	TxtViewer->ClipCopy();
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::TV_EditAddActionExecute(TObject *Sender)
{
	TxtViewer->ClipCopy(true);
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::TV_EditCopyActionUpdate(TObject *Sender)
{
	TAction *ap  = (TAction*)Sender;
	ap->Visible = ScrMode==SCMD_TVIEW;
	ap->Enabled = ap->Visible && TxtScrollPanel->Visible && TxtViewer->SelStart!=TxtViewer->SelEnd;
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::TV_EditSelAllActionExecute(TObject *Sender)
{
	if (TxtScrollPanel->Visible) TxtViewer->SelectAll();
}

//---------------------------------------------------------------------------
//ソート昇順
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::TV_SortAscActionExecute(TObject *Sender)
{
	TxtViewer->ExeCommand(_T("Sort_AO"));
}
//---------------------------------------------------------------------------
//ソート降順
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::TV_SortDesActionExecute(TObject *Sender)
{
	TxtViewer->ExeCommand(_T("Sort_DO"));
}
//---------------------------------------------------------------------------
//ソート解除
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::TV_OrgOrderActionExecute(TObject *Sender)
{
	TxtViewer->ExeCommand(_T("Sort"));
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::TV_SortActionUpdate(TObject *Sender)
{
	TAction *ap = (TAction*)Sender;
	ap->Visible = ScrMode==SCMD_TVIEW && TxtViewer->isText;
	ap->Enabled = ap->Visible && TxtViewer->MaxLine>1;
}

//---------------------------------------------------------------------------
//先頭行は項目名
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::TV_TopIsHdrActionExecute(TObject *Sender)
{
	TxtViewer->TopIsHeader = !TxtViewer->TopIsHeader;
	TxtViewer->SetSttInf();
	if (CsvRecForm->Visible) CsvRecForm->TopIsHeaderCheckBox->Checked = TxtViewer->TopIsHeader;
}

//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::TV_TopIsHdrActionUpdate(TObject *Sender)
{
	TAction *ap = (TAction*)Sender;
	ap->Visible = ScrMode==SCMD_TVIEW && TxtViewer->isText && TxtViewer->CsvCol>=0;
	ap->Enabled = ap->Visible;
	ap->Checked = TxtViewer->TopIsHeader;
}

//---------------------------------------------------------------------------
//ファイル情報のコピー
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::Inf_CopyValueActionExecute(TObject *Sender)
{
	TListBox *lp = GetCurInfListBox();
	int idx = lp->ItemIndex;
	if (idx!=-1) {
		UnicodeString lbuf = lp->Items->Strings[idx];
		if (idx>2) lbuf = Trim(get_tkn_r(lbuf, ": "));
		copy_to_Clipboard(lbuf);
	}
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::Inf_EditCopyExecute(TObject *Sender)
{
	ExeCmdListBox(GetCurInfListBox(), _T("ClipCopy"));
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::Inf_EditCopyUpdate(TObject *Sender)
{
	TAction *ap  = (TAction*)Sender;
	ap->Visible  = ScrMode==SCMD_FLIST || ScrMode==SCMD_IVIEW;
	TListBox *lp = GetCurInfListBox();
	ap->Enabled  = ap->Visible  && lp->Focused() && lp->SelCount>0;
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::Inf_EditSelectAllExecute(TObject *Sender)
{
	ListBoxSelectAll(GetCurInfListBox());
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::Inf_EditSelectAllUpdate(TObject *Sender)
{
	TAction *ap = (TAction*)Sender;
	ap->Visible = ScrMode==SCMD_FLIST || ScrMode==SCMD_IVIEW;
	ap->Enabled = ap->Visible && GetCurInfListBox()->Focused();
}

//---------------------------------------------------------------------------
//この項目内容を強調表示
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::Inf_EmpItemActionExecute(TObject *Sender)
{
	TListBox *lp = GetCurInfListBox();
	UnicodeString inam = (lp->ItemIndex>2)? Trim(get_tkn(lp->Items->Strings[lp->ItemIndex], ':')) : EmptyStr;
	if (!inam.IsEmpty()) {
		std::unique_ptr<TStringList> n_lst(new TStringList());
		n_lst->Delimiter = '|';
		n_lst->QuoteChar = '\0';
		n_lst->DelimitedText = EmpInfItems;
		int idx = n_lst->IndexOf(inam);
		if (idx!=-1) n_lst->Delete(idx); else n_lst->Add(inam);
		EmpInfItems = n_lst->DelimitedText;
		lp->Invalidate();
	}
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::Inf_EmpItemActionUpdate(TObject *Sender)
{
	TAction *ap  = (TAction *)Sender;
	if (isViewClip) {
		ap->Enabled = false;
	}
	else {
		TListBox *lp = GetCurInfListBox();
		int flag = (lp->ItemIndex!=-1)? (int)lp->Items->Objects[lp->ItemIndex] : 0;
		UnicodeString inam = (lp->ItemIndex>2 && (flag & LBFLG_STD_FINF)==0)?
								Trim(get_tkn(lp->Items->Strings[lp->ItemIndex], ':')) : EmptyStr;
		ap->Enabled = !inam.IsEmpty();
		ap->Checked = test_word_i(inam, EmpInfItems);
	}
}

//---------------------------------------------------------------------------
//この項目を隠す
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::Inf_HideItemActionExecute(TObject *Sender)
{
	TListBox *lp = GetCurInfListBox();
	UnicodeString inam = (lp->ItemIndex>2)? Trim(get_tkn(lp->Items->Strings[lp->ItemIndex], ':')) : EmptyStr;
	if (!inam.IsEmpty()) {
		UnicodeString fext = GetCurInfFext(lp->Items->Strings[0]);
		UnicodeString hlst = HideInfItems->Values[fext];
		if (!hlst.IsEmpty()) hlst += "|";
		hlst += inam;
		HideInfItems->Values[fext] = hlst;
		int idx = lp->ItemIndex;
		ViewCurFileInf();
		lp->ItemIndex = std::min(idx, lp->Count - 1);
	}
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::Inf_HideItemActionUpdate(TObject *Sender)
{
	TAction *ap  = (TAction *)Sender;
	if (isViewClip) {
		ap->Enabled = false;
	}
	else {
		TListBox *lp = GetCurInfListBox();
		int flag = (lp->ItemIndex!=-1)? (int)lp->Items->Objects[lp->ItemIndex] : 0;
		file_rec *cfp = GetCurFrecPtr(true, true);
		UnicodeString inam = (cfp && lp->ItemIndex>2 && (flag & LBFLG_STD_FINF)==0)?
								Trim(get_tkn(lp->Items->Strings[lp->ItemIndex], ':')) : EmptyStr;
		ap->Enabled = !inam.IsEmpty();
	}
}

//---------------------------------------------------------------------------
//隠した項目を戻す
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::InfPopupMenuPopup(TObject *Sender)
{
	InfShowItemItem->Clear();
	InfShowItemItem->Enabled = false;

	if (!isViewClip) {
		TListBox *lp  = GetCurInfListBox();
		if (lp->Count>0) {
			UnicodeString fext = GetCurInfFext(lp->Items->Strings[0]);
			TStringDynArray ilst = SplitString(HideInfItems->Values[fext], "|");
			for (int i=0; i<ilst.Length; i++) {
				TMenuItem *mp = new TMenuItem(InfShowItemItem);
				mp->Caption   = ilst[i];
				mp->OnClick   = ShowInfItemClick;
				InfShowItemItem->Add(mp);
			}
			if (ilst.Length>0) InfShowItemItem->Enabled = true;
		}
	}
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ShowInfItemClick(TObject *Sender)
{
	UnicodeString inam = ((TMenuItem*)Sender)->Caption;
	TListBox *lp = GetCurInfListBox();
	if (lp->Count>0) {
		UnicodeString fext = GetCurInfFext(lp->Items->Strings[0]);
		TStringDynArray ilst = SplitString(HideInfItems->Values[fext], "|");
		UnicodeString lbuf;
		for (int i=0; i<ilst.Length; i++) {
			if (!SameText(inam, ilst[i])) {
				if (!lbuf.IsEmpty()) lbuf += "|";
				lbuf += ilst[i];
			}
		}
		HideInfItems->Values[fext] = lbuf;
		ViewCurFileInf();
	}
}

//---------------------------------------------------------------------------
//URLを開く
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::Inf_OpenUrlActionExecute(TObject *Sender)
{
	Execute_ex(ListBoxGetURL(GetCurInfListBox()));
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::Inf_OpenUrlActionUpdate(TObject *Sender)
{
	TAction *ap  = (TAction*)Sender;
	ap->Visible  = ScrMode==SCMD_FLIST || ScrMode==SCMD_IVIEW;
	TListBox *lp = GetCurInfListBox();
	ap->Enabled  = ap->Visible && lp->Focused() && !ListBoxGetURL(lp).IsEmpty();
}

//---------------------------------------------------------------------------
//テキストプレビュー
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::Txt_EditCopyExecute(TObject *Sender)
{
	ExeCmdListBox(TxtTailListBox->Focused()? TxtTailListBox : TxtPrvListBox, _T("ClipCopy"));
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::Txt_EditCopyUpdate(TObject *Sender)
{
	TAction *ap = (TAction*)Sender;
	ap->Visible = ScrMode==SCMD_FLIST;
	ap->Enabled = ap->Visible &&
		((TxtPrvListBox->Focused() && TxtPrvListBox->SelCount>0) ||
		 (TxtTailListBox->Focused() && TxtTailListBox->SelCount>0));
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::Txt_EditSelectAllExecute(TObject *Sender)
{
	ListBoxSelectAll(TxtTailListBox->Focused()? TxtTailListBox : TxtPrvListBox);
}

//---------------------------------------------------------------------------
//URLを開く
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::Txt_OpenUrlActionExecute(TObject *Sender)
{
	Execute_ex(ListBoxGetURL(TxtTailListBox->Focused()? TxtTailListBox : TxtPrvListBox));
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::Txt_OpenUrlActionUpdate(TObject *Sender)
{
	TAction *ap  = (TAction*)Sender;
	ap->Visible  = ScrMode==SCMD_FLIST;
	TListBox *lp = TxtTailListBox->Focused()? TxtTailListBox : TxtPrvListBox;
	ap->Enabled  = ap->Visible && lp->Focused() && !ListBoxGetURL(lp).IsEmpty();
}

//---------------------------------------------------------------------------
//行番号を表示
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::Txt_ShowLnNoActionExecute(TObject *Sender)
{
	TxtPrvShowLineNo = !TxtPrvShowLineNo;
	TxtPrvListBox->Repaint();
	TxtTailListBox->Repaint();
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::Txt_ShowLnNoActionUpdate(TObject *Sender)
{
	((TAction*)Sender)->Checked = TxtPrvShowLineNo;
}
//---------------------------------------------------------------------------
//カーソル位置を維持
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::Txt_KeepIndexActionExecute(TObject *Sender)
{
	TxtPrvKeepIndex = !TxtPrvKeepIndex;
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::Txt_KeepIndexActionUpdate(TObject *Sender)
{
	TAction *ap = (TAction*)Sender;
	ap->Visible = TxtPrvListBox->Focused();
	ap->Checked = TxtPrvKeepIndex;
}
//---------------------------------------------------------------------------
//末尾分割表示
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::Txt_ShowTailActionExecute(TObject *Sender)
{
	ShowTailPreview = !ShowTailPreview;
	ReloadListAction->Execute();
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::Txt_ShowTailActionUpdate(TObject *Sender)
{
	((TAction*)Sender)->Checked = ShowTailPreview;
}

//---------------------------------------------------------------------------
//ログ
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::Log_EditCopyExecute(TObject *Sender)
{
	ExeCmdListBox(LogListBox, _T("ClipCopy"));
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::Log_EditCopyUpdate(TObject *Sender)
{
	TAction *ap = (TAction*)Sender;
	ap->Visible = ScrMode==SCMD_FLIST;
	ap->Enabled = ap->Visible && LogListBox->Focused() && LogListBox->SelCount>0;
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::Log_EditSelectAllExecute(TObject *Sender)
{
	ListBoxSelectAll(LogListBox);
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::Log_EditSelectAllUpdate(TObject *Sender)
{
	TAction *ap = (TAction*)Sender;
	ap->Visible = ScrMode==SCMD_FLIST;
	ap->Enabled = ap->Visible && LogListBox->Focused();
}
//---------------------------------------------------------------------------
//デバッグ情報を表示
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::Log_DebugInfActionExecute(TObject *Sender)
{
	LogDebugInf = !LogDebugInf;
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::Log_DebugInfActionUpdate(TObject *Sender)
{
	((TAction*)Sender)->Checked = LogDebugInf;
}

//---------------------------------------------------------------------------
//関数一覧
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::FunctionListActionExecute(TObject *Sender)
{
	FuncListDlg->ToFilter = TEST_ActParam("FF");
	FuncListDlg->ListMode = 0;
	if (FuncListDlg->ShowModal()==mrOk && FuncListDlg->ReqEdit) ExeCommandV(_T("FileEdit"));
}
//---------------------------------------------------------------------------
//ユーザ定義文字列一覧
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::UserDefListActionExecute(TObject *Sender)
{
	FuncListDlg->ToFilter = TEST_ActParam("FF");
	FuncListDlg->ListMode = 1;
	if (FuncListDlg->ShowModal()==mrOk && FuncListDlg->ReqEdit) ExeCommandV(_T("FileEdit"));
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::FunctionListActionUpdate(TObject *Sender)
{
	TAction *ap = (TAction*)Sender;
	ap->Visible = TxtViewer->isText;
	ap->Enabled = ap->Visible;
}
//---------------------------------------------------------------------------
//マーク行一覧
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::MarkListVActionExecute(TObject *Sender)
{
	FuncListDlg->ToFilter = TEST_ActParam("FF");
	FuncListDlg->ListMode = 2;
	if (FuncListDlg->ShowModal()==mrOk && FuncListDlg->ReqEdit) ExeCommandV(_T("FileEdit"));
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::MarkListVActionUpdate(TObject *Sender)
{
	TAction *ap = (TAction*)Sender;
	ap->Visible = TxtViewer->isText;
	ap->Enabled = ap->Visible && !TxtViewer->MarkListStr.IsEmpty();
}

//---------------------------------------------------------------------------
//HTML→テキスト変換表示
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::HtmlToTextActionExecute(TObject *Sender)
{
	if (ScrMode==SCMD_TVIEW)
		TxtViewer->ExeCommand(_T("HtmlToText"), ActionParam);
	else
		SetToggleAction(TxtViewer->isHtm2Txt);
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::HtmlToTextActionUpdate(TObject *Sender)
{
	TAction *ap = (TAction*)Sender;
	ap->Visible = TxtViewer->isText;
	ap->Checked = TxtViewer->isHtm2Txt;
}
//---------------------------------------------------------------------------
//CSV/TSVを固定長表示
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::FixedLenActionExecute(TObject *Sender)
{
	if (ScrMode==SCMD_TVIEW)
		TxtViewer->ExeCommand(_T("FixedLen"), ActionParam);
	else {
		int lmt = extract_int_def(ActionParam);
		if (lmt>0) {
			ViewFixedLimit = std::max(lmt, 4);
			ActionParam = "ON";
		}
		SetToggleAction(TxtViewer->isFixedLen);
	}
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::FixedLenActionUpdate(TObject *Sender)
{
	TAction *ap = (TAction*)Sender;
	ap->Visible = TxtViewer->isText;
	ap->Checked = TxtViewer->isFixedLen;
}

//---------------------------------------------------------------------------
//マッチ語の強調表示
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::HighlightActionExecute(TObject *Sender)
{
	TxtViewer->ExeCommand(_T("Highlight"), ActionParam);
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::HighlightActionUpdate(TObject *Sender)
{
	TAction *ap = (TAction*)Sender;
	ap->Visible = ScrMode==SCMD_TVIEW;
	ap->Enabled = ap->Visible;
	ap->Checked = TxtViewer->Highlight;
}

//---------------------------------------------------------------------------
//ルーラを表示
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ShowRulerActionExecute(TObject *Sender)
{
	if (ScrMode==SCMD_TVIEW)
		TxtViewer->ExeCommand(_T("ShowRuler"), ActionParam);
	else
		SetToggleAction(ShowTextRuler);
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ShowRulerActionUpdate(TObject *Sender)
{
	TAction *ap = (TAction*)Sender;
	ap->Visible = ScrMode==SCMD_TVIEW;
	ap->Checked = ShowTextRuler;
}
//---------------------------------------------------------------------------
//行番号を表示
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ShowLineNoActionExecute(TObject *Sender)
{
	if (ScrMode==SCMD_TVIEW)
		TxtViewer->ExeCommand(_T("ShowLineNo"), ActionParam);
	else
		SetToggleAction(ShowLineNo);
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ShowLineNoActionUpdate(TObject *Sender)
{
	TAction *ap = (TAction*)Sender;
	ap->Visible = TxtViewer->isText;
	ap->Checked = ShowLineNo;
}

//---------------------------------------------------------------------------
//改行を表示
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ShowCRActionExecute(TObject *Sender)
{
	if (ScrMode==SCMD_TVIEW)
		TxtViewer->ExeCommand(_T("ShowCR"), ActionParam);
	else
		SetToggleAction(ShowCR);
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ShowCRActionUpdate(TObject *Sender)
{
	TAction *ap = (TAction*)Sender;
	ap->Visible = TxtViewer->isText;
	ap->Checked = ShowCR;
}
//---------------------------------------------------------------------------
//タブを表示
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ShowTABActionExecute(TObject *Sender)
{
	if (ScrMode==SCMD_TVIEW)
		TxtViewer->ExeCommand(_T("ShowTAB"), ActionParam);
	else
		SetToggleAction(ShowTAB);
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ShowTABActionUpdate(TObject *Sender)
{
	TAction *ap = (TAction*)Sender;
	ap->Visible = ScrMode==SCMD_TVIEW && TxtViewer->isText;
	ap->Checked = ShowTAB;
}
//---------------------------------------------------------------------------
//ルビを表示
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ShowRubyActionExecute(TObject *Sender)
{
	if (ScrMode==SCMD_TVIEW)
		TxtViewer->ExeCommand(_T("ShowRuby"), ActionParam);
	else
		SetToggleAction(TxtViewer->ShowRuby);
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ShowRubyActionUpdate(TObject *Sender)
{
	TAction *ap = (TAction*)Sender;
	ap->Visible = ScrMode==SCMD_TVIEW && TxtViewer->isText;
	ap->Checked = TxtViewer->ShowRuby;
}

//---------------------------------------------------------------------------
//文字情報を表示
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::CharInfoActionExecute(TObject *Sender)
{
	if (!TxtViewer->isBinary) {
		bool sw = CharInfoForm->Visible;
		CharInfoForm->Visible = SetToggleAction(sw);
	}
	else {
		CharInfoForm->Visible = false;
	}

	if (CharInfoForm->Visible) TxtViewer->SetSttInf();
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::CharInfoActionUpdate(TObject *Sender)
{
	TAction *ap = (TAction*)Sender;
	ap->Visible = ScrMode==SCMD_TVIEW && TxtViewer->isText;
	ap->Enabled = ap->Visible;
	ap->Checked = CharInfoForm->Visible;
}

//---------------------------------------------------------------------------
//CSV/TSV項目の集計
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::CsvCalcActionExecute(TObject *Sender)
{
	FileInfoDlg->isCalcItem  = true;
	FileInfoDlg->DataList	 = TxtViewer->TxtBufList;
	FileInfoDlg->TopIsHeader = TxtViewer->TopIsHeader;
	FileInfoDlg->CsvCol 	 = TxtViewer->CsvCol;
	FileInfoDlg->ShowModal();
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::CsvCalcActionUpdate(TObject *Sender)
{
	TAction *ap = (TAction*)Sender;
	ap->Visible = ScrMode==SCMD_TVIEW && TxtViewer->isText;
	ap->Enabled = ap->Visible;
}

//---------------------------------------------------------------------------
//CSV/TSV項目のグラフ
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::CsvGraphActionExecute(TObject *Sender)
{
	GraphForm->DataList    = TxtViewer->TxtBufList;
	GraphForm->TopIsHeader = TxtViewer->TopIsHeader;
	GraphForm->CsvCol	   = TxtViewer->CsvCol;
	GraphForm->ShowModal();
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::CsvGraphActionUpdate(TObject *Sender)
{
	TAction *ap = (TAction*)Sender;
	ap->Visible = ScrMode==SCMD_TVIEW && TxtViewer->isText;
	ap->Enabled = ap->Visible;
}

//---------------------------------------------------------------------------
//CSV/TSVレコード表示
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::CsvRecordActionExecute(TObject *Sender)
{
	if (!TxtViewer->isBinary) {
		bool sw = CsvRecForm->Visible;
		CsvRecForm->Visible = SetToggleAction(sw);
	}
	else {
		CsvRecForm->Visible = false;
	}

	if (CsvRecForm->Visible) TxtViewer->SetSttInf();
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::CsvRecordActionUpdate(TObject *Sender)
{
	TAction *ap = (TAction*)Sender;
	ap->Visible = ScrMode==SCMD_TVIEW && TxtViewer->isText;
	ap->Enabled = ap->Visible;
	ap->Checked = CsvRecForm->Visible;
}

//---------------------------------------------------------------------------
//テキストビュアーからファイルを削除
//---------------------------------------------------------------------------
bool __fastcall TNyanFiForm::DeleteVCore(UnicodeString fnam)
{
	UnicodeString msg = make_LogHdr(_T("DELETE"), fnam);

	try {
		if (ForceDel && !set_FileWritable(fnam))	Abort();
		if (!delete_File(fnam, DelUseTrash))		Abort();
		AddLog(msg);
		return true;
	}
	catch (EAbort &e) {
		set_LogErrMsg(msg);
		AddLog(msg);
		return false;
	}
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::DeleteVActionExecute(TObject *Sender)
{
	try {
		if (CurStt->is_Arc || CurStt->is_Work || CurStt->is_FTP) UserAbort(USTR_OpeNotSuported);
		if (is_drive_protected(CurPath[CurListTag])) SysErrAbort(ERROR_WRITE_PROTECT);

		CurWorking = true;

		TStringList *lst = GetCurList(true);
		int sel_cnt = 0;
		for (int i=0; i<lst->Count; i++) {
			file_rec *fp = (file_rec*)lst->Objects[i];
			if (fp->selected && !fp->is_dir) sel_cnt++;
		}

		if (TEST_ActParam("SO") && sel_cnt==0) SkipAbort();
		if (TxtViewer->isBinary && (TxtViewer->isSelected || sel_cnt==0)) UserAbort(USTR_OpeNotSuported);

		UnicodeString org_nam = TxtViewer->OrgName;
		int n_idx = lst->IndexOf(org_nam);
		if (n_idx==-1) Abort();

		//次の表示ファイルを探す
		UnicodeString nxt_nam, top_nam;
		for (int i=0; i<lst->Count; i++) {
			file_rec *fp = (file_rec*)lst->Objects[i];
			if (fp->is_dir || fp->selected) continue;
			if (i==n_idx && sel_cnt==0) continue;
			if (i<n_idx) {
				if (top_nam.IsEmpty()) top_nam = fp->f_name;
			}
			else {
				nxt_nam = fp->f_name;
				break;
			}
		}
		if (nxt_nam.IsEmpty()) nxt_nam = top_nam;

		//選択ファイル
		int del_cnt = 0;
		UnicodeString tmp;
		if (sel_cnt>0) {
			if (msgbox_Sure(LoadUsrMsg(USTR_DeleteQ, tmp.sprintf(_T("%u個の選択ファイル"), sel_cnt)), SureDelete)) {
				StartLog(LoadUsrMsg(USTR_BeginDelete, CurPath[CurListTag]));
				int i = 0;
				while (i<lst->Count) {
					file_rec *fp = (file_rec*)lst->Objects[i];
					if (fp->selected && !fp->is_dir) {
						if (!DeleteVCore(fp->f_name)) UserAbort(USTR_FaildDelete);
						del_file_rec(fp);
						lst->Delete(i);
						del_cnt++;
					}
					else i++;
				}
				EndLog(_T("削除"));
			}
		}
		//表示ファイル
		else {
			if (msgbox_Sure(LoadUsrMsg(USTR_DeleteQ, _T("このファイル")), SureDelete)) {
				StartLog(LoadUsrMsg(USTR_BeginDelete, CurPath[CurListTag]));
				if (!DeleteVCore(org_nam)) UserAbort(USTR_FaildDelete);
				file_rec *fp = (file_rec*)lst->Objects[n_idx];
				del_file_rec(fp);
				lst->Delete(n_idx);
				del_cnt++;
				EndLog(_T("削除"));
			}
		}

		CurWorking = false;

		if (del_cnt>0) {
			n_idx = lst->IndexOf(nxt_nam);
			if (n_idx!=-1) {
				file_rec *fp = (file_rec*)lst->Objects[n_idx];
				if (fp->is_dir) Abort();
				if (SameText(org_nam, fp->f_name)) SkipAbort();
				if (!OpenTxtViewer(fp)) UserAbort(USTR_FileNotOpen);
			}
			else {
				SetScrMode(SCMD_FLIST, CurListTag);
			}
		}
	}
	catch (EAbort &e) {
		SetActionAbort(e.Message);
	}
}

//---------------------------------------------------------------------------
//CSV/TSVエクスポート
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ExportCsvActionExecute(TObject *Sender)
{
	if (!ExpCsvDlg) ExpCsvDlg = new TExpCsvDlg(this);	//初回に動的作成
	ExpCsvDlg->Viewer = TxtViewer;
	ExpCsvDlg->ShowModal();
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ExportCsvActionUpdate(TObject *Sender)
{
	TAction *ap = (TAction*)Sender;
	ap->Visible = ScrMode==SCMD_TVIEW && TxtViewer->isText && TxtViewer->isCSV;
	ap->Enabled = ap->Visible;
}

//---------------------------------------------------------------------------
//インスペクタを表示
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::InspectorActionExecute(TObject *Sender)
{
	if (TxtViewer->isBinary) {
		bool sw = InspectForm->Visible;
		InspectForm->Visible = SetToggleAction(sw);
	}
	else {
		InspectForm->Visible = false;
	}

	if (InspectForm->Visible) TxtViewer->SetSttInf();
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::InspectorActionUpdate(TObject *Sender)
{
	TAction *ap = (TAction*)Sender;
	ap->Visible = TxtViewer->isBinary;
	ap->Enabled = ap->Visible;
	ap->Checked = InspectForm->Visible;
}
//---------------------------------------------------------------------------
//ビットマップビューを表示
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::BitmapViewActionExecute(TObject *Sender)
{
	if (TxtViewer->isBinary) {
		bool sw = BitmapForm->Visible;
		BitmapForm->Visible = SetToggleAction(sw);
	}
	else {
		BitmapForm->Visible = false;
	}
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::BitmapViewActionUpdate(TObject *Sender)
{
	TAction *ap = (TAction*)Sender;
	ap->Visible = TxtViewer->isBinary;
	ap->Enabled = ap->Visible;
	ap->Checked = BitmapForm->Visible;
}

//---------------------------------------------------------------------------
//ダンプリストをファイルに保存
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::SaveDumpActionExecute(TObject *Sender)
{
	UserModule->SaveTxtDlg->Title		  = LoadUsrMsg(USTR_SaveAs, _T("ダンプリスト"));
	UserModule->SaveTxtDlg->FileName	  = ChangeFileExt(TxtViewer->FileName, ".txt");
	UserModule->SaveTxtDlg->InitialDir	  = ExtractFileDir(TxtViewer->FileName);
	UserModule->SaveTxtDlg->EncodingIndex = SaveEncIndex;
	if (UserModule->SaveTxtDlg->Execute()) {
		SaveEncIndex = UserModule->SaveTxtDlg->EncodingIndex;

		std::unique_ptr<TStringList> fbuf(new TStringList());
		TxtViewer->GetDumpList(fbuf.get());

		if (!saveto_TextFile(UserModule->SaveTxtDlg->FileName, fbuf.get(), SaveEncIndex)) msgbox_ERR(USTR_FaildSave);
	}
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::SaveDumpActionUpdate(TObject *Sender)
{
	TAction *ap = (TAction*)Sender;
	ap->Visible = TxtViewer->isBinary;
	ap->Enabled = ap->Visible;
}

//---------------------------------------------------------------------------
//先頭アドレスを設定
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::SetTopAddrActionExecute(TObject *Sender)
{
	try {
		__int64 inp_adr = -1;
		//先頭アドレスを入力
		if (ActionParam.IsEmpty()) {
			unsigned __int64 end_adr = TxtViewer->BinFileSize - 1;
			InputExDlg->IpuntExMode = INPEX_SET_TOPADDR;
			InputExDlg->InputEdit->EditLabel->Caption
				= UnicodeString().sprintf(_T("0〜%s (%llu)"), get_AddrStr(end_adr).c_str(), end_adr);
			UnicodeString inp_buf = (InputExDlg->ShowModal()==mrOk)? InputExDlg->InputEdit->Text : EmptyStr;

			remove_text(inp_buf, _T(":"));
			if (inp_buf.IsEmpty()) SkipAbort();
			inp_adr = StrToInt64Def(inp_buf, -1);
		}
		//先頭アドレスを先頭に
		else if (TEST_ActParam("TP")) {
			if (TxtViewer->TopAddress==0) Abort();
			inp_adr = 0;
		}
		//先頭アドレスを先行部に
		else if (TEST_ActParam("PR")) {
			if (TxtViewer->TopAddress==0) Abort();
			inp_adr = TxtViewer->TopAddress - (__int64)ViewBinLimitSize;
			if (inp_adr<0) inp_adr = 0;
		}
		//先頭アドレスを後続部に
		else if (TEST_ActParam("NX")) {
			if (!TxtViewer->isContinue) Abort();
			inp_adr = TxtViewer->TopAddress + TxtViewer->BinarySize;
		}
		//終端アドレスを最後に
		else if (TEST_ActParam("ED")) {
			if (!TxtViewer->isContinue) Abort();
			inp_adr = TxtViewer->BinFileSize - 1 - TxtViewer->BinarySize;
			if (inp_adr%16>0) inp_adr += (16 - inp_adr%16);
		}

		//再読み込み
		if (inp_adr<0 || inp_adr>=TxtViewer->BinFileSize) UserAbort(USTR_IllegalAddress);
		TxtViewer->AssignBin(inp_adr, true);
		if (TEST_ActParam("ED")) TxtViewer->TextEnd();
	}
	catch (EAbort &e) {
		SetActionAbort(e.Message);
	}
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::SetTopAddrActionUpdate(TObject *Sender)
{
	TAction *ap = (TAction*)Sender;
	ap->Visible = TxtViewer->isBinary;
	ap->Enabled = ap->Visible;
}
//---------------------------------------------------------------------------
//折り返し幅の設定
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::SetWidthActionExecute(TObject *Sender)
{
	int wd;
	if (ActionParam.IsEmpty()) {
		UnicodeString tmp;
		tmp.sprintf(_T("〜%u (0でウィンドウ幅)"), TxtViewer->MaxFoldWd);
		wd = inputbox_ex(_T("折り返し幅を設定"), tmp.c_str(), (ViewFoldFitWin? 0 : ViewFoldWidth), true).ToIntDef(0);
	}
	else {
		wd = ActionParam.ToIntDef(0);
	}

	if (wd==0) {
		ViewFoldFitWin = true;
	}
	else {
		ViewFoldFitWin = false;
		ViewFoldWidth  = wd;
	}

	if (ScrMode==SCMD_TVIEW) TxtViewer->UpdateScr(0);
}
//---------------------------------------------------------------------------
//左側余白を設定
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::SetMarginActionExecute(TObject *Sender)
{
	if (!ActionParam.IsEmpty()) {
		ViewLeftMargin = ActionParam.ToIntDef(0);
		if (ScrMode==SCMD_TVIEW) {
			TxtViewer->SetMetric();
			TxtViewer->Repaint(true);
		}
	}
	else SetActionAbort();
}
//---------------------------------------------------------------------------
//タブの設定
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::SetTabActionExecute(TObject *Sender)
{
	TxtViewer->TabLength = ActionParam.ToIntDef(0);
	if (ScrMode==SCMD_TVIEW) {
		TxtViewer->SetMetric();
		TxtViewer->UpdateScr(0);
	}
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::SetTvMetricActionUpdate(TObject *Sender)
{
	((TAction*)Sender)->Visible = TxtViewer->isText;
}

//---------------------------------------------------------------------------
//テキストビュアーの配色
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::SetColorActionExecute(TObject *Sender)
{
	TxtViewer->ExeCommand(_T("SetColor"), ActionParam);
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::SetColorActionUpdate(TObject *Sender)
{
	TAction *ap = (TAction*)Sender;
	ap->Visible = ScrMode==SCMD_TVIEW;
	ap->Enabled = ap->Visible && IsPrimary;
}

//---------------------------------------------------------------------------
//テキストファイルの追加更新を監視
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::WatchTailActionExecute(TObject *Sender)
{
	UnicodeString msg;

	//すべて中止
	if (TEST_ActParam("AC")) {
		if (WatchTailList->Count>0 && msgbox_Sure(_T("すべてのファイル監視を中止しますか?"))) {
			WatchTailList->Clear();
			AddLog(_T("監視終了"), true);
			ReloadList();
		}
		return;
	}

	//監視内容の表示
	if (TEST_ActParam("ST")) {
		AddLogCr();
		if (WatchTailList->Count>0) {
			AddLog(_T("監視中"), true);
			for (int i=0; i<WatchTailList->Count; i++) {
				UnicodeString lbuf = WatchTailList->Strings[i];	//ファイル名	コードページ	前回のサイズ	キーワード
				UnicodeString fnam = split_pre_tab(lbuf);
				split_pre_tab(lbuf); split_pre_tab(lbuf);
				UnicodeString kwd = lbuf;
				msg = LogFullPath? fnam : ExtractFileName(fnam);
				if (!kwd.IsEmpty()) msg.cat_sprintf(_T(" : %s"), kwd.c_str());
				AddLog(msg);
			}
			AddLogCr();
		}
		return;
	}

	try {
		if (CurStt->is_Arc) UserAbort(USTR_CantOperate);

		file_rec *cfp = GetCurFrecPtr(true);
		if (!cfp || cfp->is_dummy || cfp->is_dir || cfp->f_attr==faInvalid) Abort();

		UnicodeString fnam = cfp->f_name;
		int code_page;
		if (!is_TextFile(fnam, &code_page)) UserAbort(USTR_NotText);

		//既存を削除
		int i = 0;
		bool found = false;
		while (i<WatchTailList->Count) {
			if (SameText(get_pre_tab(WatchTailList->Strings[i]), fnam)) {
				WatchTailList->Delete(i); found = true;
			}
			else i++;
		}

		//個別中止
		if (TEST_ActParam("CC")) {
			if (found) {
				AddLog("監視終了  " + (LogFullPath? fnam : ExtractFileName(fnam)), true);
				ReloadList();
			}
			SkipAbort();
		}

		//キーワード
		UnicodeString kwd = ActionParam;
		if (is_regex_slash(kwd) && !chk_RegExPtn(exclude_top_end(kwd))) UserAbort(USTR_IllegalRegEx);

		//新規登録
		UnicodeString lbuf;
		lbuf.sprintf(_T("%s\t%u\t%llu\t"), fnam.c_str(), code_page, get_file_size(fnam));
		lbuf += kwd;
		WatchTailList->Add(lbuf);

		msg = "監視開始  " + (LogFullPath? fnam : ExtractFileName(fnam));
		if (!kwd.IsEmpty()) msg.cat_sprintf(_T(" : %s"), kwd.c_str());
		StartLog(msg);
		ReloadList();
	}
	catch (EAbort &e) {
		SetActionAbort(e.Message);
	}
}

//---------------------------------------------------------------------------
//画像のGPS情報でGoogleマップを開く
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::WebMapActionExecute(TObject *Sender)
{
	try {
		UnicodeString fnam;
		double lat, lng;
		if (TEST_ActParam("IN") || ScrMode==SCMD_TVIEW) {
			UnicodeString lbuf = Trim(inputbox_ex(_T("マップの表示地点"), _T("緯度,経度")));
			if (lbuf.IsEmpty()) SkipAbort();

			UnicodeString sc = (lbuf.Pos(',')>1)?  "," :
							   (lbuf.Pos('\t')>1)? "\t" :
							   (lbuf.Pos(';')>1)?  ";" :
							   (lbuf.Pos(' ')>1)?  " " : "";
			if (sc.IsEmpty()) UserAbort(USTR_IllegalParam);

			UnicodeString lat_str = Trim(split_tkn(lbuf, sc));  lbuf = Trim(lbuf);
			if (lat_str.IsEmpty() || lbuf.IsEmpty()) UserAbort(USTR_IllegalParam);
			lat = lat_str.ToDouble();
			lng = lbuf.ToDouble();
		}
		else {
			file_rec *cfp = GetCurFrecPtr();
			if (!cfp || !is_Viewable(cfp)) Abort();
			if (cfp->is_virtual && !SetTmpFile(cfp)) UserAbort(USTR_FaildTmpUnpack);

			fnam = cfp->is_virtual? cfp->tmp_name : cfp->f_name;
			if (!get_GpsInf(fnam, &lat, &lng)) throw EAbort(LoadUsrMsg(USTR_CantGetInfo, _T("GPS")));
		}

		if (!OpenGoogleMaps(lat, lng, fnam)) GlobalAbort();
	}
	catch (EAbort &e) {
		SetActionAbort(e.Message);
	}
	catch (...) {
		SetActionAbort(USTR_IllegalParam);
	}
}
//---------------------------------------------------------------------------
//Web で検索
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::WebSearchActionExecute(TObject *Sender)
{
	if (ScrMode==SCMD_FLIST) {
		UnicodeString kw;
		if (TEST_ActParam("CB")) {
			std::unique_ptr<TStringList> sbuf(new TStringList());
			sbuf->Text = Clipboard()->AsText;
			if (sbuf->Count>0) kw = sbuf->Strings[0];
		}
		else if (TEST_ActParam("FN")) {
			kw = ExtractFileName(GetCurFileStr(true));
		}
		else {
			kw = ActionParam;
		}

		if (kw.IsEmpty()) kw = inputbox_dir(get_WebSeaCaption().c_str(), _T("WebSearch"));
		if (!kw.IsEmpty()) {
			kw = System::Netencoding::TURLEncoding::URL->Encode(kw);
			UnicodeString urlstr = ReplaceStr(WebSeaUrl, "\\S", kw);
			if (urlstr.IsEmpty()) SetActionAbort(USTR_FaildProc);
			Execute_ex(urlstr);
		}
	}
	else if (ScrMode==SCMD_TVIEW) ExeCommandV(_T("WebSearch"));
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::WebSearchActionUpdate(TObject *Sender)
{
	TAction *ap = (TAction*)Sender;
	ap->Visible = (ScrMode==SCMD_FLIST || ScrMode==SCMD_TVIEW);
	ap->Enabled = ap->Visible && !WebSeaUrl.IsEmpty();
	ap->Caption = get_WebSeaCaption((ScrMode==SCMD_TVIEW)? TxtViewer->get_SelText() : EmptyStr);
}
//---------------------------------------------------------------------------


//■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
// イメージビュアー
//■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

//---------------------------------------------------------------------------
//画像が整うまで待つ
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::WaitForImgReady(
	bool reload)	//リロード要求 (default = false)
{
	if (reload) ImgViewThread->AddRequest(_T("RELOAD"));
	while (ImgViewThread->IsWaiting()) {
		Application->ProcessMessages();  Sleep(1);
	}
}

//---------------------------------------------------------------------------
//イメージビュアーを開く
//---------------------------------------------------------------------------
bool __fastcall TNyanFiForm::OpenImgViewer(file_rec *fp, bool fitted, int zoom)
{
	bool to_draw = (!ThumbnailGrid->Visible || !ThumbExtended);

	isViewClip = isViewFTP	= false;
	isViewIcon = isViewAGif = false;

	try {
		if (!fp) Abort();
		isViewFTP = fp->is_ftp;

		if (fp->is_virtual)
			SetTmpFile(fp);
		else if (fp->is_ftp && !file_exists(fp->tmp_name))
			fp->tmp_name = DownloadFtpCore(fp);

		UnicodeString fnam = (fp->is_virtual || fp->is_ftp)? fp->tmp_name : fp->f_name;
		if (!file_exists(fnam)) Abort();
		ViewFileName  = fnam;
		ViewFileName2 = EmptyStr;
		if (PrintImgDlg && PrintImgDlg->Visible) PrintImgDlg->FileRec = fp;
	}
	catch (EAbort &e) {
		ViewerImage->Picture->Bitmap->Handle = NULL;
		ViewFileName = ViewFileName2 = EmptyStr;
		return false;
	}

	if (ScrMode!=SCMD_IVIEW) {
		ViewerImage->Picture->Bitmap->Handle = NULL;
		SetScrMode(SCMD_IVIEW);
		//イベント: イメージビュアーを開いた直後
		ExeEventCommand(OnIvOpened);
	}
	if (isViewFTP) ThumbnailGrid->Visible = false;

	if (ShowHistogram && !HistForm->Visible)  HistForm->Show();
	if (ShowLoupe     && !LoupeForm->Visible) LoupeForm->Show();
	if (ShowSubViewer && !SubViewer->Visible) SubViewer->Show();
	SetFocus();

	TCursor org_csr = Screen->Cursor;
	if (to_draw && (!IS_FullScr() || !HideCsrInFull)) cursor_HourGlass();

	//ファイル情報
	if (ImgSidePanel->Visible) SetImgInfListBox(fp);

	UnicodeString ex_str, sz_str;

	//GIFのフレーム数を取得
	int gif_fcnt = 0;
	if (!DoublePage && AnimateGif && test_GifExt(fp->f_ext)) get_GifInf(ViewFileName, NULL, NULL, NULL, &gif_fcnt);

	//アイコン
	if (is_ExtractIcon(fp)) {
		isViewIcon = true;

		if (ThumbnailGrid->Visible) ThumbnailGrid->Repaint();

		//背景をクリア
		ViewerImage->Picture->Bitmap->SetSize(ViewerImage->ClientWidth, ViewerImage->ClientHeight);
		TCanvas *cv = ViewerImage->Canvas;
		cv->Brush->Color = col_bgImage;
		cv->FillRect(ViewerImage->ClientRect);
		//等倍フィット
		ImgScrollBox->Color = col_bgImage;
		ImgScrollBox->HorzScrollBar->Range = ImgScrollPanel->ClientWidth;
		ImgScrollBox->VertScrollBar->Range = ImgScrollPanel->ClientHeight;
		LastZoomRatio = 100;
		ImgViewThread->AddRequest(_T("ZOOM"), 100);

		//文字色設定 (背景から白or黒を選択)
		cv->Font->Assign(FileInfFont);
		cv->Font->Size	= 9;
		cv->Font->Color = SelectWorB(col_bgImage);
		int fh = get_FontHeight(cv->Font, 4);

		//アイコン
		int x = 8, y = 8;
		int x_max = 0;
		if (to_draw) {
			ViewerImage->Center = false;
			int size_lst[6] = {256, 128, 64, 48, 32, 16};
			int h = 0;
			for (int i=0; i<6; i++) {
				int size = size_lst[i];
				HICON hIcon = usr_SH->get_Icon(ViewFileName, size);
				if (hIcon && size==size_lst[i]) {
					cv->TextOut(x + 2, y, size);
					::DrawIconEx(cv->Handle, x, y + fh, hIcon, size, size, 0, NULL, DI_NORMAL);
					::DestroyIcon(hIcon);
					if (size+fh > h) h = size + fh;
					x += size + 8;
				}
			}
			y += h + 20;
			x_max = x;
		}

		//抽出アイコン
		int ixn = (int)::ExtractIcon(HInstance, ViewFileName.c_str(), -1);
		if (ixn>1) {
			sz_str.sprintf(_T(" %u Icons"), ixn);
			if (to_draw) {
				x = 8;
				bool nx_flag = false;
				for (int i=0; i<ixn; i++) {
					HICON hIcon = ::ExtractIcon(HInstance, ViewFileName.c_str(), i);	if (!hIcon) break;
					::DrawIconEx(cv->Handle, x, y, hIcon, 32, 32, 0, NULL, DI_NORMAL);
					::DestroyIcon(hIcon);
					UnicodeString nstr = i;
					cv->TextOut(x + (32 - cv->TextWidth(nstr))/2, y + 34, nstr);
					if ((x + 2*40)>ViewerImage->ClientWidth) {
						x = 8; y += (38 + fh);
						nx_flag = true;
					}
					else {
						x += 40;
						nx_flag = false;
					}
					x_max = std::max(x_max, x);
				}
				if (!nx_flag) y += (38 + fh);
			}
		}

		ViewerImage->Picture->Bitmap->SetSize(x_max, y);
		ViewerImage->Repaint();
		ImgBuff->Assign(ViewerImage->Picture);

		if (HistForm->Visible) HistForm->DrawHistogram();
		UpdateLoupe();

		if (MinShowTime>0) ImgViewThread->AddRequest(_T("WAIT"));
	}
	//アニメーションGIF
	else if (gif_fcnt>1) {
		isViewAGif = true;
		ImgBuff->Handle = NULL;

		if (ThumbnailGrid->Visible) ThumbnailGrid->Repaint();

		int i_wd = 0, i_hi = 0;
		try {
			std::unique_ptr<TGIFImage> gif_buf(new TGIFImage());
			gif_buf->LoadFromFile(ViewFileName);
			gif_buf->Animate	 = true;
			gif_buf->Transparent = true;
			i_wd = gif_buf->Width;
			i_hi = gif_buf->Height;
			ViewerImage->Picture->Assign(gif_buf.get());
		}
		catch (...) {
			ViewerImage->Picture->Assign(NULL);
		}
		ViewerImage->Center = true;
		ViewerImage->Repaint();

		ImgScrollBox->Color = col_bgImage;
		TControlScrollBar *hbar = ImgScrollBox->HorzScrollBar;
		TControlScrollBar *vbar = ImgScrollBox->VertScrollBar;
		if (i_wd>ImgScrollPanel->ClientWidth || i_hi>ImgScrollPanel->ClientHeight) {
			hbar->Range    = i_wd;
			vbar->Range    = i_hi;
			hbar->Position = (hbar->Range - ImgScrollPanel->ClientWidth)/2;
			vbar->Position = (vbar->Range - ImgScrollPanel->ClientHeight)/2;
		}
		else {
			hbar->Range = ImgScrollPanel->ClientWidth;
			vbar->Range = ImgScrollPanel->ClientHeight;
		}
		LastZoomRatio = 100;

		if (HistForm->Visible) HistForm->DrawHistogram();
		UpdateLoupe();

		if (SubViewer->Visible) SubViewer->DrawImage(ViewFileName);

		if (MinShowTime>0) ImgViewThread->AddRequest(_T("WAIT"));
	}
	//画像
	else if (is_Viewable(fp)) {
		int img_ori = 0;
		unsigned int i_wd, i_hi;
		bool size_ok = false;
		if (test_ExifExt(fp->f_ext)) {
			ex_str	= get_ExifInfStr(ViewFileName, &img_ori, &i_wd, &i_hi);
			size_ok = !ex_str.IsEmpty();
		}
		else if (test_PngExt(fp->f_ext)) {
			ex_str	= get_PngInfStr(ViewFileName, &i_wd, &i_hi);
			size_ok = !ex_str.IsEmpty();
		}
		else if (USAME_TI(fp->f_ext, ".webp")) {
			ex_str	= get_WebpInfStr(ViewFileName, &i_wd, &i_hi);
			size_ok = !ex_str.IsEmpty();
		}
		if (!size_ok) size_ok = get_img_size(ViewFileName, &i_wd, &i_hi);
		if (size_ok)  sz_str  = get_wd_x_hi_str(i_wd, i_hi);

		//表示スレッド設定
		if (to_draw) {
			WaitForImgReady();
			if (fitted) {
				ImgViewThread->AddRequest(_T("FITTED"), 1);
			}
			else if (zoom>0) {
				ImgViewThread->AddRequest(_T("FITTED"), 0);
				ImgViewThread->AddRequest(_T("ZOOM"), zoom);
				LastZoomRatio = zoom;
			}
			else if (!ImgViewThread->Fitted) {
				ImgViewThread->AddRequest(_T("FITTED"), !KeepZoomRatio? 1 : 0);
			}

			ImgViewThread->AddRequest(_T("ROTATION"), 0);
			ImgViewThread->AddRequest(_T("EXIFORI"), img_ori);

			//見開きモード
			if (DoublePage && !test_FileExt(ExtractFileExt(ViewFileName), FEXT_META FEXT_ICONVIEW) && !isViewFTP) {
				int idx = ViewFileList->IndexOf(ViewFileName);
				if (idx!=-1 && idx<ViewFileList->Count-1) {
					file_rec *vfp = (file_rec*)ViewFileList->Objects[idx + 1];
					if (!test_FileExt(vfp->f_ext, FEXT_META FEXT_ICONVIEW)) {
						if (vfp->is_virtual) SetTmpFile(vfp);
						ViewFileName2 = vfp->is_virtual? vfp->tmp_name : vfp->f_name;
					}
				}
			}
			ImgViewThread->AddRequest(_T("FILE"), ViewFileName, ViewFileName2);
		}
		else if (HistForm->Visible) {
			for (int i=0; i<ThumbnailThread->Count; i++) {
				if (!SameText(ViewFileName, get_pre_tab(ThumbnailThread->ThumbnailList->Strings[i]))) continue;
				Graphics::TBitmap *bp = (Graphics::TBitmap*)ThumbnailThread->ThumbnailList->Objects[i];
				HistForm->DrawHistogram(bp);
				break;
			}
		}

		if (SubViewer->Visible) SubViewer->DrawImage(ViewFileName);
	}

	//情報ヘッダ
	UnicodeString inf_str = warn_filename_RLO(ViewFileName) + FormatDateTime("  yy/mm/dd hh:nn:ss",  fp->f_time);
	if (!ex_str.IsEmpty()) inf_str.cat_sprintf(_T("  %s"), ex_str.c_str());

	UnicodeString pnam;
	if (isViewWork) {
		if (WorkListName.IsEmpty())
			pnam = " (新規ワークリスト)";
		else
			pnam.sprintf(_T(" %s"), get_base_name(WorkListName).c_str());
	}
	else {
		if (CurStt->is_Arc) {
			pnam = CurStt->arc_Name;
			if (!CurStt->arc_SubPath.IsEmpty()) pnam += "\\" + CurStt->arc_SubPath;
		}
		else pnam = fp->p_name;

		if (UncToNetDrive)   pnam = UNC_to_NetDriveName(pnam);
		if (!isViewWork && DispRegName) pnam = get_RegDirName(pnam);
		if (CurStt->is_Find) pnam += CurStt->find_Mask;
	}
	pnam = yen_to_delimiter(pnam);

	TStatusBar *sp = ImgSttHeader;
	sp->Panels->Items[0]->Bevel = isViewWork? pbRaised : pbLowered;
	sp->Panels->Items[0]->Text	= get_MiniPathName(pnam, sp->Panels->Items[0]->Width - 4, sp->Font);
	sp->Panels->Items[1]->Text	= inf_str;
	sp->Panels->Items[2]->Text	= sz_str;
	sp->Hint					= ViewFileName;

	if (isViewIcon || isViewAGif) {
		sp->Panels->Items[3]->Text = "100%";
		ImgInfBar->Panels->Items[1]->Text = "100%";
	}

	SetSttBarInf(fp);

	Screen->Cursor = org_csr;
	return true;
}
//---------------------------------------------------------------------------
bool __fastcall TNyanFiForm::OpenImgViewer(int idx)
{
	if (idx<0 || idx>=ViewFileList->Count) return false;

	set_GridIndex(ThumbnailGrid, idx, ViewFileList->Count);
	SetCurFrecPtr(GetFrecPtrFromViewList(idx));
	file_rec *vfp = (file_rec*)ViewFileList->Objects[idx];
	if (!OpenImgViewer(vfp)) return false;

	if (NotThumbIfArc) {
		if (vfp->is_virtual) {
			ThumbnailThread->MakeIndex = idx;
			ThumbnailThread->ReqMake   = true;
		}
		//見開きモード
		if (DoublePage && idx<ViewFileList->Count-1) {
			idx++;
			file_rec *vfp = (file_rec*)ViewFileList->Objects[idx];
			if (vfp->is_virtual) {
				while (ThumbnailThread->ReqMake) { Application->ProcessMessages();  Sleep(1); }
				ThumbnailThread->MakeIndex = idx;
				ThumbnailThread->ReqMake   = true;
			}
		}
	}
	return true;
}

//---------------------------------------------------------------------------
//クリップボードのビットマップをイメージビュアーで開く
//---------------------------------------------------------------------------
bool __fastcall TNyanFiForm::ViewClipImage(bool fitted, int zoom)
{
	if (!Clipboard()->HasFormat(CF_BITMAP)) return false;

	ImgViewThread->ImgBuff->Assign(Clipboard());
	ImgViewThread->ImgIsWmf  = false;
	ImgViewThread->FileName  = EmptyStr;
	ImgViewThread->FileName2 = EmptyStr;
	int i_wd = ImgViewThread->ImgBuff->Width;
	int i_hi = ImgViewThread->ImgBuff->Height;

	cursor_HourGlass();
	isViewClip = true;
	isViewIcon = isViewAGif = false;
	if (ScrMode!=SCMD_IVIEW) {
		ViewerImage->Picture->Bitmap->Handle = NULL;
		SetScrMode(SCMD_IVIEW);
		//イベント: イメージビュアーを開いた直後
		ExeEventCommand(OnIvOpened);
		rqThumbnail = ThumbnailGrid->Visible;
	}
	ThumbnailGrid->Visible = false;

	if (ShowHistogram && !HistForm->Visible)  HistForm->Show();
	if (ShowLoupe     && !LoupeForm->Visible) LoupeForm->Show();
	if (ShowSubViewer && !SubViewer->Visible) SubViewer->Show();
	SetFocus();

	if (ImgSidePanel->Visible) {
		std::unique_ptr<TStringList> i_lst(new TStringList());
		i_lst->AddObject("クリップボード", (TObject*)LBFLG_STD_FINF);
		i_lst->AddObject("____", (TObject*)LBFLG_STD_FINF);
		i_lst->AddObject("____", (TObject*)LBFLG_STD_FINF);
		add_PropLine(_T("種類"), "ビットマップ イメージ", i_lst.get());
		i_lst->Add(get_img_size_str(i_wd, i_hi));
		assign_InfListBox(ImgInfListBox, i_lst.get(), ImgInfScrPanel);
	}

	//表示スレッド設定
	WaitForImgReady();
	if (fitted) {
		ImgViewThread->AddRequest(_T("FITTED"), 1);
	}
	else if (zoom>0) {
		ImgViewThread->AddRequest(_T("FITTED"), 0);
		LastZoomRatio = zoom;
		ImgViewThread->AddRequest(_T("ZOOM"), zoom);
	}
	else if (!ImgViewThread->Fitted) {
		ImgViewThread->AddRequest(_T("FITTED"), !KeepZoomRatio? 1 : 0);
	}

	ImgViewThread->AddRequest(_T("ROTATION"), 0);
	ImgViewThread->AddRequest(_T("EXIFORI"),  0);
	ImgViewThread->AddRequest(_T("RELOAD"));

	//情報ヘッダ
	TStatusBar *sp = ImgSttHeader;
	sp->Panels->Items[0]->Text = EmptyStr;
	sp->Panels->Items[1]->Text = "クリップボード";
	sp->Panels->Items[2]->Text = get_wd_x_hi_str(i_wd, i_hi);
	sp->Panels->Items[4]->Text = EmptyStr;
	sp->Hint				   = EmptyStr;
	ImgInfBar->Panels->Items[0]->Text = EmptyStr;

	cursor_Default();
	return true;
}

//---------------------------------------------------------------------------
//イメージビュアーのファイル情報を取得/設定
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::SetImgInfListBox(file_rec *fp)
{
	if (has_KeyDownMsg()) {
		FinfSkipped = true;			//未処理のキー入力がある場合スキップ
		ImgInfListBox->Clear();
	}
	else {
		if (fp) {
			if (fp->is_ftp || fp->inf_list->Count==0) GetFileInfList(fp, true);
			assign_InfListBox(ImgInfListBox, fp->inf_list);
		}
		else {
			ImgInfListBox->Clear();
		}
	}

	ImgInfScrPanel->UpdateKnob();
}

//---------------------------------------------------------------------------
//ビュアーをクリア
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ClearViewImage()
{
	ImgViewThread->AddRequest(_T("CLEAR"));
	while (ImgViewThread->IsWaiting()) { Application->ProcessMessages();  Sleep(1); }
}

//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::SetViewFileIdx()
{
	InhSeekBar++;
	{
		//シークバーの設定
		int range = std::max(ViewFileList->Count - 1, 1);
		//右→左
		if (DoublePage && RightBind && SeekBindDir) {
			SeekBar->Min = -range;
			SeekBar->Max = 0;
			SeekLBtn->Action = EndFileAction;
			SeekRBtn->Action = TopFileAction;
		}
		//左→右
		else {
			SeekBar->Min = 0;
			SeekBar->Max = range;
			SeekLBtn->Action = TopFileAction;
			SeekRBtn->Action = EndFileAction;
		}
		SeekBar->PageSize = std::max(range/12, 1);

		int idx = ViewFileList->IndexOf(ViewFileName);
		if (idx!=-1) {
			IsEvenPage = (idx%2==0);
			SeekBar->Position = (SeekBar->Min<0)? -idx : idx;
			//状態表示
			UnicodeString tmp; tmp.sprintf(_T("%3u/%3u"), idx + 1, ViewFileList->Count);
			SeekSttPanel->Caption = tmp;
			int sel_cnt = GetSelCount(ViewFileList);
			if (sel_cnt>0) tmp.cat_sprintf(_T(" (選択 %u)"), sel_cnt);
			ImgSttHeader->Panels->Items[4]->Text = tmp;
			ImgInfBar->Panels->Items[0]->Text	 = tmp;
		}
	}
	InhSeekBar--;
}

//---------------------------------------------------------------------------
//ルーペの表示更新
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::UpdateLoupe()
{
	if (ScrMode!=SCMD_IVIEW || !LoupeForm->Visible) return;

	try {
		if (isViewAGif) Abort();

		Graphics::TBitmap *bp = ViewerImage->Picture->Bitmap;
		if (bp->Empty) Abort();

		TRect rc = Rect(0, 0, bp->Width, bp->Height);
		if (ViewerImage->Center)
			rc.Offset((ViewerImage->ClientWidth - bp->Width)/2, (ViewerImage->ClientHeight - bp->Height)/2);
		TPoint p = ViewerImage->ScreenToClient(Mouse->CursorPos);
		if (!rc.PtInRect(p)) Abort();

		int ix, iy;
		//画像
		if (!isViewIcon) {
			float rx = 1.0 * (p.x - rc.Left)/bp->Width;
			float ry = 1.0 * (p.y - rc.Top)/bp->Height;
			bp = ImgBuff;	if (bp->Empty) Abort();
			ix = bp->Width*rx;
			iy = bp->Height*ry;
		}
		//アイコン
		else {
			ix = p.x;
			iy = p.y;
		}
		LoupeForm->DrawImage(bp, ix, iy);
	}
	catch (EAbort &e) {
		LoupeForm->DrawImage();
	}
}

//---------------------------------------------------------------------------
//ビュアーでのキー操作
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::FormKeyDown(TObject *Sender, WORD &Key, TShiftState Shift)
{
	if (!Initialized || UnInitializing) return;

	//--------------------------
	//テキストビュアー
	//--------------------------
	if (ScrMode==SCMD_TVIEW) {
		try {
			bool hadled = true;
			//インクリメンタルサーチ
			if (TxtViewer->isIncSea) {
				UnicodeString KeyStr = get_KeyStr(Key, Shift);		if (KeyStr.IsEmpty()) return;
				TxtViewer->IncSearch(KeyStr);
			}
			//通常
			else {
				UnicodeString KeyStr = TwoStrokeSeq(Key, Shift);	if (KeyStr.IsEmpty()) return;
				UnicodeString cmd_V  = Key_to_CmdV(KeyStr);
				UnicodeString cmd_F  = Key_to_CmdF(KeyStr);
				CancelHelp	= !cmd_V.IsEmpty() && EndsStr("F1", KeyStr);
				ActionParam = EmptyStr;

				//コマンド処理
				if (ExeCommandV(cmd_V))
					ClearKeyBuff(true);
				//標準のキー処理
				else if (TxtScrollPanel->Visible && TxtViewer->StdKeyOperation(KeyStr))
					ClearKeyBuff(true);
				//右クリックメニュー
				else if (contained_wd_i(KeysStr_Popup, KeyStr) || StartsText("ContextMenu", cmd_F)) {
					show_PopupMenu(ViewPopupMenu, TextPaintBox);
				}
				//補助画面(なければビュアー)を閉じる
				else if (equal_ESC(KeyStr)) {
					if (ExeCmdsBusy) {
						if (msgbox_Sure(USTR_CancelCmdQ)) XCMD_Aborted = true;
					}
					else {
						if (!TxtViewer->CloseAuxForm()) ExeCommandV(_T("Close"));
					}
				}
				//ビュアーを閉じる
				else if (equal_ENTER(KeyStr)) ExeCommandV(_T("Close"));
				else hadled = false;
			}

			if (hadled) Key = 0;
		}
		catch (EAbort &e) {
			SttBarWarn(e.Message);
		}
	}
	//--------------------------
	//イメージビュアー
	//--------------------------
	else if (ScrMode==SCMD_IVIEW && ImgViewPanel->Visible) {
		UnicodeString KeyStr = TwoStrokeSeq(Key, Shift);	if (KeyStr.IsEmpty()) return;
		UnicodeString CmdStr = KeyFuncList->Values["I:" + KeyStr];
		CancelHelp	= !CmdStr.IsEmpty() && EndsStr("F1", KeyStr);

		//右綴じでNext/PrevFile入替
		if (SeekSwapNxtPrv && DoublePage && RightBind && ShowSeekBar) {
			if		(StartsText("NextFile", CmdStr)) CmdStr = ReplaceText(CmdStr, "NextFile", "PrevFile");
			else if (StartsText("PrevFile", CmdStr)) CmdStr = ReplaceText(CmdStr, "PrevFile", "NextFile");
		}

		ActionParam = EmptyStr;

		try {
			bool hadled = true;
			//コマンド処理
			if (ExeCommandI(CmdStr)) {
				if (!ActionOk) ActionAbort();
			}
			//閉じる
			else if (equal_ESC(KeyStr)) {
				if (ExeCmdsBusy) {
					if (msgbox_Sure(USTR_CancelCmdQ)) XCMD_Aborted = true;
				}
				else if (IS_FullScr()) SetFullScreen(false);
				else if (ColorPicker->Visible) ColorPicker->Close();
				else CloseIAction->Execute();
			}
			else if (equal_ENTER(KeyStr)) CloseIAction->Execute();
			//スクロール
			else if (!ThumbExtended && Shift.Empty()) {
				switch (Key) {
				case VK_UP:		ScrollUpIAction->Execute();		break;
				case VK_DOWN:	ScrollDownIAction->Execute();	break;
				case VK_LEFT:	ScrollLeftAction->Execute();	break;
				case VK_RIGHT:	ScrollRightAction->Execute();	break;
				case VK_PRIOR:	PrevPageAction->Execute();		break;
				case VK_NEXT:	NextPageAction->Execute();		break;
				}
			}
			//カーソル移動
			else if (!usr_ARC->Busy && Shift.Empty()) {
				switch (Key) {
				case VK_UP:		GridCursorUp(ThumbnailGrid);	break;
				case VK_DOWN:	GridCursorDown(ThumbnailGrid);	break;
				case VK_LEFT:	GridCursorLeft(ThumbnailGrid);	break;
				case VK_RIGHT:	GridCursorRight(ThumbnailGrid);	break;
				case VK_PRIOR:	PageUpIAction->Execute();		break;
				case VK_NEXT:	PageDownIAction->Execute();		break;
				}
			}
			else hadled = false;

			if (hadled) Key = 0;
		}
		catch (EAbort &e) {
			SttBarWarn(e.Message);
			Key = 0;
		}
	}
	//--------------------------
	//その他
	//--------------------------
	else {
		//Shift+F10キーの処理(エディット/コンボボックスのメニュー表示)
		//※コンボボックスでデフォルトのメニューが出てしまう現象に対応
		//　また、コントロールが隠れないように表示位置を変更
		if (USAME_TI(get_KeyStr(Key, Shift), "Shift+F10") && UserModule->ShowPopupMenu()) Key = 0;
	}
}
//---------------------------------------------------------------------------
//イメージビュアーでのマウス操作
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ViewerImageMouseDown(TObject *Sender, TMouseButton Button, TShiftState Shift, int X, int Y)
{
	CancelKeySeq();
	cursor_Default();

	if (isViewAGif) return;

	if (Button==mbLeft) {
		DragCancel = false;

		//カラーピッカー
		if (ColorPicker->Visible) {
			ColorPicker->CopyColor();
		}
		//その他
		else if (!isViewIcon  && OnIvImgDClick.IsEmpty()) {
			TControlScrollBar *hbar = ImgScrollBox->HorzScrollBar;
			TControlScrollBar *vbar = ImgScrollBox->VertScrollBar;

			if (ImgViewThread->Fitted && ImgViewThread->ZoomRatio<100) {
				//イメージ上をクリック?
				int vw = ImgViewThread->ViewBuff->Width;
				int vh = ImgViewThread->ViewBuff->Height;
				TRect rc = Rect(0, 0, vw, vh);
				rc.Offset((ViewerImage->ClientWidth - vw)/2, (ViewerImage->ClientHeight - vh)/2);
				if (rc.PtInRect(Point(X, Y))) {
					//一時的に等倍表示に
					EqualSizeAction->Execute();
					//クリック位置へ移動
					hbar->Position = (hbar->Range - ImgScrollBox->ClientWidth)  * 1.0 * (X - rc.Left)/rc.Width();
					vbar->Position = (vbar->Range - ImgScrollBox->ClientHeight) * 1.0 * (Y - rc.Top)/rc.Height();
					TmpEqualSize = true;
					//ルーペを一時的に隠す
					if (LoupeForm->Visible && LoupeForm->Floating) LoupeForm->Hide();
				}
			}

			if (hbar->Range>ImgScrollBox->ClientWidth || vbar->Range>ImgScrollBox->ClientHeight) {
				//イメージ移動開始をキャンセル
				if (DragCancel) {
					FittedSizeAction->Execute();
					if (ShowLoupe && !LoupeForm->Visible) {
						LoupeForm->Show();
						SetFocus();
					}
				}
				//イメージ移動開始
				else {
					LastP = Mouse->CursorPos;
					ImgMoving = true;
					Screen->Cursor = UserModule->crHandGrabR;
				}
			}
		}
	}
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ViewerImageMouseMove(TObject *Sender, TShiftState Shift, int X, int Y)
{
	//カラーピッカー
	if (ColorPicker->Visible) {
		ColorPicker->UpdateStt(X, Y, ImgViewThread->ZoomRatioF);
	}
	//イメージ移動中
	else if (ImgMoving) {
		TPoint cur_pos = Mouse->CursorPos;
		ImgScrollBox->HorzScrollBar->Position += (LastP.x - cur_pos.x);
		ImgScrollBox->VertScrollBar->Position += (LastP.y - cur_pos.y);
		LastP = cur_pos;
	}

	//ルーペ表示
	UpdateLoupe();
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ViewerImageMouseUp(TObject *Sender, TMouseButton Button, TShiftState Shift, int X, int Y)
{
	//左クリック
	if (Button==mbLeft) {
		if (ImgMoving) {
			//イメージ移動終了
			ImgMoving = false;
			if (TmpEqualSize) {
				TmpEqualSize = false;
				FittedSizeAction->Execute();
			}
			cursor_Default();
		}
		else DragCancel = true;	//イメージ移動開始をキャンセル

		if (ShowLoupe && !LoupeForm->Visible) {
			LoupeForm->Show();
			SetFocus();
		}
	}
	//右クリック
	else if (Button==mbRight) {
		//イベント : 画像表示部を右クリック
		ExeEventCommandMP(OnIvImgRClick);
	}
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ViewerImageDblClick(TObject *Sender)
{
	bool handled = false;
	if (!OnIvImgDClick.IsEmpty() || !OnIvMgnDClick.IsEmpty()) {
		//イメージ上をクリック?
		int vw = ImgViewThread->ViewBuff->Width;
		int vh = ImgViewThread->ViewBuff->Height;
		TRect rc = Rect(0, 0, vw, vh);
		rc.Offset((ViewerImage->ClientWidth - vw)/2, (ViewerImage->ClientHeight - vh)/2);
		if (rc.PtInRect(ViewerImage->ScreenToClient(Mouse->CursorPos))) {
			if (!OnIvImgDClick.IsEmpty()) {
				ExeEventCommand(OnIvImgDClick); handled = true;
			}
		}
		else {
			if (!OnIvMgnDClick.IsEmpty()) {
				ExeEventCommand(OnIvMgnDClick); handled = true;
			}
		}
	}

	if (!handled) CloseIAction->Execute();
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ViewerImageMouseLeave(TObject *Sender)
{
	ColorPicker->UpdateStt();
}

//---------------------------------------------------------------------------
//イメージビュアーでのコマンド処理
//---------------------------------------------------------------------------
bool __fastcall TNyanFiForm::ExeCommandI(UnicodeString cmd, UnicodeString prm)
{
	if (cmd.IsEmpty()) return false;

	if (prm.IsEmpty()) {
		prm = exclude_quot(get_PrmStr(cmd));
		cmd = get_CmdStr(cmd);
	}

	ActionParam = extract_ExeParam(prm, &ActionDesc);
	ActionOk	= true;

	try {
		MsgHint->ReleaseHandle();

		//イメージビュアー固有のコマンド
		bool handled = false;
		for (int i=0; i<ActionList1->ActionCount && !handled; i++) {
			TAction *ap = (TAction*)ActionList1->Actions[i];
			if (!USAME_TI(ap->Category, "CommandI")) continue;
			if (SameText(cmd, get_tkn(ap->Name, _T("Action"))) || SameText(cmd, get_tkn(ap->Name, _T("IAction")))) {
				if (!ExeCmdAction(ap)) SttBarWarn(ActionErrMsg);
				handled = true;
			}
		}

		if (!handled) {
			//ファイラーと共通のコマンド
			handled  = ExeCommandAction(cmd, ActionParam);
			ActionOk = true;
		}
		//ファイル数、現在位置、選択数の表示
		if (handled) SetViewFileIdx();

		return handled;
	}
	catch (EAbort &e) {
		SetActionAbort(e.Message);
		return true;
	}
	catch (...) {
		SetInternalException(cmd, ActionParam);
		return true;
	}
}

//---------------------------------------------------------------------------
//イメージビューアーを閉じる
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::CloseIActionExecute(TObject *Sender)
{
	ThumbnailThread->ReqClear = true;
	if (rqThumbnail) ThumbnailGrid->Visible = true;

	//マーク
	if (!isViewClip && MarkImgClose) {
		file_rec *cfp = GetCurFrecPtr();
		bool ok = true;
		if (!MarkImgPath.IsEmpty()) ok = match_path_list(cfp->r_name, MarkImgPath, true);
		if (ok && test_FileExt(get_extension(cfp->r_name), MarkImgFExt)) {
			ExeCommandAction("ClearMark");
			ExeCommandAction("Mark", MarkImgMemo);
		}
	}

	ViewFileName = EmptyStr;
	ImgViewThread->AddRequest(_T("GRAY"), 0);
	ImgViewThread->AddRequest(_T("CLEAR"));

	SetFullScreen(false, false);

	if (LoupeForm->Visible && LoupeForm->Floating) LoupeForm->Close();
	if (HistForm->Visible && HistForm->Floating)   HistForm->Close();
	if (SubViewer->Visible) SubViewer->Close();

	//選択状態を反映
	for (int i=0; i<ViewFileList->Count; i++) {
		file_rec *cfp = GetFrecPtrFromViewList(i);
		if (cfp) cfp->selected = ((file_rec*)ViewFileList->Objects[i])->selected;
	}
	clear_FileList(ViewFileList);

	//インデックスエラーの回避
	TStringGrid *gp = ThumbnailGrid;
	InhDrawImg++; {
		gp->Col = 0; gp->Row = 0; gp->Repaint();
	} InhDrawImg--;

	SetScrMode(SCMD_FLIST, CurListTag);
	if (ViewFromArc) RecoverFileList(CurListTag);

	isViewClip = isViewFTP	= false;
	isViewIcon = isViewAGif = false;
	ViewFromArc = false;

	//イベント: イメージビュアーを閉じた直後
	ExeEventCommand(OnIvClosed);
}

//---------------------------------------------------------------------------
//画像をクリップボードにコピー
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ClipCopyActionExecute(TObject *Sender)
{
	try {
		if (isViewAGif) {
			std::unique_ptr<Graphics::TBitmap> bmp(new Graphics::TBitmap());
			if (load_ImageFile(ViewFileName, bmp.get(), WICIMG_PREVIEW, col_bgImage))
				copy_to_Clipboard(bmp.get());
		}
		else if (TEST_ActParam("VI")) {
			copy_to_Clipboard(ViewerImage->Picture);
		}
		else {
			file_rec *cfp = GetCurFrecPtr();
			if (is_Viewable(cfp)) {
				if (!ImgViewThread->IsReady()) Abort();
				//メタファイル
				if (test_MetaExt(cfp->f_ext)) {
					std::unique_ptr<TMetafile> mf(new TMetafile());
					mf->LoadFromFile(cfp->f_name);
					copy_to_Clipboard(mf.get());
				}
				//画像
				else copy_to_Clipboard(ImgViewThread->ImgBuff);
			}
			else if (is_ExtractIcon(cfp)) {
				copy_to_Clipboard(ViewerImage->Picture);
			}
			else Abort();
		}

		if (isViewClip && TEST_ActParam("VI")) ViewClipImage();
	}
	catch (EAbort &e) {
		SetActionAbort(e.Message);
	}
	catch (...) {
		SetActionAbort();
	}
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ClipCopyActionUpdate(TObject *Sender)
{
	((TAction*)Sender)->Visible = ScrMode==SCMD_IVIEW && !isViewClip;
}

//---------------------------------------------------------------------------
//カラーピッカー
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ColorPickerActionExecute(TObject *Sender)
{
	ColorPicker->ViewImage = ViewerImage;
	ColorPicker->Show();
}

//---------------------------------------------------------------------------
//イメージビュアーから画像ファイルを削除
//---------------------------------------------------------------------------
bool __fastcall TNyanFiForm::DeleteICore(int idx)
{
	UnicodeString del_nam = ViewFileList->Strings[idx];
	UnicodeString msg = make_LogHdr(_T("DELETE"), del_nam);

	try {
		if (ForceDel && !set_FileWritable(del_nam))	Abort();
		if (!delete_File(del_nam, DelUseTrash))		Abort();
		AddLog(msg);
		del_FileListItem(ViewFileList,	idx);
		return true;
	}
	catch (EAbort &e) {
		set_LogErrMsg(msg);
		AddLog(msg);
		return false;
	}
}

//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::DeleteIActionExecute(TObject *Sender)
{
	TStringGrid *gp = ThumbnailGrid;
	if (gp->Visible) set_RedrawOff(gp);

	try {
		if (CurStt->is_Arc || CurStt->is_FTP) UserAbort(USTR_OpeNotSuported);
		if (ViewFileName.IsEmpty())	Abort();
		if (is_drive_protected(CurPath[CurListTag])) SysErrAbort(ERROR_WRITE_PROTECT);

		int sel_cnt = GetSelCount(ViewFileList);
		if (TEST_ActParam("SO") && sel_cnt==0) SkipAbort();

		int v_idx	= GetCurIndex();
		int r_top	= gp->TopRow;
		int l_col	= gp->LeftCol;

		//ワークリスト
		if (isViewWork) {
			if (WorkListFiltered) UserAbort(USTR_WorkFiltered);

			//選択画像
			if (sel_cnt>0) {
				if (msgbox_Sure(_T("選択ファイルをワークリストから外しますか?"), SureDelete)) {
					gp->Col = 0; gp->Row = 0;
					int i = 0;
					while (i<ViewFileList->Count) {
						file_rec *vfp = (file_rec*)ViewFileList->Objects[i];
						if (vfp->selected) {
							int w_idx = WorkList->IndexOf(vfp->f_name);
							if (w_idx!=-1) {
								del_FileListItem(WorkList,		w_idx);
								del_FileListItem(ViewFileList,	i);
							}
						}
						else i++;
					}
					rqWorkListDirInf = !WorkListChanged;
					WorkListChanged  = true;
				}
			}
			//表示画像
			else {
				if (v_idx==-1) Abort();
				if (msgbox_Sure(_T("このファイルをワークリストから外しますか?"), SureDelete)) {
					int w_idx = WorkList->IndexOf(ViewFileList->Strings[v_idx]);
					if (v_idx!=-1) {
						gp->Col = 0; gp->Row = 0;
						del_FileListItem(WorkList,		w_idx);
						del_FileListItem(ViewFileList,	v_idx);
					}
					rqWorkListDirInf = !WorkListChanged;
					WorkListChanged  = true;
				}
			}
		}
		//ファイル
		else {
			//選択画像
			UnicodeString msg;
			if (sel_cnt>0) {
				if (msgbox_Sure(LoadUsrMsg(USTR_DeleteQ, _T("選択ファイル")), SureDelete)) {
					StartLog(LoadUsrMsg(USTR_BeginDelete, CurPath[CurListTag]));
					gp->Col = 0; gp->Row = 0;
					int i = 0;
					while (i<ViewFileList->Count) {
						if (((file_rec*)ViewFileList->Objects[i])->selected) {
							if (!DeleteICore(i)) UserAbort(USTR_FaildDelete);
						}
						else i++;
					}
				}
			}
			//表示画像
			else {
				if (v_idx==-1) Abort();
				if (msgbox_Sure(LoadUsrMsg(USTR_DeleteQ, _T("このファイル")), SureDelete)) {
					StartLog(LoadUsrMsg(USTR_BeginDelete, CurPath[CurListTag]));
					gp->Col = 0; gp->Row = 0;
					if (!DeleteICore(v_idx)) UserAbort(USTR_FaildDelete);
				}
			}
			EndLog(_T("削除"));
		}

		//カーソル位置
		if (ViewFileList->Count>0) {
			if (v_idx>=ViewFileList->Count) v_idx = std::max(ViewFileList->Count - 1, 0);
			set_GridIndex(gp, v_idx, ViewFileList->Count);
			//全面表示の場合、不要になった行を減らす
			if (ThumbExtended) {
				int rn = ViewFileList->Count/gp->ColCount + ((ViewFileList->Count%gp->ColCount>0)? 1 : 0);
				if (rn!=gp->RowCount) gp->RowCount = rn;
			}
			//全面表示ではない場合、先頭位置を復元
			else {
				if (gp->ColCount==1) {
					gp->RowCount = ViewFileList->Count;
					gp->TopRow	 = std::min(r_top, gp->RowCount - gp->VisibleRowCount);
				}
				else if (gp->RowCount==1) {
					gp->ColCount = ViewFileList->Count;
					gp->LeftCol  = std::min(l_col, gp->ColCount - gp->VisibleColCount);
				}
			}
			//表示を更新
			if (ViewFileList->Count>0) {
				SetCurFrecPtr(GetFrecPtrFromViewList(v_idx));
				if (!OpenImgViewer((file_rec*)ViewFileList->Objects[v_idx])) Abort();
			}
		}
		else {
			//すべて削除された
			InhDrawImg++; {
				gp->Col = 0; gp->Row = 0; gp->Repaint();
				gp->ColCount = 1;	gp->RowCount = 1;
			} InhDrawImg--;
			ImgViewThread->AddRequest(_T("CLEAR"));
		}
	}
	catch (EAbort &e) {
		SetActionAbort(e.Message);
	}

	if (gp->Visible) set_RedrawOn(gp);
}

//---------------------------------------------------------------------------
//見開き表示
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::DoublePageActionExecute(TObject *Sender)
{
	SetToggleAction(DoublePage);
	SetViewFileIdx();
	ClearViewImage();
	if (!OpenImgViewer(GetCurIndex())) SetActionAbort();
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::DoublePageActionUpdate(TObject *Sender)
{
	TAction *ap = (TAction*)Sender;
	ap->Visible = ScrMode==SCMD_IVIEW;
	ap->Enabled = ap->Visible;
	ap->Checked = DoublePage;
}

//---------------------------------------------------------------------------
//等倍表示
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::EqualSizeActionExecute(TObject *Sender)
{
	LastZoomRatio = 100;
	ImgViewThread->AddRequest(_T("ZOOM"), 100);
	ImgViewThread->AddRequest(_T("FITTED"), 0);
	WaitForImgReady(true);
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::EqualSizeActionUpdate(TObject *Sender)
{
	TAction *ap = (TAction*)Sender;
	ap->Visible = ScrMode==SCMD_IVIEW;
	ap->Enabled = ap->Visible && !isViewIcon && !isViewAGif && ImgScrollPanel->Visible && ImgViewThread->IsReady();
}

//---------------------------------------------------------------------------
//最後のファイルに移動
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::EndFileActionExecute(TObject *Sender)
{
	int new_idx = -1;
	for (int i=ViewFileList->Count-1; i>=0; i--) {
		if (!((file_rec*)ViewFileList->Objects[i])->failed) { new_idx = i; break; }
	}
	if (!OpenImgViewer(new_idx)) SetActionAbort();
}

//---------------------------------------------------------------------------
//画面サイズに合わせて表示
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::FittedSizeActionExecute(TObject *Sender)
{
	ImgViewThread->AddRequest(_T("FITTED"), 1);
	ImgViewThread->AddRequest(_T("RELOAD"));
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::FittedSizeActionUpdate(TObject *Sender)
{
	TAction *ap = (TAction*)Sender;
	ap->Visible = ScrMode==SCMD_IVIEW;
	ap->Enabled = ap->Visible && !isViewIcon && !isViewAGif && ImgScrollPanel->Visible;
}

//---------------------------------------------------------------------------
//ヒストグラム
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::HistogramActionExecute(TObject *Sender)
{
	HistForm->Visible = SetToggleAction(ShowHistogram);
	int dh = SideDockPanel->Height;
	if (HistForm->Visible) {
		if (!HistForm->Floating) {
			HistDockPanel->Constraints->MinHeight = CLHI_HISTOGRAM;
			HistDockPanel->Constraints->MaxHeight = CLHI_HISTOGRAM;
			HistDockPanel->Height	 = CLHI_HISTOGRAM;
			SideDockPanel->Height	 = dh + CLHI_HISTOGRAM;
			SideDockSplitter->Height = (LoupeForm->Visible && !LoupeForm->Floating)? SplitterWidth2 : 0;
		}
		ImgViewThread->AddRequest(_T("REDRAW"));
		SetFocus();
	}
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::HistogramActionUpdate(TObject *Sender)
{
	TAction *ap = (TAction*)Sender;
	ap->Visible = ScrMode==SCMD_IVIEW;
	ap->Enabled = ap->Visible && (!IS_FullScr() || HistForm->Floating);
	ap->Checked = HistForm->Visible;
}

//---------------------------------------------------------------------------
//指定したインデックスに移動
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::JumpIndexActionExecute(TObject *Sender)
{
	try {
		UnicodeString idx_str = ActionParam;
		int max_idx = std::max(ViewFileList->Count - 1, 0);
		if (idx_str.IsEmpty()) {
			UnicodeString tmp;
			tmp.sprintf(_T("インデックス(1〜%u)"), max_idx + 1);
			idx_str = Trim(inputbox_ex(_T("指定インデックスに移動"), tmp.c_str(), EmptyStr));
		}
		if (idx_str.IsEmpty()) SkipAbort();

		int rel_sig = 0;
		if (starts_tchs(_T("+-"), idx_str)) {
			rel_sig = (idx_str[1]=='-')? -1 : 1;
			idx_str.Delete(1, 1);
		}

		int idx = idx_str.ToIntDef(0);
		if (idx==0) UserAbort(USTR_IllegalParam);

		//相対
		if (rel_sig!=0) {
			int cur_idx = ViewFileList->IndexOf(ViewFileName);
			idx = cur_idx + rel_sig * idx;
			if (idx<0 || idx>max_idx) Abort();
		}
		//絶対
		else {
			idx--;
			if (idx<0) idx = 0; else if (idx>max_idx) idx = max_idx;
		}

		set_GridIndex(ThumbnailGrid, idx, ViewFileList->Count);
	}
	catch (EAbort &e) {
		SetActionAbort(e.Message);
	}
}

//---------------------------------------------------------------------------
//ルーペ
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::LoupeActionExecute(TObject *Sender)
{
	LoupeForm->Visible = SetToggleAction(ShowLoupe);
	if (LoupeForm->Visible) {
		if (!LoupeForm->Floating) {
			LoupeDockPanel->Constraints->MinHeight = MINHI_LOUPE;
			LoupeDockPanel->Constraints->MaxHeight = 0;
			SideDockPanel->Height	 = HistDockPanel->Height + IniFile->ReadIntGen(_T("LoupeHeight"),	200);
			SideDockSplitter->Height = SplitterWidth2;
		}
		else {
			SideDockSplitter->Height = 0;
		}
		ImgViewThread->AddRequest(_T("REDRAW"));
	}
	else {
		SideDockSplitter->Height = 0;
	}
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::LoupeActionUpdate(TObject *Sender)
{
	TAction *ap = (TAction*)Sender;
	ap->Visible = ScrMode==SCMD_IVIEW;
	ap->Enabled = ap->Visible && (!IS_FullScr() || LoupeForm->Floating);
	ap->Checked = LoupeForm->Visible;
}

//---------------------------------------------------------------------------
//グレースケール化
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::GrayScaleActionExecute(TObject *Sender)
{
	bool sw = ImgViewThread->GrayScaled;
	SetToggleAction(sw);
	ImgViewThread->AddRequest(_T("GRAY"), sw? 1 : 0);
	ImgViewThread->AddRequest(_T("RELOAD"));
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::GrayScaleActionUpdate(TObject *Sender)
{
	TAction *ap = (TAction*)Sender;
	ap->Visible = ScrMode==SCMD_IVIEW;
	ap->Enabled = ap->Visible && !isViewIcon && !isViewAGif && ImgScrollPanel->Visible;
	ap->Checked = ImgViewThread->GrayScaled;
}

//---------------------------------------------------------------------------
//次/前の画像ファイルを表示
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::NextPrevFileICore(bool is_next)
{
	if (usr_ARC->Busy || CurStt->is_FTP) return;
	if (MinShowTime>0 && !ImgViewThread->IsReady()) return;

	try {
		int idx = ViewFileList->IndexOf(ViewFileName);
		if (idx==-1) throw EAbort(VListMaking? LoadUsrMsg(USTR_ImgNotReady) : EmptyStr);

		int idx0 = -1, idx1 = -1, new_idx = -1;
		//次
		if (is_next) {
			if (IsDoubleStep() && !TEST_ActParam("F1")) {
				if (idx!=(ViewFileList->Count - 1)) {
					int max_idx = ViewFileList->Count - 2;
					new_idx = idx1 = (idx < max_idx)? idx + 2 : (idx==max_idx)? -1 : max_idx;
				}
			}
			else {
				for (int i=0; i<ViewFileList->Count && idx1==-1; i++) {
					if (i<=idx && idx0!=-1) continue;
					if (((file_rec*)ViewFileList->Objects[i])->failed) continue;
					((i<=idx)? idx0 : idx1) = i;
				}
				new_idx = (idx1!=-1)? idx1 : ((LoopViewCursor && !IsDoubleStep())? idx0 : -1);
			}
		}
		//前
		else {
			if (IsDoubleStep() && !TEST_ActParam("F1")) {
				new_idx = idx1 = (idx>=2)? idx - 2 : (idx==0)? -1 : 0;
			}
			else {
				for (int i=ViewFileList->Count-1; i>=0 && idx1==-1; i--) {
					if (i>=idx && idx0!=-1) continue;
					if (((file_rec*)ViewFileList->Objects[i])->failed) continue;
					((i>=idx)? idx0 : idx1) = i;
				}
				new_idx = (idx1!=-1)? idx1 : ((LoopViewCursor && !IsDoubleStep())? idx0 : -1);
			}
		}

		if (HintTopEndImg && (!isLoopHint || !LoopViewCursor) && idx1==-1) {
			ShowMessageHint(is_next? _T("最後の画像") : _T("先頭の画像"), col_bgHint, BeepTopEndImg, false, true);
			isLoopHint = true;
			ClearKeyBuff();
		}
		else {
			isLoopHint = false;
			if		(new_idx==-1) ImgViewThread->AddRequest(_T("REDRAW"));
			else if (!OpenImgViewer(new_idx)) Abort();
		}
	}
	catch (EAbort &e) {
		SetActionAbort(e.Message);
	}
}
//---------------------------------------------------------------------------
//次の画像ファイルを表示
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::NextFileActionExecute(TObject *Sender)
{
	NextPrevFileICore(true);
}
//---------------------------------------------------------------------------
//前の画像ファイルを表示
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::PrevFileActionExecute(TObject *Sender)
{
	NextPrevFileICore(false);
}

//---------------------------------------------------------------------------
//次ページに移動
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::NextPageActionExecute(TObject *Sender)
{
	if (usr_ARC->Busy || CurStt->is_FTP) return;

	try {
		int idx = ViewFileList->IndexOf(ViewFileName);	if (idx==-1) Abort();
		bool is_end = (idx==ViewFileList->Count-1);
		TStringGrid *gp = ThumbnailGrid;
		idx += ThumbExtended ? gp->ColCount
							 : (ThumbnailPos<2)? gp->VisibleColCount : gp->VisibleRowCount;
		set_GridIndex(gp, idx, ViewFileList->Count);
		if (!OpenImgViewer(get_GridIndex(gp, ViewFileList->Count))) Abort();
		if (HintTopEndImg && is_end) {
			ShowMessageHint(_T("最後のページ"), col_bgHint, BeepTopEndImg, false, true);
			ClearKeyBuff();
		}
	}
	catch (EAbort &e) {
		SetActionAbort(e.Message);
	}
}

//---------------------------------------------------------------------------
//見開き表示の綴じ方向を変更
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::PageBindActionExecute(TObject *Sender)
{
	RightBind = TEST_ActParam("R")? true : TEST_ActParam("L")? false : !RightBind;

	SetViewFileIdx();
	ClearViewImage();
	if (!OpenImgViewer(GetCurIndex())) SetActionAbort();
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::PageBindActionUpdate(TObject *Sender)
{
	TAction *ap = (TAction*)Sender;
	ap->Visible = ScrMode==SCMD_IVIEW;
	ap->Enabled = ap->Visible;
	ap->Caption = RightBind? "左綴じに変更" : "右綴じに変更";
}

//---------------------------------------------------------------------------
//サムネイル全面表示で1ページ上に移動
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::PageUpIActionExecute(TObject *Sender)
{
	TStringGrid *gp = ThumbnailGrid;
	gp->Row = std::max(gp->Row - gp->VisibleRowCount, 0);
}
//---------------------------------------------------------------------------
//サムネイル全面表示で1ページ下に移動
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::PageDownIActionExecute(TObject *Sender)
{
	TStringGrid *gp = ThumbnailGrid;
	set_GridIndex(gp, GetCurIndex() + gp->VisibleRowCount * gp->RowCount, ViewFileList->Count);
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::PageIxActionUpdate(TObject *Sender)
{
	TAction *ap = (TAction*)Sender;
	ap->Visible = ScrMode==SCMD_IVIEW;
	ap->Enabled = ap->Visible && ThumbnailGrid->Visible && ThumbExtended && ViewFileList->Count>0;
}

//---------------------------------------------------------------------------
//前ページに移動
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::PrevPageActionExecute(TObject *Sender)
{
	if (usr_ARC->Busy || CurStt->is_FTP) return;

	try {
		int idx = ViewFileList->IndexOf(ViewFileName);	if (idx==-1) Abort();
		bool is_top = (idx==0);
		TStringGrid *gp = ThumbnailGrid;
		idx -= ThumbExtended ? gp->ColCount
							 : (ThumbnailPos<2)? gp->VisibleColCount : gp->VisibleRowCount;
		set_GridIndex(gp, idx, ViewFileList->Count);
		if (!OpenImgViewer(get_GridIndex(gp, ViewFileList->Count))) Abort();
		if (HintTopEndImg && is_top) {
			ShowMessageHint(_T("最初のページ"), col_bgHint, BeepTopEndImg, false, true);
			ClearKeyBuff();
		}
	}
	catch (EAbort &e) {
		SetActionAbort(e.Message);
	}
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::PageIActionUpdate(TObject *Sender)
{
	TAction *ap = (TAction*)Sender;
	ap->Visible = ScrMode==SCMD_IVIEW;
	ap->Enabled = ap->Visible && ThumbnailGrid->Visible && ViewFileList->Count>0;
}


//---------------------------------------------------------------------------
//画像の印刷
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::PrintActionExecute(TObject *Sender)
{
	try {
		if (Printer()->Printers->Count==0) SysErrAbort(ERROR_PRINTER_NOT_FOUND);
		if (isViewIcon || isViewAGif) UserAbort(USTR_OpeNotSuported);

		if (!PrintImgDlg) PrintImgDlg = new TPrintImgDlg(this);	//初回に動的作成
		PrintImgDlg->FileRec = GetCurFrecPtr();
		PrintImgDlg->ShowModal();
	}
	catch (EAbort &e) {
		SetActionAbort(e.Message);
	}
}

//---------------------------------------------------------------------------
//画像を左に90度回転
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::RotateLeftActionExecute(TObject *Sender)
{
	ImgViewThread->AddRequest(_T("ROTATION"), 3);
	ImgViewThread->AddRequest(_T("RELOAD"));
}
//---------------------------------------------------------------------------
//画像を右に90度回転
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::RotateRightActionExecute(TObject *Sender)
{
	ImgViewThread->AddRequest(_T("ROTATION"), 1);
	ImgViewThread->AddRequest(_T("RELOAD"));
}
//---------------------------------------------------------------------------
//画像を左右反転
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::FlipHorzActionExecute(TObject *Sender)
{
	ImgViewThread->AddRequest(_T("ROTATION"), 4);
	ImgViewThread->AddRequest(_T("RELOAD"));
}
//---------------------------------------------------------------------------
//画像を上下反転
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::FlipVertActionExecute(TObject *Sender)
{
	ImgViewThread->AddRequest(_T("ROTATION"), 5);
	ImgViewThread->AddRequest(_T("RELOAD"));
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::RotateActionUpdate(TObject *Sender)
{
	TAction *ap = (TAction*)Sender;
	ap->Visible = ScrMode==SCMD_IVIEW;
	ap->Enabled = ap->Visible && !isViewIcon && !isViewAGif && ImgScrollPanel->Visible && (ViewFileList->Count>0 || isViewClip);
}

//---------------------------------------------------------------------------
//全画面表示
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::SetFullScreen(
	bool full_sw,
	bool redraw)	//フィット再描画	(default = true)
{
	int idx = ViewFileList->IndexOf(ViewFileName);

	//全画面表示へ
	if (!IS_FullScr() && full_sw) {
		OrgWinState = WindowState;
		OrgWinRect  = BoundsRect;
		BorderStyle = bsNone;

		Menu = NULL;
		ToolBarI->Visible	   = false;
		ToolBarI2->Visible	   = false;
		ImgSidePanel->Visible  = false;
		ImgSttHeader->Visible  = false;
		ImgSideSplitter->Width = 0;
		SeekPanel->Visible	   = false;
		FKeyBar->Visible	   = false;
		StatusBar1->Visible    = false;

		WindowState = wsNormal;
		BoundsRect	= Application->MainForm->Monitor->BoundsRect;
		Screen->Cursor = HideCsrInFull? crNone : crDefault;

		nrmThumbnail = ThumbnailGrid->Visible;
		if (HideThumbInFull)
			ThumbnailGrid->Visible = false;
		else
			SetupThumbnail(idx);

		//イベント: イメージビュアーで全画面表示にした時
		ExeEventCommand(OnFullScr);
	}
	//通常表示へ
	else if (IS_FullScr() && !full_sw) {
		WindowState = OrgWinState;
		BoundsRect  = OrgWinRect;
		BorderStyle = bsSizeable;

		Menu = ShowMainMenu? MainMenu1 : NULL;
		ToolBarI2->Visible	   = ShowToolBarI && ShowImgSidebar && ToolBarISide;
		ToolBarI->Visible	   = ShowToolBarI && !ToolBarI2->Visible;
		ImgSidePanel->Visible  = ShowImgSidebar;
		ImgSttHeader->Visible  = !ImgSidePanel->Visible;
		ImgSideSplitter->Width = ImgSidePanel->Visible? SplitterWidth : 0;
		SeekPanel->Visible	   = ShowSeekBar;
		FKeyBar->Visible	   = ShowFKeyBar;
		StatusBar1->Visible    = ShowSttBar;
		Screen->Cursor		   = crDefault;

		ThumbnailGrid->Visible = nrmThumbnail;
		SetupThumbnail(idx);

		//イベント: イメージビュアーで通常表示に戻った時
		ExeEventCommand(OnNormScr);
	}

	if (redraw) FittedSizeAction->Execute();
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::FullScreenActionExecute(TObject *Sender)
{
	SetFullScreen(TEST_ActParam("ON")? true : TEST_ActParam("OFF")? false : !IS_FullScr());
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::FullScreenActionUpdate(TObject *Sender)
{
	TAction *ap = (TAction*)Sender;
	ap->Visible = ScrMode==SCMD_IVIEW;
	ap->Enabled = ap->Visible;
	ap->Checked = IS_FullScr();
}

//---------------------------------------------------------------------------
//画像のスクロール
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ScrollUpIActionExecute(TObject *Sender)
{
	ImgScrollBox->VertScrollBar->Position -= ImgScrollBox->VertScrollBar->Increment;
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ScrollDownIActionExecute(TObject *Sender)
{
	ImgScrollBox->VertScrollBar->Position += ImgScrollBox->VertScrollBar->Increment;
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ScrollLeftActionExecute(TObject *Sender)
{
	ImgScrollBox->HorzScrollBar->Position -= ImgScrollBox->HorzScrollBar->Increment;
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ScrollRightActionExecute(TObject *Sender)
{
	ImgScrollBox->HorzScrollBar->Position += ImgScrollBox->HorzScrollBar->Increment;
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ScrollActionUpdate(TObject *Sender)
{
	((TAction*)Sender)->Enabled = ScrMode==SCMD_IVIEW && ImgScrollPanel->Visible;
}

//---------------------------------------------------------------------------
//ソートダイアログ
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::SortDlgIActionExecute(TObject *Sender)
{
	bool ok = false;
	int idx = ViewFileList->IndexOf(ViewFileName);
	UnicodeString cur_fnam = (idx!=-1)? ViewFileList->Strings[idx] : EmptyStr;

	//パラメータで即変更
	if (!ActionParam.IsEmpty()) {
		int idx = SortIdStr.Pos(ActionParam[1]);
		if (idx>0) {
			idx--;
			SortMode[CurListTag] = idx;
			if (SortBoth || IsDiffList()) SortMode[OppListTag] = idx;
			ok = true;
		}
	}
	//ダイアログ
	else {
		if (!SortModeDlg) SortModeDlg = new TSortModeDlg(this);	//初回に動的作成
		ok = (SortModeDlg->ShowModal()==mrOk);
	}
	//ソート
	if (ok) {
		SortList(ViewFileList);
		set_GridIndex(ThumbnailGrid, ViewFileList->IndexOf(cur_fnam), ViewFileList->Count);
	}
}

//---------------------------------------------------------------------------
//グリッドの表示
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ShowGridActionExecute(TObject *Sender)
{
	bool sw = ImgViewThread->ShowGrid;
	SetToggleAction(sw);
	ImgViewThread->AddRequest(_T("GRID"), sw? 1 : 0);
	ImgViewThread->AddRequest(_T("REDRAW"));
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ShowGridActionUpdate(TObject *Sender)
{
	TAction *ap = (TAction*)Sender;
	ap->Visible = ScrMode==SCMD_IVIEW;
	ap->Enabled = ap->Visible && !isViewIcon && !isViewAGif && ImgScrollPanel->Visible;
	ap->Checked = ImgViewThread->ShowGrid;
}

//---------------------------------------------------------------------------
//シークバーの表示
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ShowSeekBarActionExecute(TObject *Sender)
{
	SeekPanel->Visible = SetToggleAction(ShowSeekBar);
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ShowSeekBarActionUpdate(TObject *Sender)
{
	TAction *ap = (TAction*)Sender;
	ap->Visible = ScrMode==SCMD_IVIEW;
	ap->Enabled = ap->Visible && !IS_FullScr();
	ap->Checked = ShowSeekBar;
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::SeekBarChange(TObject *Sender)
{
	if (InhSeekBar>0) return;

	int idx = abs(SeekBar->Position);
	InhSeekBar++;
	{
		if (IsDoubleStep()) {
			if ((IsEvenPage && idx%2==1) || (!IsEvenPage && idx%2==0)) {
				idx++;
				SeekBar->Position = (SeekBar->Min<0)? -idx : idx;
			}
		}
	}
	InhSeekBar--;
	set_GridIndex(ThumbnailGrid, idx, ViewFileList->Count);
}

//---------------------------------------------------------------------------
//ワークリストに送る
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::SendToWorkListActionExecute(TObject *Sender)
{
	try {
		if (isViewWork) Abort();
		if (WorkListFiltered) UserAbort(USTR_WorkFiltered);

		int sel_cnt = GetSelCount(ViewFileList);
		int snd_cnt = 0;
		UnicodeString msg;
		if (sel_cnt>0) {
			if (msgbox_Sure(_T("選択項目を登録しますか?"), SureCopy)) {
				for (int i=0; i<ViewFileList->Count; i++) {
					file_rec *fp = (file_rec*)ViewFileList->Objects[i];
					if (!fp->selected) continue;
					if (WorkList->IndexOf(fp->f_name)!=-1) continue;
					fp->selected = false;
					file_rec *lfp = cre_new_file_rec(fp);
					WorkList->AddObject(lfp->f_name, (TObject*)lfp);
					snd_cnt++;
				}
			}
		}
		else {
			file_rec *vfp = GetCurFrecPtr();
			if (!vfp || vfp->failed) Abort();
			if (WorkList->IndexOf(vfp->f_name)!=-1) UserAbort(USTR_Registered);
			if (msgbox_Sure(get_DispName(vfp) + " を登録しますか?", SureCopy)) {
				file_rec *lfp = cre_new_file_rec(vfp);
				WorkList->AddObject(lfp->f_name, (TObject*)lfp);
				snd_cnt++;
			}
		}
		ThumbnailGrid->Repaint();
		if (snd_cnt>0) {
			rqWorkListDirInf = !WorkListChanged;
			WorkListChanged  = true;
			ShowHintAndStatus(msg.sprintf(_T("%u個のファイルをワークリストに送りました。"), snd_cnt));
		}
	}
	catch (EAbort &e) {
		SetActionAbort(e.Message);
	}
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::SendToWorkListActionUpdate(TObject *Sender)
{
	TAction *ap = (TAction*)Sender;
	ap->Visible = ScrMode==SCMD_IVIEW;
	ap->Enabled = ap->Visible && !isViewClip && !isViewFTP;
}

//---------------------------------------------------------------------------
//サイドバーを表示
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::SidebarActionExecute(TObject *Sender)
{
	SetToggleAction(ShowImgSidebar);
	SetupDesign(false);

	if (ShowImgSidebar) {
		int idx = ViewFileList->IndexOf(ViewFileName);
		file_rec *vfp = (idx!=-1)? (file_rec*)ViewFileList->Objects[idx] : NULL;
		SetImgInfListBox(vfp);
	}

	//サイドバー非表示の場合のルーペ/ヒストグラム移動スムーズ化のための処理
	LoupeForm->DragKind = ShowImgSidebar? dkDock : dkDrag;
	LoupeForm->DragMode = ShowImgSidebar? dmAutomatic : dmManual;
	HistForm->DragKind	= ShowImgSidebar? dkDock : dkDrag;
	HistForm->DragMode	= ShowImgSidebar? dmAutomatic : dmManual;
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::SidebarActionUpdate(TObject *Sender)
{
	TAction *ap = (TAction*)Sender;
	ap->Visible = ScrMode==SCMD_IVIEW;
	ap->Enabled = ap->Visible && !IS_FullScr();
	ap->Checked = ImgSidePanel->Visible;
}

//---------------------------------------------------------------------------
//サブビュアーの表示
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::SubViewerActionExecute(TObject *Sender)
{
	if (SubViewer->Visible) {
		if (TEST_ActParam("OFF") || ActionParam.IsEmpty()) {
			if (ScrMode==SCMD_IVIEW) ShowSubViewer = false;
			SubViewer->Visible = false;
		}
		else {
			if (TEST_ActParam("CB")) {
				SubViewer->isClip = true;
				SubViewer->DrawImage();
			}

			if (TEST_ActParam("RL")) SubViewer->RotateImage(3);
			if (TEST_ActParam("RR")) SubViewer->RotateImage(1);
			if (TEST_ActParam("FH")) SubViewer->RotateImage(4);
			if (TEST_ActParam("FV")) SubViewer->RotateImage(5);
			if (TEST_ActParam("LK")) SubViewer->LockImage();
			SetFocus();
		}
	}
	else {
		SubViewer->Visible = (ScrMode==SCMD_IVIEW)? SetToggleAction(ShowSubViewer) : !SubViewer->Visible;
		//非表示->表示
		if (SubViewer->Visible) {
			SubViewer->isClip	 = TEST_ActParam("CB");
			SubViewer->ImgLocked = false;
			UnicodeString fnam;
			if (!SubViewer->isClip) {
				if (ScrMode==SCMD_IVIEW) {
					fnam = ViewFileName;
				}
				else {
					fnam = EmptyStr;
					file_rec *cfp = GetCurFrecPtr(true);
					if (cfp && !cfp->is_ftp  && !cfp->is_dir) {
						if (!test_FileExt(cfp->f_ext, FExtNoIView) && (is_Viewable(cfp) || test_Mp3Ext(cfp->f_ext)))
							fnam = cfp->f_name;
					}
				}
			}
			SubViewer->DrawImage(fnam);

			if (TEST_ActParam("LK")) SubViewer->ImgLocked = true;
			SetFocus();
		}
	}
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::SubViewerActionUpdate(TObject *Sender)
{
	TAction *ap = (TAction*)Sender;
	ap->Visible = (ScrMode==SCMD_FLIST || ScrMode==SCMD_IVIEW);
	ap->Enabled = ap->Visible;
	ap->Checked = SubViewer->Visible;
}

//---------------------------------------------------------------------------
//サムネイルの表示
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ThumbnailActionExecute(TObject *Sender)
{
	file_rec *vfp = NULL;
	int idx = ViewFileList->IndexOf(ViewFileName);
	if (idx!=-1) {
		SetCurFrecPtr(GetFrecPtrFromViewList(idx));
		vfp = (file_rec*)ViewFileList->Objects[idx];
	}

	TStringGrid *gp = ThumbnailGrid;
	bool sw = gp->Visible;
	gp->Visible = SetToggleAction(sw);
	if (IS_FullScr()) nrmThumbnail = gp->Visible;

	ImgScrollPanel->Visible = gp->Visible? !ThumbExtended : true;

	if (gp->Visible) SetViewFileList(false, true); else OpenImgViewer(vfp);

	if (vfp && !KeepZoomRatio) FittedSizeAction->Execute();
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ThumbnailActionUpdate(TObject *Sender)
{
	TAction *ap = (TAction*)Sender;
	ap->Visible = ScrMode==SCMD_IVIEW;
	ap->Enabled = ap->Visible && !isViewClip && !isViewFTP;
	ap->Checked = ThumbnailGrid->Visible;
}
//---------------------------------------------------------------------------
//サムネイルの全面表示
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ThumbnailExActionExecute(TObject *Sender)
{
	SetToggleAction(ThumbExtended);

	ImgScrollPanel->Visible = !ThumbExtended;

	LoupeForm->DrawImage();

	int idx = ViewFileList->IndexOf(ViewFileName);
	SetupThumbnail(idx);

	if (idx!=-1) {
		file_rec *cfp = GetFrecPtrFromViewList(idx);
		SetCurFrecPtr(cfp);
		file_rec *vfp = (file_rec*)ViewFileList->Objects[idx];
		if (!ThumbExtended) OpenImgViewer(vfp); else SetSttBarInf(vfp);
	}
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ThumbnailExActionUpdate(TObject *Sender)
{
	TAction *ap = (TAction*)Sender;
	ap->Visible = ScrMode==SCMD_IVIEW;
	ap->Enabled = ap->Visible && ThumbnailGrid->Visible;
	ap->Checked = ThumbExtended;
}

//---------------------------------------------------------------------------
//先頭ファイルに移動
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::TopFileActionExecute(TObject *Sender)
{
	int new_idx = -1;
	for (int i=0; i<ViewFileList->Count; i++) {
		if (!((file_rec*)ViewFileList->Objects[i])->failed) { new_idx = i; break; }
	}
	if (!OpenImgViewer(new_idx)) SetActionAbort();
}

//---------------------------------------------------------------------------
//白飛び警告
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::WarnHighlightActionExecute(TObject *Sender)
{
	BlinkTimer->Enabled = SetToggleAction(WarnHighlight);
	if (!WarnHighlight) ImgViewThread->AddRequest(_T("REDRAW"));
	ImgSttHeader->Repaint();
	ImgInfBar->Repaint();
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::WarnHighlightActionUpdate(TObject *Sender)
{
	TAction *ap = (TAction*)Sender;
	ap->Visible = ScrMode==SCMD_IVIEW;
	ap->Enabled = ap->Visible && ImgScrollPanel->Visible;
	ap->Checked = WarnHighlight;
}

//---------------------------------------------------------------------------
//イメージビュアーにワークリストを表示/カレントに戻す
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::WorkListIActionExecute(TObject *Sender)
{
	//インデックスエラーの回避
	InhDrawImg++; {
		TStringGrid *gp = ThumbnailGrid;
		gp->Col = 0; gp->Row = 0; gp->Repaint();
	} InhDrawImg--;

	isViewWork = !isViewWork;
	SetViewFileList(true, true);

	if (get_ViewCount()==0) SetActionAbort(USTR_NoObject);
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::WorkListIActionUpdate(TObject *Sender)
{
	TAction *ap = (TAction*)Sender;
	ap->Visible = ScrMode==SCMD_IVIEW;
	ap->Enabled = ap->Visible && !CurStt->is_Work;
}

//---------------------------------------------------------------------------
//ズームイン
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ZoomInIActionExecute(TObject *Sender)
{
	int z = ImgViewThread->ZoomRatio;
	bool z_over = false;
	int z_cnt = ZoomRatioList->Count;
	if (z_cnt>0) {
		for (int i=0; i<z_cnt; i++) {
			int r = ZoomRatioList->Strings[i].ToIntDef(100);
			if (z<r) { z = r;	break; }
			if (i==z_cnt-1 && z>=r) z_over = true;
		}
	}
	if (!z_over) {
		LastZoomRatio = z;
		ImgViewThread->AddRequest(_T("ZOOM"),   z);
		ImgViewThread->AddRequest(_T("FITTED"), 0);
		WaitForImgReady(true);
	}
}
//---------------------------------------------------------------------------
//ズームアウト
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ZoomOutIActionExecute(TObject *Sender)
{
	int z = ImgViewThread->ZoomRatio;
	bool z_over = false;
	int z_cnt = ZoomRatioList->Count;
	if (z_cnt>0) {
		for (int i=z_cnt-1; i>=0; i--) {
			int r = ZoomRatioList->Strings[i].ToIntDef(100);
			if (z>r) { z = r;	break; }
			if (i==0 && z<=r) z_over = true;
		}
	}
	if (!z_over) {
		LastZoomRatio = z;
		ImgViewThread->AddRequest(_T("ZOOM"),   z);
		ImgViewThread->AddRequest(_T("FITTED"), 0);
		WaitForImgReady(true);
	}
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ZoomIActionUpdate(TObject *Sender)
{
	TAction *ap = (TAction*)Sender;
	ap->Visible = ScrMode==SCMD_IVIEW;
	ap->Enabled = ap->Visible && !isViewIcon && !isViewAGif && ImgScrollPanel->Visible
					&& ImgViewThread->IsReady() && (ViewFileList->Count>0 || isViewClip);
}

//===========================================================================
//サムネイル
//===========================================================================
//---------------------------------------------------------------------------
//イメージビュアーのリストを設定/サムネイル作成要求
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::SetViewFileList(
	bool clr_thumb,		//リストをクリア	(default = true)
	bool draw_img)		//画像の描画		(default = false)
{
	//---------------------------------------
	//イメージビュアー用ファイルリストを作成
	//---------------------------------------
	//直前の選択状態を取得
	std::unique_ptr<TStringList> sel_lst(new TStringList());
	GetSelList(ViewFileList, sel_lst.get());

	//表示候補数を取得
	TStringList *lst = isViewWork? WorkList : GetCurList(true);
	int f_cnt = 0;
	for (int i=0; i<lst->Count; i++) {
		file_rec *fp = (file_rec*)lst->Objects[i];
		if (fp->is_dir || contains_Slash(fp->f_name) || fp->f_attr==faInvalid)	continue;
		if (test_FileExt(fp->f_ext, FExtNoIView))		continue;
		if (!is_Viewable(fp) && !is_ExtractIcon(fp))	continue;
		f_cnt++;
	}

	//グリッド初期化
	TStringGrid *gp = ThumbnailGrid;
	int l_col = gp->LeftCol;
	int t_row = gp->TopRow;
	gp->ColCount = 1;
	gp->RowCount = 1;
	//全面表示
	if (ThumbExtended) {
		gp->ColCount = f_cnt;
		gp->LeftCol  = 0;
		gp->ColCount = gp->VisibleColCount;
		gp->RowCount = f_cnt/gp->ColCount + ((f_cnt%gp->ColCount>0)? 1 : 0);
		gp->TopRow	 = t_row;
	}
	//通常表示(縦)
	else if (ThumbnailPos==2 || ThumbnailPos==3) {
		gp->RowCount = f_cnt;
		gp->TopRow	 = t_row;
	}
	//通常表示(横)
	else {
		gp->ColCount = f_cnt;
		gp->LeftCol  = l_col;
	}

	//リスト作成
	clear_FileList(ViewFileList);
	bool has_vir = false;
	try {
		VListMaking = true;
		for (int i=0; i<lst->Count; i++) {
			if (ScrMode!=SCMD_IVIEW) Abort();	//途中でビュアーが閉じられた
			file_rec *fp = (file_rec*)lst->Objects[i];
			if (fp->is_dir || contains_Slash(fp->f_name) || fp->f_attr==faInvalid)	continue;
			if (test_FileExt(fp->f_ext, FExtNoIView))		continue;
			if (!is_Viewable(fp) && !is_ExtractIcon(fp))	continue;
			UnicodeString fnam = fp->f_name;
			if (fp->is_virtual) {
				if (NotThumbIfArc) {
			 		if (!SetTmpFile(fp, true)) continue;
				}
				else if (!SetTmpFile(fp) || !file_exists(fp->tmp_name)) continue;
				fnam = fp->tmp_name;
				has_vir = true;
			}
			file_rec *vfp = cre_new_file_rec(fp);
			ViewFileList->AddObject(fnam, (TObject*)vfp);
		}
		VListMaking = false;
		SetViewFileIdx();
	}
	catch (EAbort &e) {
		VListMaking = false;
		ThumbnailThread->ReqClear = true;
		return;
	}

	SortList(ViewFileList);

	//選択状態を復元
	if (sel_lst->Count>0) {
		for (int i=0; i<ViewFileList->Count; i++) {
			file_rec *fp = (file_rec*)ViewFileList->Objects[i];
			fp->selected = (sel_lst->IndexOf(fp->f_name)!=-1);
		}
	}

	//シークバー設定
	int idx = ViewFileList->IndexOf(ViewFileName);
	InhSeekBar++;
	{
		IsEvenPage = (idx%2==0);
		SeekBar->Position = (SeekBar->Min<0)? -idx : idx;
	}
	InhSeekBar--;

	//状態表示
	UnicodeString sttstr;
	if (ViewFileList->Count>0) {
		sttstr.sprintf(_T("%3u/%3u"), idx + 1, ViewFileList->Count);
		int sel_cnt = GetSelCount(ViewFileList);
		if (sel_cnt>0) sttstr.cat_sprintf(_T(" (選択 %u)"), sel_cnt);
	}
	else {
		sttstr = "0/0";
	}
	ImgSttHeader->Panels->Items[4]->Text = sttstr;

	//---------------------------------------
	//画像の描画
	//---------------------------------------
	if (draw_img && !ThumbExtended) {
		if (get_ViewCount()>0) {
			file_rec *vfp = isViewWork? (file_rec*)ViewFileList->Objects[0] : GetCurFrecPtr(true);
			OpenImgViewer(vfp);
		}
		else {
			ImgViewThread->AddRequest(_T("CLEAR"));
		}
	}

	//---------------------------------------
	//サムネイル初期化
	//---------------------------------------
	if (clr_thumb) ThumbnailThread->ReqClear = true;
	if (!gp->Visible) return;

	set_GridIndex(gp, idx, ViewFileList->Count);

	//---------------------------------------
	//サムネイルリスト作成要求
	//---------------------------------------
	if (ThumbnailThread->IsEmpty && ViewFileList->Count>0) {
		while (ThumbnailThread->ReqClear) { Application->ProcessMessages();  Sleep(1); }
		//サムネイルリスト登録
		for (int i=0; i<ViewFileList->Count; i++) {
			Graphics::TBitmap *bp = new Graphics::TBitmap();
			ThumbnailThread->ThumbnailList->AddObject(ViewFileList->Strings[i], (TObject*)bp);
		}
		//サムネイル作成開始
		if (ViewFileList->Count>0) {
			if (idx==-1) idx = 0;
			set_GridIndex(gp, idx, ViewFileList->Count);
			if (!has_vir || !NotThumbIfArc) {
				ThumbnailThread->ReqStart  = true;
			}
			else {
				ThumbnailThread->MakeIndex = idx;
				ThumbnailThread->ReqMake   = true;
			}
		}
	}
}

//---------------------------------------------------------------------------
//デザイン/フォント・配色の適用
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::WmNyanfiAppearance(TMessage &msg)
{
	SetupFont();
	SetupDesign((bool)msg.WParam);
	Repaint();

	TxtViewer->SetColor();

	switch (ScrMode) {
	case SCMD_FLIST:
		SetCurStt(CurListTag);
		ReloadList();
		TxtPrvScrPanel->Repaint();
		InfScrPanel->Repaint();
		LogScrPanel->Repaint();
		break;
	case SCMD_TVIEW:
		TxtViewer->UpdateScr();
		break;
	}

	std::unique_ptr<TStringList> lst(new TStringList());
	get_ExViewerList(lst.get());
	for (int i=0; i<lst->Count; i++) {
		TExTxtViewer *ex_tv = dynamic_cast<TExTxtViewer *>(lst->Objects[i]);
		if (ex_tv) {
			ex_tv->ExViewer->SetColor();
			ex_tv->ExViewer->UpdateScr();
		}
	}
}

//---------------------------------------------------------------------------
//サムネイルの描画
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ThumbnailGridDrawCell(TObject *Sender, int ACol, int ARow,
		TRect &Rect, TGridDrawState State)
{
	if (ThumbnailThread->ReqClear) return;

	TStringGrid *gp = (TStringGrid*)Sender;
	TCanvas *cv = gp->Canvas;
	cv->Font->Assign(ListFont);
	cv->Font->Height = ScaledInt(12);
	int s_16 = ScaledInt(16);
	int s_14 = ScaledInt(14);

	if (VListMaking) {	//ViewFileList 作成中...
		cv->Brush->Color = col_bgImage;
		out_Text(cv, Rect.Left + 8, Rect.Top + 8, _T("準備中..."), col_Teal);
		return;
	}

	UnicodeString vfnam;
	try {
		int t_cnt = ThumbnailThread->Count;
		if (t_cnt==0) Abort();

		int v_idx = gp->ColCount * ARow + ACol;	if (v_idx>=ViewFileList->Count) Abort();
		file_rec *vfp = (file_rec*)ViewFileList->Objects[v_idx];
		vfnam = ViewFileList->Strings[v_idx];
		UnicodeString fext = get_extension(vfnam);
		bool is_forcus = gp->Col==ACol && gp->Row==ARow;
		bool is_marked = IniFile->IsMarked(vfp->r_name);

		//Exif情報を取得
		UnicodeString exif_inf;
		int t_idx = -1;
		for (int i=0; i<t_cnt; i++) {
			UnicodeString lbuf = ThumbnailThread->GetListItem(i);
			if (SameText(split_pre_tab(lbuf), vfnam)) {
				exif_inf = lbuf;
				t_idx = i; break;
			}
		}
		vfp->failed = (t_idx==-1);	//ThumbnailList にない場合、読み込みに失敗している

		//背景
		cv->Brush->Color = is_forcus?	  RatioCol(col_Cursor, 0.5) :
						   vfp->selected? col_selItem :
						   is_marked?	  col_bgMark  : col_bgImage;
		cv->FillRect(Rect);

		//ファイル名、Exif情報の背景を描画
		if (ShowThumbName || ShowThumbExif || ShowThumbTags) {
			cv->Brush->Color = is_marked? col_bgMark : vfp->selected? col_selItem : col_bgList;
			TRect rc = Rect;
			rc.Top = rc.Bottom;
			if (ShowThumbName) rc.Top -= s_16;
			if (ShowThumbExif) rc.Top -= s_16;
			if (ShowThumbTags) rc.Top -= s_16;
			cv->FillRect(rc);
		}

		//拡張子別カラーを取得
		TColor col_ext = get_ExtColor(fext);
		//ファイル名表示
		if (ShowThumbName) {
			UnicodeString tnam = minimize_str(ExtractFileName(vfnam), cv, ThumbnailSize - 4, true);
			int yp = Rect.Bottom - s_14;
			if (ShowThumbExif) yp -= s_14;
			if (ShowThumbTags) yp -= s_14;
			cv->Font->Color = vfp->failed? col_Error : col_ext;
			cv->TextOut(Rect.Left + ThumbnailSize - cv->TextWidth(tnam), yp, tnam);
		}

		//Exif情報表示
		if (ShowThumbExif) {
			UnicodeString inf_str;
			TStringDynArray i_lst = SplitString(exif_inf, " ");
			for (int i=0; i<i_lst.Length; i++) {
				if (cv->TextWidth(inf_str + i_lst[i]) > (ThumbnailSize - 4)) break;
				inf_str.cat_sprintf(_T("%s "), i_lst[i].c_str());
			}
			inf_str = Trim(inf_str);
			int wd = cv->TextWidth(inf_str);
				int yp = Rect.Bottom - s_14;
			if (ShowThumbTags) yp -= s_14;
			cv->Font->Color = col_ThumbExif;
			cv->TextOut(Rect.Left + ThumbnailSize - wd, yp, inf_str);
		}

		//タグ表示
		if (ShowThumbTags) {
			if (vfp->tags.IsEmpty()) vfp->tags = usr_TAG->GetTags(vfnam);
			if (!vfp->tags.IsEmpty())
				usr_TAG->DrawTags(vfp->tags, cv, Rect.Left + 4, Rect.Bottom - s_14,
					RevTagCololr? cv->Brush->Color : col_None);
		}

		//サムネイル表示
		if (!vfp->failed) {
			Graphics::TBitmap *bp = ThumbnailThread->GetListBitmap(t_idx);
			if (bp && !bp->Empty) {
				int xp = Rect.Left + (ThumbnailSize - bp->Width)/2 + 2;
				int yp = Rect.Top  + (ThumbnailSize - bp->Height)/2 + 2;
				cv->Draw(xp, yp, bp);
				//拡張子強調表示
				if (ShowThumbFExt) {
					cv->Pen->Width	 = 1;
					cv->Pen->Style	 = psSolid;
					cv->Pen->Color	 = col_ext;
					cv->MoveTo(Rect.Left + 2, Rect.Top + 2);
					cv->LineTo(Rect.Left + 2, Rect.Top + cv->Font->Height + 2);
					cv->Brush->Color = col_ext;
					cv->Font->Color  = col_bgList;
					cv->Font->Style  = (cv->Font->Style << fsBold);
					fext.Delete(1, 1);
					cv->TextOut(Rect.Left + 3, Rect.Top + 2, fext.UpperCase());
				}
			}
			else {
				cv->Brush->Color = col_bgImage;
				out_Text(cv, Rect.Left + 8, Rect.Top + 8,
					(vfp->is_virtual && NotThumbIfArc)? _T("未取得") : _T("読込中..."), col_Teal);
			}
		}
		//読み込み失敗
		else {
			cv->Brush->Color = col_bgImage;
			out_Text(cv, Rect.Left + 8, Rect.Top + 8, _T("読込失敗"), col_Error);
		}
	}
	catch (EAbort &e) {
		cv->Brush->Color = col_bgList;
		cv->FillRect(Rect);
	}

	//カーソル枠
	cv->Brush->Style = bsClear;
	if ((gp->Col==ACol && gp->Row==ARow) || (DoublePage && !ThumbExtended && !vfnam.IsEmpty() && SameText(vfnam, ViewFileName2))) {
		cv->Pen->Width = Scaled2;
		cv->Pen->Style = psSolid;
		cv->Pen->Color = col_Cursor;
		cv->Rectangle(Rect.Left + 1, Rect.Top + 1, Rect.Right, Rect.Bottom);
	}

	//境界線
	int dw = gp->GridLineWidth/2;
	cv->Pen->Width = gp->GridLineWidth;
	cv->Pen->Style = psSolid;
	cv->Pen->Color = col_bdrThumb;
	cv->Rectangle(Rect.Left - dw - 1, Rect.Top - dw - 1, Rect.Right + dw + 1, Rect.Bottom + dw + 1);
}

//---------------------------------------------------------------------------
//サムネイル上のキー操作
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ThumbnailGridKeyDown(TObject *Sender, WORD &Key, TShiftState Shift)
{
	FormKeyDown(Sender, Key, Shift);
}

//---------------------------------------------------------------------------
//サムネイル上のマウス操作
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ThumbnailGridClick(TObject *Sender)
{
	CancelKeySeq();
	if (InhDrawImg>0 || usr_ARC->Busy) return;

	OpenImgViewer(get_GridIndex(ThumbnailGrid, ViewFileList->Count));
	SetViewFileIdx();
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ThumbnailGridSelectCell(TObject *Sender, int ACol, int ARow,
		bool &CanSelect)
{
	CanSelect = (ViewFileList->Count>0) ? ((ARow * ThumbnailGrid->ColCount + ACol) < ViewFileList->Count)
										: (ARow==0 && ACol==0);
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ThumbnailGridMouseDown(TObject *Sender, TMouseButton Button, TShiftState Shift, int X, int Y)
{
	//サムネイルがクリックされているか？
	int col, row;
	ThumbnailGrid->MouseToCell(X, Y, col, row);
	int idx = (col!=-1 && row!=-1)? (ThumbnailGrid->ColCount * row) + col : -1;
	if (idx>=ViewFileList->Count) idx = -1;
	ThumbClicked = (idx!=-1);

	MoveCnt = 1;
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ThumbnailGridMouseMove(TObject *Sender, TShiftState Shift,
	int X, int Y)
{
	if ((!Shift.Contains(ssLeft) && !Shift.Contains(ssRight))) { DragStartTag = -1;  return; }

	if (MoveCnt==0 || ++MoveCnt<6) return;	//***
	MoveCnt = 0;

	try {
		if (!ThumbClicked  || isViewWork || ExeCmdsBusy) Abort();

		//ドラッグ対象のリストを作成
		std::unique_ptr<TStringList> flst(new TStringList());
		UnicodeString dnam;
		//選択中
		for (int i=0; i<ViewFileList->Count; i++) {
			file_rec *fp = (file_rec*)ViewFileList->Objects[i];
			if (fp->is_virtual) Abort();
			if (!fp->selected) continue;
			if (dnam.IsEmpty())
				dnam = fp->p_name;
			else if (!SameText(dnam, fp->p_name))
				Abort();
			flst->Add(fp->n_name);
		}
		//無ければカーソル位置
		if (flst->Count==0) {
			file_rec *cfp = GetCurFrecPtr();
			if (cfp) {
				dnam = cfp->p_name;
				flst->Add(cfp->n_name);
			}
		}

		if (dnam.IsEmpty() || flst->Count==0) Abort();

		//イベント: サムネイルからドラッグ開始時
		ExeEventCommand(OnDragStartI);

		DragStartTag = 2;
		usr_SH->DoFilesDragDrop(dnam, flst.get(), 2);

		//イベント: サムネイルからドラッグ完了時
		ExeEventCommand(OnDragEndI);
	}
	catch (EAbort &e) {
		DragStartTag = -1;
	}
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ThumbnailGridMouseUp(TObject *Sender, TMouseButton Button,
	TShiftState Shift, int X, int Y)
{
	MoveCnt 	 = 0;
	DragStartTag = -1;
}

//---------------------------------------------------------------------------
//サイドバーの位置
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::IV_SidebarPosActionExecute(TObject *Sender)
{
	SidebarPos0Item->Checked = ImgSidebarIsLeft;
	SidebarPos1Item->Checked = !ImgSidebarIsLeft;
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::IV_SidebarPosActionUpdate(TObject *Sender)
{
	TAction *ap = (TAction*)Sender;
	ap->Visible = ScrMode==SCMD_IVIEW;
	ap->Enabled = ap->Visible && ImgSidePanel->Visible;
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::SidebarPosItemClick(TObject *Sender)
{
	ImgSidebarIsLeft = (((TMenuItem*)Sender)->Tag==0);
	SetupDesign(false);
}

//---------------------------------------------------------------------------
//サムネイルの位置
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::IV_ThumbPosActionExecute(TObject *Sender)
{
	ThumbPos0Item->Checked = (ThumbnailPos==0);
	ThumbPos1Item->Checked = (ThumbnailPos==1);
	ThumbPos2Item->Checked = (ThumbnailPos==2);
	ThumbPos3Item->Checked = (ThumbnailPos==3);
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::IV_ThumbPosActionUpdate(TObject *Sender)
{
	TAction *ap = (TAction*)Sender;
	ap->Visible = ScrMode==SCMD_IVIEW;
	ap->Enabled = ap->Visible && ThumbnailGrid->Visible;
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ThumbPosItemClick(TObject *Sender)
{
	ThumbnailPos = ((TMenuItem*)Sender)->Tag;
	SetupDesign(false);
}

//---------------------------------------------------------------------------
//プレビュー画像を元サイズでコピー
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::CopyPreImgOrgActionExecute(TObject *Sender)
{
	copy_to_Clipboard(ImgBuff);
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::CopyPreImgOrgActionUpdate(TObject *Sender)
{
	((TAction*)Sender)->Enabled = (ImgViewThread->IsReady() && !ImgBuff->Empty);
}
//---------------------------------------------------------------------------
//プレビュー画像を表示サイズでコピー
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::CopyPreImgActionExecute(TObject *Sender)
{
	copy_to_Clipboard(PreviewImage->Picture->Bitmap);
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::CopyPreImgActionUpdate(TObject *Sender)
{
	((TAction*)Sender)->Enabled = (ImgViewThread->IsReady() && !PreviewImage->Picture->Bitmap->Empty);
}

//---------------------------------------------------------------------------
// プレビュー画面のサイズ変更表示
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ShowPreviewSize(int wd, int hi)
{
	TLabel *lp = PreviewSizeLabel;
	lp->Font->Color = col_Error;
	lp->Caption = get_wd_x_hi_str(wd, hi);
	lp->Top 	= PreviewPanel->ClientHeight/2 - 10;
	lp->Left	= (PreviewPanel->ClientWidth - lp->Width)/2;
	lp->Visible = true;
	lp->Invalidate();
	MsgHintTimer->Interval = MsgHintTime;
	MsgHintTimer->Enabled  = true;
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ImgInfSplitterCanResize(TObject *Sender, int &NewSize, bool &Accept)
{
	int wd = PreviewPanel->ClientWidth;
	int hi = PreviewPanel->ClientHeight;
	if (((TSplitter*)Sender)->Align == alLeft) wd = NewSize; else hi = NewSize;
	ShowPreviewSize(wd, hi);
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ListSubSplitterCanResize(TObject *Sender, int &NewSize, bool &Accept)
{
	int wd = PreviewPanel->ClientWidth;
	int hi = PreviewPanel->ClientHeight;
	if (((TSplitter*)Sender)->Align == alBottom) hi = NewSize; else wd = NewSize;
	ShowPreviewSize(wd, hi);
}
//---------------------------------------------------------------------------
//サイドパネルにドッキング
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ImgSidePanelDockDrop(TObject *Sender, TDragDockObject *Source, int X, int Y)
{
	TPoint p = SideInfPanel->ScreenToClient(ImgSidePanel->ClientToScreen(Point(X, Y)));
	bool is_top = (p.y < SideInfPanel->Height/2);
	if (Source->Control==LoupeForm)
		DockSideCtrl(LoupeForm, LoupeDockPanel, is_top);
	else if (Source->Control==HistForm)
		DockSideCtrl(HistForm, HistDockPanel,  is_top);
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::DockSideCtrl(TControl *cp, TPanel *pp, bool is_top)
{
	set_PanelAlign(SideDockPanel, SideDockSplitter, is_top? alTop : alBottom, SplitterWidth2);
	pp->DockSite = true;
	cp->ManualDock(pp, NULL, alClient);
	SideDockSplitter->Height = (LoupeForm->Visible && !LoupeForm->Floating)? SplitterWidth2 : 0;
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::SidePanelDockDrop(TObject *Sender, TDragDockObject *Source, int X, int Y)
{
	int dh = LoupeDockPanel->Height + HistDockPanel->Height;  if (dh<4) dh = 0;
	if (Source->Control==LoupeForm) {
		LoupeDockPanel->Constraints->MinHeight = MINHI_LOUPE;
		LoupeDockPanel->Constraints->MaxHeight = 0;
		dh += IniFile->ReadIntGen(_T("LoupeHeight"),	200);
	}
	else if (Source->Control==HistForm) {
		HistForm->BorderWidth = 2;
		HistDockPanel->Constraints->MinHeight = CLHI_HISTOGRAM;
		HistDockPanel->Constraints->MaxHeight = CLHI_HISTOGRAM;
		HistDockPanel->Height = CLHI_HISTOGRAM;
		dh += CLHI_HISTOGRAM;
	}
	SideDockPanel->Height = dh;
	if (((TPanel*)Sender)->DockManager) ((TPanel*)Sender)->DockManager->ResetBounds(true);

	//※ヒストグラムだけだと正しく表示されない現象への対処
	if (Initialized && Source->Control==HistForm && (!LoupeForm->Visible || LoupeForm->Floating)) {
		HistogramAction->Execute();
		HistogramAction->Execute();
	}

	ImgViewThread->AddRequest(_T("REDRAW"));
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::SideDockPanelDockOver(TObject *Sender, TDragDockObject *Source,
	int X, int Y, TDragState State, bool &Accept)
{
	Accept = false;

	//移動範囲を制限してマウスカーソルをそらす
	TRect rc = SideInfPanel->ClientRect;
	rc.SetLocation(SideInfPanel->ClientToScreen(rc.Location));
	if (ImgSidePanel->Align==alLeft) rc.Right = ClientRect.Right; else rc.Left = ClientRect.Left;
	::ClipCursor(&rc);
	Repaint();
	::ClipCursor(NULL);
}

//---------------------------------------------------------------------------
//サイドパネルからアンドック
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::SidePanelUnDock(TObject *Sender, TControl *Client,
	TWinControl *NewTarget, bool &Allow)
{
	TPanel *pp = (TPanel*)Sender;
	pp->DockSite = false;
	pp->Constraints->MinHeight = 1;
	pp->Constraints->MaxHeight = 0;

	int dh;
	if (Client==LoupeForm) {
		dh = HistDockPanel->Height;
		SideDockSplitter->Height	 = 0;
		LoupeForm->OptPanel->Align	 = alBottom;
		LoupeForm->MagToolBar->Align = alBottom;
	}
	else {
		dh = SideDockPanel->Height - CLHI_HISTOGRAM;
		HistDockPanel->Height = 0;
		HistForm->BorderWidth = 0;
	}

	SideDockPanel->Height = dh;
	pp->Constraints->MaxHeight = 1;
	ImgViewThread->AddRequest(_T("REDRAW"));
}

//---------------------------------------------------------------------------
//イメージビュアー情報ヘッダの描画
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ImgSttHeaderDrawPanel(TStatusBar *StatusBar, TStatusPanel *Panel,
		const TRect &Rect)
{
	TCanvas *cv = StatusBar->Canvas;
	cv->Font->Assign(StatusBar->Font);
	cv->Brush->Color = (StatusBar->Tag==SHOW_WARN_TAG && Panel->Index==0)? col_bgWarn : col_bgInfHdr;
	cv->FillRect(Rect);
	cv->Font->Color = col_fgInfHdr;
	cv->TextOut(Rect.Left + Scaled2, Rect.Top, Panel->Text);

	if ((StatusBar==ImgSttHeader && Panel->Index==3) || (StatusBar==ImgInfBar && Panel->Index==1)) {
		//グレースケール
		int xp = Rect.Right - cv->TextWidth("G ! ");
		out_Text(cv, xp, Rect.Top, ImgViewThread->GrayScaled? _T("G ") : _T("  "));
		xp += cv->TextWidth("G ");
		//白飛び警告
		if (WarnHighlight) {
			cv->Brush->Color = WarnBlink? col_fgInfHdr : col_bgInfHdr;
			out_Text(cv, xp, Rect.Top, _T("!"), WarnBlink? col_bgInfHdr : col_fgInfHdr);
		}
		else {
			out_Text(cv, xp, Rect.Top, _T("  "));
		}
	}
}

//---------------------------------------------------------------------------
//移動は2ファイル単位か?
//---------------------------------------------------------------------------
bool __fastcall TNyanFiForm::IsDoubleStep()
{
	return (DoublePage && ImgScrollPanel->Visible
			&& !test_FileExt(ExtractFileExt(ViewFileName), FEXT_META FEXT_ICONVIEW));
}

//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ToolBarDblClick(TObject *Sender)
{
	ToolBarDlgAction->Execute();
}
//---------------------------------------------------------------------------
//ツールバーの設定
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ToolBarDlgActionExecute(TObject *Sender)
{
	CancelKeySeq();
	if (!ToolBtnDlg) ToolBtnDlg = new TToolBtnDlg(this);	//初回に動的作成

	//マウス位置のボタンのインデックスを取得
	TWinControl *wp = FindControl(get_window_from_pos());
	if (wp && wp->ClassNameIs("TToolBar")) {
		TToolBar *tp = (TToolBar*)wp;
		TPoint p = tp->ScreenToClient(Mouse->CursorPos);
		int idx = -1;
		for (int i=0; i<tp->ButtonCount && idx==-1; i++)
			if (tp->Buttons[i]->BoundsRect.PtInRect(p)) idx = i;
		ToolBtnDlg->IniIndex = idx;
	}

	if (ToolBtnDlg->ShowModal()==mrOk) UpdateToolBtn();
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ToolBarDlgActionUpdate(TObject *Sender)
{
	TAction *ap = (TAction*)Sender;
	ap->Visible = ScrMode==SCMD_FLIST || ScrMode==SCMD_TVIEW || ScrMode==SCMD_IVIEW;
	ap->Enabled = ap->Visible && IsPrimary;
}

//---------------------------------------------------------------------------
//同期コピー先の設定
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::RegSyncDlgActionExecute(TObject *Sender)
{
	if (!RegSyncDlg) RegSyncDlg = new TRegSyncDlg(this);	//初回に動的作成
	RegSyncDlg->ShowModal();
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::RegSyncDlgActionUpdate(TObject *Sender)
{
	TAction *ap = (TAction*)Sender;
	ap->Visible = ScrMode==SCMD_FLIST;
	ap->Enabled = ap->Visible && IsPrimary;
}
//---------------------------------------------------------------------------


//■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
// ファイラータブの処理
//■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::SetTabStr(
	int idx,
	bool add)	//タブを追加 (default = false)
{
	if (idx>=0 && idx<TabList->Count) {
		TStringDynArray itm_buf = get_csv_array(TabList->Strings[idx], TABLIST_CSVITMCNT, true);
		UnicodeString tit = def_if_empty(itm_buf[2], get_DirNwlName(itm_buf[0]));

		if (FlTabStyle==1) tit += "|─";
		if (!itm_buf[3].IsEmpty()) tit.cat_sprintf(_T("%s"), (FlTabStyle==1)? _T("─") : _T("|─"));

		if (add)
			TabControl1->Tabs->Add(tit);
		else if (idx<TabControl1->Tabs->Count && !SameStr(TabControl1->Tabs->Strings[idx], tit))
			TabControl1->Tabs->Strings[idx] = tit;
	}
}

//---------------------------------------------------------------------------
//タブバーの更新
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::UpdateTabBar(
	int idx,
	bool force)	//表示状態にかかわらず更新 (default = false)
{
	if (!TabPanel->Visible && !force) return;

	set_RedrawOff(TabControl1);
	{
		TabControl1->Tabs->Clear();
		for (int i=0; i<TabList->Count; i++) SetTabStr(i, true);

		if (idx!=-1) {
			if (idx>=TabControl1->Tabs->Count) idx = TabControl1->Tabs->Count - 1;
			TabControl1->TabIndex = idx;
		}
	}
	set_RedrawOn(TabControl1);

	if (TabBottomPaintBox->Visible) TabBottomPaintBox->Repaint();
}

//---------------------------------------------------------------------------
//アクティブなタブを更新
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::SetCurTab(bool redraw)
{
	CurTabIndex = TabControl1->TabIndex;
	if (!TabPanel->Visible) return;

	int idx = TabControl1->TabIndex;
	if (idx!=-1) {
		TStringDynArray itm_buf = get_csv_array(TabList->Strings[idx], TABLIST_CSVITMCNT, true);
		itm_buf[0] = ListStt[0].is_Work? WorkListName : CurPath[0];
		itm_buf[1] = ListStt[1].is_Work? WorkListName : CurPath[1];
		TabList->Strings[idx] = make_csv_rec_str(itm_buf);
		SetTabStr(idx);
		if (redraw) TabControl1->Repaint();
		if (TabBottomPaintBox->Visible) TabBottomPaintBox->Repaint();
	}
}
//---------------------------------------------------------------------------
//タブの状態を保存
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::StoreTabStt(int idx)
{
	tab_info *tp = get_TabInfo(idx);
	if (tp) {
		for (int i=0; i<MAX_FILELIST; i++) {
			tp->sel_list[i]->Clear();
			flist_stt *lst_stt = &ListStt[i];
			if (lst_stt->is_TabFixed || lst_stt->is_Arc || lst_stt->is_Find) continue;
			TStringList *lst = (lst_stt->is_Work)? WorkList : FileList[i];
			for (int j=0; j<lst->Count; j++) {
				file_rec *fp = (file_rec*)lst->Objects[j];
				if (fp->selected && !fp->is_dummy) tp->sel_list[i]->Add(fp->f_name);
			}
		}
	}
}

//---------------------------------------------------------------------------
//タブを変更
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::TabControl1Changing(TObject *Sender, bool &AllowChange)
{
	StoreTabStt(TabControl1->TabIndex);
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::TabControl1Change(TObject *Sender)
{
	if (!TabPanel->Visible) return;

	try {
		int idx = TabControl1->TabIndex;
		tab_info *tp = get_TabInfo(idx);	if (!tp) Abort();

		if (TabBottomPaintBox->Visible) TabBottomPaintBox->Repaint();

		//ワークリストを設定
		if (!(CurStt->is_TabFixed && CurStt->is_Work) && !(OppStt->is_TabFixed && OppStt->is_Work)) {
			UnicodeString wnam = get_TabWorkList(idx);
			if (!wnam.IsEmpty() && !SameText(wnam, WorkListName)) {
				SaveWorkListAction->Execute();
				if (!load_WorkList(wnam)) UserAbort(USTR_WlistCantOpen);
			}
		}

		InhDirHist++;
		//反対側
		if (!OppStt->is_TabFixed) {
			UnicodeString dnam = get_csv_item(TabList->Strings[idx], OppListTag);
			if (ends_PathDlmtr(dnam)) {
				UpdateOppPath(dnam);
				if (!GlobalErrMsg.IsEmpty()) GlobalAbort();
			}
			else if (test_NwlExt(get_extension(dnam))) {
				if (!(CurStt->is_TabFixed && CurStt->is_Work)) {
					SaveWorkListAction->Execute();
					if (!SetWorkList(dnam, true)) UserAbort(USTR_WlistCantOpen);
					if (CurStt->is_Work) RecoverFileList();
					ChangeWorkList(OppListTag);
				}
			}
		}
		//カレント
		if (!CurStt->is_TabFixed) {
			UnicodeString dnam = get_csv_item(TabList->Strings[idx], CurListTag);
			if (ends_PathDlmtr(dnam)) {
				UpdateCurPath(dnam);
				if (!GlobalErrMsg.IsEmpty()) GlobalAbort();
			}
			else if (test_NwlExt(get_extension(dnam))) {
				SaveWorkListAction->Execute();
				if (!SetWorkList(dnam)) UserAbort(USTR_WlistCantOpen);
			}
		}
		InhDirHist--;
		SetCurTab(true);

		//ファイルリストの選択状態を復元
		for (int i=0; i<MAX_FILELIST; i++) {
			flist_stt *lst_stt = &ListStt[i];
			if (lst_stt->is_TabFixed || lst_stt->is_Arc || lst_stt->is_Find) continue;
			TStringList *lst = (lst_stt->is_Work)? WorkList : FileList[i];
			for (int j=0; j<lst->Count; j++) {
				file_rec *fp = (file_rec*)lst->Objects[j];
				fp->selected = (tp->sel_list[i]->IndexOf(fp->f_name)!=-1);
			}
			tp->sel_list[i]->Clear();
		}

		//イベント: 別のタブに移った
		ExeEventCommand(OnTabChange);
	}
	catch (EAbort &e) {
		SetActionAbort(e.Message);
	}
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::TabControl1Enter(TObject *Sender)
{
	FileListBox[CurListTag]->SetFocus();
}

//---------------------------------------------------------------------------
//描画すべき最初/最後のタブを取得
//---------------------------------------------------------------------------
int __fastcall TNyanFiForm::get_TopTabIndex()
{
	int  top_idx = 0;
	TRect top_rc = TRect::Empty();
	for (int i=0; i<TabControl1->Tabs->Count; i++) {
		TRect i_rc = ((tab_info*)TabList->Objects[i])->rc;
		InflateRect(i_rc, -4, 0);
		if (top_rc.IsEmpty()) {
			top_rc = i_rc;
		}
		else if (top_rc.IntersectsWith(i_rc)) {
			top_rc	= i_rc;
			top_idx = i;
		}
	}
	return top_idx;
}
//---------------------------------------------------------------------------
int __fastcall TNyanFiForm::get_EndTabIndex()
{
	int  end_idx = TabControl1->Tabs->Count - 1;
	TRect end_rc = TRect::Empty();
	for (int i=end_idx; i>=0; i--) {
		TRect i_rc = ((tab_info*)TabList->Objects[i])->rc;
		InflateRect(i_rc, -4, 0);
		if (end_rc.IsEmpty()) {
			end_rc = i_rc;
		}
		else if (end_rc.IntersectsWith(i_rc)) {
			end_rc	= i_rc;
			end_idx = i;
		}
	}
	return end_idx;
}

//---------------------------------------------------------------------------
//タブの描画
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::TabCtrlWindowProc(TMessage &msg)
{
	if (msg.Msg==WM_PAINT) {
		org_TabCtrlWindowProc(msg);

		TTabControl *tp = TabControl1;
		TCanvas *cv = tp->Canvas;
		cv->Lock();
		{
			cv->Font->Assign(tp->Font);

			if (TabControl1->Style==tsTabs) {
				cv->Brush->Color = col_bgTabBar;
				cv->FillRect(tp->ClientRect);
			}

			int top_idx = get_TopTabIndex();
			int end_idx = get_EndTabIndex();
			int act_idx = tp->TabIndex;
			TRect act_rc = ((tab_info*)TabList->Objects[act_idx])->rc;
			int y0 = act_rc.Top;
			int y1 = act_rc.Bottom;
			int h  = y1 - y0;
			int edge = EDGE_RAISED;	//BDR_RAISEDOUTER;
			std::unique_ptr<TStringList> slst(new TStringList());

			for (int i=tp->Tabs->Count-1; i>=-1; i--) {
				if (i==act_idx) continue;
				int idx = (i==-1)? act_idx : i;		//アクティブタブは最後に描画
				if (idx<top_idx || idx>end_idx) continue;	//表示範囲外
				bool is_act = (idx==act_idx);

				TRect rc = ((tab_info*)TabList->Objects[idx])->rc;
				WORD xp = rc.Left + 4;

				TColor col = (HotTabIndex==idx && HotTabIndex!=DragTabIndex)? SelectWorB(col_bgInAcTab, 0.33) :
																	  is_act? col_bgActTab : col_bgInAcTab;
				switch (FlTabStyle) {
				case 0:	//タブ
					rc.Right += is_act? 2 : 4;
					rc.Bottom = y1;
					cv->Brush->Color = col;
					cv->FillRect(rc);
					if (col_frmTab==col_None) {
						::DrawEdge(cv->Handle, &rc, edge, BF_LEFT|BF_TOP|BF_RIGHT);
					}
					else {
						cv->Brush->Color = col_frmTab;
						cv->FrameRect(rc);
						cv->Brush->Color = col;
					}
					break;

				case 1:	//タブ(斜め右辺)
					{
						xp += 8;
						int x0 = rc.Right - h/2;
						int x1 = rc.Right - h/2 + h;
						TPoint shape[4] = {Point(rc.Left, y1), Point(rc.Left, y0), Point(x0, y0), Point(x1, y1)};
						cv->Pen->Color	 = col_frmTab;
						cv->Pen->Style	 = (col_frmTab==col_None)? psClear : psSolid;
						cv->Brush->Color = col;
						cv->Polygon(shape, 3);
						if (col_frmTab==col_None) {
							TRect rc1 = Rect(rc.Left, y0, rc.Right - h/2, y1);
							TRect rc2 = Rect(x0, y0, x1, y1);
							::DrawEdge(cv->Handle, &rc1, edge, BF_LEFT|BF_TOP);
							::DrawEdge(cv->Handle, &rc2, edge, BF_DIAGONAL_ENDBOTTOMRIGHT);
						}
					}
					break;

				case 2:	//ボタン
					cv->Brush->Color = col;
					cv->FillRect(rc);
					break;

				case 3:	//フラットボタン
					if (!is_act) {
						InflateRect(rc, 4, 4);
						cv->Brush->Color = col_bgTabBar;
						cv->FillRect(rc);
						InflateRect(rc, -4, -4);
					}
					cv->Brush->Color = col;
					cv->FillRect(rc);
					break;
				}

				int wW = (rc.Width() - ((FlTabStyle==1)? 10 + h/2 : 10));

				//アイコン
				TStringDynArray itm_buf = get_csv_array(TabList->Strings[idx], TABLIST_CSVITMCNT, true);
				UnicodeString inam = to_absolute_name(itm_buf[3]);
				if (file_exists(inam)) {
					if (FlTabStyle==1) xp -= 6;
					draw_SmallIcon2(inam, cv, xp, std::max(y0 + (int)(h - SIcoSize)/2, 0));
					int iw = get_IcoWidth();
					wW -= iw;  xp += iw;
				}

				//キャプションの準備
				UnicodeString tit = get_tkn(tp->Tabs->Strings[idx], '|');
				if (tp->TabWidth>0) {
					if (!itm_buf[2].IsEmpty())
						tit = itm_buf[2];
					else if (cv->TextWidth(get_DirNwlName(itm_buf[0])) < (tp->TabWidth*2/3))
						tit.sprintf(_T("%s | %s"), get_DirNwlName(itm_buf[0]).c_str(), get_DirNwlName(itm_buf[1]).c_str());
					tit = minimize_str(tit, cv, wW, true);
				}

				WORD yp = rc.Top + ScaledInt(!has_Leading(cv)? 4 : 2);
				//左|右
				if (ContainsStr(tit, "|")) {
					UnicodeString tmp = split_tkn(tit, '|');
					slst->AddObject(tmp, (TObject*)((NativeInt)MAKELONG(xp, yp)));
					int wL = cv->TextWidth(tmp);
					int wR = cv->TextWidth(tit);
					int wH = wW/2;
					int mgn = wH*2 - (wL + wR + 4);
					xp += ((wL<wH && wR<wH)? wH : (mgn>0)? wL + mgn : wL);
					draw_Line(cv, xp, rc.Top + 2, xp, rc.Top + rc.Height() - 2, 1, SelectWorB(cv->Brush->Color, 0.33));
					xp += 2;
					slst->AddObject(tit, (TObject*)((NativeInt)MAKELONG(xp, yp)));
				}
				//左のみ
				else {
					slst->AddObject(tit, (TObject*)((NativeInt)MAKELONG(xp, yp)));
				}
			}

			//キャプションの描画(カラー絵文字対応)
			if (TDirect2DCanvas::Supported()) {
				std::unique_ptr<TDirect2DCanvas> dcv(new TDirect2DCanvas(cv, tp->ClientRect));
				dcv->BeginDraw();
				dcv->Font->Assign(tp->Font);
				dcv->Font->Color  = col_fgTab;
				dcv->Brush->Style = bsClear;
				for (int i=0; i<slst->Count; i++) {
					DWORD p = (DWORD)slst->Objects[i];
					dcv->TextOut(LOWORD(p), HIWORD(p), slst->Strings[i]);
				}
				dcv->EndDraw();
			}
			else {
				cv->Font->Color  = col_fgTab;
				cv->Brush->Style = bsClear;
				for (int i=0; i<slst->Count; i++) {
					DWORD p = (DWORD)slst->Objects[i];
					cv->TextOut(LOWORD(p), HIWORD(p), slst->Strings[i]);
				}
			}

			//閉じるボタンを描画(本来のボタンが隠れてしまうため)
			if (DelTabBtn->Visible) cv->Draw(DelTabBtn->Left, DelTabBtn->Top, DelTabBtn->Glyph);
		}
		cv->Unlock();

		msg.Result = 0;
	}
	else {
		org_TabCtrlWindowProc(msg);
	}
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::TabControl1DrawTab(TCustomTabControl *Control, int TabIndex,
	const TRect &Rect, bool Active)
{
	tab_info *tp = get_TabInfo(TabIndex);
	if (tp) tp->rc = Rect;

	if (TabBottomPaintBox->Visible) TabBottomPaintBox->Repaint();
}

//---------------------------------------------------------------------------
//タブバー底辺の描画
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::TabBottomPaintBoxPaint(TObject *Sender)
{
	if (col_frmTab!=col_None && (FlTabStyle==0 || FlTabStyle==1)) {
		TPaintBox *pp = (TPaintBox*)Sender;
		TCanvas *cv = pp->Canvas;
		cv->Pen->Width = Scaled1;
		cv->Pen->Style = psSolid;
		cv->Pen->Color = col_frmTab;
		cv->MoveTo(0, 0);
		cv->LineTo(pp->ClientWidth, 0);

		//アクティブなタブの底辺部分を消す
		int act_idx = TabControl1->TabIndex;
		if (act_idx>=get_TopTabIndex() && act_idx<=get_EndTabIndex()) {
			TRect rc = ((tab_info*)TabList->Objects[act_idx])->rc;
			rc.Offset(TabControl1->Left, 0);
			int x0 = rc.Left + 1;
			int x1 = rc.Right + ((FlTabStyle==1)? ((rc.Bottom - rc.Top)/2 - 2) : 1);
			cv->Pen->Color = col_bgActTab;
			cv->MoveTo(x0, 0);
			cv->LineTo(x1, 0);
		}
	}
}

//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::TabControl1MouseMove(TObject *Sender, TShiftState Shift, int X, int Y)
{
	bool found = false;

	if (TabControl1->Tabs->Count>1) {
		//ドラッグ中
		if (DragTabIndex!=-1) {
			if (Shift.Contains(ssLeft)) {
				Screen->Cursor = crDrag;
				if (!TabMouseCliped) {
					TRect rc = TabControl1->TabRect(0);
					rc.Right = TabControl1->TabRect(TabControl1->Tabs->Count - 1).Right;
					rc.SetLocation(TabControl1->ClientToScreen(rc.Location));
					::ClipCursor(&rc);
				}
				for (int i=0; i<TabControl1->Tabs->Count; i++) {
					if (HotTabIndex!=i && TabControl1->TabRect(i).PtInRect(Point(X, Y))) {
						HotTabIndex = i;
						TabControl1->Invalidate();
						break;
					}
				}
			}
			else {
				DragTabIndex = -1;
			}
		}
		//通常
		else if (ShowClsTabBtn) {
			for (int i=0; i<TabControl1->Tabs->Count; i++) {
				TRect rc = TabControl1->TabRect(i);
				rc.Top += 2;
				rc.Left = rc.Right - DelTabBtn->Width - 2;
				rc.SetWidth(DelTabBtn->Width);
				rc.SetHeight(DelTabBtn->Height);
				if (FlTabStyle==1) rc.Offset((i==TabControl1->TabIndex)? -8 : -10, 0);
				if (rc.PtInRect(Point(X, Y))) {
					DelTabBtn->Top  = rc.Top;
					DelTabBtn->Left = rc.Left;
					DelTabBtn->Tag	= i;
					DelTabBtn->Visible = true;
					found = true;
					break;
				}
			}
		}
	}

	if (!found) DelTabBtn->Visible = false;
}
//---------------------------------------------------------------------------
//ドラッグ&ドロップによるタブの移動
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::TabControl1MouseDown(TObject *Sender, TMouseButton Button, TShiftState Shift, int X, int Y)
{
	DragTabIndex   = -1;
	TabMouseCliped = false;
	if (Button==mbLeft && TabControl1->Tabs->Count>1) DragTabIndex = TabControl1->IndexOfTabAt(X, Y);
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::TabControl1MouseUp(TObject *Sender, TMouseButton Button, TShiftState Shift, int X, int Y)
{
	::ClipCursor(NULL);
	TabMouseCliped = false;
	cursor_Default();
	HotTabIndex = -1;
	if (DragTabIndex!=-1) {
		int idx1 = -1;
		for (int i=0; i<TabControl1->Tabs->Count && idx1==-1; i++) {
			if (i==DragTabIndex) continue;
			if (TabControl1->TabRect(i).PtInRect(Point(X, Y))) idx1 = i;
		}
		if (idx1!=-1) {
			StoreTabStt(TabControl1->TabIndex);
			TabList->Move(DragTabIndex, idx1);
			TabControl1->TabIndex = idx1;
			TabControl1Change(NULL);
		}
		DragTabIndex = -1;
	}
}

//---------------------------------------------------------------------------
//タブを追加
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::AddTabActionExecute(TObject *Sender)
{
	int idx = TabControl1->TabIndex;
	StoreTabStt(idx);

	UnicodeString ibuf;
	ibuf.sprintf(_T("%s,%s"), make_csv_str(CurPath[0]).c_str(), make_csv_str(CurPath[1]).c_str());

	//次に挿入
	if (TEST_ActParam("NX")) {
		idx++;
		if (idx<TabList->Count) insert_TabList(idx, ibuf); else idx = add_TabList(ibuf);
	}
	//前に挿入
	else if (TEST_ActParam("PR")) {
		insert_TabList(idx, ibuf);
	}
	//最後に追加
	else {
		idx = add_TabList(ibuf);
	}

	UpdateTabBar(idx);
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::AddTabActionUpdate(TObject *Sender)
{
	TAction *ap = (TAction*)Sender;
	ap->Visible = (ScrMode==SCMD_FLIST && TabPanel->Visible);
	ap->Enabled = ap->Visible;
}
//---------------------------------------------------------------------------
//タブを削除
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::DelTabActionExecute(TObject *Sender)
{
	int idx = TabControl1->TabIndex;
	tab_info *tp = get_TabInfo(idx);
	if (tp) {
		del_tab_info(tp);
		TabList->Delete(idx);
		UpdateTabBar(idx);
		TabControl1Change(NULL);
	}
}
//---------------------------------------------------------------------------
//他のタブをすべて削除
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::SoloTabActionExecute(TObject *Sender)
{
	int idx = TabControl1->TabIndex;
	if (idx>=0 && idx<TabList->Count) {
		int i=0;
		while (i<TabList->Count) {
			if (i!=idx) {
				del_tab_info((tab_info*)TabList->Objects[i]);
				TabList->Delete(i);
				if (idx>i) idx--;
			}
			else i++;
		}

		UpdateTabBar(0);
		TabControl1Change(NULL);
	}
}
//---------------------------------------------------------------------------
//タブの位置を移動
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::MoveTabActionExecute(TObject *Sender)
{
	if (TabList->Count<2) return;

	int idx0 = TabControl1->TabIndex;
	if (idx0>=0 && idx0<TabList->Count) {
		int idx1 = TEST_ActParam("TP")? 0 :
				   TEST_ActParam("ED")? TabControl1->Tabs->Count - 1 : 
				   TEST_ActParam("PR")? ((idx0>0)? idx0 - 1 : TabControl1->Tabs->Count - 1)
									  : ((idx0 < TabControl1->Tabs->Count-1)? idx0 + 1 : 0);
		if (idx0!=idx1) {
			StoreTabStt(idx0);
			TabList->Move(idx0, idx1);
			TabControl1->TabIndex = idx1;
			TabControl1Change(NULL);
		}
	}
}

//---------------------------------------------------------------------------
//前のタブ
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::PrevTabActionExecute(TObject *Sender)
{
	StoreTabStt(TabControl1->TabIndex);
	TabControl1->TabIndex = (TabControl1->TabIndex>0)? TabControl1->TabIndex - 1 : TabControl1->Tabs->Count - 1;
	TabControl1Change(NULL);
}
//---------------------------------------------------------------------------
//次のタブ
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::NextTabActionExecute(TObject *Sender)
{
	StoreTabStt(TabControl1->TabIndex);
	TabControl1->TabIndex = (TabControl1->TabIndex < TabControl1->Tabs->Count-1)? TabControl1->TabIndex + 1 : 0;
	TabControl1Change(NULL);
}
//---------------------------------------------------------------------------
//指定番号のタブへ
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ToTabActionExecute(TObject *Sender)
{
	try {
		int idx = ActionParam.ToIntDef(-1);
		//キャプション
		if (idx==-1) {
			for (int i=0; i<TabList->Count; i++) {
				if (SameText(ActionParam, get_csv_item(TabList->Strings[i], 2))) {
					idx = i + 1;  break;
				}
			}
			if (idx==-1) UserAbort(USTR_IllegalParam);
		}
		//番号
		else {
			if		(idx==0) idx = 1;
			else if (idx>TabControl1->Tabs->Count) idx = TabControl1->Tabs->Count;
		}

		StoreTabStt(TabControl1->TabIndex);
		TabControl1->TabIndex = --idx;
		TabControl1Change(NULL);
	}
	catch (EAbort &e) {
		SetActionAbort(e.Message);
	}
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ChgTabActionUpdate(TObject *Sender)
{
	TAction *ap = (TAction*)Sender;
	ap->Visible = (ScrMode==SCMD_FLIST && TabPanel->Visible);
	ap->Enabled = (ap->Visible && TabControl1->Tabs->Count>1);
}

//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::TabPopupMenuPopup(TObject *Sender)
{
	CancelKeySeq();
	ActionParam = EmptyStr;
}

//---------------------------------------------------------------------------
//タブ選択メニューを表示
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::PopTabBtnClick(TObject *Sender)
{
	PopupTabMenu();
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::PopupTabActionExecute(TObject *Sender)
{
	PopupTabMenu();
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::PopupTabActionUpdate(TObject *Sender)
{
	TAction *ap = (TAction*)Sender;
	ap->Visible = (ScrMode==SCMD_FLIST && TabPanel->Visible);
	ap->Enabled = (ap->Visible && TabControl1->Tabs->Count>0);
}

//---------------------------------------------------------------------------
//タブバーを表示
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ShowTabBarActionExecute(TObject *Sender)
{
	SetToggleAction(ShowTabBar);
	TabPanel->Visible = ShowTabBar;
	UpdateTabBar();
	TabControl1Change(NULL);
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ShowTabBarActionUpdate(TObject *Sender)
{
	TAction *ap = (TAction*)Sender;
	ap->Visible = (ScrMode==SCMD_FLIST);
	ap->Enabled = ap->Visible;
	ap->Checked = TabPanel->Visible;
}

//---------------------------------------------------------------------------
//タブ削除ボタンの処理
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::DelTabBtnMouseLeave(TObject *Sender)
{
	DelTabBtn->Visible = false;
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::DelTabBtnClick(TObject *Sender)
{
	int cur_idx = TabControl1->TabIndex;
	int idx = ((TComponent*)Sender)->Tag;
	tab_info *tp = get_TabInfo(idx);
	if (tp) {
		DelTabBtn->Visible = false;
		del_tab_info(tp);
		TabList->Delete(idx);
		UpdateTabBar(cur_idx);
		TabControl1Change(NULL);
	}
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::TabControl1MouseLeave(TObject *Sender)
{
	DelTabBtn->Visible = false;
}

//---------------------------------------------------------------------------
//タブの設定
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::TabDlgActionExecute(TObject *Sender)
{
	CancelKeySeq();
	int idx = TabControl1->TabIndex;
	if (idx>=0 && idx<TabList->Count) {
		if (!TabSetDlg) TabSetDlg = new TTabSetDlg(this);	//初回に動的作成
		TabSetDlg->TabIndex = idx;
		TabSetDlg->CurPath1 = ListStt[0].is_Work? WorkListName : CurPath[0];
		TabSetDlg->CurPath2 = ListStt[1].is_Work? WorkListName : CurPath[1];
		if (TabSetDlg->ShowModal()==mrOk) {
			UnicodeString wnam = get_TabWorkList(idx);
			if (!wnam.IsEmpty() && !SameText(wnam, WorkListName)) {
				SaveWorkListAction->Execute();
				if (!SetWorkList(wnam, !CurStt->is_Work && !OppStt->is_Work)) SetActionAbort(USTR_WlistCantOpen);
			}
			SetCurTab(true);
		}
	}
}
//---------------------------------------------------------------------------
//タブのホームへ
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::TabHomeActionExecute(TObject *Sender)
{
	try {
		int idx = TabControl1->TabIndex;
		if (idx>=0 && idx<TabList->Count) {
			for (int i=0; i<TabList->Count; i++) {
				if (TEST_ActParam("AL") || i==idx) {
					TStringDynArray itm_buf = get_csv_array(TabList->Strings[i], TABLIST_CSVITMCNT, true);
					if (!ListStt[0].is_TabFixed && !itm_buf[4].IsEmpty()) itm_buf[0] = itm_buf[4];
					if (!ListStt[1].is_TabFixed && !itm_buf[5].IsEmpty()) itm_buf[1] = itm_buf[5];
					TabList->Strings[i] = make_csv_rec_str(itm_buf);
					SetTabStr(i);
				}
			}

			//反対側
			UnicodeString dnam;
			if (!TEST_ActParam("CO") && !ListStt[OppListTag].is_TabFixed) {
				dnam = get_csv_item(TabList->Strings[idx], OppListTag);
				if (ends_PathDlmtr(dnam)) {
					ApplyDotNyan = true;
					UpdateOppPath(dnam);
					if (!GlobalErrMsg.IsEmpty()) GlobalAbort();
				}
				else if (test_NwlExt(get_extension(dnam))) {
					SaveWorkListAction->Execute();
					if (!SetWorkList(dnam, true)) UserAbort(USTR_WlistCantOpen);
					if (CurStt->is_Work) RecoverFileList();
					ChangeWorkList(OppListTag);
				}
			}
			//カレント
			if (!ListStt[CurListTag].is_TabFixed) {
				dnam = get_csv_item(TabList->Strings[idx], CurListTag);
				if (ends_PathDlmtr(dnam)) {
					ApplyDotNyan = true;
					UpdateCurPath(dnam);
					if (!GlobalErrMsg.IsEmpty()) GlobalAbort();
				}
				else if (test_NwlExt(get_extension(dnam))) {
					SaveWorkListAction->Execute();
					if (!SetWorkList(dnam)) UserAbort(USTR_WlistCantOpen);
				}
			}

			SetCurTab(true);

			//ワークリストを設定
			if (!(CurStt->is_TabFixed && CurStt->is_Work) && !(OppStt->is_TabFixed && OppStt->is_Work)) {
				UnicodeString wnam = get_TabWorkList(idx);
				if (!wnam.IsEmpty() && !SameText(wnam, WorkListName)) {
					SaveWorkListAction->Execute();
					if (!load_WorkList(wnam)) UserAbort(USTR_WlistCantOpen);
				}
			}
		}
	}
	catch (EAbort &e) {
		SetActionAbort(e.Message);
	}
}

//---------------------------------------------------------------------------
//タスクトレイの処理
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::TrayIcon1Click(TObject *Sender)
{
	ActivateMainForm();
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::TrayPopupMenuPopup(TObject *Sender)
{
	TMenuItem *ip = TrayPopupMenu->Items;

	int idx = 0;
	while (idx<ip->Count) {
		if (ip->Items[idx]->Tag>=TRYNYN_BASE) ip->Delete(idx); else idx++;
	}

	std::unique_ptr<TStringList> lst(new TStringList());
	get_NyanFiList(lst.get());
	int ins_p = 0;
	for (int i=0; i<lst->Count; i++) {
		int n = get_tkn(lst->Strings[i], ',').ToIntDef(0);
		TMenuItem *mp = new TMenuItem(TrayPopupMenu);
		mp->Caption   = UnicodeString().sprintf(_T("NyanFi - &%u"), n);
		mp->OnClick   = ShowNyanFiClick;
		mp->Tag 	  = TRYNYN_BASE + n;
		ip->Insert(ins_p++, mp);
	}
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ShowNyanFiClick(TObject *Sender)
{
	activate_NyanFi(((TMenuItem*)Sender)->Tag - TRYNYN_BASE, false);
}

//---------------------------------------------------------------------------
//テキストビュアー情報ヘッダの描画
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::TxtSttHeaderDrawPanel(TStatusBar *StatusBar, TStatusPanel *Panel,
	const TRect &Rect)
{
	TxtViewer->SttHeaderDrawPanel(StatusBar, Panel, Rect);
}

//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::LogListBoxEnter(TObject *Sender)
{
	((TListBox*)Sender)->Repaint();

	UpdateFKeyBtn();
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::TxtPrvListBoxEnter(TObject *Sender)
{
	UpdateFKeyBtn();
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::InfListBoxEnter(TObject *Sender)
{
	UpdateFKeyBtn();
}

//---------------------------------------------------------------------------
//FTPの(再)生成
//  FTPが機能回復できない場合に、一旦破棄して再生成。
//  ※「Socket エラー #10054」やアップロード中断後の不具合対策
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::RecycleFTP()
{
	delete IdFTP1;
	delete IdAntiFreeze1;
	delete IdSSLIOHandlerSocketOpenSSL1;

	IdFTP1 = new TIdFTP();
	IdFTP1->OnDisconnected	   = IdFTP1Disconnected;
	IdFTP1->OnWork			   = IdFTP1Work;
	IdFTP1->OnBannerAfterLogin = IdFTP1BannerAfterLogin;
	IdFTP1->OnStatus		   = IdFTP1Status;

	IdAntiFreeze1 = new TIdAntiFreeze();

	IdSSLIOHandlerSocketOpenSSL1 = new TIdSSLIOHandlerSocketOpenSSL();
	IdFTP1->IOHandler = IdSSLIOHandlerSocketOpenSSL1;

	FTPhasCHMOD = false;
}

//---------------------------------------------------------------------------
//FTPカレントディレクトリの取得・設定
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::set_CurFTPPath()
{
	UnicodeString dnam = slash_to_yen(IdFTP1->RetrieveCurrentDir());
	if (!dnam.IsEmpty()) dnam = IncludeTrailingPathDelimiter(dnam);
	if (!SameText(CurFTPPath, dnam)) {
		add_FTPLogMsg();
		CurFTPPath = dnam;
	}
}

//---------------------------------------------------------------------------
//FTPコマンドの実行結果を表示
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::add_FTPLogMsg(UnicodeString msg)
{
	if (!msg.IsEmpty()) AddLog(msg);

	if (FTPLogResponse) {
		if (msg.IsEmpty()) {
			TListBox *lp = LogListBox;
			if (lp->Count>0 && ContainsStr(lp->Items->Strings[lp->Count - 1], "終了")) lp->Items->Add(EmptyStr);
		}

		UnicodeString tmp;
		for (int i=0; i<IdFTP1->LastCmdResult->Text->Count; i++) {
			UnicodeString lbuf = IdFTP1->LastCmdResult->Text->Strings[i];
			if (i==0)
				tmp.sprintf(_T("     %s %s"),  IdFTP1->LastCmdResult->Code.c_str(), lbuf.c_str());
			else
				tmp.sprintf(_T("         %s"), lbuf.c_str());
			AddLog(tmp);
		}
	}
}

//---------------------------------------------------------------------------
//FTP接続
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::FTPConnectActionExecute(TObject *Sender)
{
	try {
		if (IsDiffList()) UserAbort(USTR_CantOperate);

		//パラメータでホスト指定
		if (!ActionParam.IsEmpty()) {
			std::unique_ptr<TStringList> lst(new TStringList());
			IniFile->LoadListItems("FtpHostList", lst.get(), 20, false);
			for (int i=0; i<lst->Count; i++) {
				if (SameText(ActionParam, get_csv_item(lst->Strings[i], 0))) {
					FTPHostItem = lst->Strings[i];  break;
				}
			}
			if (FTPHostItem.IsEmpty()) throw EAbort(LoadUsrMsg(USTR_NotFound, _T("ホスト設定")));
		}
		//ダイアログで指定
		else {
			if (!FtpConnectDlg) FtpConnectDlg = new TFtpConnectDlg(this);	//初回に動的作成
			if (FtpConnectDlg->ShowModal()!=mrOk) SkipAbort();
			FTPHostItem = FtpConnectDlg->HostItem;
		}

		if (!InternetConnected()) TextAbort(_T("インターネットに接続されていません。"));

		cursor_HourGlass();
		if (OppStt->is_FTP) RecoverFileList(OppListTag);
		RecoverFileList();
		if		(FTPRemoteSide==1 && CurListTag==1) ToLeftAction->Execute();
		else if (FTPRemoteSide==2 && CurListTag==0) ToRightAction->Execute();

		RecycleFTP();	//FTPを再生成

		TStringDynArray itm_buf = get_csv_array(FTPHostItem, 7 + 2, true);
		UnicodeString opt_str = itm_buf[6];
		IdFTP1->Host	 = get_tkn(itm_buf[1], ":");
		IdFTP1->Username = itm_buf[2];
		IdFTP1->Password = uncipher(itm_buf[3]);
		IdFTP1->Passive  = !ContainsText(opt_str, "PORT");
		int port_no = get_tkn_r(itm_buf[1], ":").ToIntDef(0);	//標準以外のポート番号

		//SSL暗号化
		if (ContainsText(opt_str, "IMPLICIT")) {
			IdFTP1->UseTLS = utUseImplicitTLS;
			IdFTP1->DataPortProtection = ftpdpsPrivate;
			IdFTP1->Port   = (port_no>0)? port_no : 990;
		}
		else if (ContainsText(opt_str, "EXPLICIT")) {
			IdFTP1->UseTLS = utUseRequireTLS;
			IdFTP1->DataPortProtection = ftpdpsPrivate;
			IdFTP1->Port   = (port_no>0)? port_no : 21;
		}
		else {
			IdFTP1->UseTLS = utNoTLSSupport;
			IdFTP1->DataPortProtection = ftpdpsClear;
			IdFTP1->Port   = (port_no>0)? port_no : 21;
		}

		FTPLastWorkCnt = FTPLastNoopCnt = GetTickCount();
		CurFTPPath	   = EmptyStr;
		FTPTryModTime  = true;

		//接続開始
		StartLog("FTP接続  " + itm_buf[1]);
		IdFTP1->Connect();
		AddLog("         " + IdFTP1->SystemDesc);
		if (IdFTP1->UsingSFTP) AddLog(_T("         TLS接続が確立されました"));
		InhFTPCheck = false;

		//CHMOD コマンドに対応しているか?
		FTPhasCHMOD = false;
		try {
			IdFTP1->Site("HELP");
		}
		catch (...) { ; }
		if (USAME_TS(IdFTP1->LastCmdResult->Code, "214")) {
			TRegExOptions opt; opt << roIgnoreCase;
			for (int i=0; i<IdFTP1->LastCmdResult->Text->Count && !FTPhasCHMOD; i++)
				FTPhasCHMOD = TRegEx::IsMatch(IdFTP1->LastCmdResult->Text->Strings[i], "\\bCHMOD\\b", opt);
		}

		TopFTPPath = itm_buf[4];
		if		(TopFTPPath.IsEmpty())		  TopFTPPath = "/";
		else if (!StartsStr('/', TopFTPPath)) TopFTPPath.Insert("/", 1);

		//ローカル開始ディレクトリ
		if (dir_exists(itm_buf[5])) UpdateOppPath(itm_buf[5]);
		itm_buf[8] = PathMask[CurListTag];				//カレントのパスマスクを待避
		PathMask[CurListTag] = PathMask[OppListTag];	//リモート側のパスマスクをローカル側に合わせる
		//ホスト開始ディレクトリ
		if (!ChangeFtpFileList(CurListTag, TopFTPPath, "..")) {
			if (!ChangeFtpFileList()) GlobalAbort();
		}
		//ディレクトリ同期変更
		if (ContainsText(opt_str, "SyncLR")) {
			//切断時の復帰コマンドを設定
			itm_buf[7]	= UnicodeString().sprintf(_T("SyncLR_%s"), SyncLR? _T("ON") : _T("OFF"));
			FTPHostItem = make_csv_rec_str(itm_buf);
			ExeCmdAction(SyncLRAction, "ON");
		}

		cursor_Default();
		ClearTempArc(TempPathFTP);
		play_sound(FTPSndConnect);
		//イベント : FTPホストに接続した
		ExeEventCommand(OnFTPConnect);
	}
	catch (EAbort &e) {
		SetActionAbort(e.Message);
	}
	catch (...) {
		UnicodeString msg = "接続に失敗しました";
		add_FTPLogMsg(msg);
		SetActionAbort(msg);
	}
}
//---------------------------------------------------------------------------
//FTP切断
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::DisconnectFTP()
{
	int rmt_tag = CurStt->is_FTP? CurListTag : OppStt->is_FTP? OppListTag : -1;
	if (rmt_tag!=-1) {
		TStringDynArray itm_buf = get_csv_array(FTPHostItem, 7 + 2, true);
		PathMask[rmt_tag] = itm_buf[8];	//パスマスクの復帰
		RecoverFileList(rmt_tag);
		ExeCommandAction(itm_buf[7]);	//SyncLR の復帰
	}
	FTPHostItem = EmptyStr;
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::FTPDisconnectActionExecute(TObject *Sender)
{
	InhFTPCheck = true;
	DisconnectFTP();
	InhFTPCheck = false;
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::FTPDisconnectActionUpdate(TObject *Sender)
{
	TAction *ap = (TAction*)Sender;
	ap->Visible = (ScrMode==SCMD_FLIST);
	try {
		ap->Enabled = ap->Visible && IdFTP1->Connected();
	}
	catch (...) {
		ap->Enabled = false;
	}
}

//---------------------------------------------------------------------------
//切断した
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::IdFTP1Disconnected(TObject *Sender)
{
	ClearTempArc(TempPathFTP);

	AddLog(_T("FTP切断"), true);
	play_sound(FTPSndDiscon);

	//イベント : FTPホストから切断した
	ExeEventCommand(OnFTPDiscon);
}
//---------------------------------------------------------------------------
//ダウンロード/アップロード進捗状況表示
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::IdFTP1Work(TObject *ASender, TWorkMode AWorkMode, __int64 AWorkCount)
{
	IdAntiFreeze1->Process();
	PosWorkProgress(AWorkCount, FTPMaxCount);
	FTPLastWorkCnt = GetTickCount();
}
//---------------------------------------------------------------------------
//応答メッセージのログ表示
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::IdFTP1BannerAfterLogin(TObject *ASender, const UnicodeString AMsg)
{
	std::unique_ptr<TStringList> lst(new TStringList());
	lst->Text = AMsg;
	for (int i=0; i<lst->Count; i++) AddLog("     " + lst->Strings[i]);
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::IdFTP1Status(TObject *ASender, const TIdStatus AStatus,
		const UnicodeString AStatusText)
{
	if (FTPLogResponse && (AStatus==hsResolving || AStatus==hsConnecting || AStatus==hsStatusText)) {
		AddLog("         " + AStatusText);
	}
}

//---------------------------------------------------------------------------
//FTPダウンロード
//  戻り値 : ダウンロード先のファイル名、失敗時は EmptyStr
//---------------------------------------------------------------------------
UnicodeString __fastcall TNyanFiForm::DownloadFtpCore(
	file_rec *fp,
	UnicodeString dst_dir)	//ダウンロード先ディレクトリ (無い場合は作成)
							//  default = EmptyStr (一時ディレクトリ)
{
	try {
		if (!IdFTP1->Connected())	Abort();
		if (fp->is_dir)				Abort();

		bool tmp_ren = false;
		if (dst_dir.IsEmpty()) {
			//一時ダウンロード、自動改名
			dst_dir = TempPathFTP;
			tmp_ren = true;
		}
		if (dst_dir.IsEmpty())		Abort();
		dst_dir = IncludeTrailingPathDelimiter(dst_dir);
		if (!dir_exists(dst_dir) && !create_ForceDirs(dst_dir)) Abort();

		UnicodeString fnam = fp->n_name;
		UnicodeString dst_fnam = dst_dir + fnam;
		UnicodeString msg = make_LogHdr(_T("FTPGET"), fp);
		if (ProgressPanel->Visible) ProgressSubLabel->Caption = minimize_str(fnam, Canvas, ProgressSubLabel->Width);

		bool s_flag = file_exists(dst_fnam);
		bool o_flag = false, n_flag = false;

		//同名ファイルの処理
		if (s_flag) {
			UnicodeString dnam = ExtractFilePath(dst_fnam);
			if (tmp_ren) {
				UnicodeString bnam = get_base_name(dst_fnam);
				int fn = 1;
				do {
					dst_fnam.sprintf(_T("%s%s_%u%s"), dnam.c_str(), bnam.c_str(), fn++, get_extension(dst_fnam).c_str());
				} while(file_exists(dst_fnam));
				set_RenameLog(msg, dst_fnam);
				n_flag = true;
			}
			else {
				UnicodeString cpy_nam = ExtractFileName(dst_fnam);
				if (!gCopyAll) {
					TaskSttTimer->Enabled = false;
					SameNameDlg->Caption  = LoadUsrMsg(USTR_SameName, _T("ダウンロード"));
					SameNameDlg->TaskNo   = -1;
					SameNameDlg->CopyMode = gCopyMode;
					SameNameDlg->CopyAll  = gCopyAll;
					SameNameDlg->RenameEdit->Text = cpy_nam;
					SameNameDlg->IsSamePath = false;
					SameNameDlg->CurSrcName = fp->f_name;
					SameNameDlg->CurSrcSize = fp->f_size;
					SameNameDlg->CurSrcTime = fp->f_time;
					SameNameDlg->CurDstName = dst_fnam;
					SameNameDlg->CurDstSize = get_file_size(dst_fnam);
					SameNameDlg->CurDstTime = get_file_age(dst_fnam);
					if (SameNameDlg->ShowModal()==mrCancel) {
						AddLog(_T("コピー中断"), true);
						gCopyCancel = true;
					}
					else {
						gCopyMode = SameNameDlg->CopyMode;
						gCopyAll  = SameNameDlg->CopyAll;
						gCopyFmt  = AutoRenFmt;
						cpy_nam   = SameNameDlg->RenameEdit->Text;
					}
					TaskSttTimer->Enabled = true;
					if (gCopyCancel) return EmptyStr;
				}

				switch (gCopyMode) {
				case CPYMD_OW:		//上書き
					msg[1] = 'O';
					o_flag = true;
					break;
				case CPYMD_NEW:		//最新なら
					if (is_NewerTime(SameNameDlg->CurSrcTime, SameNameDlg->CurDstTime)) {
						msg[1] = 'N';
						o_flag = true;
					}
					else {
						if (LogHideSkip) msg = EmptyStr; else msg[1] = 'S';
					}
					break;
				case CPYMD_SKIP:	//スキップ
					if (LogHideSkip) msg = EmptyStr; else msg[1] = 'S';
					break;
				case CPYMD_AUT_REN:	//自動的に名前を変更
					dst_fnam = format_CloneName(gCopyFmt, fp->n_name, dnam, false, &fp->f_time);
					set_RenameLog(msg, dst_fnam);
					n_flag = true;
					break;
				case CPYMD_MAN_REN:	//名前を変更
					dst_fnam = dnam + cpy_nam;
					if (!file_exists(dst_fnam)) {
						set_RenameLog(msg, cpy_nam);
						n_flag = true;
					}
					else set_LogErrMsg(msg, LoadUsrMsg(USTR_DuplicateName));
					break;
				default:
					Abort();
				}
			}
		}

		//ダウンロード
		if (!s_flag || o_flag || n_flag) {
			if (tmp_ren) {
				CurWorking = true;
				BeginWorkProgress(LoadUsrMsg(USTR_Download), EmptyStr, FileListBox[CurListTag], true);
			}

			try {
				UnicodeString tmp_fnam;
				if (o_flag || n_flag) {
					//元ファイルを改名待避
					int fn = 1;
					do {
						tmp_fnam = ChangeFileExt(dst_fnam, ".~" + IntToHex(fn++, 3));
					} while(file_exists(tmp_fnam));
					move_File(dst_fnam, tmp_fnam);
				}
				FTPMaxCount = fp->f_size;
				IdFTP1->TransferType = (!tmp_ren && test_FileExt(fp->f_ext, FTPTextModeFExt))? ftASCII : ftBinary;
				IdFTP1->Get(fnam, dst_fnam);
				//中断
				if (CancelWork) {
					//中断ファイルを削除して元ファイルを復帰
					delete_File(dst_fnam);
					if (file_exists(tmp_fnam)) move_File(tmp_fnam, dst_fnam);
					msg[1] = 'C';
				}
				//完了
				else {
					if (FTPDlKeepTime) set_file_age(dst_fnam, fp->f_time);
					delete_FileIf(tmp_fnam);
				}
			}
			catch (EAbort &e) {
				set_LogErrMsg(msg, e.Message);
			}
			catch (...) {
				msg[1] = 'E';
				dst_fnam = EmptyStr;
			}

			if (tmp_ren) {
				EndWorkProgress();
				CurWorking = false;
			}
		}

		if (!msg.IsEmpty()) add_FTPLogMsg(msg);

		return dst_fnam;
	}
	catch (...) {
		return EmptyStr;
	}
}
//---------------------------------------------------------------------------
//FTPアップロード
//---------------------------------------------------------------------------
bool __fastcall TNyanFiForm::UploadFtpCore(file_rec *fp)
{
	UnicodeString msg;

	try {
		if (!IdFTP1->Connected()) Abort();

		if (fp->is_dir) Abort();

		UnicodeString dst_fnam = fp->n_name;
		msg = make_LogHdr(_T("FTPPUT"), fp);
		if (ProgressPanel->Visible) ProgressSubLabel->Caption = minimize_str(dst_fnam, Canvas, ProgressSubLabel->Width);

		TStringList *o_lst = GetOppList();
		file_rec *dst_fp = ExistsInList(dst_fnam, o_lst);
		bool s_flag = (dst_fp!=NULL);
		bool o_flag = false, n_flag = false;

		//同名ファイルの処理
		if (dst_fp) {
			UnicodeString dnam	  = dst_fnam;
			UnicodeString cpy_nam = dst_fnam;
			if (!gCopyAll) {
				TaskSttTimer->Enabled = false;
				SameNameDlg->Caption  = LoadUsrMsg(USTR_SameName, _T("アップロード"));
				SameNameDlg->TaskNo   = -1;
				SameNameDlg->CopyMode = gCopyMode;
				SameNameDlg->CopyAll  = gCopyAll;
				SameNameDlg->RenameEdit->Text = cpy_nam;
				SameNameDlg->IsSamePath = false;
				SameNameDlg->CurSrcName = fp->f_name;
				SameNameDlg->CurSrcSize = fp->f_size;
				SameNameDlg->CurSrcTime = fp->f_time;
				SameNameDlg->CurDstName = dst_fp->f_name;
				SameNameDlg->CurDstSize = dst_fp->f_size;
				SameNameDlg->CurDstTime = dst_fp->f_time;
				if (SameNameDlg->ShowModal()==mrCancel) {
					AddLog(_T("コピー中断"), true);
					gCopyCancel = true;
				}
				else {
					gCopyMode = SameNameDlg->CopyMode;
					gCopyAll  = SameNameDlg->CopyAll;
					gCopyFmt  = AutoRenFmt;
					cpy_nam   = SameNameDlg->RenameEdit->Text;
				}
				TaskSttTimer->Enabled = true;
				if (gCopyCancel) return true;
			}

			switch (gCopyMode) {
			case CPYMD_OW:		//上書き
				msg[1] = 'O';
				o_flag = true;
				break;
			case CPYMD_NEW:		//最新なら
				if (is_NewerTime(SameNameDlg->CurSrcTime, SameNameDlg->CurDstTime)) {
					msg[1] = 'N';
					o_flag = true;
				}
				else {
					if (LogHideSkip) msg = EmptyStr; else msg[1] = 'S';
				}
				break;
			case CPYMD_SKIP:	//スキップ
				if (LogHideSkip) msg = EmptyStr; else msg[1] = 'S';
				break;
			case CPYMD_AUT_REN:	//自動的に名前を変更
				dst_fnam = format_CloneName(gCopyFmt, fp->n_name, EmptyStr, false, &fp->f_time, o_lst);
				set_RenameLog(msg, dst_fnam);
				n_flag = true;
				break;
			case CPYMD_MAN_REN:	//名前を変更
				dst_fnam = cpy_nam;
				if (!ExistsInList(dst_fnam, o_lst)) {
					set_RenameLog(msg, cpy_nam);
					n_flag = true;
				}
				else set_LogErrMsg(msg, LoadUsrMsg(USTR_DuplicateName));
				break;
			default:
				Abort();
			}
		}

		//アップロード
		if (!s_flag || o_flag || n_flag) {
			bool ok = true;
			try {
				if (FTPUpToLower) dst_fnam = dst_fnam.LowerCase();
				FTPMaxCount = fp->f_size;
				IdFTP1->TransferType = test_FileExt(fp->f_ext, FTPTextModeFExt)? ftASCII : ftBinary;
				IdFTP1->Put(fp->f_name, dst_fnam);
				add_FTPLogMsg(msg);

				//タイムスタンプを維持
				if (FTPUpKeepTime && FTPTryModTime) {
					try {
						IdFTP1->SetModTime(dst_fnam, fp->f_time);
					}
					catch (...) {
						try {
							if (IdFTP1->IsExtSupported("MFMT")) Abort();
							//※ダメもとで MFMT による強制再試行
							//  LaCoocan はなぜかこれでいける
							IdFTP1->Capabilities->Add("MFMT");
							IdFTP1->SetModTime(dst_fnam, fp->f_time);
						}
						catch (...) {
							FTPTryModTime = false;
						}
					}
					add_FTPLogMsg();
				}
			}
			catch (...) {
				msg[1] = 'E';
				add_FTPLogMsg(msg);
				ok = false;
			}

			return ok;
		}
		else {
			if (!msg.IsEmpty()) add_FTPLogMsg(msg);
			return true;
		}
	}
	catch (...) {
		return false;
	}
}

//---------------------------------------------------------------------------
//パーミッションの設定
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::FTPChmodActionExecute(TObject *Sender)
{
	try {
		if (!IdFTP1->Connected()) { RecoverFileList();  Abort(); }
		if (!FTPhasCHMOD) TextAbort(_T("サーバが対応していません。"));

		if (!FtpChmodDlg) FtpChmodDlg = new TFtpChmodDlg(this);	//初回に動的作成
		if (!FtpChmodDlg->SetPermission(GetCurRepFrecPtr()->attr_str)) UserAbort(USTR_FmtNotSuported);

		TStringList *lst = GetCurList(true);
		bool lst_sel = ListSelected(lst);
		if (!lst_sel && !GetCurFrecPtr()) Abort();

		UnicodeString prm;
		//パラメータで指定
		if (!ActionParam.IsEmpty()) {
			prm = ActionParam;
			if (!is_match_regex(prm, _T("^[0-7]{3}$"))) UserAbort(USTR_IllegalParam);
		}
		//ダイアログで指定
		else {
			if (FtpChmodDlg->ShowModal()!=mrOk) SkipAbort();
			prm = FtpChmodDlg->OctalEdit->EditText;
		}

		UnicodeString msg, cmd;
		CurWorking = true;
		StartLog(msg.sprintf(_T("パーミッション設定開始  %s %s"), prm.c_str(), yen_to_slash(CurFTPPath).c_str()));

		int ok_cnt = 0, er_cnt = 0;
		int cur_idx = FileListBox[CurListTag]->ItemIndex;
		for (int i=0; i<lst->Count; i++) {
			file_rec *fp = (file_rec*)lst->Objects[i];
			if (fp->selected || (!lst_sel && i==cur_idx)) {
				msg = make_LogHdr(_T("CHMOD"), fp);
				try {
					IdFTP1->Site(cmd.sprintf(_T("CHMOD %s %s"), prm.c_str(), fp->n_name.c_str()));
				}
				catch (...) {
					msg[1] = 'E';
				}
				((msg[1]=='E')? er_cnt : ok_cnt)++;
				add_FTPLogMsg(msg);
				fp->selected = false;
				InvalidateFileList();
			}
		}
		if (!ChangeFtpFileList()) GlobalAbort();
		CurWorking = false;
		EndLog(_T("設定"), get_res_cnt_str(ok_cnt, er_cnt));
		SetFileInf();
	}
	catch (EAbort &e) {
		SetActionAbort(e.Message);
	}
	catch (...) {
		SetInternalException();
	}
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::FTPChmodActionUpdate(TObject *Sender)
{
	TAction *ap = (TAction*)Sender;
	ap->Visible = (ScrMode==SCMD_FLIST && CurStt->is_FTP);
	ap->Enabled = ap->Visible;
}

//---------------------------------------------------------------------------
//タスク表示部
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::TaskPaintBoxPaint(TObject *Sender)
{
	TPaintBox *pp = (TPaintBox*)Sender;
	TCanvas *cv = pp->Canvas;
	cv->Font->Assign(LogFont);
	cv->Brush->Color = col_bgTask;
	cv->FillRect(pp->ClientRect);

	int h  = get_FontHeight(cv->Font) * 5/4 + Scaled4;
	int xp = 4;
	int yp = 2;

	cv->Font->Color = col_fgLog;
	int fsz = cv->Font->Size;
	cv->Font->Size = fsz * 9 / 10;
	out_Text(cv, xp, yp, _T("タスク"));
	cv->Font->Size = fsz;
	yp += h;

	UnicodeString tmp;
	int maxn = get_MaxTaskCount();
	for (int i=0; i<maxn; i++) {
		cv->Brush->Color = col_bgTask;

		TTaskThread *tp = TaskThread[i];
		if (tp) {
			cv->Font->Color = (tp->PreCount>0)? clGreen : tp->TaskPause? clRed : col_fgLog;
			cv->TextOut(xp, yp, tmp.sprintf(_T("%u:%5u"), i + 1, tp->Config->TaskList->Count));
			yp += h;
			int n = (tp->PreCount>0)? tp->PreCount : (tp->SubCount>0)? tp->SubCount : 0;
			if (n>0) cv->TextOut(xp, yp, tmp.sprintf(_T("%7u"), n));

			//進捗表示
			if (tp->CurProgress>=0) {
				int x0 = xp + get_CharWidth(cv, 2);
				int x1 = pp->Width - 4;
				TRect rc_f = (tmp.IsEmpty())? Rect(x0, yp + 2, x1, yp + 4) : Rect(x0, yp + h - 4, x1, yp + h - 2);
				draw_ProgressBar(cv, rc_f, tp->CurProgress);
				//高速実行
				if (tp->TaskIsFast) {
					rc_f.Left -= 8;  rc_f.Right = rc_f.Left + 4;
					InflateRect(rc_f, 0, 1);
					cv->Brush->Color = clRed;
					cv->FillRect(rc_f);
				}
			}
			yp += h;
		}
		else {
			cv->Font->Color = AdjustColor(col_fgLog, 96);
			cv->TextOut(xp, yp, tmp.sprintf(_T("%u:_____"), i + 1));
			yp += h * 2;
		}
	}

	//予約タスク状態表示
	cv->Brush->Color = col_bgTask;
	cv->Font->Color  = col_fgLog;
	yp += h/2;
	if (TaskReserveList->Count>0) {
		out_Text(cv, xp, yp, RsvSuspended? _T("保留中") : _T("待機中"));
		yp += h;
		cv->TextOut(xp, yp, tmp.sprintf(_T("  %4u"), TaskReserveList->Count));
		yp += h;
	}
	else if (RsvSuspended) {
		out_Text(cv, xp, yp, _T("保留中"));
		yp += h * 2;
	}

	//ファイル監視表示
	if (WatchTailList->Count>0) {
		out_Text(cv, xp, yp, _T("監視中"));
		yp += h;
		cv->TextOut(xp, yp, tmp.sprintf(_T("  %4u"), WatchTailList->Count));
	}
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::TaskPaintBoxDblClick(TObject *Sender)
{
	ExeEventCommand(OnTskDClick);
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::TaskPaintBoxMouseUp(TObject *Sender, TMouseButton Button, TShiftState Shift, int X, int Y)
{
	ClearNopStt();
	if (Button==mbRight) ExeEventCommandMP(OnTskRClick);
}

//---------------------------------------------------------------------------
//イベント: ファイルリストのシンプルスクロールバーを右クリック
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::FlScrPanelMouseUp(TObject *Sender, TMouseButton Button, TShiftState Shift, int X, int Y)
{
	if (Button==mbRight) ExeEventCommandMP(OnFScrRClick);
}

//---------------------------------------------------------------------------
//デフォルトの構文強調表示定義をコピー
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::DefHighlightActionExecute(TObject *Sender)
{
	UnicodeString fext = inputbox_ex(_T("デフォルトの構文強調表示定義をコピー"), _T("拡張子(単独指定)"), EmptyStr);
	if (!fext.IsEmpty()) {
		std::unique_ptr<TStringList> rbuf(new TStringList());
		if (GetDefaultHighlight(fext, rbuf.get(), HeadlineList)) {
			copy_to_Clipboard(rbuf->Text);
		}
		else msgbox_WARN("定義されていません。");
	}
}

//---------------------------------------------------------------------------
//色見本定義ファイルの編集
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::EditSwatchItemClick(TObject *Sender)
{
	try {
		UnicodeString fnam = ExePath + SWATCH_FILE;
		//なければ作成
		if (!file_exists(fnam)) {
			if (!SaveSwatchbook(fnam)) UserAbort(USTR_FaildSave);
		}
		//編集
		UnicodeString cmd;
		cmd.sprintf(_T("FileEdit_\"%s\""), fnam.c_str());
		if (!ExeCommandsCore(cmd)) GlobalAbort();
		//再読み込み
		if (msgbox_Sure(_T("変更を反映するために再読み込みしますか?"), true, true)) {
			UnicodeString msg = make_LogHdr(_T("LOAD"), fnam);
			if (LoadSwatchbook(fnam)==0) msg[1] = 'E';
			AddLog(msg);
		}
	}
	catch (EAbort &e) {
		msgbox_ERR(e.Message);
	}
}
//---------------------------------------------------------------------------
//フォントサンプル定義の編集
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::EditFontSmplItemClick(TObject *Sender)
{
	try {
		//なければ作成
		UnicodeString fnam = ExePath + FONTSMPL_FILE;
		if (!file_exists(fnam) && !save_FontSample(fnam)) UserAbort(USTR_FaildSave);

		//編集
		UnicodeString cmd;
		cmd.sprintf(_T("FileEdit_\"%s\""), fnam.c_str());
		if (!ExeCommandsCore(cmd)) GlobalAbort();

		//再読み込み
		if (msgbox_Sure(_T("変更を反映するために再読み込みしますか?"), true, true)) {
			if (load_FontSample(fnam)) SetFileInf();
		}
	}
	catch (EAbort &e) {
		msgbox_ERR(e.Message);
	}
}

//---------------------------------------------------------------------------
//イメージプレビューの右クリックメニュー
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::ImgPrvPopupMenuPopup(TObject *Sender)
{
	file_rec *cfp = GetCurFrecPtr(true);
	PopEditFontSmplItem->Visible = (cfp && test_FontExt(cfp->f_ext));
}

//---------------------------------------------------------------------------
//プレビューのマウスポインタを設定
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::SetPrvImgCursor(bool sw)
{
	if (sw) {
		PreviewImage->Cursor = crTmpPrev;
	}
	else {
		PreviewImage->Cursor = crDefault;
		HCURSOR hCur = (HCURSOR)Screen->Cursors[crTmpPrev];
		if (hCur && ::DestroyCursor(hCur)) Screen->Cursors[crTmpPrev] = NULL;
	}

	TPoint p = Mouse->CursorPos;
	Mouse->CursorPos = Point(p.x+1, p.y+1);
	Mouse->CursorPos = p;
}

//---------------------------------------------------------------------------
//プレビュー内で、マウスポインタのホットスポットに十字線を表示
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::PreviewImageMouseDown(TObject *Sender, TMouseButton Button,
	TShiftState Shift, int X, int Y)
{
	if (SetPrvCursor && Button==mbLeft && PreviewImage->Cursor!=crDefault) {
		HotPosImage->Picture->Bitmap->SetSize(HotPosImage->ClientWidth, HotPosImage->ClientHeight);
		TCanvas *cv = HotPosImage->Canvas;
		cv->Brush->Color = col_bgImage;
		TRect rc = HotPosImage->ClientRect;
		cv->FillRect(rc);
		//十字線
		int p = HotPosImage->ClientWidth/2;
		cv->Pen->Width = Scaled1;
		cv->Pen->Style = psSolid;
		cv->Pen->Color = clRed;
		cv->MoveTo(0, p);	cv->LineTo(rc.Right, p);
		cv->MoveTo(p, 0);	cv->LineTo(p, rc.Bottom);
		HotPosImage->Left = X - p;
		HotPosImage->Top  = Y - p;
		HotPosImage->Visible = true;
	}
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::PreviewImageMouseMove(TObject *Sender, TShiftState Shift,
	int X, int Y)
{
	HotPosImage->Visible = false;
}
//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::PreviewImageMouseUp(TObject *Sender, TMouseButton Button,
	TShiftState Shift, int X, int Y)
{
	HotPosImage->Visible = false;
}

//---------------------------------------------------------------------------
void __fastcall TNyanFiForm::GrepRepComboBoxEnter(TObject *Sender)
{
	UpdateActions();
}
//---------------------------------------------------------------------------

